import {
  require_react
} from "./chunk-OXAWTBIM.js";
import {
  __commonJS,
  __export,
  __toESM
} from "./chunk-Y4AOG3KG.js";

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type) {
          return typeof type === "string" || typeof type === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type === REACT_FRAGMENT_TYPE || type === REACT_CONCURRENT_MODE_TYPE || type === REACT_PROFILER_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || typeof type === "object" && type !== null && (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_RESPONDER_TYPE || type.$$typeof === REACT_SCOPE_TYPE || type.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object4) {
          if (typeof object4 === "object" && object4 !== null) {
            var $$typeof = object4.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type = object4.type;
                switch (type) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type;
                  default:
                    var $$typeofType = type && type.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element3 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment2 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object4) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object4) || typeOf(object4) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object4) {
          return typeOf(object4) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object4) {
          return typeOf(object4) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object4) {
          return typeOf(object4) === REACT_PROVIDER_TYPE;
        }
        function isElement(object4) {
          return typeof object4 === "object" && object4 !== null && object4.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object4) {
          return typeOf(object4) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object4) {
          return typeOf(object4) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object4) {
          return typeOf(object4) === REACT_LAZY_TYPE;
        }
        function isMemo(object4) {
          return typeOf(object4) === REACT_MEMO_TYPE;
        }
        function isPortal(object4) {
          return typeOf(object4) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object4) {
          return typeOf(object4) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object4) {
          return typeOf(object4) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object4) {
          return typeOf(object4) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element3;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment2;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/object-assign/index.js
var require_object_assign = __commonJS({
  "node_modules/object-assign/index.js"(exports, module) {
    "use strict";
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var hasOwnProperty4 = Object.prototype.hasOwnProperty;
    var propIsEnumerable = Object.prototype.propertyIsEnumerable;
    function toObject(val) {
      if (val === null || val === void 0) {
        throw new TypeError("Object.assign cannot be called with null or undefined");
      }
      return Object(val);
    }
    function shouldUseNative() {
      try {
        if (!Object.assign) {
          return false;
        }
        var test1 = new String("abc");
        test1[5] = "de";
        if (Object.getOwnPropertyNames(test1)[0] === "5") {
          return false;
        }
        var test2 = {};
        for (var i = 0; i < 10; i++) {
          test2["_" + String.fromCharCode(i)] = i;
        }
        var order2 = Object.getOwnPropertyNames(test2).map(function(n) {
          return test2[n];
        });
        if (order2.join("") !== "0123456789") {
          return false;
        }
        var test3 = {};
        "abcdefghijklmnopqrst".split("").forEach(function(letter) {
          test3[letter] = letter;
        });
        if (Object.keys(Object.assign({}, test3)).join("") !== "abcdefghijklmnopqrst") {
          return false;
        }
        return true;
      } catch (err2) {
        return false;
      }
    }
    module.exports = shouldUseNative() ? Object.assign : function(target, source) {
      var from;
      var to = toObject(target);
      var symbols;
      for (var s = 1; s < arguments.length; s++) {
        from = Object(arguments[s]);
        for (var key in from) {
          if (hasOwnProperty4.call(from, key)) {
            to[key] = from[key];
          }
        }
        if (getOwnPropertySymbols) {
          symbols = getOwnPropertySymbols(from);
          for (var i = 0; i < symbols.length; i++) {
            if (propIsEnumerable.call(from, symbols[i])) {
              to[symbols[i]] = from[symbols[i]];
            }
          }
        }
      }
      return to;
    };
  }
});

// node_modules/prop-types/lib/ReactPropTypesSecret.js
var require_ReactPropTypesSecret = __commonJS({
  "node_modules/prop-types/lib/ReactPropTypesSecret.js"(exports, module) {
    "use strict";
    var ReactPropTypesSecret = "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED";
    module.exports = ReactPropTypesSecret;
  }
});

// node_modules/prop-types/lib/has.js
var require_has = __commonJS({
  "node_modules/prop-types/lib/has.js"(exports, module) {
    module.exports = Function.call.bind(Object.prototype.hasOwnProperty);
  }
});

// node_modules/prop-types/checkPropTypes.js
var require_checkPropTypes = __commonJS({
  "node_modules/prop-types/checkPropTypes.js"(exports, module) {
    "use strict";
    var printWarning = function() {
    };
    if (true) {
      ReactPropTypesSecret = require_ReactPropTypesSecret();
      loggedTypeFailures = {};
      has3 = require_has();
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    var ReactPropTypesSecret;
    var loggedTypeFailures;
    var has3;
    function checkPropTypes(typeSpecs, values5, location, componentName, getStack) {
      if (true) {
        for (var typeSpecName in typeSpecs) {
          if (has3(typeSpecs, typeSpecName)) {
            var error2;
            try {
              if (typeof typeSpecs[typeSpecName] !== "function") {
                var err2 = Error(
                  (componentName || "React class") + ": " + location + " type `" + typeSpecName + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof typeSpecs[typeSpecName] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`."
                );
                err2.name = "Invariant Violation";
                throw err2;
              }
              error2 = typeSpecs[typeSpecName](values5, typeSpecName, componentName, location, null, ReactPropTypesSecret);
            } catch (ex) {
              error2 = ex;
            }
            if (error2 && !(error2 instanceof Error)) {
              printWarning(
                (componentName || "React class") + ": type specification of " + location + " `" + typeSpecName + "` is invalid; the type checker function must return `null` or an `Error` but returned a " + typeof error2 + ". You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument)."
              );
            }
            if (error2 instanceof Error && !(error2.message in loggedTypeFailures)) {
              loggedTypeFailures[error2.message] = true;
              var stack2 = getStack ? getStack() : "";
              printWarning(
                "Failed " + location + " type: " + error2.message + (stack2 != null ? stack2 : "")
              );
            }
          }
        }
      }
    }
    checkPropTypes.resetWarningCache = function() {
      if (true) {
        loggedTypeFailures = {};
      }
    };
    module.exports = checkPropTypes;
  }
});

// node_modules/prop-types/factoryWithTypeCheckers.js
var require_factoryWithTypeCheckers = __commonJS({
  "node_modules/prop-types/factoryWithTypeCheckers.js"(exports, module) {
    "use strict";
    var ReactIs = require_react_is();
    var assign2 = require_object_assign();
    var ReactPropTypesSecret = require_ReactPropTypesSecret();
    var has3 = require_has();
    var checkPropTypes = require_checkPropTypes();
    var printWarning = function() {
    };
    if (true) {
      printWarning = function(text) {
        var message = "Warning: " + text;
        if (typeof console !== "undefined") {
          console.error(message);
        }
        try {
          throw new Error(message);
        } catch (x) {
        }
      };
    }
    function emptyFunctionThatReturnsNull() {
      return null;
    }
    module.exports = function(isValidElement2, throwOnDirectAccess) {
      var ITERATOR_SYMBOL = typeof Symbol === "function" && Symbol.iterator;
      var FAUX_ITERATOR_SYMBOL = "@@iterator";
      function getIteratorFn(maybeIterable) {
        var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
        if (typeof iteratorFn === "function") {
          return iteratorFn;
        }
      }
      var ANONYMOUS = "<<anonymous>>";
      var ReactPropTypes = {
        array: createPrimitiveTypeChecker("array"),
        bigint: createPrimitiveTypeChecker("bigint"),
        bool: createPrimitiveTypeChecker("boolean"),
        func: createPrimitiveTypeChecker("function"),
        number: createPrimitiveTypeChecker("number"),
        object: createPrimitiveTypeChecker("object"),
        string: createPrimitiveTypeChecker("string"),
        symbol: createPrimitiveTypeChecker("symbol"),
        any: createAnyTypeChecker(),
        arrayOf: createArrayOfTypeChecker,
        element: createElementTypeChecker(),
        elementType: createElementTypeTypeChecker(),
        instanceOf: createInstanceTypeChecker,
        node: createNodeChecker(),
        objectOf: createObjectOfTypeChecker,
        oneOf: createEnumTypeChecker,
        oneOfType: createUnionTypeChecker,
        shape: createShapeTypeChecker,
        exact: createStrictShapeTypeChecker
      };
      function is(x, y) {
        if (x === y) {
          return x !== 0 || 1 / x === 1 / y;
        } else {
          return x !== x && y !== y;
        }
      }
      function PropTypeError(message, data) {
        this.message = message;
        this.data = data && typeof data === "object" ? data : {};
        this.stack = "";
      }
      PropTypeError.prototype = Error.prototype;
      function createChainableTypeChecker(validate) {
        if (true) {
          var manualPropTypeCallCache = {};
          var manualPropTypeWarningCount = 0;
        }
        function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
          componentName = componentName || ANONYMOUS;
          propFullName = propFullName || propName;
          if (secret !== ReactPropTypesSecret) {
            if (throwOnDirectAccess) {
              var err2 = new Error(
                "Calling PropTypes validators directly is not supported by the `prop-types` package. Use `PropTypes.checkPropTypes()` to call them. Read more at http://fb.me/use-check-prop-types"
              );
              err2.name = "Invariant Violation";
              throw err2;
            } else if (typeof console !== "undefined") {
              var cacheKey = componentName + ":" + propName;
              if (!manualPropTypeCallCache[cacheKey] && // Avoid spamming the console because they are often not actionable except for lib authors
              manualPropTypeWarningCount < 3) {
                printWarning(
                  "You are manually calling a React.PropTypes validation function for the `" + propFullName + "` prop on `" + componentName + "`. This is deprecated and will throw in the standalone `prop-types` package. You may be seeing this warning due to a third-party PropTypes library. See https://fb.me/react-warning-dont-call-proptypes for details."
                );
                manualPropTypeCallCache[cacheKey] = true;
                manualPropTypeWarningCount++;
              }
            }
          }
          if (props[propName] == null) {
            if (isRequired) {
              if (props[propName] === null) {
                return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required " + ("in `" + componentName + "`, but its value is `null`."));
              }
              return new PropTypeError("The " + location + " `" + propFullName + "` is marked as required in " + ("`" + componentName + "`, but its value is `undefined`."));
            }
            return null;
          } else {
            return validate(props, propName, componentName, location, propFullName);
          }
        }
        var chainedCheckType = checkType.bind(null, false);
        chainedCheckType.isRequired = checkType.bind(null, true);
        return chainedCheckType;
      }
      function createPrimitiveTypeChecker(expectedType) {
        function validate(props, propName, componentName, location, propFullName, secret) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== expectedType) {
            var preciseType = getPreciseType(propValue);
            return new PropTypeError(
              "Invalid " + location + " `" + propFullName + "` of type " + ("`" + preciseType + "` supplied to `" + componentName + "`, expected ") + ("`" + expectedType + "`."),
              { expectedType }
            );
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createAnyTypeChecker() {
        return createChainableTypeChecker(emptyFunctionThatReturnsNull);
      }
      function createArrayOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside arrayOf.");
          }
          var propValue = props[propName];
          if (!Array.isArray(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an array."));
          }
          for (var i = 0; i < propValue.length; i++) {
            var error2 = typeChecker(propValue, i, componentName, location, propFullName + "[" + i + "]", ReactPropTypesSecret);
            if (error2 instanceof Error) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!isValidElement2(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createElementTypeTypeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          if (!ReactIs.isValidElementType(propValue)) {
            var propType = getPropType(propValue);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected a single ReactElement type."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createInstanceTypeChecker(expectedClass) {
        function validate(props, propName, componentName, location, propFullName) {
          if (!(props[propName] instanceof expectedClass)) {
            var expectedClassName = expectedClass.name || ANONYMOUS;
            var actualClassName = getClassName(props[propName]);
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + actualClassName + "` supplied to `" + componentName + "`, expected ") + ("instance of `" + expectedClassName + "`."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createEnumTypeChecker(expectedValues) {
        if (!Array.isArray(expectedValues)) {
          if (true) {
            if (arguments.length > 1) {
              printWarning(
                "Invalid arguments supplied to oneOf, expected an array, got " + arguments.length + " arguments. A common mistake is to write oneOf(x, y, z) instead of oneOf([x, y, z])."
              );
            } else {
              printWarning("Invalid argument supplied to oneOf, expected an array.");
            }
          }
          return emptyFunctionThatReturnsNull;
        }
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          for (var i = 0; i < expectedValues.length; i++) {
            if (is(propValue, expectedValues[i])) {
              return null;
            }
          }
          var valuesString = JSON.stringify(expectedValues, function replacer(key, value) {
            var type = getPreciseType(value);
            if (type === "symbol") {
              return String(value);
            }
            return value;
          });
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` of value `" + String(propValue) + "` " + ("supplied to `" + componentName + "`, expected one of " + valuesString + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createObjectOfTypeChecker(typeChecker) {
        function validate(props, propName, componentName, location, propFullName) {
          if (typeof typeChecker !== "function") {
            return new PropTypeError("Property `" + propFullName + "` of component `" + componentName + "` has invalid PropType notation inside objectOf.");
          }
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type " + ("`" + propType + "` supplied to `" + componentName + "`, expected an object."));
          }
          for (var key in propValue) {
            if (has3(propValue, key)) {
              var error2 = typeChecker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
              if (error2 instanceof Error) {
                return error2;
              }
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createUnionTypeChecker(arrayOfTypeCheckers) {
        if (!Array.isArray(arrayOfTypeCheckers)) {
          true ? printWarning("Invalid argument supplied to oneOfType, expected an instance of array.") : void 0;
          return emptyFunctionThatReturnsNull;
        }
        for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
          var checker = arrayOfTypeCheckers[i];
          if (typeof checker !== "function") {
            printWarning(
              "Invalid argument supplied to oneOfType. Expected an array of check functions, but received " + getPostfixForTypeWarning(checker) + " at index " + i + "."
            );
            return emptyFunctionThatReturnsNull;
          }
        }
        function validate(props, propName, componentName, location, propFullName) {
          var expectedTypes = [];
          for (var i2 = 0; i2 < arrayOfTypeCheckers.length; i2++) {
            var checker2 = arrayOfTypeCheckers[i2];
            var checkerResult = checker2(props, propName, componentName, location, propFullName, ReactPropTypesSecret);
            if (checkerResult == null) {
              return null;
            }
            if (checkerResult.data && has3(checkerResult.data, "expectedType")) {
              expectedTypes.push(checkerResult.data.expectedType);
            }
          }
          var expectedTypesMessage = expectedTypes.length > 0 ? ", expected one of type [" + expectedTypes.join(", ") + "]" : "";
          return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`" + expectedTypesMessage + "."));
        }
        return createChainableTypeChecker(validate);
      }
      function createNodeChecker() {
        function validate(props, propName, componentName, location, propFullName) {
          if (!isNode(props[propName])) {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` supplied to " + ("`" + componentName + "`, expected a ReactNode."));
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function invalidValidatorError(componentName, location, propFullName, key, type) {
        return new PropTypeError(
          (componentName || "React class") + ": " + location + " type `" + propFullName + "." + key + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + type + "`."
        );
      }
      function createShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          for (var key in shapeTypes) {
            var checker = shapeTypes[key];
            if (typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function createStrictShapeTypeChecker(shapeTypes) {
        function validate(props, propName, componentName, location, propFullName) {
          var propValue = props[propName];
          var propType = getPropType(propValue);
          if (propType !== "object") {
            return new PropTypeError("Invalid " + location + " `" + propFullName + "` of type `" + propType + "` " + ("supplied to `" + componentName + "`, expected `object`."));
          }
          var allKeys = assign2({}, props[propName], shapeTypes);
          for (var key in allKeys) {
            var checker = shapeTypes[key];
            if (has3(shapeTypes, key) && typeof checker !== "function") {
              return invalidValidatorError(componentName, location, propFullName, key, getPreciseType(checker));
            }
            if (!checker) {
              return new PropTypeError(
                "Invalid " + location + " `" + propFullName + "` key `" + key + "` supplied to `" + componentName + "`.\nBad object: " + JSON.stringify(props[propName], null, "  ") + "\nValid keys: " + JSON.stringify(Object.keys(shapeTypes), null, "  ")
              );
            }
            var error2 = checker(propValue, key, componentName, location, propFullName + "." + key, ReactPropTypesSecret);
            if (error2) {
              return error2;
            }
          }
          return null;
        }
        return createChainableTypeChecker(validate);
      }
      function isNode(propValue) {
        switch (typeof propValue) {
          case "number":
          case "string":
          case "undefined":
            return true;
          case "boolean":
            return !propValue;
          case "object":
            if (Array.isArray(propValue)) {
              return propValue.every(isNode);
            }
            if (propValue === null || isValidElement2(propValue)) {
              return true;
            }
            var iteratorFn = getIteratorFn(propValue);
            if (iteratorFn) {
              var iterator = iteratorFn.call(propValue);
              var step;
              if (iteratorFn !== propValue.entries) {
                while (!(step = iterator.next()).done) {
                  if (!isNode(step.value)) {
                    return false;
                  }
                }
              } else {
                while (!(step = iterator.next()).done) {
                  var entry = step.value;
                  if (entry) {
                    if (!isNode(entry[1])) {
                      return false;
                    }
                  }
                }
              }
            } else {
              return false;
            }
            return true;
          default:
            return false;
        }
      }
      function isSymbol(propType, propValue) {
        if (propType === "symbol") {
          return true;
        }
        if (!propValue) {
          return false;
        }
        if (propValue["@@toStringTag"] === "Symbol") {
          return true;
        }
        if (typeof Symbol === "function" && propValue instanceof Symbol) {
          return true;
        }
        return false;
      }
      function getPropType(propValue) {
        var propType = typeof propValue;
        if (Array.isArray(propValue)) {
          return "array";
        }
        if (propValue instanceof RegExp) {
          return "object";
        }
        if (isSymbol(propType, propValue)) {
          return "symbol";
        }
        return propType;
      }
      function getPreciseType(propValue) {
        if (typeof propValue === "undefined" || propValue === null) {
          return "" + propValue;
        }
        var propType = getPropType(propValue);
        if (propType === "object") {
          if (propValue instanceof Date) {
            return "date";
          } else if (propValue instanceof RegExp) {
            return "regexp";
          }
        }
        return propType;
      }
      function getPostfixForTypeWarning(value) {
        var type = getPreciseType(value);
        switch (type) {
          case "array":
          case "object":
            return "an " + type;
          case "boolean":
          case "date":
          case "regexp":
            return "a " + type;
          default:
            return type;
        }
      }
      function getClassName(propValue) {
        if (!propValue.constructor || !propValue.constructor.name) {
          return ANONYMOUS;
        }
        return propValue.constructor.name;
      }
      ReactPropTypes.checkPropTypes = checkPropTypes;
      ReactPropTypes.resetWarningCache = checkPropTypes.resetWarningCache;
      ReactPropTypes.PropTypes = ReactPropTypes;
      return ReactPropTypes;
    };
  }
});

// node_modules/prop-types/index.js
var require_prop_types = __commonJS({
  "node_modules/prop-types/index.js"(exports, module) {
    if (true) {
      ReactIs = require_react_is();
      throwOnDirectAccess = true;
      module.exports = require_factoryWithTypeCheckers()(ReactIs.isElement, throwOnDirectAccess);
    } else {
      module.exports = null();
    }
    var ReactIs;
    var throwOnDirectAccess;
  }
});

// node_modules/@progress/kendo-react-gauges/dist/es/ArcGauge.js
var React34 = __toESM(require_react());

// node_modules/@progress/kendo-react-gauges/dist/es/BaseGauge.js
var React32 = __toESM(require_react());
var PropTypes7 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-intl/dist/es/Intl/IntlProvider.js
var React2 = __toESM(require_react());
var PropTypes = __toESM(require_prop_types());

// node_modules/@progress/kendo-intl/dist/es/cldr/default-data.js
var defaultData = {
  en: {
    name: "en",
    identity: {
      version: {
        _unicodeVersion: "14.0.0",
        _cldrVersion: "41"
      },
      language: "en"
    },
    territory: "US",
    numbers: {
      symbols: {
        decimal: ".",
        group: ",",
        list: ";",
        percentSign: "%",
        plusSign: "+",
        minusSign: "-",
        exponential: "E",
        superscriptingExponent: "×",
        perMille: "‰",
        infinity: "∞",
        nan: "NaN",
        timeSeparator: ":",
        approximatelySign: "~"
      },
      decimal: {
        patterns: [
          "n"
        ],
        groupSize: [
          3
        ]
      },
      scientific: {
        patterns: [
          "nEn"
        ],
        groupSize: []
      },
      percent: {
        patterns: [
          "n%"
        ],
        groupSize: [
          3
        ]
      },
      currency: {
        patterns: [
          "$n"
        ],
        groupSize: [
          3
        ],
        "unitPattern-count-one": "n $",
        "unitPattern-count-other": "n $"
      },
      currencies: {
        BGN: {
          displayName: "Bulgarian Lev",
          "displayName-count-one": "Bulgarian lev",
          "displayName-count-other": "Bulgarian leva",
          symbol: "BGN"
        },
        EUR: {
          displayName: "Euro",
          "displayName-count-one": "euro",
          "displayName-count-other": "euros",
          symbol: "€",
          "symbol-alt-narrow": "€"
        },
        USD: {
          displayName: "US Dollar",
          "displayName-count-one": "US dollar",
          "displayName-count-other": "US dollars",
          symbol: "$",
          "symbol-alt-narrow": "$"
        }
      },
      localeCurrency: "USD",
      accounting: {
        patterns: [
          "$n",
          "($n)"
        ],
        groupSize: [
          3
        ]
      }
    },
    calendar: {
      gmtFormat: "GMT{0}",
      gmtZeroFormat: "GMT",
      patterns: {
        d: "M/d/y",
        D: "EEEE, MMMM d, y",
        m: "MMM d",
        M: "MMMM d",
        y: "MMM y",
        Y: "MMMM y",
        F: "EEEE, MMMM d, y h:mm:ss a",
        g: "M/d/y h:mm a",
        G: "M/d/y h:mm:ss a",
        t: "h:mm a",
        T: "h:mm:ss a",
        s: "yyyy'-'MM'-'dd'T'HH':'mm':'ss",
        u: "yyyy'-'MM'-'dd HH':'mm':'ss'Z'"
      },
      dateTimeFormats: {
        full: "{1} 'at' {0}",
        long: "{1} 'at' {0}",
        medium: "{1}, {0}",
        short: "{1}, {0}",
        availableFormats: {
          Bh: "h B",
          Bhm: "h:mm B",
          Bhms: "h:mm:ss B",
          d: "d",
          E: "ccc",
          EBhm: "E h:mm B",
          EBhms: "E h:mm:ss B",
          Ed: "d E",
          Ehm: "E h:mm a",
          EHm: "E HH:mm",
          Ehms: "E h:mm:ss a",
          EHms: "E HH:mm:ss",
          Gy: "y G",
          GyMd: "M/d/y GGGGG",
          GyMMM: "MMM y G",
          GyMMMd: "MMM d, y G",
          GyMMMEd: "E, MMM d, y G",
          h: "h a",
          H: "HH",
          hm: "h:mm a",
          Hm: "HH:mm",
          hms: "h:mm:ss a",
          Hms: "HH:mm:ss",
          hmsv: "h:mm:ss a v",
          Hmsv: "HH:mm:ss v",
          hmv: "h:mm a v",
          Hmv: "HH:mm v",
          M: "L",
          Md: "M/d",
          MEd: "E, M/d",
          MMM: "LLL",
          MMMd: "MMM d",
          MMMEd: "E, MMM d",
          MMMMd: "MMMM d",
          "MMMMW-count-one": "'week' W 'of' MMMM",
          "MMMMW-count-other": "'week' W 'of' MMMM",
          ms: "mm:ss",
          y: "y",
          yM: "M/y",
          yMd: "M/d/y",
          yMEd: "E, M/d/y",
          yMMM: "MMM y",
          yMMMd: "MMM d, y",
          yMMMEd: "E, MMM d, y",
          yMMMM: "MMMM y",
          yQQQ: "QQQ y",
          yQQQQ: "QQQQ y",
          "yw-count-one": "'week' w 'of' Y",
          "yw-count-other": "'week' w 'of' Y"
        }
      },
      timeFormats: {
        full: "h:mm:ss a zzzz",
        long: "h:mm:ss a z",
        medium: "h:mm:ss a",
        short: "h:mm a"
      },
      dateFormats: {
        full: "EEEE, MMMM d, y",
        long: "MMMM d, y",
        medium: "MMM d, y",
        short: "M/d/yy"
      },
      days: {
        format: {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Sun",
            "Mon",
            "Tue",
            "Wed",
            "Thu",
            "Fri",
            "Sat"
          ],
          narrow: [
            "S",
            "M",
            "T",
            "W",
            "T",
            "F",
            "S"
          ],
          short: [
            "Su",
            "Mo",
            "Tu",
            "We",
            "Th",
            "Fr",
            "Sa"
          ],
          wide: [
            "Sunday",
            "Monday",
            "Tuesday",
            "Wednesday",
            "Thursday",
            "Friday",
            "Saturday"
          ]
        }
      },
      months: {
        format: {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Jan",
            "Feb",
            "Mar",
            "Apr",
            "May",
            "Jun",
            "Jul",
            "Aug",
            "Sep",
            "Oct",
            "Nov",
            "Dec"
          ],
          narrow: [
            "J",
            "F",
            "M",
            "A",
            "M",
            "J",
            "J",
            "A",
            "S",
            "O",
            "N",
            "D"
          ],
          wide: [
            "January",
            "February",
            "March",
            "April",
            "May",
            "June",
            "July",
            "August",
            "September",
            "October",
            "November",
            "December"
          ]
        }
      },
      quarters: {
        format: {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        },
        "stand-alone": {
          abbreviated: [
            "Q1",
            "Q2",
            "Q3",
            "Q4"
          ],
          narrow: [
            "1",
            "2",
            "3",
            "4"
          ],
          wide: [
            "1st quarter",
            "2nd quarter",
            "3rd quarter",
            "4th quarter"
          ]
        }
      },
      dayPeriods: {
        format: {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          narrow: {
            midnight: "mi",
            am: "a",
            "am-alt-variant": "am",
            noon: "n",
            pm: "p",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "in the morning",
            afternoon1: "in the afternoon",
            evening1: "in the evening",
            night1: "at night"
          }
        },
        "stand-alone": {
          abbreviated: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          narrow: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          },
          wide: {
            midnight: "midnight",
            am: "AM",
            "am-alt-variant": "am",
            noon: "noon",
            pm: "PM",
            "pm-alt-variant": "pm",
            morning1: "morning",
            afternoon1: "afternoon",
            evening1: "evening",
            night1: "night"
          }
        }
      },
      eras: {
        format: {
          wide: {
            "0": "Before Christ",
            "1": "Anno Domini",
            "0-alt-variant": "Before Common Era",
            "1-alt-variant": "Common Era"
          },
          abbreviated: {
            "0": "BC",
            "1": "AD",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          },
          narrow: {
            "0": "B",
            "1": "A",
            "0-alt-variant": "BCE",
            "1-alt-variant": "CE"
          }
        }
      },
      dateFields: {
        era: {
          wide: "era",
          short: "era",
          narrow: "era"
        },
        year: {
          wide: "year",
          short: "yr.",
          narrow: "yr."
        },
        quarter: {
          wide: "quarter",
          short: "qtr.",
          narrow: "qtr."
        },
        month: {
          wide: "month",
          short: "mo.",
          narrow: "mo."
        },
        week: {
          wide: "week",
          short: "wk.",
          narrow: "wk."
        },
        weekOfMonth: {
          wide: "week of month",
          short: "wk. of mo.",
          narrow: "wk. of mo."
        },
        day: {
          wide: "day",
          short: "day",
          narrow: "day"
        },
        dayOfYear: {
          wide: "day of year",
          short: "day of yr.",
          narrow: "day of yr."
        },
        weekday: {
          wide: "day of the week",
          short: "day of wk.",
          narrow: "day of wk."
        },
        weekdayOfMonth: {
          wide: "weekday of the month",
          short: "wkday. of mo.",
          narrow: "wkday. of mo."
        },
        dayperiod: {
          short: "AM/PM",
          wide: "AM/PM",
          narrow: "AM/PM"
        },
        hour: {
          wide: "hour",
          short: "hr.",
          narrow: "hr."
        },
        minute: {
          wide: "minute",
          short: "min.",
          narrow: "min."
        },
        second: {
          wide: "second",
          short: "sec.",
          narrow: "sec."
        },
        zone: {
          wide: "time zone",
          short: "zone",
          narrow: "zone"
        },
        millisecond: {
          narrow: "ms",
          short: "ms",
          wide: "millisecond"
        }
      }
    }
  },
  supplemental: {
    likelySubtags: {
      en: "en-Latn-US"
    },
    currencyData: {
      region: {
        US: [
          {
            USD: {
              _from: "1792-01-01"
            }
          }
        ]
      }
    },
    weekData: {
      firstDay: {
        US: "sun"
      },
      weekendStart: {
        "001": "sat"
      },
      weekendEnd: {
        "001": "sun"
      }
    }
  }
};
var default_data_default = defaultData;

// node_modules/@progress/kendo-intl/dist/es/common/is-string.js
function isString(value) {
  return typeof value === "string";
}

// node_modules/@progress/kendo-intl/dist/es/error-details.js
var error_details_default = {
  "NoLocale": "Missing locale info for '{0}'",
  "NoCurrency": "Cannot determine currency information. Please load the locale currencies data.",
  "NoSupplementalCurrency": "Cannot determine currency. Please load the supplemental currencyData.",
  "NoCurrencyRegion": "No currency data for region '{0}'",
  "NoCurrencyDisplay": "Cannot determine currency display information. Please load the locale currencies data. The default culture does not include the all currencies data.",
  "NoGMTInfo": "Cannot determine locale GMT format. Please load the locale timeZoneNames data.",
  "NoWeekData": "Cannot determine locale first day of week. Please load the supplemental weekData.",
  "NoFirstDay": "Cannot determine locale first day of week. Please load the supplemental weekData. The default culture includes only the 'en-US' first day info.",
  "NoValidCurrency": "Cannot determine a default currency for the {0} locale. Please specify explicitly the currency with the format options.",
  "NoDateFieldNames": "Cannot determine the locale date field names. Please load the locale dateFields data."
};

// node_modules/@progress/kendo-intl/dist/es/errors.js
var formatRegExp = /\{(\d+)}?\}/g;
var IntlError = function IntlError2(ref2) {
  var name3 = ref2.name;
  var message = ref2.message;
  if (!name3 || !message) {
    throw new Error("{ name: string, message: string } object is required!");
  }
  this.name = name3;
  this.message = message;
};
IntlError.prototype.formatMessage = function formatMessage() {
  var values5 = [], len = arguments.length;
  while (len--)
    values5[len] = arguments[len];
  var flattenValues = flatten(values5);
  var formattedMessage = this.message.replace(formatRegExp, function(match, index) {
    return flattenValues[parseInt(index, 10)];
  });
  return this.name + ": " + formattedMessage;
};
IntlError.prototype.error = function error() {
  var values5 = [], len = arguments.length;
  while (len--)
    values5[len] = arguments[len];
  return new Error(this.formatMessage(values5));
};
var flatten = function(arr) {
  return arr.reduce(function(a, b) {
    return a.concat(b);
  }, []);
};
var toIntlErrors = function(errors2) {
  var predicate = function(prev, name3) {
    prev[name3] = new IntlError({ name: name3, message: errors2[name3] });
    return prev;
  };
  return Object.keys(errors2).reduce(predicate, {});
};
var errors = toIntlErrors(error_details_default);

// node_modules/@progress/kendo-intl/dist/es/cldr/info.js
function availableLocaleInfo(fullName, suffixes) {
  var parts = fullName.split("-");
  var language = parts[0];
  var script = parts[1];
  var territory = parts[2];
  return cldr[fullName] || suffixes.indexOf(territory) !== -1 && cldr[language + "-" + territory] || suffixes.indexOf(script) !== -1 && cldr[language + "-" + script] || cldr[language];
}
function localeFullName(language, suffixes) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  for (var idx = 0; idx < suffixes.length; idx++) {
    var name3 = likelySubtags[language + "-" + suffixes[idx]];
    if (name3) {
      return name3;
    }
  }
  if (likelySubtags[language]) {
    return likelySubtags[language];
  }
}
var cldr = default_data_default;
function getLocaleInfo(locale) {
  var info;
  if (isString(locale)) {
    info = localeInfo(locale);
  } else {
    info = locale;
  }
  return info;
}
function localeInfo(locale) {
  if (cldr[locale]) {
    return cldr[locale];
  }
  var likelySubtags = cldr.supplemental.likelySubtags;
  if (likelySubtags) {
    var parts = locale.split("-");
    var language = parts[0];
    var suffixes = parts.slice(1);
    var fullName = localeFullName(language, suffixes);
    var info = fullName ? availableLocaleInfo(fullName, suffixes) : null;
    if (info) {
      return info;
    }
  }
  throw errors.NoLocale.error(locale);
}

// node_modules/@progress/kendo-intl/dist/es/common/constants.js
var DECIMAL = "decimal";
var CURRENCY = "currency";
var ACCOUNTING = "accounting";
var PERCENT = "percent";
var SCIENTIFIC = "scientific";
var CURRENCY_PLACEHOLDER = "$";
var PERCENT_PLACEHOLDER = "%";
var NUMBER_PLACEHOLDER = "n";
var LIST_SEPARATOR = ";";
var GROUP_SEPARATOR = ",";
var POINT = ".";
var EMPTY = "";
var DEFAULT_LOCALE = "en";

// node_modules/@progress/kendo-intl/dist/es/cldr/territory.js
function territoryFromName(name3, identity) {
  var likelySubtags = cldr.supplemental.likelySubtags;
  var parts = name3.split("-");
  if (likelySubtags) {
    var likelyName = likelySubtags[name3] || likelySubtags[parts[0]];
    if (likelyName) {
      parts = likelyName.split("-");
    }
  }
  if (identity) {
    for (var idx = parts.length - 1; idx >= 1; idx--) {
      var part = parts[idx];
      if (part === identity.variant || part === identity.script) {
        parts.splice(idx, 1);
      }
    }
  }
  var length = parts.length;
  if (length > 1) {
    var territory = parts[length - 1];
    return territory.toUpperCase();
  }
}
function localeTerritory(info) {
  if (info.territory) {
    return info.territory;
  }
  var name3 = info.name;
  var identity = info.identity;
  var territory;
  if (identity && identity.territory) {
    territory = identity.territory;
  } else {
    territory = territoryFromName(name3, identity);
  }
  info.territory = territory;
  return territory;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-field-name.js
function dateFieldName(options2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var dateFields = info.calendar.dateFields;
  if (!dateFields) {
    throw errors.NoDateFieldNames.error();
  }
  var fieldNameInfo = dateFields[options2.type] || {};
  return fieldNameInfo[options2.nameType] || fieldNameInfo["wide"];
}

// node_modules/@progress/kendo-intl/dist/es/cldr/date-format-names.js
function lowerArray(arr) {
  var result = [];
  for (var idx = 0; idx < arr.length; idx++) {
    result.push(arr[idx].toLowerCase());
  }
  return result;
}
function lowerObject(obj) {
  var result = {};
  for (var field in obj) {
    result[field] = obj[field].toLowerCase();
  }
  return result;
}
function cloneLower(obj) {
  var result = Array.isArray(obj) ? lowerArray(obj) : lowerObject(obj);
  return result;
}
function dateFormatNames(locale, options2) {
  var type = options2.type;
  var nameType = options2.nameType;
  var standAlone = options2.standAlone;
  var lower = options2.lower;
  var info = getLocaleInfo(locale);
  var formatType = standAlone ? "stand-alone" : "format";
  var lowerNameType = (lower ? "lower-" : EMPTY) + nameType;
  var formatNames2 = info.calendar[type][formatType];
  var result = formatNames2[lowerNameType];
  if (!result && lower) {
    result = formatNames2[lowerNameType] = cloneLower(formatNames2[nameType]);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/parse-range-date.js
function parseRangeDate(value) {
  var parts = value.split("-");
  var year = parseInt(parts[0], 10);
  var month = parseInt(parts[1], 10) - 1;
  var day = parseInt(parts[2], 10);
  return new Date(year, month, day);
}

// node_modules/@progress/kendo-intl/dist/es/cldr/currency.js
var NoCurrency = errors.NoCurrency;
var NoCurrencyDisplay = errors.NoCurrencyDisplay;
var NoSupplementalCurrency = errors.NoSupplementalCurrency;
var NoCurrencyRegion = errors.NoCurrencyRegion;
var NoValidCurrency = errors.NoValidCurrency;
var DEFAULT_CURRENCY_FRACTIONS = 2;
var SYMBOL = "symbol";
var INVALID_CURRENCY_CODE = "XXX";
var GLOBAL_CURRENCIES = {
  "001": "USD",
  // 001 refers to world. not sure if it is correct to assume USD but seems better than throw an error
  "150": "EUR"
  // 150 territory for Europe
};
function getCurrencyInfo(locale, currency, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var currencies = info.numbers.currencies;
  if (!currencies) {
    if (throwIfNoValid) {
      throw NoCurrency.error();
    }
    return;
  }
  var currencyDisplayInfo = currencies[currency];
  if (!currencyDisplayInfo) {
    if (throwIfNoValid) {
      throw NoCurrencyDisplay.error();
    }
    return;
  }
  return currencyDisplayInfo;
}
function lengthComparer(a, b) {
  return b.length - a.length;
}
function regionCurrency(regionCurrencies) {
  var latestValidUntil, latestValidUntilRange;
  var latestStillValid, latestStillValidDate;
  for (var idx = 0; idx < regionCurrencies.length; idx++) {
    var currency = regionCurrencies[idx];
    var code2 = Object.keys(currency)[0];
    var info = currency[code2];
    if (code2 !== INVALID_CURRENCY_CODE && info._tender !== "false" && info._from) {
      if (!info._to) {
        var stillValidDate = parseRangeDate(info._from);
        if (!latestStillValidDate || latestStillValidDate < stillValidDate) {
          latestStillValid = code2;
          latestStillValidDate = stillValidDate;
        }
      } else if (!latestStillValid) {
        var validFrom = parseRangeDate(info._from);
        var validTo = parseRangeDate(info._to);
        if (!latestValidUntilRange || latestValidUntilRange.to < validTo || latestValidUntilRange.from < validFrom) {
          latestValidUntil = code2;
          latestValidUntilRange = {
            from: validFrom,
            to: validTo
          };
        }
      }
    }
  }
  return latestStillValid || latestValidUntil;
}
function currencyDisplays(locale, currency, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  var currencyInfo = getCurrencyInfo(locale, currency, throwIfNoValid);
  if (!currencyInfo) {
    return;
  }
  if (!currencyInfo.displays) {
    var displays = [currency];
    for (var field in currencyInfo) {
      displays.push(currencyInfo[field]);
    }
    displays.sort(lengthComparer);
    currencyInfo.displays = displays;
  }
  return currencyInfo.displays;
}
function currencyDisplay(locale, options2) {
  var value = options2.value;
  var currency = options2.currency;
  var currencyDisplay2 = options2.currencyDisplay;
  if (currencyDisplay2 === void 0)
    currencyDisplay2 = SYMBOL;
  if (currencyDisplay2 === "code") {
    return currency;
  }
  var currencyInfo = getCurrencyInfo(locale, currency, true);
  var result;
  if (currencyDisplay2 === SYMBOL) {
    result = currencyInfo["symbol-alt-narrow"] || currencyInfo[SYMBOL];
  } else {
    if (typeof value === "undefined" || value !== 1) {
      result = currencyInfo["displayName-count-other"];
    } else {
      result = currencyInfo["displayName-count-one"];
    }
  }
  return result;
}
function currencyFractionOptions(code2) {
  var minimumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var maximumFractionDigits = DEFAULT_CURRENCY_FRACTIONS;
  var fractions = ((cldr.supplemental.currencyData || {}).fractions || {})[code2];
  if (fractions && fractions._digits) {
    maximumFractionDigits = minimumFractionDigits = parseInt(fractions._digits, 10);
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function territoryCurrencyCode(territory, throwIfNoValid) {
  if (throwIfNoValid === void 0)
    throwIfNoValid = true;
  if (GLOBAL_CURRENCIES[territory]) {
    return GLOBAL_CURRENCIES[territory];
  }
  var currencyData = cldr.supplemental.currencyData;
  if (!currencyData) {
    if (throwIfNoValid) {
      throw NoSupplementalCurrency.error();
    }
    return;
  }
  var regionCurrencies = currencyData.region[territory];
  if (!regionCurrencies) {
    if (throwIfNoValid) {
      throw NoCurrencyRegion.error(territory);
    }
    return;
  }
  var currencyCode = regionCurrency(regionCurrencies);
  return currencyCode;
}
function localeCurrency(locale, throwIfNoValid) {
  var info = getLocaleInfo(locale);
  var numbers = info.numbers;
  if (!numbers.localeCurrency) {
    var currency = territoryCurrencyCode(localeTerritory(info), throwIfNoValid);
    if (!currency && throwIfNoValid) {
      throw NoValidCurrency.error(info.name);
    }
    numbers.localeCurrency = currency;
  }
  return numbers.localeCurrency;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/constants.js
var DAYS_OF_WEEK = ["sun", "mon", "tue", "wed", "thu", "fri", "sat"];
var DEFAULT_TERRITORY = "001";

// node_modules/@progress/kendo-intl/dist/es/cldr/first-day.js
var NoWeekData = errors.NoWeekData;
var NoFirstDay = errors.NoFirstDay;
function firstDay(locale) {
  var info = getLocaleInfo(locale);
  if (!isNaN(info.firstDay)) {
    return info.firstDay;
  }
  var weekData = cldr.supplemental.weekData;
  if (!weekData) {
    throw NoWeekData.error();
  }
  var firstDay3 = weekData.firstDay[localeTerritory(info)] || weekData.firstDay[DEFAULT_TERRITORY];
  if (!firstDay3) {
    throw NoFirstDay.error();
  }
  info.firstDay = DAYS_OF_WEEK.indexOf(firstDay3);
  return info.firstDay;
}

// node_modules/@progress/kendo-intl/dist/es/cldr/weekend-range.js
var NoWeekData2 = errors.NoWeekData;

// node_modules/@progress/kendo-intl/dist/es/cldr/number-symbols.js
function numberSymbols(locale) {
  var info = getLocaleInfo(locale);
  return info.numbers.symbols;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-negative-zero.js
function isNegativeZero(value) {
  return 1 / value === -Infinity;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-currency-symbol.js
function formatCurrencySymbol(info, options2) {
  if (options2 === void 0)
    options2 = {};
  if (!options2.currency) {
    options2.currency = localeCurrency(info, true);
  }
  var display = currencyDisplay(info, options2);
  return display;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/group-integer.js
function groupInteger(number2, start, end, options2, info) {
  var symbols = info.numbers.symbols;
  var decimalIndex = number2.indexOf(symbols.decimal);
  var groupSizes = options2.groupSize.slice();
  var groupSize = groupSizes.shift();
  var integerEnd = decimalIndex !== -1 ? decimalIndex : end + 1;
  var integer = number2.substring(start, integerEnd);
  var result = number2;
  var integerLength = integer.length;
  if (integerLength >= groupSize) {
    var idx = integerLength;
    var parts = [];
    while (idx > -1) {
      var value = integer.substring(idx - groupSize, idx);
      if (value) {
        parts.push(value);
      }
      idx -= groupSize;
      var newGroupSize = groupSizes.shift();
      groupSize = newGroupSize !== void 0 ? newGroupSize : groupSize;
      if (groupSize === 0) {
        value = integer.substring(0, idx);
        if (value) {
          parts.push(value);
        }
        break;
      }
    }
    integer = parts.reverse().join(symbols.group);
    result = number2.substring(0, start) + integer + number2.substring(integerEnd);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/is-currency-style.js
function isCurrencyStyle(style) {
  return style === CURRENCY || style === ACCOUNTING;
}

// node_modules/@progress/kendo-intl/dist/es/common/pad.js
function pad(number2, digits, right) {
  if (digits === void 0)
    digits = 2;
  if (right === void 0)
    right = false;
  var count = digits - String(number2).length;
  var result = number2;
  if (count > 0) {
    var padString = new Array(count + 1).join("0");
    result = right ? number2 + padString : padString + number2;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/round.js
var MAX_PRECISION = 20;
function round(value, precision) {
  var result = value;
  var decimals = precision || 0;
  result = result.toString().split("e");
  result = Math.round(Number(result[0] + "e" + (result[1] ? Number(result[1]) + decimals : decimals)));
  result = result.toString().split("e");
  result = Number(result[0] + "e" + (result[1] ? Number(result[1]) - decimals : -decimals));
  return result.toFixed(Math.min(decimals, MAX_PRECISION));
}

// node_modules/@progress/kendo-intl/dist/es/numbers/standard-number-format.js
var DEFAULT_DECIMAL_ROUNDING = 3;
var DEFAULT_PERCENT_ROUNDING = 0;
var trailingZeroRegex = /0+$/;
function fractionOptions(options2) {
  var minimumFractionDigits = options2.minimumFractionDigits;
  var maximumFractionDigits = options2.maximumFractionDigits;
  var style = options2.style;
  var isCurrency = isCurrencyStyle(style);
  var currencyFractions;
  if (isCurrency) {
    currencyFractions = currencyFractionOptions(options2.currency);
  }
  if (minimumFractionDigits === void 0) {
    minimumFractionDigits = isCurrency ? currencyFractions.minimumFractionDigits : 0;
  }
  if (maximumFractionDigits === void 0) {
    if (style === PERCENT) {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_PERCENT_ROUNDING);
    } else if (isCurrency) {
      maximumFractionDigits = Math.max(minimumFractionDigits, currencyFractions.maximumFractionDigits);
    } else {
      maximumFractionDigits = Math.max(minimumFractionDigits, DEFAULT_DECIMAL_ROUNDING);
    }
  }
  return {
    minimumFractionDigits,
    maximumFractionDigits
  };
}
function applyPattern(value, pattern, symbol) {
  var result = EMPTY;
  for (var idx = 0, length = pattern.length; idx < length; idx++) {
    var ch = pattern.charAt(idx);
    if (ch === NUMBER_PLACEHOLDER) {
      result += value;
    } else if (ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER) {
      result += symbol;
    } else {
      result += ch;
    }
  }
  return result;
}
function currencyUnitPattern(info, value) {
  var currencyInfo = info.numbers.currency;
  var pattern = value !== 1 ? currencyInfo["unitPattern-count-other"] : currencyInfo["unitPattern-count-one"];
  if (value < 0) {
    pattern = pattern.replace(NUMBER_PLACEHOLDER, "-" + NUMBER_PLACEHOLDER);
  }
  return pattern;
}
function standardNumberFormat(number2, options2, info) {
  var symbols = info.numbers.symbols;
  var style = options2.style;
  var isCurrency = isCurrencyStyle(style);
  if (style === SCIENTIFIC) {
    var exponential = options2.minimumFractionDigits !== void 0 ? number2.toExponential(options2.minimumFractionDigits) : number2.toExponential();
    return exponential.replace(POINT, symbols.decimal);
  }
  var value = number2;
  var symbol;
  if (isCurrency) {
    options2.value = value;
    symbol = formatCurrencySymbol(info, options2);
  }
  if (style === PERCENT) {
    value *= 100;
    symbol = symbols.percentSign;
  }
  var ref2 = fractionOptions(options2);
  var minimumFractionDigits = ref2.minimumFractionDigits;
  var maximumFractionDigits = ref2.maximumFractionDigits;
  value = round(value, maximumFractionDigits);
  var negative = value < 0;
  var negativeZero = isNegativeZero(number2);
  var parts = value.split(POINT);
  var integer = parts[0];
  var fraction = pad(parts[1] ? parts[1].replace(trailingZeroRegex, EMPTY) : EMPTY, minimumFractionDigits, true);
  if (negative) {
    integer = integer.substring(1);
  }
  if (options2.minimumIntegerDigits) {
    integer = pad(integer, options2.minimumIntegerDigits);
  }
  var formattedValue = options2.useGrouping !== false ? groupInteger(integer, 0, integer.length, options2, info) : integer;
  if (fraction) {
    formattedValue += symbols.decimal + fraction;
  }
  var pattern;
  if (isCurrency && options2.currencyDisplay === "name") {
    pattern = currencyUnitPattern(info, number2);
  } else {
    var patterns = options2.patterns;
    pattern = negative || negativeZero ? patterns[1] || "-" + patterns[0] : patterns[0];
  }
  if (pattern === NUMBER_PLACEHOLDER && !negative) {
    return formattedValue;
  }
  var result = applyPattern(formattedValue, pattern, symbol);
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/utils.js
var literalRegExp = /(\\.)|(['][^']*[']?)|(["][^"]*["]?)/g;
var PLACEHOLDER = "__??__";
function setStyleOptions(formatOptions2, info) {
  var format2 = formatOptions2.format;
  if (format2.indexOf(PERCENT_PLACEHOLDER) !== -1) {
    formatOptions2.style = PERCENT;
    formatOptions2.symbol = info.numbers.symbols.percentSign;
    formatOptions2.number *= 100;
  }
  if (format2.indexOf(CURRENCY_PLACEHOLDER) !== -1) {
    formatOptions2.style = CURRENCY;
    formatOptions2.symbol = formatCurrencySymbol(info);
  }
}
function setFormatLiterals(formatOptions2) {
  var format2 = formatOptions2.format;
  if (format2.indexOf("'") > -1 || format2.indexOf('"') > -1 || format2.indexOf("\\") > -1) {
    var literals2 = formatOptions2.literals = [];
    formatOptions2.format = format2.replace(literalRegExp, function(match) {
      var quoteChar = match.charAt(0).replace("\\", EMPTY);
      var literal = match.slice(1).replace(quoteChar, EMPTY);
      literals2.push(literal);
      return PLACEHOLDER;
    });
  }
}
function replaceLiterals(number2, literals2) {
  var result = number2;
  if (literals2) {
    var length = literals2.length;
    for (var idx = 0; idx < length; idx++) {
      result = result.replace(PLACEHOLDER, literals2[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/custom-number-format.js
var SHARP = "#";
var ZERO = "0";
var trailingZerosRegExp = /(\.(?:[0-9]*[1-9])?)0+$/g;
var trailingPointRegExp = /\.$/;
var commaRegExp = /,/g;
function trimTrailingZeros(value, lastZero) {
  var trimRegex;
  if (lastZero === 0) {
    trimRegex = trailingZerosRegExp;
  } else {
    trimRegex = new RegExp("(\\.[0-9]{" + lastZero + "}[1-9]*)0+$", "g");
  }
  return value.replace(trimRegex, "$1").replace(trailingPointRegExp, EMPTY);
}
function roundNumber(formatOptions2) {
  var number2 = formatOptions2.number;
  var format2 = formatOptions2.format;
  var decimalIndex = format2.indexOf(POINT);
  if (decimalIndex !== -1) {
    var zeroIndex = format2.lastIndexOf(ZERO) - decimalIndex;
    var sharpIndex = format2.lastIndexOf(SHARP) - decimalIndex;
    var hasZero = zeroIndex > -1;
    var hasSharp = sharpIndex > -1;
    var fraction = number2.toString().split("e");
    if (fraction[1]) {
      fraction = round(number2, Math.abs(fraction[1]));
    } else {
      fraction = fraction[0];
    }
    fraction = fraction.split(POINT)[1] || EMPTY;
    var precision = fraction.length;
    var trailingZeros = -1;
    if (!hasZero && !hasSharp) {
      formatOptions2.format = format2.substring(0, decimalIndex) + format2.substring(decimalIndex + 1);
      decimalIndex = -1;
      precision = 0;
    } else if (hasZero && zeroIndex > sharpIndex) {
      precision = zeroIndex;
    } else if (sharpIndex > zeroIndex) {
      if (hasSharp && precision > sharpIndex) {
        precision = sharpIndex;
      } else if (hasZero && precision < zeroIndex) {
        precision = zeroIndex;
      }
      trailingZeros = hasZero ? zeroIndex : 0;
    }
    if (precision > -1) {
      number2 = round(number2, precision);
      if (trailingZeros > -1) {
        number2 = trimTrailingZeros(number2, trailingZeros);
      }
    }
  } else {
    number2 = round(number2);
  }
  if (formatOptions2.negative && number2 * -1 >= 0 && !formatOptions2.negativeZero) {
    formatOptions2.negative = false;
  }
  formatOptions2.number = number2;
  formatOptions2.decimalIndex = decimalIndex;
}
function isConstantFormat(format2) {
  return format2.indexOf(SHARP) === -1 && format2.indexOf(ZERO) === -1;
}
function setValueSpecificFormat(formatOptions2) {
  var number2 = formatOptions2.number;
  var format2 = formatOptions2.format;
  format2 = format2.split(LIST_SEPARATOR);
  if ((formatOptions2.negative || formatOptions2.negativeZero) && format2[1]) {
    format2 = format2[1];
    formatOptions2.hasNegativeFormat = true;
  } else if (number2 === 0) {
    var zeroFormat = format2[2];
    format2 = zeroFormat || format2[0];
    if (zeroFormat && isConstantFormat(zeroFormat)) {
      formatOptions2.constant = zeroFormat;
    }
  } else {
    format2 = format2[0];
  }
  formatOptions2.format = format2;
}
function setGroupOptions(formatOptions2) {
  formatOptions2.hasGroup = formatOptions2.format.indexOf(GROUP_SEPARATOR) > -1;
  if (formatOptions2.hasGroup) {
    formatOptions2.format = formatOptions2.format.replace(commaRegExp, EMPTY);
  }
}
function placeholderIndex(index1, index2, start) {
  var index;
  if (index1 === -1 && index2 !== -1) {
    index = index2;
  } else if (index1 !== -1 && index2 === -1) {
    index = index1;
  } else {
    index = start ? Math.min(index1, index2) : Math.max(index1, index2);
  }
  return index;
}
function setPlaceholderIndices(formatOptions2) {
  var format2 = formatOptions2.format;
  var sharpIndex = format2.indexOf(SHARP);
  var zeroIndex = format2.indexOf(ZERO);
  var start = placeholderIndex(sharpIndex, zeroIndex, true);
  sharpIndex = format2.lastIndexOf(SHARP);
  zeroIndex = format2.lastIndexOf(ZERO);
  var end = placeholderIndex(sharpIndex, zeroIndex);
  if (start === format2.length) {
    end = start;
  }
  formatOptions2.start = start;
  formatOptions2.end = end;
  formatOptions2.lastZeroIndex = zeroIndex;
}
function replaceStyleSymbols(number2, style, symbol) {
  var result = number2;
  if (style === CURRENCY || style === PERCENT) {
    result = EMPTY;
    for (var idx = 0, length = number2.length; idx < length; idx++) {
      var ch = number2.charAt(idx);
      result += ch === CURRENCY_PLACEHOLDER || ch === PERCENT_PLACEHOLDER ? symbol : ch;
    }
  }
  return result;
}
function replacePlaceHolders(formatOptions2, info) {
  var start = formatOptions2.start;
  var end = formatOptions2.end;
  var negative = formatOptions2.negative;
  var negativeZero = formatOptions2.negativeZero;
  var format2 = formatOptions2.format;
  var decimalIndex = formatOptions2.decimalIndex;
  var lastZeroIndex = formatOptions2.lastZeroIndex;
  var hasNegativeFormat = formatOptions2.hasNegativeFormat;
  var hasGroup = formatOptions2.hasGroup;
  var number2 = formatOptions2.number;
  var value = number2.toString().split(POINT);
  var length = format2.length;
  var integer = value[0];
  var fraction = value[1] || EMPTY;
  var integerLength = integer.length;
  var replacement = EMPTY;
  number2 = format2.substring(0, start);
  if ((negative || negativeZero) && !hasNegativeFormat) {
    number2 += "-";
  }
  for (var idx = start; idx < length; idx++) {
    var ch = format2.charAt(idx);
    if (decimalIndex === -1) {
      if (end - idx < integerLength) {
        number2 += integer;
        break;
      }
    } else {
      if (lastZeroIndex !== -1 && lastZeroIndex < idx) {
        replacement = EMPTY;
      }
      if (decimalIndex - idx <= integerLength && decimalIndex - idx > -1) {
        number2 += integer;
        idx = decimalIndex;
      }
      if (decimalIndex === idx) {
        number2 += (fraction ? info.numbers.symbols.decimal : EMPTY) + fraction;
        idx += end - decimalIndex + 1;
        continue;
      }
    }
    if (ch === ZERO) {
      number2 += ch;
      replacement = ch;
    } else if (ch === SHARP) {
      number2 += replacement;
    }
  }
  if (hasGroup) {
    number2 = groupInteger(number2, start + (negative && !hasNegativeFormat ? 1 : 0), Math.max(end, integerLength + start), info.numbers.decimal, info);
  }
  if (end >= start) {
    number2 += format2.substring(end + 1);
  }
  return number2;
}
function applyCustomFormat(formatOptions2, info) {
  var number2 = formatOptions2.number;
  if (formatOptions2.start !== -1) {
    number2 = replacePlaceHolders(formatOptions2, info);
    number2 = replaceStyleSymbols(number2, formatOptions2.style, formatOptions2.symbol);
    number2 = replaceLiterals(number2, formatOptions2.literals);
  }
  return number2;
}
function customNumberFormat(number2, format2, info) {
  var formatOptions2 = {
    negative: number2 < 0,
    number: Math.abs(number2),
    negativeZero: isNegativeZero(number2),
    format: format2
  };
  setValueSpecificFormat(formatOptions2);
  if (formatOptions2.constant) {
    return formatOptions2.constant;
  }
  setFormatLiterals(formatOptions2);
  setStyleOptions(formatOptions2, info);
  setGroupOptions(formatOptions2);
  roundNumber(formatOptions2);
  setPlaceholderIndices(formatOptions2);
  return applyCustomFormat(formatOptions2, info);
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-options.js
var standardFormatRegExp = /^(n|c|p|e|a)(\d*)$/i;
function standardFormatOptions(format2) {
  var formatAndPrecision = standardFormatRegExp.exec(format2);
  if (formatAndPrecision) {
    var options2 = {
      style: DECIMAL
    };
    var style = formatAndPrecision[1].toLowerCase();
    if (style === "c") {
      options2.style = CURRENCY;
    } else if (style === "a") {
      options2.style = ACCOUNTING;
    } else if (style === "p") {
      options2.style = PERCENT;
    } else if (style === "e") {
      options2.style = SCIENTIFIC;
    }
    if (formatAndPrecision[2]) {
      options2.minimumFractionDigits = options2.maximumFractionDigits = parseInt(formatAndPrecision[2], 10);
    }
    return options2;
  }
}
function formatOptions(format2) {
  var options2;
  if (isString(format2)) {
    options2 = standardFormatOptions(format2);
  } else {
    options2 = format2;
  }
  return options2;
}

// node_modules/@progress/kendo-intl/dist/es/numbers/format-number.js
function formatNumber(number2, format2, locale) {
  if (format2 === void 0)
    format2 = NUMBER_PLACEHOLDER;
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (number2 === void 0 || number2 === null) {
    return EMPTY;
  }
  if (!isFinite(number2)) {
    return String(number2);
  }
  var info = localeInfo(locale);
  var options2 = formatOptions(format2);
  var result;
  if (options2) {
    var style = options2.style || DECIMAL;
    result = standardNumberFormat(number2, Object.assign({}, info.numbers[style], options2), info);
  } else {
    result = customNumberFormat(number2, format2, info);
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/common/is-number.js
function isNumber(value) {
  return typeof value === "number";
}

// node_modules/@progress/kendo-intl/dist/es/numbers/parse-number.js
var exponentRegExp = /[eE][-+]?[0-9]+/;
var nonBreakingSpaceRegExp = /\u00A0/g;
function cleanNegativePattern(number2, patterns) {
  if (patterns.length > 1) {
    var parts = (patterns[1] || EMPTY).replace(CURRENCY_PLACEHOLDER, EMPTY).split(NUMBER_PLACEHOLDER);
    if (number2.indexOf(parts[0]) > -1 && number2.indexOf(parts[1]) > -1) {
      return number2.replace(parts[0], EMPTY).replace(parts[1], EMPTY);
    }
  }
}
function cleanCurrencyNumber(value, info, format2) {
  var options2 = formatOptions(format2) || {};
  var isCurrency = isCurrencyStyle(options2.style);
  var number2 = value;
  var negative;
  var currency = options2.currency || localeCurrency(info, isCurrency);
  if (currency) {
    var displays = currencyDisplays(info, currency, isCurrency);
    if (displays) {
      for (var idx = 0; idx < displays.length; idx++) {
        var display = displays[idx];
        if (number2.includes(display)) {
          number2 = number2.replace(display, EMPTY);
          isCurrency = true;
          break;
        }
      }
    }
    if (isCurrency) {
      var cleanNumber = cleanNegativePattern(number2, info.numbers.currency.patterns) || cleanNegativePattern(number2, info.numbers.accounting.patterns);
      if (cleanNumber) {
        negative = true;
        number2 = cleanNumber;
      }
    }
  }
  return {
    number: number2,
    negative
  };
}
function cleanLiterals(number2, formatOptions2) {
  var literals2 = formatOptions2.literals;
  var result = number2;
  if (literals2) {
    for (var idx = 0; idx < literals2.length; idx++) {
      result = result.replace(literals2[idx], EMPTY);
    }
  }
  return result;
}
function divideBy100(number2) {
  var strNumber = String(number2);
  var pointIndex = strNumber.indexOf(POINT);
  var zeroesCount = 2;
  var result = number2 / Math.pow(10, zeroesCount);
  if (pointIndex === -1 || String(result).length <= strNumber.length + zeroesCount) {
    return result;
  }
  var fractionDigits = strNumber.length - pointIndex + 1 + zeroesCount;
  return parseFloat(result.toFixed(fractionDigits));
}
function parseNumber(value, locale, format2) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (format2 === void 0)
    format2 = {};
  if (!value && value !== 0) {
    return null;
  }
  if (isNumber(value)) {
    return value;
  }
  var info = localeInfo(locale);
  var symbols = info.numbers.symbols;
  var number2 = value.toString();
  var formatOptions2 = format2 || {};
  var isPercent;
  if (isString(format2)) {
    formatOptions2 = { format: format2 };
    setFormatLiterals(formatOptions2);
    number2 = cleanLiterals(number2, formatOptions2);
    setStyleOptions(formatOptions2, info);
  }
  if (formatOptions2.style === PERCENT || number2.indexOf(symbols.percentSign) > -1) {
    number2 = number2.replace(symbols.percentSign, EMPTY);
    isPercent = true;
  }
  if (exponentRegExp.test(number2)) {
    number2 = parseFloat(number2.replace(symbols.decimal, POINT));
    return isNaN(number2) ? null : number2;
  }
  var ref2 = cleanCurrencyNumber(number2, info, formatOptions2);
  var negativeCurrency = ref2.negative;
  var currencyNumber = ref2.number;
  number2 = String(currencyNumber).trim();
  var negativeSignIndex = number2.indexOf("-");
  if (negativeSignIndex > 0) {
    return null;
  }
  var isNegative = negativeSignIndex > -1;
  isNegative = negativeCurrency !== void 0 ? negativeCurrency : isNegative;
  number2 = number2.replace("-", EMPTY).replace(nonBreakingSpaceRegExp, " ").split(symbols.group.replace(nonBreakingSpaceRegExp, " ")).join(EMPTY).replace(symbols.decimal, POINT);
  number2 = parseFloat(number2);
  if (isNaN(number2)) {
    number2 = null;
  } else if (isNegative) {
    number2 *= -1;
  }
  if (number2 && isPercent) {
    number2 = divideBy100(number2);
  }
  return number2;
}

// node_modules/@progress/kendo-intl/dist/es/common/format-string.js
var formatRegExp2 = /\{(\d+)}/g;
function formatString(format2) {
  var values5 = arguments;
  return format2.replace(formatRegExp2, function(match, index) {
    var value = values5[parseInt(index, 10) + 1];
    return value;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-pattern.js
var REMOVAL_PENALTY = 120;
var ADDITION_PENALTY = 20;
var LENGHT_DELTA = [2, 1, 5, 3, 4];
var LONG_LESS_PENALTY_DELTA = -2;
var SHORT_LESS_PENALTY_DELTA = -1;
var SHORT_MORE_PENALTY_DELTA = 1;
var LONG_MORE_PENALTY_DELTA = 2;
var PENALTIES = {};
PENALTIES[LONG_LESS_PENALTY_DELTA.toString()] = 8;
PENALTIES[SHORT_LESS_PENALTY_DELTA.toString()] = 6;
PENALTIES[LONG_MORE_PENALTY_DELTA.toString()] = 6;
PENALTIES[SHORT_MORE_PENALTY_DELTA.toString()] = 3;
var VALUE_FORMAT_LENGTH = {
  numeric: 1,
  "2-digit": 2,
  short: 3,
  long: 4,
  narrow: 5
};
var TIME_SPECIFIERS_REGEX = /[hHmsSzZoOvVxX]/;
function getHourSpecifier(options2) {
  return options2.hour12 ? "h" : "H";
}
var DATE_OPTIONS_MAP = [{
  key: "era",
  specifier: "G"
}, {
  key: "year",
  specifier: "y"
}, {
  key: "month",
  specifier: "M"
}, {
  key: "day",
  specifier: "d"
}, {
  key: "weekday",
  specifier: "E"
}, {
  key: "hour",
  getSpecifier: getHourSpecifier
}, {
  key: "minute",
  specifier: "m"
}, {
  key: "second",
  specifier: "s"
}, {
  key: "timeZoneName",
  specifier: "z"
}];
var STAND_ALONE_SPECIFIERS = {
  e: "c",
  E: "c",
  M: "L",
  Q: "q"
};
var specifiersRegex = {};
var resolvedFormats = {};
function getSpecifierRegex(specifier) {
  if (!specifiersRegex[specifier]) {
    specifiersRegex[specifier] = new RegExp(specifier + "+");
  }
  return specifiersRegex[specifier];
}
function skeletonSpecifiers(skeleton) {
  var result = [];
  var current4 = skeleton.charAt(0);
  var specifier = current4;
  for (var idx = 1; idx < skeleton.length; idx++) {
    var character = skeleton.charAt(idx);
    if (character === specifier) {
      current4 += character;
    } else {
      result.push(current4);
      current4 = specifier = character;
    }
  }
  result.push(current4);
  return result;
}
function findBestMatch(specifiers, availableFormats) {
  var specifiersLength = specifiers.length;
  var maxScore = -Number.MAX_VALUE;
  var bestMatches, result;
  for (var format2 in availableFormats) {
    var matches2 = [];
    var currentFormat = format2.replace("v", "z");
    var score = 0;
    for (var idx = 0; idx < specifiersLength; idx++) {
      var specifier = specifiers[idx];
      var specifierRegex = getSpecifierRegex(specifier[0]);
      var match = (specifierRegex.exec(currentFormat) || [])[0];
      if (!match) {
        score -= REMOVAL_PENALTY;
      } else {
        currentFormat = currentFormat.replace(match, EMPTY);
        if (match.length !== specifier.length) {
          var delta = Math.max(Math.min(LENGHT_DELTA[match.length] - LENGHT_DELTA[specifier.length], 2), -2);
          score -= PENALTIES[delta];
        }
      }
      matches2.push(match);
      if (score < maxScore) {
        break;
      }
    }
    if (currentFormat.length) {
      score -= skeletonSpecifiers(currentFormat).length * ADDITION_PENALTY;
    }
    if (score > maxScore) {
      maxScore = score;
      bestMatches = matches2;
      result = availableFormats[format2];
    }
  }
  result = result.replace("v", "z");
  for (var idx$1 = 0; idx$1 < specifiersLength; idx$1++) {
    var bestMatch = bestMatches[idx$1];
    if (bestMatch && bestMatch !== specifiers[idx$1]) {
      var matchSpecifier = bestMatches[idx$1][0];
      result = result.replace(getSpecifierRegex(matchSpecifier), specifiers[idx$1]);
      if (STAND_ALONE_SPECIFIERS[matchSpecifier]) {
        result = result.replace(getSpecifierRegex(STAND_ALONE_SPECIFIERS[matchSpecifier]), specifiers[idx$1]);
      }
    }
  }
  return result;
}
function cacheFormat(skeleton, format2, locale) {
  if (!resolvedFormats[locale]) {
    resolvedFormats[locale] = {};
  }
  resolvedFormats[locale][skeleton] = format2;
}
function skeletonFormat(skeleton, info) {
  var availableFormats = info.calendar.dateTimeFormats.availableFormats;
  if (availableFormats[skeleton]) {
    return availableFormats[skeleton];
  }
  if (resolvedFormats[info.name] && resolvedFormats[info.name][skeleton]) {
    return resolvedFormats[info.name][skeleton];
  }
  var timeStartIndex = skeleton.search(TIME_SPECIFIERS_REGEX);
  var result;
  if (timeStartIndex > 0) {
    var dateSkeleton = skeleton.substr(0, timeStartIndex);
    var timeSkeleton = skeleton.substr(timeStartIndex);
    result = formatString(
      info.calendar.dateTimeFormats.short,
      //should be deterimed based on specifiers
      availableFormats[timeSkeleton] || findBestMatch(skeletonSpecifiers(timeSkeleton), availableFormats),
      availableFormats[dateSkeleton] || findBestMatch(skeletonSpecifiers(dateSkeleton), availableFormats)
    );
  } else {
    result = findBestMatch(skeletonSpecifiers(skeleton), availableFormats);
  }
  cacheFormat(skeleton, result, info.name);
  return result;
}
function skeletonFromOptions(options2) {
  var result = [];
  for (var idx = 0; idx < DATE_OPTIONS_MAP.length; idx++) {
    var option = DATE_OPTIONS_MAP[idx];
    var field = option.key;
    var value = options2[field];
    if (value) {
      var spcifier = option.specifier || option.getSpecifier(options2);
      result.push(spcifier.repeat(VALUE_FORMAT_LENGTH[value]));
    }
  }
  return result.join(EMPTY);
}
function datePattern(format2, info) {
  var calendar = info.calendar;
  var result;
  if (isString(format2)) {
    if (calendar.patterns[format2]) {
      result = calendar.patterns[format2];
    } else {
      result = format2;
    }
  } else if (format2) {
    if (format2.pattern) {
      return format2.pattern;
    }
    var skeleton = format2.skeleton;
    if (!skeleton) {
      if (format2.datetime) {
        result = formatString(calendar.dateTimeFormats[format2.datetime], calendar.timeFormats[format2.datetime], calendar.dateFormats[format2.datetime]);
      } else if (format2.date) {
        result = calendar.dateFormats[format2.date];
      } else if (format2.time) {
        result = calendar.timeFormats[format2.time];
      } else {
        skeleton = skeletonFromOptions(format2);
      }
    }
    if (skeleton) {
      result = skeletonFormat(skeleton, info);
    }
  }
  if (!result) {
    result = calendar.patterns.d;
  }
  return result;
}

// node_modules/@progress/kendo-intl/dist/es/dates/date-name-type.js
function dateNameType(formatLength) {
  var nameType;
  if (formatLength <= 3) {
    nameType = "abbreviated";
  } else if (formatLength === 4) {
    nameType = "wide";
  } else if (formatLength === 5) {
    nameType = "narrow";
  } else if (formatLength === 6) {
    nameType = "short";
  }
  return nameType;
}

// node_modules/@progress/kendo-intl/dist/es/dates/format-names.js
function formatNames(locale, type, formatLength, standAlone, lower) {
  return dateFormatNames(locale, {
    type,
    nameType: dateNameType(formatLength),
    standAlone,
    lower
  });
}

// node_modules/@progress/kendo-intl/dist/es/common/is-date.js
function isFunction(fun) {
  return typeof fun === "function";
}
function isDate(value) {
  return Boolean(value) && isFunction(value.getTime) && isFunction(value.getMonth);
}

// node_modules/@progress/kendo-intl/dist/es/dates/constants.js
var MONTH = "month";
var HOUR = "hour";
var ZONE = "zone";
var WEEKDAY = "weekday";
var QUARTER = "quarter";
var DATE_FIELD_MAP = {
  "G": "era",
  "y": "year",
  "q": QUARTER,
  "Q": QUARTER,
  "M": MONTH,
  "L": MONTH,
  "d": "day",
  "E": WEEKDAY,
  "c": WEEKDAY,
  "e": WEEKDAY,
  "h": HOUR,
  "H": HOUR,
  "k": HOUR,
  "K": HOUR,
  "m": "minute",
  "s": "second",
  "S": "millisecond",
  "a": "dayperiod",
  "x": ZONE,
  "X": ZONE,
  "z": ZONE,
  "Z": ZONE
};
var dateFormatRegExp = /d{1,2}|E{1,6}|e{1,6}|c{3,6}|c{1}|M{1,5}|L{1,5}|y{1,4}|H{1,2}|h{1,2}|k{1,2}|K{1,2}|m{1,2}|a{1,5}|s{1,2}|S{1,3}|z{1,4}|Z{1,5}|x{1,5}|X{1,5}|G{1,5}|q{1,5}|Q{1,5}|"[^"]*"|'[^']*'/g;

// node_modules/@progress/kendo-intl/dist/es/dates/format-date.js
function formatDayOfWeekIndex(day, formatLength, localeInfo2) {
  var firstDayIndex = firstDay(localeInfo2);
  var dayIndex;
  if (day < firstDayIndex) {
    dayIndex = 7 - firstDayIndex + day;
  } else {
    dayIndex = day - firstDayIndex;
  }
  return dayIndex + 1;
}
function formatMonth(month, formatLength, info, standAlone) {
  if (formatLength <= 2) {
    return pad(month + 1, formatLength);
  }
  return formatNames(info, "months", formatLength, standAlone)[month];
}
function formatQuarter(date, formatLength, info, standAlone) {
  var quarter = Math.floor(date.getMonth() / 3);
  if (formatLength < 3) {
    return quarter + 1;
  }
  return formatNames(info, "quarters", formatLength, standAlone)[quarter];
}
function formatTimeZone(date, info, options2) {
  var shortHours = options2.shortHours;
  var optionalMinutes = options2.optionalMinutes;
  var separator = options2.separator;
  var localizedName = options2.localizedName;
  var zZeroOffset = options2.zZeroOffset;
  var offset = date.getTimezoneOffset() / 60;
  if (offset === 0 && zZeroOffset) {
    return "Z";
  }
  var sign = offset <= 0 ? "+" : "-";
  var hoursMinutes = Math.abs(offset).toString().split(".");
  var minutes = hoursMinutes[1] || 0;
  var result = sign + (shortHours ? hoursMinutes[0] : pad(hoursMinutes[0], 2));
  if (minutes || !optionalMinutes) {
    result += (separator ? ":" : EMPTY) + pad(minutes, 2);
  }
  if (localizedName) {
    var localizedFormat = offset === 0 ? info.calendar.gmtZeroFormat : info.calendar.gmtFormat;
    result = formatString(localizedFormat, result);
  }
  return result;
}
function formatDayOfWeek(date, formatLength, info, standAlone) {
  var result;
  if (formatLength < 3) {
    result = formatDayOfWeekIndex(date.getDay(), formatLength, info);
  } else {
    result = formatNames(info, "days", formatLength, standAlone)[date.getDay()];
  }
  return result;
}
var formatters = {};
formatters.d = function(date, formatLength) {
  return pad(date.getDate(), formatLength);
};
formatters.E = function(date, formatLength, info) {
  return formatNames(info, "days", formatLength)[date.getDay()];
};
formatters.M = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, false);
};
formatters.L = function(date, formatLength, info) {
  return formatMonth(date.getMonth(), formatLength, info, true);
};
formatters.y = function(date, formatLength) {
  var year = date.getFullYear();
  if (formatLength === 2) {
    year = year % 100;
  }
  return pad(year, formatLength);
};
formatters.h = function(date, formatLength) {
  var hours = date.getHours() % 12 || 12;
  return pad(hours, formatLength);
};
formatters.H = function(date, formatLength) {
  return pad(date.getHours(), formatLength);
};
formatters.k = function(date, formatLength) {
  return pad(date.getHours() || 24, formatLength);
};
formatters.K = function(date, formatLength) {
  return pad(date.getHours() % 12, formatLength);
};
formatters.m = function(date, formatLength) {
  return pad(date.getMinutes(), formatLength);
};
formatters.s = function(date, formatLength) {
  return pad(date.getSeconds(), formatLength);
};
formatters.S = function(date, formatLength) {
  var milliseconds = date.getMilliseconds();
  var result;
  if (milliseconds !== 0) {
    result = pad(String(milliseconds / 1e3).split(".")[1].substr(0, formatLength), formatLength, true);
  } else {
    result = pad(EMPTY, formatLength);
  }
  return result;
};
formatters.a = function(date, formatLength, info) {
  return formatNames(info, "dayPeriods", formatLength)[date.getHours() < 12 ? "am" : "pm"];
};
formatters.z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    shortHours: formatLength < 4,
    optionalMinutes: formatLength < 4,
    separator: true,
    localizedName: true
  });
};
formatters.Z = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    separator: formatLength > 3,
    localizedName: formatLength === 4,
    zZeroOffset: formatLength === 5
  });
};
formatters.x = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5
  });
};
formatters.X = function(date, formatLength, info) {
  return formatTimeZone(date, info, {
    optionalMinutes: formatLength === 1,
    separator: formatLength === 3 || formatLength === 5,
    zZeroOffset: true
  });
};
formatters.G = function(date, formatLength, info) {
  var era = date.getFullYear() >= 0 ? 1 : 0;
  return formatNames(info, "eras", formatLength)[era];
};
formatters.e = formatDayOfWeek;
formatters.c = function(date, formatLength, info) {
  return formatDayOfWeek(date, formatLength, info, true);
};
formatters.q = function(date, formatLength, info) {
  return formatQuarter(date, formatLength, info, true);
};
formatters.Q = formatQuarter;
function formatDate(date, format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!isDate(date)) {
    if (date === void 0 || date === null) {
      return EMPTY;
    }
    return date;
  }
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  return pattern.replace(dateFormatRegExp, function(match) {
    var formatLength = match.length;
    var result;
    if (match.includes("'") || match.includes('"')) {
      result = match.slice(1, formatLength - 1);
    } else {
      result = formatters[match[0]](date, formatLength, info);
    }
    return result;
  });
}

// node_modules/@progress/kendo-intl/dist/es/dates/time-utils.js
function convertTimeZone(date, fromOffset, toOffset) {
  var fromLocalOffset = date.getTimezoneOffset();
  var offsetDate = new Date(date.getTime() + (fromOffset - toOffset) * 6e4);
  var toLocalOffset = offsetDate.getTimezoneOffset();
  return new Date(offsetDate.getTime() + (toLocalOffset - fromLocalOffset) * 6e4);
}
function adjustDST(date, hours) {
  if (!hours && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
  }
}

// node_modules/@progress/kendo-intl/dist/es/dates/parse-date.js
var timeZoneOffsetRegExp = /([+|-]\d{1,2})(:?)(\d{2})?/;
var dateRegExp = /^\/Date\((.*?)\)\/$/;
var offsetRegExp = /[+-]\d*/;
var numberRegExp = {
  2: /^\d{1,2}/,
  3: /^\d{1,3}/,
  4: /^\d{4}/
};
var numberRegex = /\d+/;
var PLACEHOLDER2 = "{0}";
var leadingSpacesRegex = /^ */;
var trailingSpacesRegex = / *$/;
var standardDateFormats = [
  "yyyy/MM/dd HH:mm:ss",
  "yyyy/MM/dd HH:mm",
  "yyyy/MM/dd",
  "E MMM dd yyyy HH:mm:ss",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSXXX",
  "yyyy-MM-ddTHH:mm:ss.SSXXX",
  "yyyy-MM-ddTHH:mm:ssXXX",
  "yyyy-MM-ddTHH:mm:ss.SSSSSSS",
  "yyyy-MM-ddTHH:mm:ss.SSS",
  "yyyy-MM-ddTHH:mmXXX",
  "yyyy-MM-ddTHH:mmX",
  "yyyy-MM-ddTHH:mm:ss",
  "yyyy-MM-ddTHH:mm",
  "yyyy-MM-dd HH:mm:ss",
  "yyyy-MM-dd HH:mm",
  "yyyy-MM-dd",
  "HH:mm:ss",
  "HH:mm"
];
var FORMATS_SEQUENCE = ["G", "g", "F", "Y", "y", "M", "m", "D", "d", "y", "T", "t"];
var TWO_DIGIT_YEAR_MAX = 2029;
function outOfRange(value, start, end) {
  return !(value >= start && value <= end);
}
function lookAhead(match, state) {
  var format2 = state.format;
  var idx = state.idx;
  var i = 0;
  while (format2[idx] === match) {
    i++;
    idx++;
  }
  if (i > 0) {
    idx -= 1;
  }
  state.idx = idx;
  return i;
}
function getNumber(size, state) {
  var regex = size ? numberRegExp[size] || new RegExp("^\\d{1," + size + "}") : numberRegex, match = state.value.substr(state.valueIdx, size).match(regex);
  if (match) {
    match = match[0];
    state.valueIdx += match.length;
    return parseInt(match, 10);
  }
  return null;
}
function getIndexByName(names, state, lower) {
  var i = 0, length = names.length, name3, nameLength, matchLength = 0, matchIdx = 0, subValue;
  for (; i < length; i++) {
    name3 = names[i];
    nameLength = name3.length;
    subValue = state.value.substr(state.valueIdx, nameLength);
    if (lower) {
      subValue = subValue.toLowerCase();
    }
    if (subValue === name3 && nameLength > matchLength) {
      matchLength = nameLength;
      matchIdx = i;
    }
  }
  if (matchLength) {
    state.valueIdx += matchLength;
    return matchIdx + 1;
  }
  return null;
}
function checkLiteral(state) {
  var result = false;
  if (state.value.charAt(state.valueIdx) === state.format[state.idx]) {
    state.valueIdx++;
    result = true;
  }
  return result;
}
function calendarGmtFormats(calendar) {
  var gmtFormat = calendar.gmtFormat;
  var gmtZeroFormat = calendar.gmtZeroFormat;
  if (!gmtFormat) {
    throw errors.NoGMTInfo.error();
  }
  return [gmtFormat.replace(PLACEHOLDER2, EMPTY).toLowerCase(), gmtZeroFormat.replace(PLACEHOLDER2, EMPTY).toLowerCase()];
}
function parseTimeZoneOffset(state, info, options2) {
  var shortHours = options2.shortHours;
  var noSeparator = options2.noSeparator;
  var optionalMinutes = options2.optionalMinutes;
  var localizedName = options2.localizedName;
  var zLiteral = options2.zLiteral;
  state.UTC = true;
  if (zLiteral && state.value.charAt(state.valueIdx) === "Z") {
    state.valueIdx++;
    return false;
  }
  if (localizedName && !getIndexByName(calendarGmtFormats(info.calendar), state, true)) {
    return true;
  }
  var matches2 = timeZoneOffsetRegExp.exec(state.value.substr(state.valueIdx, 6));
  if (!matches2) {
    return !localizedName;
  }
  var hoursMatch = matches2[1];
  var minutesMatch = matches2[3];
  var hoursOffset = parseInt(hoursMatch, 10);
  var separator = matches2[2];
  var minutesOffset = parseInt(minutesMatch, 10);
  if (isNaN(hoursOffset) || !shortHours && hoursMatch.length !== 3 || !optionalMinutes && isNaN(minutesOffset) || noSeparator && separator) {
    return true;
  }
  if (isNaN(minutesOffset)) {
    minutesOffset = null;
  }
  if (outOfRange(hoursOffset, -12, 13) || minutesOffset && outOfRange(minutesOffset, 0, 59)) {
    return true;
  }
  state.valueIdx += matches2[0].length;
  state.hoursOffset = hoursOffset;
  state.minutesOffset = minutesOffset;
}
function parseMonth(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "months", count, ch === "L", true);
  var month = count < 3 ? getNumber(2, state) : getIndexByName(names, state, true);
  if (month === null || outOfRange(month, 1, 12)) {
    return true;
  }
  state.month = month - 1;
}
function parseDayOfWeek(ch, state, info) {
  var count = lookAhead(ch, state);
  var names = formatNames(info, "days", count, ch === "c", true);
  var dayOfWeek = count < 3 ? getNumber(1, state) : getIndexByName(names, state, true);
  if (!dayOfWeek && dayOfWeek !== 0 || outOfRange(dayOfWeek, 1, 7)) {
    return true;
  }
}
var parsers = {};
parsers.d = function(state) {
  lookAhead("d", state);
  var day = getNumber(2, state);
  if (day === null || outOfRange(day, 1, 31)) {
    return true;
  }
  if (state.day === null) {
    state.day = day;
  }
};
parsers.E = function(state, info) {
  var count = lookAhead("E", state);
  var dayOfWeek = getIndexByName(formatNames(info, "days", count, false, true), state, true);
  if (dayOfWeek === null) {
    return true;
  }
};
parsers.M = function(state, info) {
  return parseMonth("M", state, info);
};
parsers.L = function(state, info) {
  return parseMonth("L", state, info);
};
parsers.y = function(state) {
  var count = lookAhead("y", state);
  var year = getNumber(count === 1 ? void 0 : count, state);
  if (year === null) {
    return true;
  }
  if (count === 2) {
    var currentYear = new Date().getFullYear();
    year = currentYear - currentYear % 100 + year;
    if (year > TWO_DIGIT_YEAR_MAX) {
      year -= 100;
    }
  }
  state.year = year;
};
parsers.h = function(state) {
  lookAhead("h", state);
  var hours = getNumber(2, state);
  if (hours === 12) {
    hours = 0;
  }
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.K = function(state) {
  lookAhead("K", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 11)) {
    return true;
  }
  state.hours = hours;
};
parsers.a = function(state, info) {
  var count = lookAhead("a", state);
  var periodFormats = formatNames(info, "dayPeriods", count, false, true);
  var pmHour = getIndexByName([periodFormats.pm], state, true);
  if (!pmHour && !getIndexByName([periodFormats.am], state, true)) {
    return true;
  }
  state.pmHour = pmHour;
};
parsers.H = function(state) {
  lookAhead("H", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 0, 23)) {
    return true;
  }
  state.hours = hours;
};
parsers.k = function(state) {
  lookAhead("k", state);
  var hours = getNumber(2, state);
  if (hours === null || outOfRange(hours, 1, 24)) {
    return true;
  }
  state.hours = hours === 24 ? 0 : hours;
};
parsers.m = function(state) {
  lookAhead("m", state);
  var minutes = getNumber(2, state);
  if (minutes === null || outOfRange(minutes, 0, 59)) {
    return true;
  }
  state.minutes = minutes;
};
parsers.s = function(state) {
  lookAhead("s", state);
  var seconds = getNumber(2, state);
  if (seconds === null || outOfRange(seconds, 0, 59)) {
    return true;
  }
  state.seconds = seconds;
};
parsers.S = function(state) {
  var count = lookAhead("S", state);
  var match = state.value.substr(state.valueIdx, count);
  var milliseconds = null;
  if (!isNaN(parseInt(match, 10))) {
    milliseconds = parseFloat("0." + match, 10);
    milliseconds = round(milliseconds, 3);
    milliseconds *= 1e3;
    state.valueIdx += count;
  }
  if (milliseconds === null || outOfRange(milliseconds, 0, 999)) {
    return true;
  }
  state.milliseconds = milliseconds;
};
parsers.z = function(state, info) {
  var count = lookAhead("z", state);
  var shortFormat = count < 4;
  var invalid = parseTimeZoneOffset(state, info, {
    shortHours: shortFormat,
    optionalMinutes: shortFormat,
    localizedName: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.Z = function(state, info) {
  var count = lookAhead("Z", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count < 4,
    zLiteral: count === 5,
    localizedName: count === 4
  });
  if (invalid) {
    return invalid;
  }
};
parsers.x = function(state, info) {
  var count = lookAhead("x", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1
  });
  if (invalid) {
    return invalid;
  }
};
parsers.X = function(state, info) {
  var count = lookAhead("X", state);
  var invalid = parseTimeZoneOffset(state, info, {
    noSeparator: count !== 3 && count !== 5,
    optionalMinutes: count === 1,
    zLiteral: true
  });
  if (invalid) {
    return invalid;
  }
};
parsers.G = function(state, info) {
  var count = lookAhead("G", state);
  var eras = formatNames(info, "eras", count, false, true);
  var era = getIndexByName([eras[0], eras[1]], state, true);
  if (era === null) {
    return true;
  }
};
parsers.e = function(state, info) {
  return parseDayOfWeek("e", state, info);
};
parsers.c = function(state, info) {
  return parseDayOfWeek("c", state, info);
};
function createDate(state) {
  var year = state.year;
  var month = state.month;
  var day = state.day;
  var hours = state.hours;
  var minutes = state.minutes;
  var seconds = state.seconds;
  var milliseconds = state.milliseconds;
  var pmHour = state.pmHour;
  var UTC = state.UTC;
  var hoursOffset = state.hoursOffset;
  var minutesOffset = state.minutesOffset;
  var hasTime = hours !== null || minutes !== null || seconds || null;
  var date = new Date();
  var result;
  if (year === null && month === null && day === null && hasTime) {
    year = date.getFullYear();
    month = date.getMonth();
    day = date.getDate();
  } else {
    if (year === null) {
      year = date.getFullYear();
    }
    if (day === null) {
      day = 1;
    }
  }
  if (pmHour && hours < 12) {
    hours += 12;
  }
  if (UTC) {
    if (hoursOffset) {
      hours += -hoursOffset;
    }
    if (minutesOffset) {
      minutes += -minutesOffset * (hoursOffset < 0 ? -1 : 1);
    }
    result = new Date(Date.UTC(year, month, day, hours, minutes, seconds, milliseconds));
  } else {
    result = new Date(year, month, day, hours, minutes, seconds, milliseconds);
    adjustDST(result, hours);
  }
  if (year < 100) {
    result.setFullYear(year);
  }
  if (result.getDate() !== day && UTC === void 0) {
    return null;
  }
  return result;
}
function addFormatSpaces(value, format2) {
  var leadingSpaces = leadingSpacesRegex.exec(format2)[0];
  var trailingSpaces = trailingSpacesRegex.exec(format2)[0];
  return "" + leadingSpaces + value + trailingSpaces;
}
function parseExact(value, format2, info) {
  var pattern = datePattern(format2, info).split(EMPTY);
  var state = {
    format: pattern,
    idx: 0,
    value: addFormatSpaces(value, format2),
    valueIdx: 0,
    year: null,
    month: null,
    day: null,
    hours: null,
    minutes: null,
    seconds: null,
    milliseconds: null
  };
  var length = pattern.length;
  var literal = false;
  for (; state.idx < length; state.idx++) {
    var ch = pattern[state.idx];
    if (literal) {
      if (ch === "'") {
        literal = false;
      }
      checkLiteral(state);
    } else {
      if (parsers[ch]) {
        var invalid = parsers[ch](state, info);
        if (invalid) {
          return null;
        }
      } else if (ch === "'") {
        literal = true;
        checkLiteral(state);
      } else if (!checkLiteral(state)) {
        return null;
      }
    }
  }
  if (state.valueIdx < value.length) {
    return null;
  }
  return createDate(state) || null;
}
function parseMicrosoftDateOffset(offset) {
  var sign = offset.substr(0, 1) === "-" ? -1 : 1;
  var result = offset.substring(1);
  result = parseInt(result.substr(0, 2), 10) * 60 + parseInt(result.substring(2), 10);
  return sign * result;
}
function parseMicrosoftDateFormat(value) {
  if (value && value.indexOf("/D") === 0) {
    var date = dateRegExp.exec(value);
    if (date) {
      date = date[1];
      var tzoffset = offsetRegExp.exec(date.substring(1));
      date = new Date(parseInt(date, 10));
      if (tzoffset) {
        tzoffset = parseMicrosoftDateOffset(tzoffset[0]);
        date = convertTimeZone(date, date.getTimezoneOffset(), 0);
        date = convertTimeZone(date, 0, -1 * tzoffset);
      }
      return date;
    }
  }
}
function defaultFormats(calendar) {
  var formats = [];
  var patterns = calendar.patterns;
  var length = FORMATS_SEQUENCE.length;
  for (var idx = 0; idx < length; idx++) {
    formats.push(patterns[FORMATS_SEQUENCE[idx]]);
  }
  return formats.concat(standardDateFormats);
}
function parseDate(value, formats, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  if (!value) {
    return null;
  }
  if (isDate(value)) {
    return value;
  }
  var parseValue = String(value).trim();
  var date = parseMicrosoftDateFormat(parseValue);
  if (date) {
    return date;
  }
  var info = localeInfo(locale);
  var parseFormats = formats || defaultFormats(info.calendar);
  parseFormats = Array.isArray(parseFormats) ? parseFormats : [parseFormats];
  var length = parseFormats.length;
  for (var idx = 0; idx < length; idx++) {
    date = parseExact(parseValue, parseFormats[idx], info);
    if (date) {
      return date;
    }
  }
  return date;
}

// node_modules/@progress/kendo-intl/dist/es/dates/split-date-format.js
var NAME_TYPES = {
  month: {
    type: "months",
    minLength: 3,
    standAlone: "L"
  },
  quarter: {
    type: "quarters",
    minLength: 3,
    standAlone: "q"
  },
  weekday: {
    type: "days",
    minLength: {
      E: 0,
      c: 3,
      e: 3
    },
    standAlone: "c"
  },
  dayperiod: {
    type: "dayPeriods",
    minLength: 0
  },
  era: {
    type: "eras",
    minLength: 0
  }
};
var LITERAL = "literal";
function addLiteral(parts, value) {
  var lastPart = parts[parts.length - 1];
  if (lastPart && lastPart.type === LITERAL) {
    lastPart.pattern += value;
  } else {
    parts.push({
      type: LITERAL,
      pattern: value
    });
  }
}
function isHour12(pattern) {
  return pattern === "h" || pattern === "K";
}
function splitDateFormat(format2, locale) {
  if (locale === void 0)
    locale = DEFAULT_LOCALE;
  var info = localeInfo(locale);
  var pattern = datePattern(format2, info);
  var parts = [];
  var lastIndex = dateFormatRegExp.lastIndex = 0;
  var match = dateFormatRegExp.exec(pattern);
  while (match) {
    var value = match[0];
    if (lastIndex < match.index) {
      addLiteral(parts, pattern.substring(lastIndex, match.index));
    }
    if (value.startsWith('"') || value.startsWith("'")) {
      addLiteral(parts, value);
    } else {
      var specifier = value[0];
      var type = DATE_FIELD_MAP[specifier];
      var part = {
        type,
        pattern: value
      };
      if (type === "hour") {
        part.hour12 = isHour12(value);
      }
      var names = NAME_TYPES[type];
      if (names) {
        var minLength = isNumber(names.minLength) ? names.minLength : names.minLength[specifier];
        var patternLength = value.length;
        if (patternLength >= minLength) {
          part.names = {
            type: names.type,
            nameType: dateNameType(patternLength),
            standAlone: names.standAlone === specifier
          };
        }
      }
      parts.push(part);
    }
    lastIndex = dateFormatRegExp.lastIndex;
    match = dateFormatRegExp.exec(pattern);
  }
  if (lastIndex < pattern.length) {
    addLiteral(parts, pattern.substring(lastIndex));
  }
  return parts;
}

// node_modules/@progress/kendo-intl/dist/es/format.js
var formatRegExp3 = /\{(\d+)(:[^}]+)?\}/g;
function toString(value, format2, locale) {
  if (format2) {
    if (isDate(value)) {
      return formatDate(value, format2, locale);
    } else if (isNumber(value)) {
      return formatNumber(value, format2, locale);
    }
  }
  return value !== void 0 && value !== null ? value : EMPTY;
}
function format(format2, values5, locale) {
  return format2.replace(formatRegExp3, function(match, index, placeholderFormat) {
    var value = values5[parseInt(index, 10)];
    return toString(value, placeholderFormat ? placeholderFormat.substring(1) : EMPTY, locale);
  });
}

// node_modules/@progress/kendo-licensing/dist/index-esm.js
var index_esm_exports = {};
__export(index_esm_exports, {
  setScriptKey: () => setScriptKey,
  validatePackage: () => validatePackage
});
var _0x3f5f = ["tMjXqw8=", "ALvUuLu=", "DMvYC2LVBG==", "B2jQzwn0", "zNvUy3rPB24=", "AgfZ", "CgfYC2u=", "se52y2S=", "CeTOB0C=", "Ag9dwha=", "ChjVzhvJDe5HBwu=", "y29Kzq==", "BgDyrK4=", "zgf0yq==", "DgLTzxn0yw1W", "vgHLihbYB2r1y3qGAxmGBM90igLUy2X1zgvKigLUihrOzsbSAwnLBNnLlGO=", "vevpChm=", "CgfJA2fNzu5HBwu=", "C2v0", "CNzVquK=", "DhLWzq==", "rK9ht3q=", "A29lt3C=", "C2nYAxb0s2v5", "D2fYBG==", "lcb0AguGCgfJA2fNzsb3yxmGChvIBgLZAgvKig9Uia==", "tM8GBgLJzw5ZzsbMB3vUzc4k", "Dw5KzwzPBMvK", "zxHWAxj5rgf0zq==", "qxPWD00=", "DwD0D1a=", "ww91CIbSAwnLBNnLigv4CgLYzwqGB24G", "BgvUz3rO", "zeDetM8=", "rgTIvfi=", "zg9JC1vYBa==", "ChjVzhvJDenVzgvZ", "Dg9mB2nHBgvtDhjPBMC=", "q3jhuhy=", "D0f4tMu=", "q09jChO=", "z2v0", "BgLJzw5Zzuv4CgLYyxrPB25eyxrL", "BuTXu3e=", "ChjVzhvJDhm=", "DfrNreS=", "C29YDa==", "zMLUza==", "u2vLia==", "u2XdEfO=", "uhjVz3jLC3mG", "z3jVDxa=", "BMfTzq==", "CejABNy=", "BgLJzw5ZAw5Nrg9JC1vYBa==", "igzVCIbTB3jLigLUzM9YBwf0Aw9UlGO=", "y29Uy2f0", "ChvIBgLZAerHDgu=", "z3jVDxbfBMq=", "CK1fru8=", "uwzXvuK=", "tgLJzw5ZzsbHy3rPDMf0Aw9UigzHAwXLzcbMB3iG"];
(function(_0x3ffcd8, _0x3f5fc6) {
  var _0x4fe1c2 = function(_0x228463) {
    while (--_0x228463) {
      _0x3ffcd8["push"](_0x3ffcd8["shift"]());
    }
  };
  _0x4fe1c2(++_0x3f5fc6);
})(_0x3f5f, 369);
var _0x4fe1 = function(_0x3ffcd8, _0x3f5fc6) {
  _0x3ffcd8 = _0x3ffcd8 - 0;
  var _0x4fe1c2 = _0x3f5f[_0x3ffcd8];
  if (_0x4fe1["rlqmyH"] === void 0) {
    var _0x228463 = function(_0x31bd4d) {
      var _0x1ae84e = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789+/=", _0x18c0a1 = String(_0x31bd4d)["replace"](/=+$/, "");
      var _0x34f60f = "";
      for (var _0x2f90c2 = 0, _0x1e97d4, _0x3ffa722, _0x161b802 = 0; _0x3ffa722 = _0x18c0a1["charAt"](_0x161b802++); ~_0x3ffa722 && (_0x1e97d4 = _0x2f90c2 % 4 ? _0x1e97d4 * 64 + _0x3ffa722 : _0x3ffa722, _0x2f90c2++ % 4) ? _0x34f60f += String["fromCharCode"](255 & _0x1e97d4 >> (-2 * _0x2f90c2 & 6)) : 0) {
        _0x3ffa722 = _0x1ae84e["indexOf"](_0x3ffa722);
      }
      return _0x34f60f;
    };
    _0x4fe1["tDWcmv"] = function(_0x54b76b) {
      var _0x446133 = _0x228463(_0x54b76b);
      var _0x286684 = [];
      for (var _0x34c59d2 = 0, _0x3b51a62 = _0x446133["length"]; _0x34c59d2 < _0x3b51a62; _0x34c59d2++) {
        _0x286684 += "%" + ("00" + _0x446133["charCodeAt"](_0x34c59d2)["toString"](16))["slice"](-2);
      }
      return decodeURIComponent(_0x286684);
    }, _0x4fe1["GoSChA"] = {}, _0x4fe1["rlqmyH"] = !![];
  }
  var _0x2bf482 = _0x4fe1["GoSChA"][_0x3ffcd8];
  return _0x2bf482 === void 0 ? (_0x4fe1c2 = _0x4fe1["tDWcmv"](_0x4fe1c2), _0x4fe1["GoSChA"][_0x3ffcd8] = _0x4fe1c2) : _0x4fe1c2 = _0x2bf482, _0x4fe1c2;
};
var context = { data: "  {}  " };
var cache = /* @__PURE__ */ new Map();
function setScriptKey(_0x332c3f) {
}
function validatePackage(_0x288448) {
  if (cache[_0x4fe1("0x8")](_0x288448[_0x4fe1("0x37")])) {
    if (_0x4fe1("0x19") === _0x4fe1("0x19"))
      return cache[_0x4fe1("0x2c")](_0x288448[_0x4fe1("0x37")]);
    else {
      let _0x1d633f = function() {
        _0x47c5ba = { "type": 1, "packageName": _0x404fc4, "docsUrl": _0x35fad0[_0x4fe1("0x39")] };
      };
    }
  }
  var _0x1dbcb5 = _0x288448[_0x4fe1("0x5")] ? " v" + _0x288448[_0x4fe1("0x5")] : "", _0x36c009 = _0x288448[_0x4fe1("0x37")] + _0x1dbcb5, _0x41f400 = JSON[_0x4fe1("0x9")](context[_0x4fe1("0x10")]), _0x3fe82f = !_0x41f400[_0x4fe1("0x1a")] && !_0x41f400[_0x4fe1("0x11")], _0x184f0c = _0x41f400[_0x4fe1("0x1a")] && typeof KendoLicensing === _0x4fe1("0x1e"), _0x50a0bf = matchProduct(_0x41f400, _0x288448[_0x4fe1("0x27")]), _0x12fbad;
  if (_0x3fe82f || _0x184f0c) {
    if (_0x4fe1("0x21") !== _0x4fe1("0x13"))
      _0x12fbad = { "type": 0, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
    else {
      let _0x10e197 = function() {
        _0x26dcf1 = { "type": 2, "packageName": _0x4a8fb8, "publishDate": _0x394bc9(_0x20a329[_0x4fe1("0x3c")]), "expiryDate": _0x2076a8(_0x4c8acd[_0x4fe1("0x2d")]), "docsUrl": _0x2c90b5[_0x4fe1("0x39")] };
      };
    }
  } else {
    if (_0x4fe1("0x38") !== _0x4fe1("0x0")) {
      if (!_0x50a0bf) {
        if (_0x4fe1("0xf") !== _0x4fe1("0xf")) {
          let _0x40dac7 = function() {
            return _0x2b7e21[_0x4fe1("0x2d")] - _0x283ffd[_0x4fe1("0x2d")];
          };
        } else
          _0x12fbad = { "type": 1, "packageName": _0x36c009, "docsUrl": _0x288448[_0x4fe1("0x39")] };
      } else {
        if (_0x4fe1("0x34") !== _0x4fe1("0x34")) {
          let _0x335a37 = function() {
            _0x451252 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5b4393[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x427d68[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
          };
        } else {
          if (_0x50a0bf[_0x4fe1("0x2d")] < _0x288448[_0x4fe1("0x3c")]) {
            if (_0x4fe1("0x25") !== _0x4fe1("0xc"))
              _0x12fbad = { "type": 2, "packageName": _0x36c009, "publishDate": parseDate2(_0x288448[_0x4fe1("0x3c")]), "expiryDate": parseDate2(_0x50a0bf[_0x4fe1("0x2d")]), "docsUrl": _0x288448[_0x4fe1("0x39")] };
            else {
              let _0x5258b7 = function() {
                _0x1bdee6[_0x4fe1("0x36")](_0x1b76ca);
              };
            }
          }
        }
      }
    } else {
      let _0x280f77 = function() {
        _0x38b037[_0x4fe1("0x2d")] < _0x617673[_0x4fe1("0x3c")] && (_0x189610 = { "type": 2, "packageName": _0x44ed7b, "publishDate": _0x54a628(_0x577a38[_0x4fe1("0x3c")]), "expiryDate": _0x16dcb4(_0x23f6ce[_0x4fe1("0x2d")]), "docsUrl": _0x429372[_0x4fe1("0x39")] });
      };
    }
  }
  if (_0x12fbad && typeof console === _0x4fe1("0x6")) {
    if (_0x4fe1("0x20") !== _0x4fe1("0x20")) {
      let _0x5d228a = function() {
        var _0x4230b5 = _0x103455[_0x4fe1("0x2f")];
        if (!_0x4230b5 || !_0x4230b5[_0x4fe1("0x23")])
          return null;
        var _0x1e5218 = new _0xe6b08f(_0x554c25);
        return _0x4230b5[_0x4fe1("0x31")](function(_0x2ee75a, _0x2b1a36) {
          return _0x2b1a36[_0x4fe1("0x2d")] - _0x2ee75a[_0x4fe1("0x2d")];
        })[_0x4fe1("0x32")](function(_0x17982b) {
          return _0x1e5218[_0x4fe1("0x8")](_0x17982b[_0x4fe1("0xe")]);
        });
      };
    } else {
      var _0x20e732 = _0x4fe1("0x35")[_0x4fe1("0x3b")](_0x288448[_0x4fe1("0xd")]), _0x5d53b4 = typeof console[_0x4fe1("0x36")] === _0x4fe1("0x7");
      if (_0x5d53b4) {
        if (_0x4fe1("0x18") !== _0x4fe1("0x24"))
          console[_0x4fe1("0x36")](_0x20e732);
        else {
          let _0x8fc6c0 = function() {
            var _0x333192 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x532507[_0x4fe1("0x14")], "\n");
            if (_0x2d53ef[_0x4fe1("0x17")] === 2)
              _0x333192 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x4ebbe6[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x4c2c15[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
            else {
              if (_0x6a6452[_0x4fe1("0x17")] === 0)
                _0x333192 += _0x4fe1("0x1d");
              else
                _0x1b6fe2[_0x4fe1("0x17")] === 1 && (_0x333192 += _0x4fe1("0x12"));
            }
            return _0x333192 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x585a35[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x333192;
          };
        }
      } else {
        if (_0x4fe1("0x4") === _0x4fe1("0x4"))
          console[_0x4fe1("0x1b")](_0x20e732);
        else {
          let _0x32c891 = function() {
            return new _0x5c247c(_0x332fe8 * 1e3);
          };
        }
      }
      console[_0x4fe1("0x1b")](formatError(_0x12fbad));
      if (_0x5d53b4) {
        if (_0x4fe1("0x2b") === _0x4fe1("0x2b"))
          console[_0x4fe1("0x3d")]();
        else {
          let _0x145e8c = function() {
            return _0x2a692e[_0x4fe1("0x8")](_0x32480f[_0x4fe1("0xe")]);
          };
        }
      }
    }
  }
  var _0x3f9e87 = !_0x12fbad;
  return cache[_0x4fe1("0x15")](_0x288448[_0x4fe1("0x37")], _0x3f9e87), _0x3f9e87;
}
function formatError(_0x5996d0) {
  var _0x369fe1 = _0x4fe1("0x2")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x14")], "\n");
  if (_0x5996d0[_0x4fe1("0x17")] === 2) {
    if (_0x4fe1("0xb") !== _0x4fe1("0xb")) {
      let _0x42b4e8 = function() {
        _0x57e852 += _0x4fe1("0x12");
      };
    } else
      _0x369fe1 += _0x4fe1("0x22")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x1f")][_0x4fe1("0x28")](), _0x4fe1("0x1c"))[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x3c")][_0x4fe1("0x28")](), ".\n");
  } else {
    if (_0x5996d0[_0x4fe1("0x17")] === 0) {
      if (_0x4fe1("0x2e") !== _0x4fe1("0x2e")) {
        let _0x170217 = function() {
          return null;
        };
      } else
        _0x369fe1 += _0x4fe1("0x1d");
    } else {
      if (_0x5996d0[_0x4fe1("0x17")] === 1) {
        if (_0x4fe1("0x2a") === _0x4fe1("0x2a"))
          _0x369fe1 += _0x4fe1("0x12");
        else {
          let _0x589fb9 = function() {
            return _0x3ffa72[_0x4fe1("0x2c")](_0x161b80[_0x4fe1("0x37")]);
          };
        }
      }
    }
  }
  return _0x369fe1 += _0x4fe1("0x33")[_0x4fe1("0x3b")](_0x5996d0[_0x4fe1("0x26")], _0x4fe1("0x3a")), _0x369fe1;
}
function matchProduct(_0x2fe56c, _0x1db63e) {
  var _0x48173a = _0x2fe56c[_0x4fe1("0x2f")];
  if (!_0x48173a || !_0x48173a[_0x4fe1("0x23")]) {
    if (_0x4fe1("0x29") !== _0x4fe1("0x16"))
      return null;
    else {
      let _0x5d3cfe = function() {
        _0x3e8f7b += _0x4fe1("0x1d");
      };
    }
  }
  var _0x1dd0f6 = new Set(_0x1db63e);
  return _0x48173a[_0x4fe1("0x31")](function(_0xd163b7, _0x23878c) {
    if (_0x4fe1("0x30") === _0x4fe1("0x3")) {
      let _0x134c08 = function() {
        !_0xbcc2ed ? _0xb3f5b6 = { "type": 1, "packageName": _0x495d13, "docsUrl": _0x4dead0[_0x4fe1("0x39")] } : _0xa8b7ca[_0x4fe1("0x2d")] < _0x177345[_0x4fe1("0x3c")] && (_0x2625da = { "type": 2, "packageName": _0x5e46dc, "publishDate": _0x10f6c5(_0x357f8a[_0x4fe1("0x3c")]), "expiryDate": _0x70483f(_0x32abbc[_0x4fe1("0x2d")]), "docsUrl": _0x4a4999[_0x4fe1("0x39")] });
      };
    } else
      return _0x23878c[_0x4fe1("0x2d")] - _0xd163b7[_0x4fe1("0x2d")];
  })[_0x4fe1("0x32")](function(_0x1d8f83) {
    if (_0x4fe1("0xa") === _0x4fe1("0x1")) {
      let _0x428ed6 = function() {
        _0x34c59d = { "type": 0, "packageName": _0x3b51a6, "docsUrl": _0x3d18c6[_0x4fe1("0x39")] };
      };
    } else
      return _0x1dd0f6[_0x4fe1("0x8")](_0x1d8f83[_0x4fe1("0xe")]);
  });
}
function parseDate2(_0x9d6621) {
  return new Date(_0x9d6621 * 1e3);
}

// node_modules/@progress/kendo-react-intl/dist/es/package-metadata.js
var packageMetadata = {
  name: "@progress/kendo-react-intl",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1675428386,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-intl/dist/es/Intl/IntlService.js
var IntlService = (
  /** @class */
  function() {
    function IntlService4(locale) {
      this.locale = locale;
      if (typeof index_esm_exports !== "undefined") {
        validatePackage(packageMetadata);
      } else {
        var message = "License activation failed for ".concat(packageMetadata.name, "\n");
        message += "The @progress/kendo-licensing script is not loaded.\n";
        message += "See ".concat(packageMetadata.licensingDocsUrl, " for more information.\n");
        console.warn(message);
      }
      if (locale === "" && true) {
        throw "Locale should not be empty string";
      }
    }
    IntlService4.prototype.format = function(format2) {
      var values5 = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        values5[_i - 1] = arguments[_i];
      }
      if (values5.length === 1 && Array.isArray(values5[0])) {
        return format(format2, values5[0], this.locale);
      }
      return format(format2, values5, this.locale);
    };
    IntlService4.prototype.formatDate = function(value, format2) {
      return formatDate(value, format2, this.locale);
    };
    IntlService4.prototype.toString = function(value, format2) {
      return toString(value, format2, this.locale);
    };
    IntlService4.prototype.parseNumber = function(value, format2) {
      return parseNumber(value, this.locale, format2);
    };
    IntlService4.prototype.parseDate = function(value, format2) {
      return parseDate(value, format2, this.locale);
    };
    IntlService4.prototype.formatNumber = function(value, format2) {
      return formatNumber(value, format2, this.locale);
    };
    IntlService4.prototype.dateFieldName = function(options2) {
      return dateFieldName(options2, this.locale);
    };
    IntlService4.prototype.dateFormatNames = function(options2) {
      return dateFormatNames(this.locale, options2);
    };
    IntlService4.prototype.splitDateFormat = function(format2) {
      return splitDateFormat(format2, this.locale);
    };
    IntlService4.prototype.numberSymbols = function() {
      return numberSymbols(this.locale);
    };
    IntlService4.prototype.firstDay = function() {
      return firstDay(this.locale);
    };
    return IntlService4;
  }()
);

// node_modules/@progress/kendo-react-intl/dist/es/globalization/GlobalizationContext.js
var React = __toESM(require_react());

// node_modules/@progress/kendo-react-intl/dist/es/Localization/messages.js
var messages = /* @__PURE__ */ Object.create({});

// node_modules/@progress/kendo-react-intl/dist/es/Localization/LocalizationService.js
var LocalizationService = (
  /** @class */
  function() {
    function LocalizationService2(language) {
      this.language = language;
      if (language === "" && true) {
        throw "Language should not be an empty string";
      }
    }
    LocalizationService2.prototype.toLanguageString = function(key, defaultValue) {
      if (this.language && messages[this.language] && messages[this.language].hasOwnProperty(key)) {
        return messages[this.language][key];
      } else {
        return defaultValue;
      }
    };
    return LocalizationService2;
  }()
);

// node_modules/@progress/kendo-react-intl/dist/es/globalization/GlobalizationContext.js
var GlobalizationContext = React.createContext({
  intl: new IntlService("en"),
  localization: new LocalizationService()
});

// node_modules/@progress/kendo-react-intl/dist/es/Intl/IntlProvider.js
var __extends = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var IntlProvider = (
  /** @class */
  function(_super) {
    __extends(IntlProvider2, _super);
    function IntlProvider2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IntlProvider2.prototype.getIntlService = function() {
      return new IntlService(this.props.locale);
    };
    IntlProvider2.prototype.render = function() {
      var _this = this;
      return React2.createElement(GlobalizationContext.Consumer, null, function(glob) {
        return React2.createElement(GlobalizationContext.Provider, { value: __assign(__assign({}, glob), { intl: _this.getIntlService() }) }, _this.props.children);
      });
    };
    IntlProvider2.propTypes = {
      locale: PropTypes.string
    };
    return IntlProvider2;
  }(React2.Component)
);

// node_modules/@progress/kendo-react-intl/dist/es/Localization/LocalizationProvider.js
var React3 = __toESM(require_react());
var PropTypes2 = __toESM(require_prop_types());
var __extends2 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var LocalizationProvider = (
  /** @class */
  function(_super) {
    __extends2(LocalizationProvider2, _super);
    function LocalizationProvider2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LocalizationProvider2.prototype.getLocalizationService = function() {
      return new LocalizationService(this.props.language);
    };
    LocalizationProvider2.prototype.render = function() {
      var _this = this;
      return React3.createElement(GlobalizationContext.Consumer, null, function(glob) {
        return React3.createElement(GlobalizationContext.Provider, { value: __assign2(__assign2({}, glob), { localization: _this.getLocalizationService() }) }, _this.props.children);
      });
    };
    LocalizationProvider2.propTypes = {
      language: PropTypes2.string
    };
    return LocalizationProvider2;
  }(React3.Component)
);

// node_modules/@progress/kendo-react-intl/dist/es/intlUtils.js
function provideIntlService(component) {
  if (!component && true) {
    throw "Passed component - ".concat(component, " is invalid.");
  }
  var context2 = component.context;
  return context2 && context2.intl ? context2.intl : new IntlService("en");
}
function registerForIntl(component) {
  component.contextType = GlobalizationContext;
}

// node_modules/@progress/kendo-react-intl/dist/es/hooks/useInternationalization.js
var React4 = __toESM(require_react());

// node_modules/@progress/kendo-react-intl/dist/es/hooks/useLocalization.js
var React5 = __toESM(require_react());

// node_modules/@progress/kendo-charts/dist/es/common/constants.js
var ARC = "arc";
var AXIS_LABEL_CLICK = "axisLabelClick";
var BLACK = "#000";
var BOTTOM = "bottom";
var CENTER = "center";
var CIRCLE = "circle";
var COORD_PRECISION = 3;
var CROSS = "cross";
var DATE = "date";
var DEFAULT_FONT = "12px sans-serif";
var DEFAULT_HEIGHT = 400;
var DEFAULT_PRECISION = 10;
var DEFAULT_WIDTH = 600;
var END = "end";
var FORMAT_REGEX = /\{\d+:?/;
var HEIGHT = "height";
var HIGHLIGHT_ZINDEX = 100;
var INSIDE = "inside";
var LEFT = "left";
var MAX_VALUE = Number.MAX_VALUE;
var MIN_VALUE = -Number.MAX_VALUE;
var NONE = "none";
var NOTE_CLICK = "noteClick";
var NOTE_HOVER = "noteHover";
var NOTE_LEAVE = "noteLeave";
var OBJECT = "object";
var OUTSIDE = "outside";
var RIGHT = "right";
var ROUNDED_RECT = "roundedRect";
var START = "start";
var STRING = "string";
var TOP = "top";
var TRIANGLE = "triangle";
var VALUE = "value";
var WHITE = "#fff";
var WIDTH = "width";
var X = "x";
var Y = "y";
var DEFAULT_SERIES_OPACITY = 1;

// node_modules/@progress/kendo-charts/dist/es/common/is-array.js
function isArray(value) {
  return Array.isArray(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/add-class.js
function addClass(element, classes) {
  var classArray = isArray(classes) ? classes : [classes];
  for (var idx = 0; idx < classArray.length; idx++) {
    var className = classArray[idx];
    if (element.className.indexOf(className) === -1) {
      element.className += " " + className;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/remove-class.js
var SPACE_REGEX = /\s+/g;
function removeClass(element, className) {
  if (element && element.className) {
    element.className = element.className.replace(className, "").replace(SPACE_REGEX, " ");
  }
}

// node_modules/@progress/kendo-drawing/dist/es/drawing.js
var drawing_exports = {};
__export(drawing_exports, {
  Animation: () => animation_default,
  AnimationFactory: () => animation_factory_default,
  Arc: () => arc_default2,
  BaseNode: () => base_node_default,
  Circle: () => circle_default2,
  Element: () => element_default,
  Gradient: () => gradient_default,
  GradientStop: () => gradient_stop_default,
  Group: () => group_default,
  HasObservers: () => has_observers_default,
  Image: () => image_default,
  Layout: () => layout_default,
  LinearGradient: () => linear_gradient_default,
  MultiPath: () => MultiPath,
  OptionsStore: () => options_store_default,
  Path: () => Path,
  PathParser: () => path_parser_default,
  QuadNode: () => quad_node_default,
  RadialGradient: () => radial_gradient_default,
  Rect: () => rect_default2,
  ShapesQuadTree: () => shapes_quad_tree_default,
  Surface: () => surface_default4,
  SurfaceFactory: () => surface_factory_default,
  Text: () => text_default,
  align: () => align,
  canvas: () => canvas_exports,
  exportImage: () => exportImage,
  exportSVG: () => exportSVG,
  fit: () => fit,
  parsePath: () => parse_path_default,
  stack: () => stack,
  svg: () => svg_exports,
  util: () => util_exports,
  vAlign: () => vAlign,
  vStack: () => vStack,
  vWrap: () => vWrap,
  wrap: () => wrap
});

// node_modules/@progress/kendo-drawing/dist/es/common/class.js
var Class = function Class2() {
};
var class_default = Class;

// node_modules/@progress/kendo-drawing/dist/es/common/observable.js
var Observable = function(Class3) {
  function Observable3() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable3.__proto__ = Class3;
  Observable3.prototype = Object.create(Class3 && Class3.prototype);
  Observable3.prototype.constructor = Observable3;
  Observable3.prototype.bind = function bind(eventName, handlers, one) {
    var arguments$1 = arguments;
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    var length = eventNames.length;
    if (handlers === void 0) {
      for (var field in eventName) {
        this$1.bind(field, eventName[field]);
      }
      return this;
    }
    var loop = function(idx2) {
      var eventName$1 = eventNames[idx2];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        if (one) {
          var original = handler;
          handler = function() {
            this$1.unbind(eventName$1, handler);
            original.apply(this$1, arguments$1);
          };
          handler.original = original;
        }
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.push(handler);
      }
    };
    for (var idx = 0; idx < length; idx++)
      loop(idx);
    return this;
  };
  Observable3.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable3.prototype.first = function first(eventName, handlers) {
    var this$1 = this;
    var eventNames = getArray(eventName);
    var handlersIsFunction = isFunction2(handlers);
    for (var idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      var handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        var events2 = this$1._events[eventName$1] = this$1._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return this;
  };
  Observable3.prototype.trigger = function trigger2(eventName, e) {
    var this$1 = this;
    if (e === void 0)
      e = {};
    var events2 = this._events[eventName];
    if (events2) {
      var length = events2.length;
      e.sender = this;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault;
      e.isDefaultPrevented = isDefaultPrevented;
      events2 = events2.slice();
      for (var idx = 0; idx < length; idx++) {
        events2[idx].call(this$1, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable3.prototype.unbind = function unbind(eventName, handler) {
    var events2 = this._events[eventName];
    if (eventName === void 0) {
      this._events = {};
    } else if (events2) {
      if (handler) {
        for (var idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        this._events[eventName] = [];
      }
    }
    return this;
  };
  return Observable3;
}(class_default);
function isFunction2(value) {
  return typeof value === "function";
}
function getArray(value) {
  return typeof value === "string" ? [value] : value;
}
function preventDefault() {
  this._defaultPrevented = true;
}
function isDefaultPrevented() {
  return this._defaultPrevented === true;
}
var observable_default = Observable;

// node_modules/@progress/kendo-drawing/dist/es/common/animation-frame.js
var animationFrameProxy = function(callback) {
  var wnd = typeof window !== "undefined" ? window : {};
  var animationFrame2 = wnd.requestAnimationFrame || wnd.webkitRequestAnimationFrame || wnd.mozRequestAnimationFrame || wnd.oRequestAnimationFrame || wnd.msRequestAnimationFrame || function(callback2) {
    setTimeout(callback2, 1e3 / 60);
  };
  animationFrameProxy = function(callback2) {
    return animationFrame2.call(wnd, callback2);
  };
  animationFrameProxy(callback);
};
var animation_frame_default = animationFrameProxy;

// node_modules/@progress/kendo-drawing/dist/es/common/html-encode.js
var ampRegExp = /&/g;
var ltRegExp = /</g;
var quoteRegExp = /"/g;
var aposRegExp = /'/g;
var gtRegExp = />/g;
function htmlEncode(value) {
  return String(value).replace(ampRegExp, "&amp;").replace(ltRegExp, "&lt;").replace(gtRegExp, "&gt;").replace(quoteRegExp, "&quot;").replace(aposRegExp, "&#39;");
}

// node_modules/@progress/kendo-drawing/dist/es/common/log-to-console.js
function logToConsole(message) {
  var console2 = window.console;
  if (typeof console2 != "undefined" && console2.log) {
    console2.log(message);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/common/support.js
function matchUserAgent(userAgent) {
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+))/i
  };
  var browser7 = {};
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      var match = userAgent.match(browserRxs[agent]);
      if (match) {
        browser7[agent] = true;
        browser7[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser7.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browser7;
}
var browser = null;
var support = {
  get browser() {
    if (typeof window === "undefined" || browser) {
      return browser;
    }
    browser = matchUserAgent(window.navigator.userAgent);
    return browser;
  }
};
var support_default = support;

// node_modules/@progress/kendo-drawing/dist/es/common/template.js
function template() {
  throw new Error("Template implementation missing.");
}

// node_modules/@progress/kendo-drawing/dist/es/util/now.js
var now = Date.now || function() {
  return new Date().getTime();
};
var now_default = now;

// node_modules/@progress/kendo-drawing/dist/es/common/throttle.js
function throttle(fn, delay) {
  var lastExecTime = 0;
  var timeout;
  if (!delay || delay <= 0) {
    return fn;
  }
  var throttled = function() {
    var elapsed = now_default() - lastExecTime;
    var args = arguments;
    var exec = function() {
      fn.apply(null, args);
      lastExecTime = now_default();
    };
    if (!lastExecTime) {
      return exec();
    }
    if (timeout) {
      clearTimeout(timeout);
    }
    if (elapsed > delay) {
      exec();
    } else {
      timeout = setTimeout(exec, delay - elapsed);
    }
  };
  throttled.cancel = function() {
    clearTimeout(timeout);
  };
  return throttled;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/named-colors.js
var namedColors = {
  aliceblue: "f0f8ff",
  antiquewhite: "faebd7",
  aqua: "00ffff",
  aquamarine: "7fffd4",
  azure: "f0ffff",
  beige: "f5f5dc",
  bisque: "ffe4c4",
  black: "000000",
  blanchedalmond: "ffebcd",
  blue: "0000ff",
  blueviolet: "8a2be2",
  brown: "a52a2a",
  burlywood: "deb887",
  cadetblue: "5f9ea0",
  chartreuse: "7fff00",
  chocolate: "d2691e",
  coral: "ff7f50",
  cornflowerblue: "6495ed",
  cornsilk: "fff8dc",
  crimson: "dc143c",
  cyan: "00ffff",
  darkblue: "00008b",
  darkcyan: "008b8b",
  darkgoldenrod: "b8860b",
  darkgray: "a9a9a9",
  darkgrey: "a9a9a9",
  darkgreen: "006400",
  darkkhaki: "bdb76b",
  darkmagenta: "8b008b",
  darkolivegreen: "556b2f",
  darkorange: "ff8c00",
  darkorchid: "9932cc",
  darkred: "8b0000",
  darksalmon: "e9967a",
  darkseagreen: "8fbc8f",
  darkslateblue: "483d8b",
  darkslategray: "2f4f4f",
  darkslategrey: "2f4f4f",
  darkturquoise: "00ced1",
  darkviolet: "9400d3",
  deeppink: "ff1493",
  deepskyblue: "00bfff",
  dimgray: "696969",
  dimgrey: "696969",
  dodgerblue: "1e90ff",
  firebrick: "b22222",
  floralwhite: "fffaf0",
  forestgreen: "228b22",
  fuchsia: "ff00ff",
  gainsboro: "dcdcdc",
  ghostwhite: "f8f8ff",
  gold: "ffd700",
  goldenrod: "daa520",
  gray: "808080",
  grey: "808080",
  green: "008000",
  greenyellow: "adff2f",
  honeydew: "f0fff0",
  hotpink: "ff69b4",
  indianred: "cd5c5c",
  indigo: "4b0082",
  ivory: "fffff0",
  khaki: "f0e68c",
  lavender: "e6e6fa",
  lavenderblush: "fff0f5",
  lawngreen: "7cfc00",
  lemonchiffon: "fffacd",
  lightblue: "add8e6",
  lightcoral: "f08080",
  lightcyan: "e0ffff",
  lightgoldenrodyellow: "fafad2",
  lightgray: "d3d3d3",
  lightgrey: "d3d3d3",
  lightgreen: "90ee90",
  lightpink: "ffb6c1",
  lightsalmon: "ffa07a",
  lightseagreen: "20b2aa",
  lightskyblue: "87cefa",
  lightslategray: "778899",
  lightslategrey: "778899",
  lightsteelblue: "b0c4de",
  lightyellow: "ffffe0",
  lime: "00ff00",
  limegreen: "32cd32",
  linen: "faf0e6",
  magenta: "ff00ff",
  maroon: "800000",
  mediumaquamarine: "66cdaa",
  mediumblue: "0000cd",
  mediumorchid: "ba55d3",
  mediumpurple: "9370d8",
  mediumseagreen: "3cb371",
  mediumslateblue: "7b68ee",
  mediumspringgreen: "00fa9a",
  mediumturquoise: "48d1cc",
  mediumvioletred: "c71585",
  midnightblue: "191970",
  mintcream: "f5fffa",
  mistyrose: "ffe4e1",
  moccasin: "ffe4b5",
  navajowhite: "ffdead",
  navy: "000080",
  oldlace: "fdf5e6",
  olive: "808000",
  olivedrab: "6b8e23",
  orange: "ffa500",
  orangered: "ff4500",
  orchid: "da70d6",
  palegoldenrod: "eee8aa",
  palegreen: "98fb98",
  paleturquoise: "afeeee",
  palevioletred: "d87093",
  papayawhip: "ffefd5",
  peachpuff: "ffdab9",
  peru: "cd853f",
  pink: "ffc0cb",
  plum: "dda0dd",
  powderblue: "b0e0e6",
  purple: "800080",
  red: "ff0000",
  rosybrown: "bc8f8f",
  royalblue: "4169e1",
  saddlebrown: "8b4513",
  salmon: "fa8072",
  sandybrown: "f4a460",
  seagreen: "2e8b57",
  seashell: "fff5ee",
  sienna: "a0522d",
  silver: "c0c0c0",
  skyblue: "87ceeb",
  slateblue: "6a5acd",
  slategray: "708090",
  slategrey: "708090",
  snow: "fffafa",
  springgreen: "00ff7f",
  steelblue: "4682b4",
  tan: "d2b48c",
  teal: "008080",
  thistle: "d8bfd8",
  tomato: "ff6347",
  turquoise: "40e0d0",
  violet: "ee82ee",
  wheat: "f5deb3",
  white: "ffffff",
  whitesmoke: "f5f5f5",
  yellow: "ffff00",
  yellowgreen: "9acd32"
};
var named_colors_default = namedColors;

// node_modules/@progress/kendo-drawing/dist/es/common/color/parse-color.js
var browser2 = support_default.browser;
var matchNamedColor = function(color) {
  var colorNames = Object.keys(named_colors_default);
  colorNames.push("transparent");
  var regexp = new RegExp("^(" + colorNames.join("|") + ")(\\W|$)", "i");
  matchNamedColor = function(color2) {
    return regexp.exec(color2);
  };
  return regexp.exec(color);
};
var BaseColor = function(Class3) {
  function BaseColor2() {
    Class3.call(this);
  }
  if (Class3)
    BaseColor2.__proto__ = Class3;
  BaseColor2.prototype = Object.create(Class3 && Class3.prototype);
  BaseColor2.prototype.constructor = BaseColor2;
  BaseColor2.prototype.toHSV = function toHSV() {
    return this;
  };
  BaseColor2.prototype.toRGB = function toRGB() {
    return this;
  };
  BaseColor2.prototype.toHex = function toHex(options2) {
    return this.toBytes().toHex(options2);
  };
  BaseColor2.prototype.toBytes = function toBytes() {
    return this;
  };
  BaseColor2.prototype.toCss = function toCss(options2) {
    return "#" + this.toHex(options2);
  };
  BaseColor2.prototype.toCssRgba = function toCssRgba() {
    var rgb = this.toBytes();
    return "rgba(" + rgb.r + ", " + rgb.g + ", " + rgb.b + ", " + parseFloat(Number(this.a).toFixed(3)) + ")";
  };
  BaseColor2.prototype.toDisplay = function toDisplay() {
    if (browser2.msie && browser2.version < 9) {
      return this.toCss();
    }
    return this.toCssRgba();
  };
  BaseColor2.prototype.equals = function equals(c) {
    return c === this || c !== null && c !== void 0 && this.toCssRgba() === parseColor(c).toCssRgba();
  };
  BaseColor2.prototype.diff = function diff(other) {
    if (other === null) {
      return NaN;
    }
    var c1 = this.toBytes();
    var c2 = other.toBytes();
    return Math.sqrt(Math.pow((c1.r - c2.r) * 0.3, 2) + Math.pow((c1.g - c2.g) * 0.59, 2) + Math.pow((c1.b - c2.b) * 0.11, 2));
  };
  BaseColor2.prototype.clone = function clone2() {
    var c = this.toBytes();
    if (c === this) {
      c = new Bytes(c.r, c.g, c.b, c.a);
    }
    return c;
  };
  return BaseColor2;
}(class_default);
var RGB = function(BaseColor2) {
  function RGB2(r, g, b, a) {
    BaseColor2.call(this);
    this.r = r;
    this.g = g;
    this.b = b;
    this.a = a;
  }
  if (BaseColor2)
    RGB2.__proto__ = BaseColor2;
  RGB2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  RGB2.prototype.constructor = RGB2;
  RGB2.prototype.toHSV = function toHSV() {
    var ref2 = this;
    var r = ref2.r;
    var g = ref2.g;
    var b = ref2.b;
    var min3 = Math.min(r, g, b);
    var max2 = Math.max(r, g, b);
    var delta = max2 - min3;
    var v = max2;
    var h, s;
    if (delta === 0) {
      return new HSV(0, 0, v, this.a);
    }
    if (max2 !== 0) {
      s = delta / max2;
      if (r === max2) {
        h = (g - b) / delta;
      } else if (g === max2) {
        h = 2 + (b - r) / delta;
      } else {
        h = 4 + (r - g) / delta;
      }
      h *= 60;
      if (h < 0) {
        h += 360;
      }
    } else {
      s = 0;
      h = -1;
    }
    return new HSV(h, s, v, this.a);
  };
  RGB2.prototype.toHSL = function toHSL() {
    var ref2 = this;
    var r = ref2.r;
    var g = ref2.g;
    var b = ref2.b;
    var max2 = Math.max(r, g, b);
    var min3 = Math.min(r, g, b);
    var h, s, l = (max2 + min3) / 2;
    if (max2 === min3) {
      h = s = 0;
    } else {
      var d = max2 - min3;
      s = l > 0.5 ? d / (2 - max2 - min3) : d / (max2 + min3);
      switch (max2) {
        case r:
          h = (g - b) / d + (g < b ? 6 : 0);
          break;
        case g:
          h = (b - r) / d + 2;
          break;
        case b:
          h = (r - g) / d + 4;
          break;
        default:
          break;
      }
    }
    return new HSL(h * 60, s * 100, l * 100, this.a);
  };
  RGB2.prototype.toBytes = function toBytes() {
    return new Bytes(this.r * 255, this.g * 255, this.b * 255, this.a);
  };
  return RGB2;
}(BaseColor);
var Bytes = function(RGB2) {
  function Bytes2(r, g, b, a) {
    RGB2.call(this, Math.round(r), Math.round(g), Math.round(b), a);
  }
  if (RGB2)
    Bytes2.__proto__ = RGB2;
  Bytes2.prototype = Object.create(RGB2 && RGB2.prototype);
  Bytes2.prototype.constructor = Bytes2;
  Bytes2.prototype.toRGB = function toRGB() {
    return new RGB2(this.r / 255, this.g / 255, this.b / 255, this.a);
  };
  Bytes2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  Bytes2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  Bytes2.prototype.toHex = function toHex(options2) {
    var value = hex(this.r, 2) + hex(this.g, 2) + hex(this.b, 2);
    if (options2 && options2.alpha) {
      value += hex(Math.round(this.a * 255), 2);
    }
    return value;
  };
  Bytes2.prototype.toBytes = function toBytes() {
    return this;
  };
  return Bytes2;
}(RGB);
function hex(n, width, pad4) {
  if (pad4 === void 0)
    pad4 = "0";
  var result = n.toString(16);
  while (width > result.length) {
    result = pad4 + result;
  }
  return result;
}
var HSV = function(BaseColor2) {
  function HSV2(h, s, v, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.v = v;
    this.a = a;
  }
  if (BaseColor2)
    HSV2.__proto__ = BaseColor2;
  HSV2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSV2.prototype.constructor = HSV2;
  HSV2.prototype.toRGB = function toRGB() {
    var ref2 = this;
    var h = ref2.h;
    var s = ref2.s;
    var v = ref2.v;
    var r, g, b;
    if (s === 0) {
      r = g = b = v;
    } else {
      h /= 60;
      var i = Math.floor(h);
      var f = h - i;
      var p2 = v * (1 - s);
      var q = v * (1 - s * f);
      var t = v * (1 - s * (1 - f));
      switch (i) {
        case 0:
          r = v;
          g = t;
          b = p2;
          break;
        case 1:
          r = q;
          g = v;
          b = p2;
          break;
        case 2:
          r = p2;
          g = v;
          b = t;
          break;
        case 3:
          r = p2;
          g = q;
          b = v;
          break;
        case 4:
          r = t;
          g = p2;
          b = v;
          break;
        default:
          r = v;
          g = p2;
          b = q;
          break;
      }
    }
    return new RGB(r, g, b, this.a);
  };
  HSV2.prototype.toHSL = function toHSL() {
    return this.toRGB().toHSL();
  };
  HSV2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSV2;
}(BaseColor);
var HSL = function(BaseColor2) {
  function HSL2(h, s, l, a) {
    BaseColor2.call(this);
    this.h = h;
    this.s = s;
    this.l = l;
    this.a = a;
  }
  if (BaseColor2)
    HSL2.__proto__ = BaseColor2;
  HSL2.prototype = Object.create(BaseColor2 && BaseColor2.prototype);
  HSL2.prototype.constructor = HSL2;
  HSL2.prototype.toRGB = function toRGB() {
    var h = this.h / 360;
    var s = this.s / 100;
    var l = this.l / 100;
    var r, g, b;
    if (s === 0) {
      r = g = b = l;
    } else {
      var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
      var p2 = 2 * l - q;
      r = hue2rgb(p2, q, h + 1 / 3);
      g = hue2rgb(p2, q, h);
      b = hue2rgb(p2, q, h - 1 / 3);
    }
    return new RGB(r, g, b, this.a);
  };
  HSL2.prototype.toHSV = function toHSV() {
    return this.toRGB().toHSV();
  };
  HSL2.prototype.toBytes = function toBytes() {
    return this.toRGB().toBytes();
  };
  return HSL2;
}(BaseColor);
function hue2rgb(p2, q, s) {
  var t = s;
  if (t < 0) {
    t += 1;
  }
  if (t > 1) {
    t -= 1;
  }
  if (t < 1 / 6) {
    return p2 + (q - p2) * 6 * t;
  }
  if (t < 1 / 2) {
    return q;
  }
  if (t < 2 / 3) {
    return p2 + (q - p2) * (2 / 3 - t) * 6;
  }
  return p2;
}
function alphaFromHex(a) {
  return parseFloat(parseFloat(parseInt(a, 16) / 255).toFixed(3));
}
function parseColor(value, safe) {
  var m, ret;
  if (value == null || value === "none") {
    return null;
  }
  if (value instanceof BaseColor) {
    return value;
  }
  var color = value.toLowerCase();
  if (m = matchNamedColor(color)) {
    if (m[1] === "transparent") {
      color = new RGB(1, 1, 1, 0);
    } else {
      color = parseColor(named_colors_default[m[1]], safe);
    }
    color.match = [m[1]];
    return color;
  }
  if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      1
    );
  } else if (m = /^#?([0-9a-f])([0-9a-f])([0-9a-f])([0-9a-f])\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1] + m[1], 16),
      parseInt(m[2] + m[2], 16),
      parseInt(m[3] + m[3], 16),
      alphaFromHex(m[4] + m[4])
    );
  } else if (m = /^#?([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})([0-9a-f]{2})\b/i.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 16),
      parseInt(m[2], 16),
      parseInt(m[3], 16),
      alphaFromHex(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      1
    );
  } else if (m = /^rgba\(\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new Bytes(
      parseInt(m[1], 10),
      parseInt(m[2], 10),
      parseInt(m[3], 10),
      parseFloat(m[4])
    );
  } else if (m = /^rgb\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      1
    );
  } else if (m = /^rgba\(\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9]*\.?[0-9]+)%\s*,\s*([0-9.]+)\s*\)/.exec(color)) {
    ret = new RGB(
      parseFloat(m[1]) / 100,
      parseFloat(m[2]) / 100,
      parseFloat(m[3]) / 100,
      parseFloat(m[4])
    );
  }
  if (ret) {
    ret.match = m;
  } else if (!safe) {
    throw new Error("Cannot parse color: " + color);
  }
  return ret;
}

// node_modules/@progress/kendo-drawing/dist/es/common/color/color.js
var DARK_TRESHOLD = 180;
var Color = function(Class3) {
  function Color2(value) {
    var this$1 = this;
    Class3.call(this);
    if (arguments.length === 1) {
      var formats = Color2.formats;
      var resolvedColor = this.resolveColor(value);
      for (var idx = 0; idx < formats.length; idx++) {
        var formatRegex = formats[idx].re;
        var processor = formats[idx].process;
        var parts = formatRegex.exec(resolvedColor);
        if (parts) {
          var channels = processor(parts);
          this$1.r = channels[0];
          this$1.g = channels[1];
          this$1.b = channels[2];
        }
      }
    } else {
      this.r = arguments[0];
      this.g = arguments[1];
      this.b = arguments[2];
    }
    this.r = this.normalizeByte(this.r);
    this.g = this.normalizeByte(this.g);
    this.b = this.normalizeByte(this.b);
  }
  if (Class3)
    Color2.__proto__ = Class3;
  Color2.prototype = Object.create(Class3 && Class3.prototype);
  Color2.prototype.constructor = Color2;
  Color2.prototype.toHex = function toHex() {
    var pad4 = this.padDigit;
    var r = this.r.toString(16);
    var g = this.g.toString(16);
    var b = this.b.toString(16);
    return "#" + pad4(r) + pad4(g) + pad4(b);
  };
  Color2.prototype.resolveColor = function resolveColor(value) {
    var color = value || "black";
    if (color.charAt(0) === "#") {
      color = color.substr(1, 6);
    }
    color = color.replace(/ /g, "");
    color = color.toLowerCase();
    color = Color2.namedColors[color] || color;
    return color;
  };
  Color2.prototype.normalizeByte = function normalizeByte(value) {
    if (value < 0 || isNaN(value)) {
      return 0;
    }
    return value > 255 ? 255 : value;
  };
  Color2.prototype.padDigit = function padDigit(value) {
    return value.length === 1 ? "0" + value : value;
  };
  Color2.prototype.brightness = function brightness(value) {
    var round5 = Math.round;
    this.r = round5(this.normalizeByte(this.r * value));
    this.g = round5(this.normalizeByte(this.g * value));
    this.b = round5(this.normalizeByte(this.b * value));
    return this;
  };
  Color2.prototype.percBrightness = function percBrightness() {
    return Math.sqrt(0.241 * this.r * this.r + 0.691 * this.g * this.g + 0.068 * this.b * this.b);
  };
  Color2.prototype.isDark = function isDark() {
    return this.percBrightness() < DARK_TRESHOLD;
  };
  Color2.fromBytes = function fromBytes(r, g, b, a) {
    return new Bytes(r, g, b, a != null ? a : 1);
  };
  Color2.fromRGB = function fromRGB(r, g, b, a) {
    return new RGB(r, g, b, a != null ? a : 1);
  };
  Color2.fromHSV = function fromHSV(h, s, v, a) {
    return new HSV(h, s, v, a != null ? a : 1);
  };
  Color2.fromHSL = function fromHSL(h, s, l, a) {
    return new HSL(h, s, l, a != null ? a : 1);
  };
  return Color2;
}(class_default);
Color.formats = [{
  re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 10),
      parseInt(parts[2], 10),
      parseInt(parts[3], 10)
    ];
  }
}, {
  re: /^(\w{2})(\w{2})(\w{2})$/,
  process: function(parts) {
    return [
      parseInt(parts[1], 16),
      parseInt(parts[2], 16),
      parseInt(parts[3], 16)
    ];
  }
}, {
  re: /^(\w{1})(\w{1})(\w{1})$/,
  process: function(parts) {
    return [
      parseInt(parts[1] + parts[1], 16),
      parseInt(parts[2] + parts[2], 16),
      parseInt(parts[3] + parts[3], 16)
    ];
  }
}];
Color.namedColors = named_colors_default;
var color_default = Color;

// node_modules/@progress/kendo-drawing/dist/es/core/has-observers.js
var HasObservers = function(Class3) {
  function HasObservers2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    HasObservers2.__proto__ = Class3;
  HasObservers2.prototype = Object.create(Class3 && Class3.prototype);
  HasObservers2.prototype.constructor = HasObservers2;
  HasObservers2.prototype.observers = function observers() {
    this._observers = this._observers || [];
    return this._observers;
  };
  HasObservers2.prototype.addObserver = function addObserver(element) {
    if (!this._observers) {
      this._observers = [element];
    } else {
      this._observers.push(element);
    }
    return this;
  };
  HasObservers2.prototype.removeObserver = function removeObserver(element) {
    var observers = this.observers();
    var index = observers.indexOf(element);
    if (index !== -1) {
      observers.splice(index, 1);
    }
    return this;
  };
  HasObservers2.prototype.trigger = function trigger2(methodName, event) {
    var observers = this._observers;
    if (observers && !this._suspended) {
      for (var idx = 0; idx < observers.length; idx++) {
        var observer = observers[idx];
        if (observer[methodName]) {
          observer[methodName](event);
        }
      }
    }
    return this;
  };
  HasObservers2.prototype.optionsChange = function optionsChange(e) {
    if (e === void 0)
      e = {};
    e.element = this;
    this.trigger("optionsChange", e);
  };
  HasObservers2.prototype.geometryChange = function geometryChange() {
    this.trigger("geometryChange", {
      element: this
    });
  };
  HasObservers2.prototype.suspend = function suspend() {
    this._suspended = (this._suspended || 0) + 1;
    return this;
  };
  HasObservers2.prototype.resume = function resume() {
    this._suspended = Math.max((this._suspended || 0) - 1, 0);
    return this;
  };
  HasObservers2.prototype._observerField = function _observerField(field, value) {
    if (this[field]) {
      this[field].removeObserver(this);
    }
    this[field] = value;
    value.addObserver(this);
  };
  return HasObservers2;
}(class_default);
var has_observers_default = HasObservers;

// node_modules/@progress/kendo-drawing/dist/es/util.js
var util_exports = {};
__export(util_exports, {
  DEG_TO_RAD: () => DEG_TO_RAD,
  LRUCache: () => lru_cache_default,
  MAX_NUM: () => MAX_NUM,
  MIN_NUM: () => MIN_NUM,
  TextMetrics: () => text_metrics_default,
  append: () => append,
  arabicToRoman: () => arabicToRoman,
  bindEvents: () => bindEvents,
  createPromise: () => createPromise,
  defined: () => defined,
  definitionId: () => definitionId,
  deg: () => deg,
  elementOffset: () => elementOffset,
  elementPadding: () => elementPadding,
  elementScale: () => elementScale,
  elementSize: () => elementSize,
  elementStyles: () => elementStyles,
  encodeBase64: () => encodeBase64,
  eventCoordinates: () => eventCoordinates,
  eventElement: () => eventElement,
  hashKey: () => hashKey,
  isTransparent: () => isTransparent,
  last: () => last,
  limitValue: () => limitValue,
  measureText: () => measureText,
  mergeSort: () => mergeSort,
  normalizeText: () => normalizeText,
  now: () => now_default,
  objectKey: () => objectKey,
  promiseAll: () => promiseAll,
  rad: () => rad,
  round: () => round2,
  unbindEvents: () => unbindEvents,
  valueOrDefault: () => valueOrDefault
});

// node_modules/@progress/kendo-drawing/dist/es/util/append.js
function append(first, second) {
  first.push.apply(first, second);
  return first;
}

// node_modules/@progress/kendo-drawing/dist/es/util/arabic-to-roman.js
var literals = {
  1: "i",
  10: "x",
  100: "c",
  2: "ii",
  20: "xx",
  200: "cc",
  3: "iii",
  30: "xxx",
  300: "ccc",
  4: "iv",
  40: "xl",
  400: "cd",
  5: "v",
  50: "l",
  500: "d",
  6: "vi",
  60: "lx",
  600: "dc",
  7: "vii",
  70: "lxx",
  700: "dcc",
  8: "viii",
  80: "lxxx",
  800: "dccc",
  9: "ix",
  90: "xc",
  900: "cm",
  1e3: "m"
};
function arabicToRoman(n) {
  var values5 = [
    1e3,
    900,
    800,
    700,
    600,
    500,
    400,
    300,
    200,
    100,
    90,
    80,
    70,
    60,
    50,
    40,
    30,
    20,
    10,
    9,
    8,
    7,
    6,
    5,
    4,
    3,
    2,
    1
  ];
  var roman = "";
  while (n > 0) {
    if (n < values5[0]) {
      values5.shift();
    } else {
      roman += literals[values5[0]];
      n -= values5[0];
    }
  }
  return roman;
}

// node_modules/@progress/kendo-drawing/dist/es/util/create-promise.js
function createPromise() {
  var resolveFn, rejectFn;
  var promise = new Promise(function(resolve, reject) {
    resolveFn = function(data) {
      promise._state = "resolved";
      resolve(data);
      return promise;
    };
    rejectFn = function(data) {
      promise._state = "rejected";
      reject(data);
      return promise;
    };
  });
  promise._state = "pending";
  promise.resolve = resolveFn;
  promise.reject = rejectFn;
  promise.state = function() {
    return promise._state;
  };
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/util/defined.js
var UNDEFINED = "undefined";
function defined(value) {
  return typeof value !== UNDEFINED;
}

// node_modules/@progress/kendo-drawing/dist/es/util/definition-id.js
var defId = 1;
function definitionId() {
  return "kdef" + defId++;
}

// node_modules/@progress/kendo-drawing/dist/es/util/constants.js
var DEG_TO_RAD = Math.PI / 180;
var MAX_NUM = Number.MAX_VALUE;
var MIN_NUM = -Number.MAX_VALUE;

// node_modules/@progress/kendo-drawing/dist/es/util/deg.js
function deg(radians) {
  return radians / DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-utf.js
var fromCharCode = String.fromCharCode;
var BOM = "þÿ";
function encodeUTF8(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    var code2 = input.charCodeAt(i);
    if (55296 <= code2 && code2 <= 56319) {
      var hi = code2;
      var low = input.charCodeAt(++i);
      if (!isNaN(low)) {
        code2 = (hi - 55296) * 1024 + (low - 56320) + 65536;
      }
    }
    if (code2 < 128) {
      output += fromCharCode(code2);
    } else if (code2 < 2048) {
      output += fromCharCode(192 | code2 >>> 6);
      output += fromCharCode(128 | code2 & 63);
    } else if (code2 < 65536) {
      output += fromCharCode(224 | code2 >>> 12);
      output += fromCharCode(128 | code2 >>> 6 & 63);
      output += fromCharCode(128 | code2 & 63);
    } else if (code2 < 1114111) {
      output += fromCharCode(240 | code2 >>> 18);
      output += fromCharCode(128 | code2 >>> 12 & 63);
      output += fromCharCode(128 | code2 >>> 6 & 63);
      output += fromCharCode(128 | code2 & 63);
    }
  }
  return output;
}
function encodeUnit(codeUnit) {
  return fromCharCode(codeUnit >> 8) + fromCharCode(codeUnit & 255);
}
function encodeUTF16BE(input) {
  var output = "";
  for (var i = 0; i < input.length; i++) {
    var c = input.charCodeAt(i);
    if (c < 65535) {
      output += encodeUnit(c);
    } else {
      var lead = (c - 65536 >> 10) + 55296;
      var trail = (c - 65536 & 1023) + 56320;
      output += encodeUnit(lead);
      output += encodeUnit(trail);
    }
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/encode-base64.js
var KEY_STR = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
function encodeBase64(input) {
  var output = "";
  var i = 0;
  var utfInput = encodeUTF8(input);
  while (i < utfInput.length) {
    var chr1 = utfInput.charCodeAt(i++);
    var chr2 = utfInput.charCodeAt(i++);
    var chr3 = utfInput.charCodeAt(i++);
    var enc1 = chr1 >> 2;
    var enc2 = (chr1 & 3) << 4 | chr2 >> 4;
    var enc3 = (chr2 & 15) << 2 | chr3 >> 6;
    var enc4 = chr3 & 63;
    if (isNaN(chr2)) {
      enc3 = enc4 = 64;
    } else if (isNaN(chr3)) {
      enc4 = 64;
    }
    output = output + KEY_STR.charAt(enc1) + KEY_STR.charAt(enc2) + KEY_STR.charAt(enc3) + KEY_STR.charAt(enc4);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-coordinates.js
function eventCoordinates(e) {
  if (defined((e.x || {}).location)) {
    return {
      x: e.x.location,
      y: e.y.location
    };
  }
  return {
    x: e.pageX || e.clientX || 0,
    y: e.pageY || e.clientY || 0
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/event-element.js
function eventElement(e) {
  if (e === void 0)
    e = {};
  return e.touch ? e.touch.initialTouch : e.target;
}

// node_modules/@progress/kendo-drawing/dist/es/util/is-transparent.js
function isTransparent(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined(color);
}

// node_modules/@progress/kendo-drawing/dist/es/util/last.js
function last(array) {
  if (array) {
    return array[array.length - 1];
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/limit-value.js
function limitValue(value, min3, max2) {
  return Math.max(Math.min(value, max2), min3);
}

// node_modules/@progress/kendo-drawing/dist/es/util/merge-sort.js
function mergeSort(a, cmp) {
  if (a.length < 2) {
    return a.slice();
  }
  function merge(a2, b) {
    var r = [], ai = 0, bi = 0, i = 0;
    while (ai < a2.length && bi < b.length) {
      if (cmp(a2[ai], b[bi]) <= 0) {
        r[i++] = a2[ai++];
      } else {
        r[i++] = b[bi++];
      }
    }
    if (ai < a2.length) {
      r.push.apply(r, a2.slice(ai));
    }
    if (bi < b.length) {
      r.push.apply(r, b.slice(bi));
    }
    return r;
  }
  return function sort(a2) {
    if (a2.length <= 1) {
      return a2;
    }
    var m = Math.floor(a2.length / 2);
    var left = a2.slice(0, m);
    var right = a2.slice(m);
    left = sort(left);
    right = sort(right);
    return merge(left, right);
  }(a);
}

// node_modules/@progress/kendo-drawing/dist/es/util/promise-all.js
function promiseAll(promises) {
  return Promise.all(promises);
}

// node_modules/@progress/kendo-drawing/dist/es/util/rad.js
function rad(degrees) {
  return degrees * DEG_TO_RAD;
}

// node_modules/@progress/kendo-drawing/dist/es/util/round.js
function pow(p2) {
  if (p2) {
    return Math.pow(10, p2);
  }
  return 1;
}
function round2(value, precision) {
  var power = pow(precision);
  return Math.round(value * power) / power;
}

// node_modules/@progress/kendo-drawing/dist/es/util/value-or-default.js
function valueOrDefault(value, defaultValue) {
  return defined(value) ? value : defaultValue;
}

// node_modules/@progress/kendo-drawing/dist/es/util/bind-events.js
function bindEvents(element, events2) {
  for (var eventName in events2) {
    var eventNames = eventName.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element.addEventListener(eventNames[idx], events2[eventName], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-offset.js
function elementOffset(element) {
  var box = element.getBoundingClientRect();
  var documentElement = document.documentElement;
  return {
    top: box.top + (window.pageYOffset || documentElement.scrollTop) - (documentElement.clientTop || 0),
    left: box.left + (window.pageXOffset || documentElement.scrollLeft) - (documentElement.clientLeft || 0)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-styles.js
function elementStyles(element, styles) {
  var result = {};
  var style = window.getComputedStyle(element) || {};
  var stylesArray = Array.isArray(styles) ? styles : [styles];
  for (var idx = 0; idx < stylesArray.length; idx++) {
    var field = stylesArray[idx];
    result[field] = style[field];
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-size.js
function getPixels(value) {
  if (isNaN(value)) {
    return value;
  }
  return value + "px";
}
function elementSize(element, size) {
  if (size) {
    var width = size.width;
    var height = size.height;
    if (defined(width)) {
      element.style.width = getPixels(width);
    }
    if (defined(height)) {
      element.style.height = getPixels(height);
    }
  } else {
    var size$1 = elementStyles(element, ["width", "height"]);
    return {
      width: parseInt(size$1.width, 10),
      height: parseInt(size$1.height, 10)
    };
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/unbind-events.js
function unbindEvents(element, events2) {
  if (events2 === void 0)
    events2 = {};
  for (var name3 in events2) {
    var eventNames = name3.trim().split(" ");
    for (var idx = 0; idx < eventNames.length; idx++) {
      element.removeEventListener(eventNames[idx], events2[name3], false);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/util/element-padding.js
function elementPadding(element) {
  var ref2 = elementStyles(element, ["paddingLeft", "paddingTop"]);
  var paddingLeft = ref2.paddingLeft;
  var paddingTop = ref2.paddingTop;
  return {
    top: parseFloat(paddingTop),
    left: parseFloat(paddingLeft)
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/matrix.js
var Matrix = function(Class3) {
  function Matrix3(a, b, c, d, e, f) {
    if (a === void 0)
      a = 0;
    if (b === void 0)
      b = 0;
    if (c === void 0)
      c = 0;
    if (d === void 0)
      d = 0;
    if (e === void 0)
      e = 0;
    if (f === void 0)
      f = 0;
    Class3.call(this);
    this.a = a;
    this.b = b;
    this.c = c;
    this.d = d;
    this.e = e;
    this.f = f;
  }
  if (Class3)
    Matrix3.__proto__ = Class3;
  Matrix3.prototype = Object.create(Class3 && Class3.prototype);
  Matrix3.prototype.constructor = Matrix3;
  Matrix3.prototype.multiplyCopy = function multiplyCopy(matrix) {
    return new Matrix3(
      this.a * matrix.a + this.c * matrix.b,
      this.b * matrix.a + this.d * matrix.b,
      this.a * matrix.c + this.c * matrix.d,
      this.b * matrix.c + this.d * matrix.d,
      this.a * matrix.e + this.c * matrix.f + this.e,
      this.b * matrix.e + this.d * matrix.f + this.f
    );
  };
  Matrix3.prototype.invert = function invert() {
    var ref2 = this;
    var a = ref2.a;
    var b = ref2.b;
    var d = ref2.c;
    var e = ref2.d;
    var g = ref2.e;
    var h = ref2.f;
    var det = a * e - b * d;
    if (det === 0) {
      return null;
    }
    return new Matrix3(
      e / det,
      -b / det,
      -d / det,
      a / det,
      (d * h - e * g) / det,
      (b * g - a * h) / det
    );
  };
  Matrix3.prototype.clone = function clone2() {
    return new Matrix3(this.a, this.b, this.c, this.d, this.e, this.f);
  };
  Matrix3.prototype.equals = function equals(other) {
    if (!other) {
      return false;
    }
    return this.a === other.a && this.b === other.b && this.c === other.c && this.d === other.d && this.e === other.e && this.f === other.f;
  };
  Matrix3.prototype.round = function round$1(precision) {
    this.a = round2(this.a, precision);
    this.b = round2(this.b, precision);
    this.c = round2(this.c, precision);
    this.d = round2(this.d, precision);
    this.e = round2(this.e, precision);
    this.f = round2(this.f, precision);
    return this;
  };
  Matrix3.prototype.toArray = function toArray(precision) {
    var result = [this.a, this.b, this.c, this.d, this.e, this.f];
    if (defined(precision)) {
      for (var i = 0; i < result.length; i++) {
        result[i] = round2(result[i], precision);
      }
    }
    return result;
  };
  Matrix3.prototype.toString = function toString4(precision, separator) {
    if (separator === void 0)
      separator = ",";
    return this.toArray(precision).join(separator);
  };
  Matrix3.translate = function translate2(x, y) {
    return new Matrix3(1, 0, 0, 1, x, y);
  };
  Matrix3.unit = function unit() {
    return new Matrix3(1, 0, 0, 1, 0, 0);
  };
  Matrix3.rotate = function rotate(angle, x, y) {
    var matrix = new Matrix3();
    matrix.a = Math.cos(rad(angle));
    matrix.b = Math.sin(rad(angle));
    matrix.c = -matrix.b;
    matrix.d = matrix.a;
    matrix.e = x - x * matrix.a + y * matrix.b || 0;
    matrix.f = y - y * matrix.a - x * matrix.b || 0;
    return matrix;
  };
  Matrix3.scale = function scale(scaleX, scaleY) {
    return new Matrix3(scaleX, 0, 0, scaleY, 0, 0);
  };
  return Matrix3;
}(class_default);
Matrix.IDENTITY = Matrix.unit();
var matrix_default = Matrix;

// node_modules/@progress/kendo-drawing/dist/es/util/element-scale.js
var matrixRegexp = /matrix\((.*)\)/;
function parseMatrix(matrixString) {
  var match = matrixString.match(matrixRegexp);
  if (match === null || match.length !== 2) {
    return matrix_default.unit();
  }
  var members = match[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(matrix_default, [null].concat(members)))();
}
function transformMatrix(element) {
  var transform2 = getComputedStyle(element).transform;
  if (transform2 === "none") {
    return matrix_default.unit();
  }
  return parseMatrix(transform2);
}
function elementScale(element) {
  if (!element) {
    return matrix_default.unit();
  }
  var matrix = transformMatrix(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/lru-cache.js
var LRUCache = function(Class3) {
  function LRUCache2(size) {
    Class3.call(this);
    this._size = size;
    this._length = 0;
    this._map = {};
  }
  if (Class3)
    LRUCache2.__proto__ = Class3;
  LRUCache2.prototype = Object.create(Class3 && Class3.prototype);
  LRUCache2.prototype.constructor = LRUCache2;
  LRUCache2.prototype.put = function put(key, value) {
    var map2 = this._map;
    var entry = { key, value };
    map2[key] = entry;
    if (!this._head) {
      this._head = this._tail = entry;
    } else {
      this._tail.newer = entry;
      entry.older = this._tail;
      this._tail = entry;
    }
    if (this._length >= this._size) {
      map2[this._head.key] = null;
      this._head = this._head.newer;
      this._head.older = null;
    } else {
      this._length++;
    }
  };
  LRUCache2.prototype.get = function get2(key) {
    var entry = this._map[key];
    if (entry) {
      if (entry === this._head && entry !== this._tail) {
        this._head = entry.newer;
        this._head.older = null;
      }
      if (entry !== this._tail) {
        if (entry.older) {
          entry.older.newer = entry.newer;
          entry.newer.older = entry.older;
        }
        entry.older = this._tail;
        entry.newer = null;
        this._tail.newer = entry;
        this._tail = entry;
      }
      return entry.value;
    }
  };
  return LRUCache2;
}(class_default);
var lru_cache_default = LRUCache;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/util.js
var REPLACE_REGEX = /\r?\n|\r|\t/g;
var SPACE = " ";
function normalizeText(text) {
  return String(text).replace(REPLACE_REGEX, SPACE);
}
function objectKey(object4) {
  var parts = [];
  for (var key in object4) {
    parts.push(key + object4[key]);
  }
  return parts.sort().join("");
}
function hashKey(str) {
  var hash = 2166136261;
  for (var i = 0; i < str.length; ++i) {
    hash += (hash << 1) + (hash << 4) + (hash << 7) + (hash << 8) + (hash << 24);
    hash ^= str.charCodeAt(i);
  }
  return hash >>> 0;
}

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/text-metrics.js
function zeroSize() {
  return { width: 0, height: 0, baseline: 0 };
}
var DEFAULT_OPTIONS = {
  baselineMarkerSize: 1
};
var defaultMeasureBox;
if (typeof document !== "undefined") {
  defaultMeasureBox = document.createElement("div");
  defaultMeasureBox.style.cssText = "position: absolute !important; top: -4000px !important; width: auto !important; height: auto !important;padding: 0 !important; margin: 0 !important; border: 0 !important;line-height: normal !important; visibility: hidden !important; white-space: pre!important;";
}
var TextMetrics = function(Class3) {
  function TextMetrics2(options2) {
    Class3.call(this);
    this._cache = new lru_cache_default(1e3);
    this.options = Object.assign({}, DEFAULT_OPTIONS, options2);
  }
  if (Class3)
    TextMetrics2.__proto__ = Class3;
  TextMetrics2.prototype = Object.create(Class3 && Class3.prototype);
  TextMetrics2.prototype.constructor = TextMetrics2;
  TextMetrics2.prototype.measure = function measure(text, style, options2) {
    if (options2 === void 0)
      options2 = {};
    if (typeof text === "undefined" || text === null) {
      return zeroSize();
    }
    var styleKey = objectKey(style);
    var cacheKey = hashKey(text + styleKey);
    var cachedResult = this._cache.get(cacheKey);
    if (cachedResult) {
      return cachedResult;
    }
    var size = zeroSize();
    var measureBox = options2.box || defaultMeasureBox;
    var baselineMarker = this._baselineMarker().cloneNode(false);
    for (var key in style) {
      var value = style[key];
      if (typeof value !== "undefined") {
        measureBox.style[key] = value;
      }
    }
    var textStr = options2.normalizeText !== false ? normalizeText(text) : String(text);
    measureBox.textContent = textStr;
    measureBox.appendChild(baselineMarker);
    document.body.appendChild(measureBox);
    if (textStr.length) {
      size.width = measureBox.offsetWidth - this.options.baselineMarkerSize;
      size.height = measureBox.offsetHeight;
      size.baseline = baselineMarker.offsetTop + this.options.baselineMarkerSize;
    }
    if (size.width > 0 && size.height > 0) {
      this._cache.put(cacheKey, size);
    }
    measureBox.parentNode.removeChild(measureBox);
    return size;
  };
  TextMetrics2.prototype._baselineMarker = function _baselineMarker() {
    var marker = document.createElement("div");
    marker.style.cssText = "display: inline-block; vertical-align: baseline;width: " + this.options.baselineMarkerSize + "px; height: " + this.options.baselineMarkerSize + "px;overflow: hidden;";
    return marker;
  };
  return TextMetrics2;
}(class_default);
TextMetrics.current = new TextMetrics();
var text_metrics_default = TextMetrics;

// node_modules/@progress/kendo-drawing/dist/es/text-metrics/measure-text.js
function measureText(text, style, measureBox) {
  return text_metrics_default.current.measure(text, style, measureBox);
}

// node_modules/@progress/kendo-drawing/dist/es/core/options-store.js
var toString2 = {}.toString;
var OptionsStore = function(HasObservers2) {
  function OptionsStore2(options2, prefix) {
    var this$1 = this;
    if (prefix === void 0)
      prefix = "";
    HasObservers2.call(this);
    this.prefix = prefix;
    for (var field in options2) {
      var member = options2[field];
      member = this$1._wrap(member, field);
      this$1[field] = member;
    }
  }
  if (HasObservers2)
    OptionsStore2.__proto__ = HasObservers2;
  OptionsStore2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  OptionsStore2.prototype.constructor = OptionsStore2;
  OptionsStore2.prototype.get = function get2(field) {
    var parts = field.split(".");
    var result = this;
    while (parts.length && result) {
      var part = parts.shift();
      result = result[part];
    }
    return result;
  };
  OptionsStore2.prototype.set = function set2(field, value) {
    var current4 = this.get(field);
    if (current4 !== value) {
      this._set(field, this._wrap(value, field));
      this.optionsChange({
        field: this.prefix + field,
        value
      });
    }
  };
  OptionsStore2.prototype._set = function _set(field, value) {
    var this$1 = this;
    var composite = field.indexOf(".") >= 0;
    var parentObj = this;
    var fieldName = field;
    if (composite) {
      var parts = fieldName.split(".");
      var prefix = this.prefix;
      while (parts.length > 1) {
        fieldName = parts.shift();
        prefix += fieldName + ".";
        var obj = parentObj[fieldName];
        if (!obj) {
          obj = new OptionsStore2({}, prefix);
          obj.addObserver(this$1);
          parentObj[fieldName] = obj;
        }
        parentObj = obj;
      }
      fieldName = parts[0];
    }
    parentObj._clear(fieldName);
    parentObj[fieldName] = value;
  };
  OptionsStore2.prototype._clear = function _clear(field) {
    var current4 = this[field];
    if (current4 && current4.removeObserver) {
      current4.removeObserver(this);
    }
  };
  OptionsStore2.prototype._wrap = function _wrap(object4, field) {
    var type = toString2.call(object4);
    var wrapped = object4;
    if (wrapped !== null && defined(wrapped) && type === "[object Object]") {
      if (!(object4 instanceof OptionsStore2) && !(object4 instanceof class_default)) {
        wrapped = new OptionsStore2(wrapped, this.prefix + field + ".");
      }
      wrapped.addObserver(this);
    }
    return wrapped;
  };
  return OptionsStore2;
}(has_observers_default);
var options_store_default = OptionsStore;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-accessors.js
function setAccessor(field) {
  return function(value) {
    if (this[field] !== value) {
      this[field] = value;
      this.geometryChange();
    }
    return this;
  };
}
function getAccessor(field) {
  return function() {
    return this[field];
  };
}
function defineAccessors(fn, fields) {
  for (var i = 0; i < fields.length; i++) {
    var name3 = fields[i];
    var capitalized = name3.charAt(0).toUpperCase() + name3.substring(1, name3.length);
    fn["set" + capitalized] = setAccessor(name3);
    fn["get" + capitalized] = getAccessor(name3);
  }
}
var withAccessors = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineAccessors(result.prototype, names);
  return result;
};
var with_accessors_default = withAccessors;

// node_modules/@progress/kendo-drawing/dist/es/geometry/to-matrix.js
function toMatrix(transformation) {
  if (transformation && typeof transformation.matrix === "function") {
    return transformation.matrix();
  }
  return transformation;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/point.js
var Point = function(superclass) {
  function Point8(x, y) {
    superclass.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (superclass)
    Point8.__proto__ = superclass;
  Point8.prototype = Object.create(superclass && superclass.prototype);
  Point8.prototype.constructor = Point8;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Point8.prototype.equals = function equals(other) {
    return other && other.x === this.x && other.y === this.y;
  };
  Point8.prototype.clone = function clone2() {
    return new Point8(this.x, this.y);
  };
  Point8.prototype.rotate = function rotate(angle, origin) {
    var originPoint = Point8.create(origin) || Point8.ZERO;
    return this.transform(matrix_default.rotate(angle, originPoint.x, originPoint.y));
  };
  Point8.prototype.translate = function translate2(x, y) {
    this.x += x;
    this.y += y;
    this.geometryChange();
    return this;
  };
  Point8.prototype.translateWith = function translateWith(point2) {
    return this.translate(point2.x, point2.y);
  };
  Point8.prototype.move = function move(x, y) {
    this.x = this.y = 0;
    return this.translate(x, y);
  };
  Point8.prototype.scale = function scale(scaleX, scaleY) {
    if (scaleY === void 0)
      scaleY = scaleX;
    this.x *= scaleX;
    this.y *= scaleY;
    this.geometryChange();
    return this;
  };
  Point8.prototype.scaleCopy = function scaleCopy(scaleX, scaleY) {
    return this.clone().scale(scaleX, scaleY);
  };
  Point8.prototype.transform = function transform2(transformation) {
    var matrix = toMatrix(transformation);
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    this.x = matrix.a * x + matrix.c * y + matrix.e;
    this.y = matrix.b * x + matrix.d * y + matrix.f;
    this.geometryChange();
    return this;
  };
  Point8.prototype.transformCopy = function transformCopy(transformation) {
    var point2 = this.clone();
    if (transformation) {
      point2.transform(transformation);
    }
    return point2;
  };
  Point8.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point8.prototype.round = function round$1(digits) {
    this.x = round2(this.x, digits);
    this.y = round2(this.y, digits);
    this.geometryChange();
    return this;
  };
  Point8.prototype.toArray = function toArray(digits) {
    var doRound = defined(digits);
    var x = doRound ? round2(this.x, digits) : this.x;
    var y = doRound ? round2(this.y, digits) : this.y;
    return [x, y];
  };
  Point8.prototype.toString = function toString4(digits, separator) {
    if (separator === void 0)
      separator = " ";
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    if (defined(digits)) {
      x = round2(x, digits);
      y = round2(y, digits);
    }
    return x + separator + y;
  };
  Point8.create = function create2(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Point8) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Point8(arg0[0], arg0[1]);
      }
      return new Point8(arg0, arg1);
    }
  };
  Point8.min = function min3() {
    var arguments$1 = arguments;
    var minX = MAX_NUM;
    var minY = MAX_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      minX = Math.min(point2.x, minX);
      minY = Math.min(point2.y, minY);
    }
    return new Point8(minX, minY);
  };
  Point8.max = function max2() {
    var arguments$1 = arguments;
    var maxX = MIN_NUM;
    var maxY = MIN_NUM;
    for (var i = 0; i < arguments.length; i++) {
      var point2 = arguments$1[i];
      maxX = Math.max(point2.x, maxX);
      maxY = Math.max(point2.y, maxY);
    }
    return new Point8(maxX, maxY);
  };
  Point8.minPoint = function minPoint() {
    return new Point8(MIN_NUM, MIN_NUM);
  };
  Point8.maxPoint = function maxPoint() {
    return new Point8(MAX_NUM, MAX_NUM);
  };
  staticAccessors2.ZERO.get = function() {
    return new Point8(0, 0);
  };
  Object.defineProperties(Point8, staticAccessors2);
  return Point8;
}(with_accessors_default(has_observers_default, ["x", "y"]));
var point_default = Point;

// node_modules/@progress/kendo-drawing/dist/es/geometry/size.js
var Size = function(superclass) {
  function Size2(width, height) {
    superclass.call(this);
    this.width = width || 0;
    this.height = height || 0;
  }
  if (superclass)
    Size2.__proto__ = superclass;
  Size2.prototype = Object.create(superclass && superclass.prototype);
  Size2.prototype.constructor = Size2;
  var staticAccessors2 = { ZERO: { configurable: true } };
  Size2.prototype.equals = function equals(other) {
    return other && other.width === this.width && other.height === this.height;
  };
  Size2.prototype.clone = function clone2() {
    return new Size2(this.width, this.height);
  };
  Size2.prototype.toArray = function toArray(digits) {
    var doRound = defined(digits);
    var width = doRound ? round2(this.width, digits) : this.width;
    var height = doRound ? round2(this.height, digits) : this.height;
    return [width, height];
  };
  Size2.create = function create2(arg0, arg1) {
    if (defined(arg0)) {
      if (arg0 instanceof Size2) {
        return arg0;
      } else if (arguments.length === 1 && arg0.length === 2) {
        return new Size2(arg0[0], arg0[1]);
      }
      return new Size2(arg0, arg1);
    }
  };
  staticAccessors2.ZERO.get = function() {
    return new Size2(0, 0);
  };
  Object.defineProperties(Size2, staticAccessors2);
  return Size2;
}(with_accessors_default(has_observers_default, ["width", "height"]));
var size_default = Size;

// node_modules/@progress/kendo-drawing/dist/es/geometry/rect.js
var Rect = function(HasObservers2) {
  function Rect3(origin, size, cornerRadius) {
    if (origin === void 0)
      origin = new point_default();
    if (size === void 0)
      size = new size_default();
    if (cornerRadius === void 0)
      cornerRadius = 0;
    HasObservers2.call(this);
    this.setOrigin(origin);
    this.setSize(size);
    this.setCornerRadius(cornerRadius);
  }
  if (HasObservers2)
    Rect3.__proto__ = HasObservers2;
  Rect3.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Rect3.prototype.constructor = Rect3;
  Rect3.prototype.clone = function clone2() {
    return new Rect3(
      this.origin.clone(),
      this.size.clone()
    );
  };
  Rect3.prototype.equals = function equals(other) {
    return other && other.origin.equals(this.origin) && other.size.equals(this.size);
  };
  Rect3.prototype.setOrigin = function setOrigin(value) {
    this._observerField("origin", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getOrigin = function getOrigin() {
    return this.origin;
  };
  Rect3.prototype.setCornerRadius = function setCornerRadius(radius) {
    this.cornerRadius = Array.isArray(radius) ? radius : [radius, radius];
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getCornerRadius = function getCornerRadius() {
    return this.cornerRadius;
  };
  Rect3.prototype.setSize = function setSize(value) {
    this._observerField("size", size_default.create(value));
    this.geometryChange();
    return this;
  };
  Rect3.prototype.getSize = function getSize() {
    return this.size;
  };
  Rect3.prototype.width = function width() {
    return this.size.width;
  };
  Rect3.prototype.height = function height() {
    return this.size.height;
  };
  Rect3.prototype.topLeft = function topLeft() {
    return this.origin.clone();
  };
  Rect3.prototype.bottomRight = function bottomRight() {
    return this.origin.clone().translate(this.width(), this.height());
  };
  Rect3.prototype.topRight = function topRight() {
    return this.origin.clone().translate(this.width(), 0);
  };
  Rect3.prototype.bottomLeft = function bottomLeft() {
    return this.origin.clone().translate(0, this.height());
  };
  Rect3.prototype.center = function center() {
    return this.origin.clone().translate(this.width() / 2, this.height() / 2);
  };
  Rect3.prototype.bbox = function bbox(matrix) {
    var tl = this.topLeft().transformCopy(matrix);
    var tr = this.topRight().transformCopy(matrix);
    var br = this.bottomRight().transformCopy(matrix);
    var bl = this.bottomLeft().transformCopy(matrix);
    return Rect3.fromPoints(tl, tr, br, bl);
  };
  Rect3.prototype.transformCopy = function transformCopy(m) {
    return Rect3.fromPoints(
      this.topLeft().transform(m),
      this.bottomRight().transform(m)
    );
  };
  Rect3.prototype.expand = function expand(x, y) {
    if (y === void 0)
      y = x;
    this.size.width += 2 * x;
    this.size.height += 2 * y;
    this.origin.translate(-x, -y);
    return this;
  };
  Rect3.prototype.expandCopy = function expandCopy(x, y) {
    return this.clone().expand(x, y);
  };
  Rect3.prototype.containsPoint = function containsPoint(point2) {
    var origin = this.origin;
    var bottomRight = this.bottomRight();
    return !(point2.x < origin.x || point2.y < origin.y || bottomRight.x < point2.x || bottomRight.y < point2.y);
  };
  Rect3.prototype._isOnPath = function _isOnPath(point2, width) {
    var rectOuter = this.expandCopy(width, width);
    var rectInner = this.expandCopy(-width, -width);
    return rectOuter.containsPoint(point2) && !rectInner.containsPoint(point2);
  };
  Rect3.fromPoints = function fromPoints() {
    var topLeft = point_default.min.apply(null, arguments);
    var bottomRight = point_default.max.apply(null, arguments);
    var size = new size_default(
      bottomRight.x - topLeft.x,
      bottomRight.y - topLeft.y
    );
    return new Rect3(topLeft, size);
  };
  Rect3.union = function union(a, b) {
    return Rect3.fromPoints(
      point_default.min(a.topLeft(), b.topLeft()),
      point_default.max(a.bottomRight(), b.bottomRight())
    );
  };
  Rect3.intersect = function intersect2(a, b) {
    var rect1 = {
      left: a.topLeft().x,
      top: a.topLeft().y,
      right: a.bottomRight().x,
      bottom: a.bottomRight().y
    };
    var rect2 = {
      left: b.topLeft().x,
      top: b.topLeft().y,
      right: b.bottomRight().x,
      bottom: b.bottomRight().y
    };
    if (rect1.left <= rect2.right && rect2.left <= rect1.right && rect1.top <= rect2.bottom && rect2.top <= rect1.bottom) {
      return Rect3.fromPoints(
        new point_default(Math.max(rect1.left, rect2.left), Math.max(rect1.top, rect2.top)),
        new point_default(Math.min(rect1.right, rect2.right), Math.min(rect1.bottom, rect2.bottom))
      );
    }
  };
  return Rect3;
}(has_observers_default);
var rect_default = Rect;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transformation.js
var Transformation = function(HasObservers2) {
  function Transformation2(matrix) {
    if (matrix === void 0)
      matrix = matrix_default.unit();
    HasObservers2.call(this);
    this._matrix = matrix;
  }
  if (HasObservers2)
    Transformation2.__proto__ = HasObservers2;
  Transformation2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Transformation2.prototype.constructor = Transformation2;
  Transformation2.prototype.clone = function clone2() {
    return new Transformation2(
      this._matrix.clone()
    );
  };
  Transformation2.prototype.equals = function equals(other) {
    return other && other._matrix.equals(this._matrix);
  };
  Transformation2.prototype.translate = function translate2(x, y) {
    this._matrix = this._matrix.multiplyCopy(matrix_default.translate(x, y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.scale = function scale(scaleX, scaleY, origin) {
    if (scaleY === void 0)
      scaleY = scaleX;
    if (origin === void 0)
      origin = null;
    var originPoint = origin;
    if (originPoint) {
      originPoint = point_default.create(originPoint);
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(originPoint.x, originPoint.y));
    }
    this._matrix = this._matrix.multiplyCopy(matrix_default.scale(scaleX, scaleY));
    if (originPoint) {
      this._matrix = this._matrix.multiplyCopy(matrix_default.translate(-originPoint.x, -originPoint.y));
    }
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.rotate = function rotate(angle, origin) {
    var originPoint = point_default.create(origin) || point_default.ZERO;
    this._matrix = this._matrix.multiplyCopy(matrix_default.rotate(angle, originPoint.x, originPoint.y));
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.multiply = function multiply(transformation) {
    var matrix = toMatrix(transformation);
    this._matrix = this._matrix.multiplyCopy(matrix);
    this._optionsChange();
    return this;
  };
  Transformation2.prototype.matrix = function matrix(value) {
    if (value) {
      this._matrix = value;
      this._optionsChange();
      return this;
    }
    return this._matrix;
  };
  Transformation2.prototype._optionsChange = function _optionsChange() {
    this.optionsChange({
      field: "transform",
      value: this
    });
  };
  return Transformation2;
}(has_observers_default);
var transformation_default = Transformation;

// node_modules/@progress/kendo-drawing/dist/es/geometry/transform.js
function transform(matrix) {
  if (matrix === null) {
    return null;
  }
  if (matrix instanceof transformation_default) {
    return matrix;
  }
  return new transformation_default(matrix);
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/element.js
var Element2 = function(HasObservers2) {
  function Element3(options2) {
    HasObservers2.call(this);
    this._initOptions(options2);
  }
  if (HasObservers2)
    Element3.__proto__ = HasObservers2;
  Element3.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Element3.prototype.constructor = Element3;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Rect";
  };
  Element3.prototype._initOptions = function _initOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var clip = options2.clip;
    var transform2 = options2.transform;
    if (transform2) {
      options2.transform = transform(transform2);
    }
    if (clip && !clip.id) {
      clip.id = definitionId();
    }
    this.options = new options_store_default(options2);
    this.options.addObserver(this);
  };
  Element3.prototype.transform = function transform2(value) {
    if (defined(value)) {
      this.options.set("transform", transform(value));
    } else {
      return this.options.get("transform");
    }
  };
  Element3.prototype.parentTransform = function parentTransform() {
    var element = this;
    var parentMatrix;
    while (element.parent) {
      element = element.parent;
      var transformation = element.transform();
      if (transformation) {
        parentMatrix = transformation.matrix().multiplyCopy(parentMatrix || matrix_default.unit());
      }
    }
    if (parentMatrix) {
      return transform(parentMatrix);
    }
  };
  Element3.prototype.currentTransform = function currentTransform(parentTransform) {
    if (parentTransform === void 0)
      parentTransform = this.parentTransform();
    var elementTransform = this.transform();
    var elementMatrix = toMatrix(elementTransform);
    var parentMatrix = toMatrix(parentTransform);
    var combinedMatrix;
    if (elementMatrix && parentMatrix) {
      combinedMatrix = parentMatrix.multiplyCopy(elementMatrix);
    } else {
      combinedMatrix = elementMatrix || parentMatrix;
    }
    if (combinedMatrix) {
      return transform(combinedMatrix);
    }
  };
  Element3.prototype.visible = function visible(value) {
    if (defined(value)) {
      this.options.set("visible", value);
      return this;
    }
    return this.options.get("visible") !== false;
  };
  Element3.prototype.clip = function clip(value) {
    var options2 = this.options;
    if (defined(value)) {
      if (value && !value.id) {
        value.id = definitionId();
      }
      options2.set("clip", value);
      return this;
    }
    return options2.get("clip");
  };
  Element3.prototype.opacity = function opacity(value) {
    if (defined(value)) {
      this.options.set("opacity", value);
      return this;
    }
    return valueOrDefault(this.options.get("opacity"), 1);
  };
  Element3.prototype.clippedBBox = function clippedBBox(transformation) {
    var bbox = this._clippedBBox(transformation);
    if (bbox) {
      var clip = this.clip();
      return clip ? rect_default.intersect(bbox, clip.bbox(transformation)) : bbox;
    }
  };
  Element3.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var transform2 = this.currentTransform(parentTransform);
      var transformedPoint = point2;
      if (transform2) {
        transformedPoint = point2.transformCopy(transform2.matrix().invert());
      }
      return this._hasFill() && this._containsPoint(transformedPoint) || this._isOnPath && this._hasStroke() && this._isOnPath(transformedPoint);
    }
    return false;
  };
  Element3.prototype._hasFill = function _hasFill() {
    var fill = this.options.fill;
    return fill && !isTransparent(fill.color);
  };
  Element3.prototype._hasStroke = function _hasStroke() {
    var stroke = this.options.stroke;
    return stroke && stroke.width > 0 && !isTransparent(stroke.color);
  };
  Element3.prototype._clippedBBox = function _clippedBBox(transformation) {
    return this.bbox(transformation);
  };
  Object.defineProperties(Element3.prototype, prototypeAccessors4);
  return Element3;
}(has_observers_default);
var element_default = Element2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/ellipse-extreme-angles.js
function ellipseExtremeAngles(center, rx, ry, matrix) {
  var extremeX = 0;
  var extremeY = 0;
  if (matrix) {
    extremeX = Math.atan2(matrix.c * ry, matrix.a * rx);
    if (matrix.b !== 0) {
      extremeY = Math.atan2(matrix.d * ry, matrix.b * rx);
    }
  }
  return {
    x: extremeX,
    y: extremeY
  };
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/circle.js
var PI_DIV_2 = Math.PI / 2;
var Circle = function(superclass) {
  function Circle4(center, radius) {
    if (center === void 0)
      center = new point_default();
    if (radius === void 0)
      radius = 0;
    superclass.call(this);
    this.setCenter(center);
    this.setRadius(radius);
  }
  if (superclass)
    Circle4.__proto__ = superclass;
  Circle4.prototype = Object.create(superclass && superclass.prototype);
  Circle4.prototype.constructor = Circle4;
  Circle4.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Circle4.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Circle4.prototype.equals = function equals(other) {
    return other && other.center.equals(this.center) && other.radius === this.radius;
  };
  Circle4.prototype.clone = function clone2() {
    return new Circle4(this.center.clone(), this.radius);
  };
  Circle4.prototype.pointAt = function pointAt(angle) {
    return this._pointAt(rad(angle));
  };
  Circle4.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radius, this.radius, matrix);
    var minPoint = point_default.maxPoint();
    var maxPoint = point_default.minPoint();
    for (var i = 0; i < 4; i++) {
      var currentPointX = this$1._pointAt(extremeAngles.x + i * PI_DIV_2).transformCopy(matrix);
      var currentPointY = this$1._pointAt(extremeAngles.y + i * PI_DIV_2).transformCopy(matrix);
      var currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Circle4.prototype._pointAt = function _pointAt(angle) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    return new point_default(
      center.x + radius * Math.cos(angle),
      center.y + radius * Math.sin(angle)
    );
  };
  Circle4.prototype.containsPoint = function containsPoint(point2) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var inCircle = Math.pow(point2.x - center.x, 2) + Math.pow(point2.y - center.y, 2) <= Math.pow(radius, 2);
    return inCircle;
  };
  Circle4.prototype._isOnPath = function _isOnPath(point2, width) {
    var ref2 = this;
    var center = ref2.center;
    var radius = ref2.radius;
    var pointDistance = center.distanceTo(point2);
    return radius - width <= pointDistance && pointDistance <= radius + width;
  };
  return Circle4;
}(with_accessors_default(has_observers_default, ["radius"]));
var circle_default = Circle;

// node_modules/@progress/kendo-drawing/dist/es/mixins/paintable.js
var GRADIENT = "Gradient";
var paintable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.fill = function fill(color, opacity) {
      var options2 = this.options;
      if (defined(color)) {
        if (color && color.nodeType !== GRADIENT) {
          var newFill = {
            color
          };
          if (defined(opacity)) {
            newFill.opacity = opacity;
          }
          options2.set("fill", newFill);
        } else {
          options2.set("fill", color);
        }
        return this;
      }
      return options2.get("fill");
    };
    anonymous.prototype.stroke = function stroke(color, width, opacity) {
      if (defined(color)) {
        this.options.set("stroke.color", color);
        if (defined(width)) {
          this.options.set("stroke.width", width);
        }
        if (defined(opacity)) {
          this.options.set("stroke.opacity", opacity);
        }
        return this;
      }
      return this.options.get("stroke");
    };
    return anonymous;
  }(TBase);
};
var paintable_default = paintable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/measurable.js
var IDENTITY_MATRIX_HASH = matrix_default.IDENTITY.toString();
var measurable = function(TBase) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.bbox = function bbox(transformation) {
      var combinedMatrix = toMatrix(this.currentTransform(transformation));
      var matrixHash = combinedMatrix ? combinedMatrix.toString() : IDENTITY_MATRIX_HASH;
      var bbox2;
      if (this._bboxCache && this._matrixHash === matrixHash) {
        bbox2 = this._bboxCache.clone();
      } else {
        bbox2 = this._bbox(combinedMatrix);
        this._bboxCache = bbox2 ? bbox2.clone() : null;
        this._matrixHash = matrixHash;
      }
      var strokeWidth = this.options.get("stroke.width");
      if (strokeWidth && bbox2) {
        bbox2.expand(strokeWidth / 2);
      }
      return bbox2;
    };
    anonymous.prototype.geometryChange = function geometryChange() {
      delete this._bboxCache;
      this.trigger("geometryChange", {
        element: this
      });
    };
    return anonymous;
  }(TBase);
};
var measurable_default = measurable;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-geometry.js
function geometryAccessor(name3) {
  var fieldName = "_" + name3;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, value);
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function defineGeometryAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = geometryAccessor(names[i]);
  }
}
var withGeometry = function(TBase, names) {
  if (names === void 0)
    names = ["geometry"];
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineGeometryAccessors(result.prototype, names);
  return result;
};
var with_geometry_default = withGeometry;

// node_modules/@progress/kendo-drawing/dist/es/shapes/circle.js
var DEFAULT_STROKE = "#000";
var Circle2 = function(superclass) {
  function Circle4(geometry, options2) {
    if (geometry === void 0)
      geometry = new circle_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE);
    }
  }
  if (superclass)
    Circle4.__proto__ = superclass;
  Circle4.prototype = Object.create(superclass && superclass.prototype);
  Circle4.prototype.constructor = Circle4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Circle";
  };
  Circle4.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Circle4.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Circle4.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Circle4.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Circle4.prototype, prototypeAccessors4);
  return Circle4;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var circle_default2 = Circle2;

// node_modules/@progress/kendo-drawing/dist/es/geometry/constants.js
var PRECISION = 10;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close.js
function close(a, b, tolerance) {
  if (tolerance === void 0)
    tolerance = PRECISION;
  return round2(Math.abs(a - b), tolerance) === 0;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/close-or-less.js
function closeOrLess(a, b, tolerance) {
  return a < b || close(a, b, tolerance);
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersection.js
function lineIntersection(p0, p1, p2, p3) {
  var s1x = p1.x - p0.x;
  var s2x = p3.x - p2.x;
  var s1y = p1.y - p0.y;
  var s2y = p3.y - p2.y;
  var nx = p0.x - p2.x;
  var ny = p0.y - p2.y;
  var d = s1x * s2y - s2x * s1y;
  var s = (s1x * ny - s1y * nx) / d;
  var t = (s2x * ny - s2y * nx) / d;
  if (s >= 0 && s <= 1 && t >= 0 && t <= 1) {
    return new point_default(p0.x + t * s1x, p0.y + t * s1y);
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/arc.js
var MAX_INTERVAL = 45;
var pow2 = Math.pow;
var accessors = ["radiusX", "radiusY", "startAngle", "endAngle", "anticlockwise"];
var Arc = function(superclass) {
  function Arc4(center, options2) {
    if (center === void 0)
      center = new point_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this);
    this.setCenter(center);
    this.radiusX = options2.radiusX;
    this.radiusY = options2.radiusY || options2.radiusX;
    this.startAngle = options2.startAngle;
    this.endAngle = options2.endAngle;
    this.anticlockwise = options2.anticlockwise || false;
    this.xRotation = options2.xRotation;
  }
  if (superclass)
    Arc4.__proto__ = superclass;
  Arc4.prototype = Object.create(superclass && superclass.prototype);
  Arc4.prototype.constructor = Arc4;
  Arc4.prototype.clone = function clone2() {
    return new Arc4(this.center, {
      radiusX: this.radiusX,
      radiusY: this.radiusY,
      startAngle: this.startAngle,
      endAngle: this.endAngle,
      anticlockwise: this.anticlockwise
    });
  };
  Arc4.prototype.setCenter = function setCenter(value) {
    this._observerField("center", point_default.create(value));
    this.geometryChange();
    return this;
  };
  Arc4.prototype.getCenter = function getCenter() {
    return this.center;
  };
  Arc4.prototype.pointAt = function pointAt(angle) {
    var center = this.center;
    var radian = rad(angle);
    return new point_default(
      center.x + this.radiusX * Math.cos(radian),
      center.y + this.radiusY * Math.sin(radian)
    );
  };
  Arc4.prototype.curvePoints = function curvePoints() {
    var this$1 = this;
    var startAngle = this.startAngle;
    var dir = this.anticlockwise ? -1 : 1;
    var curvePoints2 = [this.pointAt(startAngle)];
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var subIntervalsCount = Math.ceil(intervalAngle / MAX_INTERVAL);
    var subIntervalAngle = intervalAngle / subIntervalsCount;
    var currentAngle = startAngle;
    var transformation;
    if (this.xRotation) {
      transformation = transform().rotate(this.xRotation, this.center);
    }
    for (var i = 1; i <= subIntervalsCount; i++) {
      var nextAngle = currentAngle + dir * subIntervalAngle;
      var points3 = this$1._intervalCurvePoints(currentAngle, nextAngle, transformation);
      curvePoints2.push(points3.cp1, points3.cp2, points3.p2);
      currentAngle = nextAngle;
    }
    return curvePoints2;
  };
  Arc4.prototype.bbox = function bbox(matrix) {
    var this$1 = this;
    var interval = this._arcInterval();
    var startAngle = interval.startAngle;
    var endAngle = interval.endAngle;
    var extremeAngles = ellipseExtremeAngles(this.center, this.radiusX, this.radiusY, matrix);
    var extremeX = deg(extremeAngles.x);
    var extremeY = deg(extremeAngles.y);
    var endPoint = this.pointAt(endAngle).transformCopy(matrix);
    var currentAngleX = bboxStartAngle(extremeX, startAngle);
    var currentAngleY = bboxStartAngle(extremeY, startAngle);
    var currentPoint = this.pointAt(startAngle).transformCopy(matrix);
    var minPoint = point_default.min(currentPoint, endPoint);
    var maxPoint = point_default.max(currentPoint, endPoint);
    while (currentAngleX < endAngle || currentAngleY < endAngle) {
      var currentPointX = void 0;
      if (currentAngleX < endAngle) {
        currentPointX = this$1.pointAt(currentAngleX).transformCopy(matrix);
        currentAngleX += 90;
      }
      var currentPointY = void 0;
      if (currentAngleY < endAngle) {
        currentPointY = this$1.pointAt(currentAngleY).transformCopy(matrix);
        currentAngleY += 90;
      }
      currentPoint = new point_default(currentPointX.x, currentPointY.y);
      minPoint = point_default.min(minPoint, currentPoint);
      maxPoint = point_default.max(maxPoint, currentPoint);
    }
    return rect_default.fromPoints(minPoint, maxPoint);
  };
  Arc4.prototype._arcInterval = function _arcInterval() {
    var ref2 = this;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var anticlockwise = ref2.anticlockwise;
    if (anticlockwise) {
      var oldStart = startAngle;
      startAngle = endAngle;
      endAngle = oldStart;
    }
    if (startAngle > endAngle || anticlockwise && startAngle === endAngle) {
      endAngle += 360;
    }
    return {
      startAngle,
      endAngle
    };
  };
  Arc4.prototype._intervalCurvePoints = function _intervalCurvePoints(startAngle, endAngle, transformation) {
    var p1 = this.pointAt(startAngle);
    var p2 = this.pointAt(endAngle);
    var p1Derivative = this._derivativeAt(startAngle);
    var p2Derivative = this._derivativeAt(endAngle);
    var t = (rad(endAngle) - rad(startAngle)) / 3;
    var cp1 = new point_default(p1.x + t * p1Derivative.x, p1.y + t * p1Derivative.y);
    var cp2 = new point_default(p2.x - t * p2Derivative.x, p2.y - t * p2Derivative.y);
    if (transformation) {
      p1.transform(transformation);
      p2.transform(transformation);
      cp1.transform(transformation);
      cp2.transform(transformation);
    }
    return {
      p1,
      cp1,
      cp2,
      p2
    };
  };
  Arc4.prototype._derivativeAt = function _derivativeAt(angle) {
    var radian = rad(angle);
    return new point_default(-this.radiusX * Math.sin(radian), this.radiusY * Math.cos(radian));
  };
  Arc4.prototype.containsPoint = function containsPoint(point2) {
    var interval = this._arcInterval();
    var intervalAngle = interval.endAngle - interval.startAngle;
    var ref2 = this;
    var center = ref2.center;
    var radiusX = ref2.radiusX;
    var radiusY = ref2.radiusY;
    var distance = center.distanceTo(point2);
    var angleRad = Math.atan2(point2.y - center.y, point2.x - center.x);
    var pointRadius = radiusX * radiusY / Math.sqrt(pow2(radiusX, 2) * pow2(Math.sin(angleRad), 2) + pow2(radiusY, 2) * pow2(Math.cos(angleRad), 2));
    var startPoint = this.pointAt(this.startAngle).round(PRECISION);
    var endPoint = this.pointAt(this.endAngle).round(PRECISION);
    var intersection2 = lineIntersection(center, point2.round(PRECISION), startPoint, endPoint);
    var containsPoint2;
    if (intervalAngle < 180) {
      containsPoint2 = intersection2 && closeOrLess(center.distanceTo(intersection2), distance) && closeOrLess(distance, pointRadius);
    } else {
      var angle = calculateAngle(center.x, center.y, radiusX, radiusY, point2.x, point2.y);
      if (angle !== 360) {
        angle = (360 + angle) % 360;
      }
      var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
      containsPoint2 = inAngleRange && closeOrLess(distance, pointRadius) || !inAngleRange && (!intersection2 || intersection2.equals(point2));
    }
    return containsPoint2;
  };
  Arc4.prototype._isOnPath = function _isOnPath(point2, width) {
    var interval = this._arcInterval();
    var center = this.center;
    var angle = calculateAngle(center.x, center.y, this.radiusX, this.radiusY, point2.x, point2.y);
    if (angle !== 360) {
      angle = (360 + angle) % 360;
    }
    var inAngleRange = interval.startAngle <= angle && angle <= interval.endAngle;
    return inAngleRange && this.pointAt(angle).distanceTo(point2) <= width;
  };
  Arc4.fromPoints = function fromPoints(start, end, rx, ry, largeArc, swipe, rotation) {
    var arcParameters = normalizeArcParameters({
      x1: start.x,
      y1: start.y,
      x2: end.x,
      y2: end.y,
      rx,
      ry,
      largeArc,
      swipe,
      rotation
    });
    return new Arc4(arcParameters.center, {
      startAngle: arcParameters.startAngle,
      endAngle: arcParameters.endAngle,
      radiusX: arcParameters.radiusX,
      radiusY: arcParameters.radiusY,
      xRotation: arcParameters.xRotation,
      anticlockwise: swipe === 0
    });
  };
  return Arc4;
}(with_accessors_default(has_observers_default, accessors));
function calculateAngle(cx, cy, rx, ry, x, y) {
  var cos2 = round2((x - cx) / rx, 3);
  var sin3 = round2((y - cy) / ry, 3);
  return round2(deg(Math.atan2(sin3, cos2)));
}
function normalizeArcParameters(parameters) {
  var x1 = parameters.x1;
  var y1 = parameters.y1;
  var x2 = parameters.x2;
  var y2 = parameters.y2;
  var rx = parameters.rx;
  var ry = parameters.ry;
  var largeArc = parameters.largeArc;
  var swipe = parameters.swipe;
  var rotation = parameters.rotation;
  if (rotation === void 0)
    rotation = 0;
  var radians = rad(rotation);
  var cosine = Math.cos(radians);
  var sine = Math.sin(radians);
  var xT = cosine * (x1 - x2) / 2 + sine * (y1 - y2) / 2;
  var yT = -sine * (x1 - x2) / 2 + cosine * (y1 - y2) / 2;
  var sign = largeArc !== swipe ? 1 : -1;
  var xt2 = Math.pow(xT, 2);
  var yt2 = Math.pow(yT, 2);
  var rx2 = Math.pow(rx, 2);
  var ry2 = Math.pow(ry, 2);
  var delta = xt2 / rx2 + yt2 / ry2;
  if (delta > 1) {
    delta = Math.sqrt(xt2 / rx2 + yt2 / ry2);
    rx = delta * rx;
    rx2 = Math.pow(rx, 2);
    ry = delta * ry;
    ry2 = Math.pow(ry, 2);
  }
  var constT = sign * Math.sqrt((rx2 * ry2 - rx2 * yt2 - ry2 * xt2) / (rx2 * yt2 + ry2 * xt2));
  if (isNaN(constT)) {
    constT = 0;
  }
  var cxT = constT * (rx * yT) / ry;
  var cyT = -constT * (ry * xT) / rx;
  var cx = cosine * cxT - sine * cyT + (x1 + x2) / 2;
  var cy = sine * cxT + cosine * cyT + (y1 + y2) / 2;
  var uX = (xT - cxT) / rx;
  var uY = (yT - cyT) / ry;
  var vX = -(xT + cxT) / rx;
  var vY = -(yT + cyT) / ry;
  var startAngle = (uY >= 0 ? 1 : -1) * deg(Math.acos(uX / Math.sqrt(uX * uX + uY * uY)));
  var angleCosine = round2((uX * vX + uY * vY) / (Math.sqrt(uX * uX + uY * uY) * Math.sqrt(vX * vX + vY * vY)), 10);
  var angle = (uX * vY - uY * vX >= 0 ? 1 : -1) * deg(Math.acos(angleCosine));
  if (!swipe && angle > 0) {
    angle -= 360;
  }
  if (swipe && angle < 0) {
    angle += 360;
  }
  var endAngle = startAngle + angle;
  var signEndAngle = endAngle >= 0 ? 1 : -1;
  endAngle = Math.abs(endAngle) % 360 * signEndAngle;
  return {
    center: new point_default(cx, cy),
    startAngle,
    endAngle,
    radiusX: rx,
    radiusY: ry,
    xRotation: rotation
  };
}
function bboxStartAngle(angle, start) {
  var startAngle = angle;
  while (startAngle < start) {
    startAngle += 90;
  }
  return startAngle;
}
var arc_default = Arc;

// node_modules/@progress/kendo-drawing/dist/es/shapes/elements-array.js
var push = [].push;
var pop = [].pop;
var splice = [].splice;
var shift = [].shift;
var slice = [].slice;
var unshift = [].unshift;
var ElementsArray = function(HasObservers2) {
  function ElementsArray2(array) {
    if (array === void 0)
      array = [];
    HasObservers2.call(this);
    this.length = 0;
    this._splice(0, array.length, array);
  }
  if (HasObservers2)
    ElementsArray2.__proto__ = HasObservers2;
  ElementsArray2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  ElementsArray2.prototype.constructor = ElementsArray2;
  ElementsArray2.prototype.elements = function elements(value) {
    if (value) {
      this._splice(0, this.length, value);
      this._change();
      return this;
    }
    return this.slice(0);
  };
  ElementsArray2.prototype.push = function push$1() {
    var elements = arguments;
    var result = push.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.slice = function slice$1() {
    return slice.call(this);
  };
  ElementsArray2.prototype.pop = function pop$1() {
    var length = this.length;
    var result = pop.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.splice = function splice2(index, howMany) {
    var elements = slice.call(arguments, 2);
    var result = this._splice(index, howMany, elements);
    this._change();
    return result;
  };
  ElementsArray2.prototype.shift = function shift$1() {
    var length = this.length;
    var result = shift.apply(this);
    if (length) {
      this._remove([result]);
    }
    return result;
  };
  ElementsArray2.prototype.unshift = function unshift$1() {
    var elements = arguments;
    var result = unshift.apply(this, elements);
    this._add(elements);
    return result;
  };
  ElementsArray2.prototype.indexOf = function indexOf2(element) {
    var this$1 = this;
    var length = this.length;
    for (var idx = 0; idx < length; idx++) {
      if (this$1[idx] === element) {
        return idx;
      }
    }
    return -1;
  };
  ElementsArray2.prototype._splice = function _splice(index, howMany, elements) {
    var result = splice.apply(this, [index, howMany].concat(elements));
    this._clearObserver(result);
    this._setObserver(elements);
    return result;
  };
  ElementsArray2.prototype._add = function _add(elements) {
    this._setObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._remove = function _remove(elements) {
    this._clearObserver(elements);
    this._change();
  };
  ElementsArray2.prototype._setObserver = function _setObserver(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].addObserver(this$1);
    }
  };
  ElementsArray2.prototype._clearObserver = function _clearObserver(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      elements[idx].removeObserver(this$1);
    }
  };
  ElementsArray2.prototype._change = function _change() {
  };
  return ElementsArray2;
}(has_observers_default);
var elements_array_default = ElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/shapes/geometry-elements-array.js
var GeometryElementsArray = function(ElementsArray2) {
  function GeometryElementsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    GeometryElementsArray2.__proto__ = ElementsArray2;
  GeometryElementsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  GeometryElementsArray2.prototype.constructor = GeometryElementsArray2;
  GeometryElementsArray2.prototype._change = function _change() {
    this.geometryChange();
  };
  return GeometryElementsArray2;
}(elements_array_default);
var geometry_elements_array_default = GeometryElementsArray;

// node_modules/@progress/kendo-drawing/dist/es/geometry.js
var geometry_exports = {};
__export(geometry_exports, {
  Arc: () => arc_default,
  Circle: () => circle_default,
  Matrix: () => matrix_default,
  Point: () => point_default,
  Rect: () => rect_default,
  Segment: () => segment_default,
  Size: () => size_default,
  Transformation: () => transformation_default,
  toMatrix: () => toMatrix,
  transform: () => transform
});

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/is-out-of-end-point.js
function isOutOfEndPoint(endPoint, controlPoint, point2) {
  var angle = deg(Math.atan2(controlPoint.y - endPoint.y, controlPoint.x - endPoint.x));
  var rotatedPoint = point2.transformCopy(transform().rotate(-angle, endPoint));
  return rotatedPoint.x < endPoint.x;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/calculate-curve-at.js
function calculateCurveAt(t, field, points3) {
  var t1 = 1 - t;
  return Math.pow(t1, 3) * points3[0][field] + 3 * Math.pow(t1, 2) * t * points3[1][field] + 3 * Math.pow(t, 2) * t1 * points3[2][field] + Math.pow(t, 3) * points3[3][field];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/to-cubic-polynomial.js
function toCubicPolynomial(points3, field) {
  return [
    -points3[0][field] + 3 * points3[1][field] - 3 * points3[2][field] + points3[3][field],
    3 * (points3[0][field] - 2 * points3[1][field] + points3[2][field]),
    3 * (-points3[0][field] + points3[1][field]),
    points3[0][field]
  ];
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/complex-number.js
var ComplexNumber = function(Class3) {
  function ComplexNumber2(real, img) {
    if (real === void 0)
      real = 0;
    if (img === void 0)
      img = 0;
    Class3.call(this);
    this.real = real;
    this.img = img;
  }
  if (Class3)
    ComplexNumber2.__proto__ = Class3;
  ComplexNumber2.prototype = Object.create(Class3 && Class3.prototype);
  ComplexNumber2.prototype.constructor = ComplexNumber2;
  ComplexNumber2.prototype.add = function add3(cNumber) {
    return new ComplexNumber2(round2(this.real + cNumber.real, PRECISION), round2(this.img + cNumber.img, PRECISION));
  };
  ComplexNumber2.prototype.addConstant = function addConstant(value) {
    return new ComplexNumber2(this.real + value, this.img);
  };
  ComplexNumber2.prototype.negate = function negate() {
    return new ComplexNumber2(-this.real, -this.img);
  };
  ComplexNumber2.prototype.multiply = function multiply(cNumber) {
    return new ComplexNumber2(
      this.real * cNumber.real - this.img * cNumber.img,
      this.real * cNumber.img + this.img * cNumber.real
    );
  };
  ComplexNumber2.prototype.multiplyConstant = function multiplyConstant(value) {
    return new ComplexNumber2(this.real * value, this.img * value);
  };
  ComplexNumber2.prototype.nthRoot = function nthRoot(n) {
    var rad3 = Math.atan2(this.img, this.real);
    var r = Math.sqrt(Math.pow(this.img, 2) + Math.pow(this.real, 2));
    var nthR = Math.pow(r, 1 / n);
    return new ComplexNumber2(nthR * Math.cos(rad3 / n), nthR * Math.sin(rad3 / n));
  };
  ComplexNumber2.prototype.equals = function equals(cNumber) {
    return this.real === cNumber.real && this.img === cNumber.img;
  };
  ComplexNumber2.prototype.isReal = function isReal() {
    return this.img === 0;
  };
  return ComplexNumber2;
}(class_default);
var complex_number_default = ComplexNumber;

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/solve-cubic-equation.js
function numberSign(x) {
  return x < 0 ? -1 : 1;
}
function solveQuadraticEquation(a, b, c) {
  var squareRoot = Math.sqrt(Math.pow(b, 2) - 4 * a * c);
  return [
    (-b + squareRoot) / (2 * a),
    (-b - squareRoot) / (2 * a)
  ];
}
function solveCubicEquation(a, b, c, d) {
  if (a === 0) {
    return solveQuadraticEquation(b, c, d);
  }
  var p2 = (3 * a * c - Math.pow(b, 2)) / (3 * Math.pow(a, 2));
  var q = (2 * Math.pow(b, 3) - 9 * a * b * c + 27 * Math.pow(a, 2) * d) / (27 * Math.pow(a, 3));
  var Q = Math.pow(p2 / 3, 3) + Math.pow(q / 2, 2);
  var i = new complex_number_default(0, 1);
  var b3a = -b / (3 * a);
  var x1, x2, y1, y2, y3, z1, z2;
  if (Q < 0) {
    x1 = new complex_number_default(-q / 2, Math.sqrt(-Q)).nthRoot(3);
    x2 = new complex_number_default(-q / 2, -Math.sqrt(-Q)).nthRoot(3);
  } else {
    x1 = -q / 2 + Math.sqrt(Q);
    x1 = new complex_number_default(numberSign(x1) * Math.pow(Math.abs(x1), 1 / 3));
    x2 = -q / 2 - Math.sqrt(Q);
    x2 = new complex_number_default(numberSign(x2) * Math.pow(Math.abs(x2), 1 / 3));
  }
  y1 = x1.add(x2);
  z1 = x1.add(x2).multiplyConstant(-1 / 2);
  z2 = x1.add(x2.negate()).multiplyConstant(Math.sqrt(3) / 2);
  y2 = z1.add(i.multiply(z2));
  y3 = z1.add(i.negate().multiply(z2));
  var result = [];
  if (y1.isReal()) {
    result.push(round2(y1.real + b3a, PRECISION));
  }
  if (y2.isReal()) {
    result.push(round2(y2.real + b3a, PRECISION));
  }
  if (y3.isReal()) {
    result.push(round2(y3.real + b3a, PRECISION));
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/has-roots-in-range.js
function hasRootsInRange(points3, point2, field, rootField, range) {
  var polynomial = toCubicPolynomial(points3, rootField);
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2[rootField]);
  var intersection2;
  for (var idx = 0; idx < roots.length; idx++) {
    if (0 <= roots[idx] && roots[idx] <= 1) {
      intersection2 = calculateCurveAt(roots[idx], field, points3);
      if (Math.abs(intersection2 - point2[field]) <= range) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/curve-intersections-count.js
function curveIntersectionsCount(points3, point2, bbox) {
  var polynomial = toCubicPolynomial(points3, "x");
  var roots = solveCubicEquation(polynomial[0], polynomial[1], polynomial[2], polynomial[3] - point2.x);
  var rayIntersection, intersectsRay;
  var count = 0;
  for (var i = 0; i < roots.length; i++) {
    rayIntersection = calculateCurveAt(roots[i], "y", points3);
    intersectsRay = close(rayIntersection, point2.y) || rayIntersection > point2.y;
    if (intersectsRay && ((roots[i] === 0 || roots[i] === 1) && bbox.bottomRight().x > point2.x || 0 < roots[i] && roots[i] < 1)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-drawing/dist/es/geometry/math/line-intersections-count.js
function lineIntersectionsCount(a, b, point2) {
  var intersects;
  if (a.x !== b.x) {
    var minX = Math.min(a.x, b.x);
    var maxX = Math.max(a.x, b.x);
    var minY = Math.min(a.y, b.y);
    var maxY = Math.max(a.y, b.y);
    var inRange = minX <= point2.x && point2.x < maxX;
    if (minY === maxY) {
      intersects = point2.y <= minY && inRange;
    } else {
      intersects = inRange && (maxY - minY) * ((a.x - b.x) * (a.y - b.y) > 0 ? point2.x - minX : maxX - point2.x) / (maxX - minX) + minY - point2.y >= 0;
    }
  }
  return intersects ? 1 : 0;
}

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-points.js
function pointAccessor(name3) {
  var fieldName = "_" + name3;
  return function(value) {
    if (defined(value)) {
      this._observerField(fieldName, point_default.create(value));
      this.geometryChange();
      return this;
    }
    return this[fieldName];
  };
}
function definePointAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = pointAccessor(names[i]);
  }
}
var withPoints = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  definePointAccessors(result.prototype, names);
  return result;
};
var with_points_default = withPoints;

// node_modules/@progress/kendo-drawing/dist/es/geometry/segment.js
var points = ["anchor", "controlIn", "controlOut"];
var Segment = function(superclass) {
  function Segment2(anchor, controlIn, controlOut) {
    superclass.call(this);
    this.anchor(anchor || new point_default());
    this.controlIn(controlIn);
    this.controlOut(controlOut);
  }
  if (superclass)
    Segment2.__proto__ = superclass;
  Segment2.prototype = Object.create(superclass && superclass.prototype);
  Segment2.prototype.constructor = Segment2;
  Segment2.prototype.bboxTo = function bboxTo(toSegment, matrix) {
    var segmentAnchor = this.anchor().transformCopy(matrix);
    var toSegmentAnchor = toSegment.anchor().transformCopy(matrix);
    var rect;
    if (this.controlOut() && toSegment.controlIn()) {
      rect = this._curveBoundingBox(
        segmentAnchor,
        this.controlOut().transformCopy(matrix),
        toSegment.controlIn().transformCopy(matrix),
        toSegmentAnchor
      );
    } else {
      rect = this._lineBoundingBox(segmentAnchor, toSegmentAnchor);
    }
    return rect;
  };
  Segment2.prototype._lineBoundingBox = function _lineBoundingBox(p1, p2) {
    return rect_default.fromPoints(p1, p2);
  };
  Segment2.prototype._curveBoundingBox = function _curveBoundingBox(p1, cp1, cp2, p2) {
    var points3 = [p1, cp1, cp2, p2];
    var extremesX = this._curveExtremesFor(points3, "x");
    var extremesY = this._curveExtremesFor(points3, "y");
    var xLimits = arrayLimits([extremesX.min, extremesX.max, p1.x, p2.x]);
    var yLimits = arrayLimits([extremesY.min, extremesY.max, p1.y, p2.y]);
    return rect_default.fromPoints(new point_default(xLimits.min, yLimits.min), new point_default(xLimits.max, yLimits.max));
  };
  Segment2.prototype._curveExtremesFor = function _curveExtremesFor(points3, field) {
    var extremes = this._curveExtremes(
      points3[0][field],
      points3[1][field],
      points3[2][field],
      points3[3][field]
    );
    return {
      min: calculateCurveAt(extremes.min, field, points3),
      max: calculateCurveAt(extremes.max, field, points3)
    };
  };
  Segment2.prototype._curveExtremes = function _curveExtremes(x1, x2, x3, x4) {
    var a = x1 - 3 * x2 + 3 * x3 - x4;
    var b = -2 * (x1 - 2 * x2 + x3);
    var c = x1 - x2;
    var sqrt = Math.sqrt(b * b - 4 * a * c);
    var t1 = 0;
    var t2 = 1;
    if (a === 0) {
      if (b !== 0) {
        t1 = t2 = -c / b;
      }
    } else if (!isNaN(sqrt)) {
      t1 = (-b + sqrt) / (2 * a);
      t2 = (-b - sqrt) / (2 * a);
    }
    var min3 = Math.max(Math.min(t1, t2), 0);
    if (min3 < 0 || min3 > 1) {
      min3 = 0;
    }
    var max2 = Math.min(Math.max(t1, t2), 1);
    if (max2 > 1 || max2 < 0) {
      max2 = 1;
    }
    return {
      min: min3,
      max: max2
    };
  };
  Segment2.prototype._intersectionsTo = function _intersectionsTo(segment, point2) {
    var intersectionsCount;
    if (this.controlOut() && segment.controlIn()) {
      intersectionsCount = curveIntersectionsCount([this.anchor(), this.controlOut(), segment.controlIn(), segment.anchor()], point2, this.bboxTo(segment));
    } else {
      intersectionsCount = lineIntersectionsCount(this.anchor(), segment.anchor(), point2);
    }
    return intersectionsCount;
  };
  Segment2.prototype._isOnCurveTo = function _isOnCurveTo(segment, point2, width, endSegment) {
    var bbox = this.bboxTo(segment).expand(width, width);
    if (bbox.containsPoint(point2)) {
      var p1 = this.anchor();
      var p2 = this.controlOut();
      var p3 = segment.controlIn();
      var p4 = segment.anchor();
      if (endSegment === "start" && p1.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p1, p2, point2);
      } else if (endSegment === "end" && p4.distanceTo(point2) <= width) {
        return !isOutOfEndPoint(p4, p3, point2);
      }
      var points3 = [p1, p2, p3, p4];
      if (hasRootsInRange(points3, point2, "x", "y", width) || hasRootsInRange(points3, point2, "y", "x", width)) {
        return true;
      }
      var rotation = transform().rotate(45, point2);
      var rotatedPoints = [p1.transformCopy(rotation), p2.transformCopy(rotation), p3.transformCopy(rotation), p4.transformCopy(rotation)];
      return hasRootsInRange(rotatedPoints, point2, "x", "y", width) || hasRootsInRange(rotatedPoints, point2, "y", "x", width);
    }
  };
  Segment2.prototype._isOnLineTo = function _isOnLineTo(segment, point2, width) {
    var p1 = this.anchor();
    var p2 = segment.anchor();
    var angle = deg(Math.atan2(p2.y - p1.y, p2.x - p1.x));
    var rect = new rect_default([p1.x, p1.y - width / 2], [p1.distanceTo(p2), width]);
    return rect.containsPoint(point2.transformCopy(transform().rotate(-angle, p1)));
  };
  Segment2.prototype._isOnPathTo = function _isOnPathTo(segment, point2, width, endSegment) {
    var isOnPath;
    if (this.controlOut() && segment.controlIn()) {
      isOnPath = this._isOnCurveTo(segment, point2, width / 2, endSegment);
    } else {
      isOnPath = this._isOnLineTo(segment, point2, width);
    }
    return isOnPath;
  };
  return Segment2;
}(with_points_default(has_observers_default, points));
function arrayLimits(arr) {
  var length = arr.length;
  var min3 = MAX_NUM;
  var max2 = MIN_NUM;
  for (var i = 0; i < length; i++) {
    max2 = Math.max(max2, arr[i]);
    min3 = Math.min(min3, arr[i]);
  }
  return {
    min: min3,
    max: max2
  };
}
var segment_default = Segment;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/points-to-curve.js
var WEIGHT = 0.333;
var EXTREMUM_ALLOWED_DEVIATION = 0.01;
var X2 = "x";
var Y2 = "y";
function pointsToCurve(pointsIn, closed) {
  var points3 = pointsIn.slice(0);
  var segments = [];
  var length = points3.length;
  if (length > 2) {
    removeDuplicates(0, points3);
    length = points3.length;
  }
  if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
    return segments;
  }
  var p0 = points3[0];
  var p1 = points3[1];
  var p2 = points3[2];
  segments.push(new segment_default(p0));
  while (p0.equals(points3[length - 1])) {
    closed = true;
    points3.pop();
    length--;
  }
  if (length === 2) {
    var tangent = getTangent(p0, p1, X2, Y2);
    last(segments).controlOut(
      firstControlPoint(tangent, p0, p1, X2, Y2)
    );
    segments.push(new segment_default(
      p1,
      secondControlPoint(tangent, p0, p1, X2, Y2)
    ));
    return segments;
  }
  var initialControlPoint, lastControlPoint;
  if (closed) {
    p0 = points3[length - 1];
    p1 = points3[0];
    p2 = points3[1];
    var controlPoints = getControlPoints(p0, p1, p2);
    initialControlPoint = controlPoints[1];
    lastControlPoint = controlPoints[0];
  } else {
    var tangent$1 = getTangent(p0, p1, X2, Y2);
    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X2, Y2);
  }
  var cp0 = initialControlPoint;
  for (var idx = 0; idx <= length - 3; idx++) {
    removeDuplicates(idx, points3);
    length = points3.length;
    if (idx + 3 <= length) {
      p0 = points3[idx];
      p1 = points3[idx + 1];
      p2 = points3[idx + 2];
      var controlPoints$1 = getControlPoints(p0, p1, p2);
      last(segments).controlOut(cp0);
      cp0 = controlPoints$1[1];
      var cp1 = controlPoints$1[0];
      segments.push(new segment_default(p1, cp1));
    }
  }
  if (closed) {
    p0 = points3[length - 2];
    p1 = points3[length - 1];
    p2 = points3[0];
    var controlPoints$2 = getControlPoints(p0, p1, p2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p1,
      controlPoints$2[0]
    ));
    last(segments).controlOut(controlPoints$2[1]);
    segments.push(new segment_default(
      p2,
      lastControlPoint
    ));
  } else {
    var tangent$2 = getTangent(p1, p2, X2, Y2);
    last(segments).controlOut(cp0);
    segments.push(new segment_default(
      p2,
      secondControlPoint(tangent$2, p1, p2, X2, Y2)
    ));
  }
  return segments;
}
function removeDuplicates(idx, points3) {
  while (points3[idx + 1] && (points3[idx].equals(points3[idx + 1]) || points3[idx + 1].equals(points3[idx + 2]))) {
    points3.splice(idx + 1, 1);
  }
}
function invertAxis(p0, p1, p2) {
  var invertAxis2 = false;
  if (p0.x === p1.x) {
    invertAxis2 = true;
  } else if (p1.x === p2.x) {
    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
      invertAxis2 = true;
    }
  } else {
    var fn = lineFunction(p0, p1);
    var y2 = calculateFunction(fn, p2.x);
    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
      invertAxis2 = true;
    }
  }
  return invertAxis2;
}
function isLine(p0, p1, p2) {
  var fn = lineFunction(p0, p1);
  var y2 = calculateFunction(fn, p2.x);
  return p0.x === p1.x && p1.x === p2.x || round2(y2, 1) === round2(p2.y, 1);
}
function lineFunction(p1, p2) {
  var a = (p2.y - p1.y) / (p2.x - p1.x);
  var b = p1.y - a * p1.x;
  return [b, a];
}
function getControlPoints(p0, p1, p2) {
  var xField = X2;
  var yField = Y2;
  var restrict = false;
  var switchOrientation = false;
  var tangent;
  if (isLine(p0, p1, p2)) {
    tangent = getTangent(p0, p1, X2, Y2);
  } else {
    var monotonic = {
      x: isMonotonicByField(p0, p1, p2, X2),
      y: isMonotonicByField(p0, p1, p2, Y2)
    };
    if (monotonic.x && monotonic.y) {
      tangent = getTangent(p0, p2, X2, Y2);
      restrict = true;
    } else {
      if (invertAxis(p0, p1, p2)) {
        xField = Y2;
        yField = X2;
      }
      if (monotonic[xField]) {
        tangent = 0;
      } else {
        var sign;
        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
          sign = numberSign2((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
        } else {
          sign = -numberSign2((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
        }
        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;
        switchOrientation = true;
      }
    }
  }
  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);
  if (switchOrientation) {
    var oldXField = xField;
    xField = yField;
    yField = oldXField;
  }
  var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);
  if (restrict) {
    restrictControlPoint(p0, p1, secondCP, tangent);
    restrictControlPoint(p1, p2, firstCP, tangent);
  }
  return [secondCP, firstCP];
}
function restrictControlPoint(p1, p2, cp, tangent) {
  if (p1.y < p2.y) {
    if (p2.y < cp.y) {
      cp.x = p1.x + (p2.y - p1.y) / tangent;
      cp.y = p2.y;
    } else if (cp.y < p1.y) {
      cp.x = p2.x - (p2.y - p1.y) / tangent;
      cp.y = p1.y;
    }
  } else {
    if (cp.y < p2.y) {
      cp.x = p1.x - (p1.y - p2.y) / tangent;
      cp.y = p2.y;
    } else if (p1.y < cp.y) {
      cp.x = p2.x + (p1.y - p2.y) / tangent;
      cp.y = p1.y;
    }
  }
}
function getTangent(p0, p1, xField, yField) {
  var x = p1[xField] - p0[xField];
  var y = p1[yField] - p0[yField];
  var tangent;
  if (x === 0) {
    tangent = 0;
  } else {
    tangent = y / x;
  }
  return tangent;
}
function isMonotonicByField(p0, p1, p2, field) {
  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
}
function firstControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
}
function secondControlPoint(tangent, p0, p3, xField, yField) {
  var t1 = p0[xField];
  var t2 = p3[xField];
  var distance = (t2 - t1) * WEIGHT;
  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
}
function point(xValue, yValue, xField, yField) {
  var controlPoint = new point_default();
  controlPoint[xField] = xValue;
  controlPoint[yField] = yValue;
  return controlPoint;
}
function calculateFunction(fn, x) {
  var length = fn.length;
  var result = 0;
  for (var i = 0; i < length; i++) {
    result += Math.pow(x, i) * fn[i];
  }
  return result;
}
function numberSign2(value) {
  return value <= 0 ? -1 : 1;
}

// node_modules/@progress/kendo-drawing/dist/es/parsing/shape-map.js
var ShapeMap = {
  l: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 2) {
      var point2 = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        point2.translateWith(position);
      }
      path.lineTo(point2.x, point2.y);
      position.x = point2.x;
      position.y = point2.y;
    }
  },
  c: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 6) {
      var controlOut = new point_default(parameters[i], parameters[i + 1]);
      var controlIn = new point_default(parameters[i + 2], parameters[i + 3]);
      var point2 = new point_default(parameters[i + 4], parameters[i + 5]);
      if (options2.isRelative) {
        controlIn.translateWith(position);
        controlOut.translateWith(position);
        point2.translateWith(position);
      }
      path.curveTo(controlOut, controlIn, point2);
      position.x = point2.x;
      position.y = point2.y;
    }
  },
  v: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.x;
    toLineParamaters(options2.parameters, true, value);
    this.l(path, options2);
  },
  h: function(path, options2) {
    var value = options2.isRelative ? 0 : options2.position.y;
    toLineParamaters(options2.parameters, false, value);
    this.l(path, options2);
  },
  a: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 7) {
      var radiusX = parameters[i];
      var radiusY = parameters[i + 1];
      var rotation = parameters[i + 2];
      var largeArc = parameters[i + 3];
      var swipe = parameters[i + 4];
      var endPoint = new point_default(parameters[i + 5], parameters[i + 6]);
      if (options2.isRelative) {
        endPoint.translateWith(position);
      }
      if (position.x !== endPoint.x || position.y !== endPoint.y) {
        path.arcTo(endPoint, radiusX, radiusY, largeArc, swipe, rotation);
        position.x = endPoint.x;
        position.y = endPoint.y;
      }
    }
  },
  s: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    var previousCommand = options2.previousCommand;
    var lastControlIn;
    if (previousCommand === "s" || previousCommand === "c") {
      lastControlIn = last(last(path.paths).segments).controlIn();
    }
    for (var i = 0; i < parameters.length; i += 4) {
      var controlIn = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      var controlOut = void 0;
      if (options2.isRelative) {
        controlIn.translateWith(position);
        endPoint.translateWith(position);
      }
      if (lastControlIn) {
        controlOut = reflectionPoint(lastControlIn, position);
      } else {
        controlOut = position.clone();
      }
      lastControlIn = controlIn;
      path.curveTo(controlOut, controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  },
  q: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    for (var i = 0; i < parameters.length; i += 4) {
      var controlPoint = new point_default(parameters[i], parameters[i + 1]);
      var endPoint = new point_default(parameters[i + 2], parameters[i + 3]);
      if (options2.isRelative) {
        controlPoint.translateWith(position);
        endPoint.translateWith(position);
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  },
  t: function(path, options2) {
    var parameters = options2.parameters;
    var position = options2.position;
    var previousCommand = options2.previousCommand;
    var controlPoint;
    if (previousCommand === "q" || previousCommand === "t") {
      var lastSegment = last(last(path.paths).segments);
      controlPoint = lastSegment.controlIn().clone().translateWith(position.scaleCopy(-1 / 3)).scale(3 / 2);
    }
    for (var i = 0; i < parameters.length; i += 2) {
      var endPoint = new point_default(parameters[i], parameters[i + 1]);
      if (options2.isRelative) {
        endPoint.translateWith(position);
      }
      if (controlPoint) {
        controlPoint = reflectionPoint(controlPoint, position);
      } else {
        controlPoint = position.clone();
      }
      var cubicControlPoints = quadraticToCubicControlPoints(position, controlPoint, endPoint);
      path.curveTo(cubicControlPoints.controlOut, cubicControlPoints.controlIn, endPoint);
      position.x = endPoint.x;
      position.y = endPoint.y;
    }
  }
};
function toLineParamaters(parameters, isVertical, value) {
  var insertPosition = isVertical ? 0 : 1;
  for (var i = 0; i < parameters.length; i += 2) {
    parameters.splice(i + insertPosition, 0, value);
  }
}
function reflectionPoint(point2, center) {
  if (point2 && center) {
    return center.scaleCopy(2).translate(-point2.x, -point2.y);
  }
}
var third = 1 / 3;
function quadraticToCubicControlPoints(position, controlPoint, endPoint) {
  var scaledPoint = controlPoint.clone().scale(2 / 3);
  return {
    controlOut: scaledPoint.clone().translateWith(position.scaleCopy(third)),
    controlIn: scaledPoint.translateWith(endPoint.scaleCopy(third))
  };
}
var shape_map_default = ShapeMap;

// node_modules/@progress/kendo-drawing/dist/es/parsing/parse-path.js
var SEGMENT_REGEX = /([a-df-z]{1})([^a-df-z]*)(z)?/gi;
var SPLIT_REGEX = /[,\s]?([+\-]?(?:\d*\.\d+|\d+)(?:[eE][+\-]?\d+)?)/g;
var MOVE = "m";
var CLOSE = "z";
function parseParameters(str) {
  var parameters = [];
  str.replace(SPLIT_REGEX, function(match, number2) {
    parameters.push(parseFloat(number2));
  });
  return parameters;
}
function parsePath(pathInstance, str) {
  var position = new point_default();
  var previousCommand;
  str.replace(SEGMENT_REGEX, function(match, element, params, closePath) {
    var command = element.toLowerCase();
    var isRelative = command === element;
    var parameters = parseParameters(params.trim());
    if (command === MOVE) {
      if (isRelative) {
        position.x += parameters[0];
        position.y += parameters[1];
      } else {
        position.x = parameters[0];
        position.y = parameters[1];
      }
      pathInstance.moveTo(position.x, position.y);
      if (parameters.length > 2) {
        command = "l";
        parameters.splice(0, 2);
      }
    }
    if (shape_map_default[command]) {
      shape_map_default[command](
        pathInstance,
        {
          parameters,
          position,
          isRelative,
          previousCommand
        }
      );
      if (closePath && closePath.toLowerCase() === CLOSE) {
        pathInstance.close();
      }
    } else if (command !== MOVE) {
      throw new Error("Error while parsing SVG path. Unsupported command: " + command);
    }
    previousCommand = command;
  });
  return pathInstance;
}
var parse_path_default = parsePath;

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-bounding-box.js
function elementsBoundingBox(elements, applyTransform, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    if (element.visible()) {
      var elementBoundingBox = applyTransform ? element.bbox(transformation) : element.rawBBox();
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/utils/elements-clippend-bounding-box.js
function elementsClippedBoundingBox(elements, transformation) {
  var boundingBox;
  for (var i = 0; i < elements.length; i++) {
    var element = elements[i];
    if (element.visible()) {
      var elementBoundingBox = element.clippedBBox(transformation);
      if (elementBoundingBox) {
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, elementBoundingBox);
        } else {
          boundingBox = elementBoundingBox;
        }
      }
    }
  }
  return boundingBox;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/path.js
var SPACE2 = " ";
var printPoints = function(precision) {
  return function() {
    var points3 = [], len = arguments.length;
    while (len--)
      points3[len] = arguments[len];
    return points3.map(function(p2) {
      return p2.toString(precision);
    }).join(SPACE2);
    ;
  };
};
var segmentType = function(segmentStart, segmentEnd) {
  return segmentStart.controlOut() && segmentEnd.controlIn() ? "C" : "L";
};
var Path = function(superclass) {
  function Path9(options2) {
    superclass.call(this, options2);
    this.segments = new geometry_elements_array_default();
    this.segments.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
      if (!defined(this.options.stroke.lineJoin)) {
        this.options.set("stroke.lineJoin", "miter");
      }
    }
  }
  if (superclass)
    Path9.__proto__ = superclass;
  Path9.prototype = Object.create(superclass && superclass.prototype);
  Path9.prototype.constructor = Path9;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Path";
  };
  Path9.prototype.moveTo = function moveTo(x, y) {
    this.suspend();
    this.segments.elements([]);
    this.resume();
    this.lineTo(x, y);
    return this;
  };
  Path9.prototype.lineTo = function lineTo(x, y) {
    var point2 = defined(y) ? new point_default(x, y) : x;
    var segment = new segment_default(point2);
    this.segments.push(segment);
    return this;
  };
  Path9.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var segment = new segment_default(point2, controlIn);
      this.suspend();
      lastSegment.controlOut(controlOut);
      this.resume();
      this.segments.push(segment);
    }
    return this;
  };
  Path9.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var start = rad(startAngle);
      var center = new point_default(
        anchor.x - radiusX * Math.cos(start),
        anchor.y - radiusY * Math.sin(start)
      );
      var arc2 = new arc_default(center, {
        startAngle,
        endAngle,
        radiusX,
        radiusY,
        anticlockwise
      });
      this._addArcSegments(arc2);
    }
    return this;
  };
  Path9.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.segments.length > 0) {
      var lastSegment = last(this.segments);
      var anchor = lastSegment.anchor();
      var arc = arc_default.fromPoints(anchor, point_default.create(end), rx, ry, largeArc, swipe, rotation);
      this._addArcSegments(arc);
    }
    return this;
  };
  Path9.prototype._addArcSegments = function _addArcSegments(arc) {
    var this$1 = this;
    this.suspend();
    var curvePoints = arc.curvePoints();
    for (var i = 1; i < curvePoints.length; i += 3) {
      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
    }
    this.resume();
    this.geometryChange();
  };
  Path9.prototype.close = function close2() {
    this.options.closed = true;
    this.geometryChange();
    return this;
  };
  Path9.prototype.rawBBox = function rawBBox() {
    return this._bbox();
  };
  Path9.prototype.toString = function toString4(digits) {
    var output = "";
    var segments = this.segments;
    var length = segments.length;
    if (length > 0) {
      var parts = [];
      var print = printPoints(digits);
      var currentType;
      for (var i = 1; i < length; i++) {
        var type = segmentType(segments[i - 1], segments[i]);
        if (type !== currentType) {
          currentType = type;
          parts.push(type);
        }
        if (type === "L") {
          parts.push(print(segments[i].anchor()));
        } else {
          parts.push(print(
            segments[i - 1].controlOut(),
            segments[i].controlIn(),
            segments[i].anchor()
          ));
        }
      }
      output = "M" + print(segments[0].anchor()) + SPACE2 + parts.join(SPACE2);
      if (this.options.closed) {
        output += "Z";
      }
    }
    return output;
  };
  Path9.prototype._containsPoint = function _containsPoint(point2) {
    var segments = this.segments;
    var length = segments.length;
    var intersectionsCount = 0;
    var previous, current4;
    for (var idx = 1; idx < length; idx++) {
      previous = segments[idx - 1];
      current4 = segments[idx];
      intersectionsCount += previous._intersectionsTo(current4, point2);
    }
    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {
      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point2);
    }
    return intersectionsCount % 2 !== 0;
  };
  Path9.prototype._isOnPath = function _isOnPath(point2, width) {
    var segments = this.segments;
    var length = segments.length;
    var pathWidth = width || this.options.stroke.width;
    if (length > 1) {
      if (segments[0]._isOnPathTo(segments[1], point2, pathWidth, "start")) {
        return true;
      }
      for (var idx = 2; idx <= length - 2; idx++) {
        if (segments[idx - 1]._isOnPathTo(segments[idx], point2, pathWidth)) {
          return true;
        }
      }
      if (segments[length - 2]._isOnPathTo(segments[length - 1], point2, pathWidth, "end")) {
        return true;
      }
    }
    return false;
  };
  Path9.prototype._bbox = function _bbox(matrix) {
    var segments = this.segments;
    var length = segments.length;
    var boundingBox;
    if (length === 1) {
      var anchor = segments[0].anchor().transformCopy(matrix);
      boundingBox = new rect_default(anchor, size_default.ZERO);
    } else if (length > 0) {
      for (var i = 1; i < length; i++) {
        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);
        if (boundingBox) {
          boundingBox = rect_default.union(boundingBox, segmentBox);
        } else {
          boundingBox = segmentBox;
        }
      }
    }
    return boundingBox;
  };
  Path9.parse = function parse3(str, options2) {
    return MultiPath.parse(str, options2);
  };
  Path9.fromRect = function fromRect(rect, options2) {
    var path = new Path9(options2);
    var ref2 = rect.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();
    } else {
      var origin = rect.origin;
      var x = origin.x;
      var y = origin.y;
      var width = rect.width();
      var height = rect.height();
      rx = limitValue(rx, 0, width / 2);
      ry = limitValue(ry, 0, height / 2);
      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);
    }
    return path;
  };
  Path9.fromPoints = function fromPoints(points3, options2) {
    if (points3) {
      var path = new Path9(options2);
      for (var i = 0; i < points3.length; i++) {
        var point2 = point_default.create(points3[i]);
        if (point2) {
          if (i === 0) {
            path.moveTo(point2);
          } else {
            path.lineTo(point2);
          }
        }
      }
      return path;
    }
  };
  Path9.curveFromPoints = function curveFromPoints(points3, options2) {
    if (points3) {
      var segments = pointsToCurve(points3);
      var path = new Path9(options2);
      path.segments.push.apply(path.segments, segments);
      return path;
    }
  };
  Path9.fromArc = function fromArc(arc, options2) {
    var path = new Path9(options2);
    var startAngle = arc.startAngle;
    var start = arc.pointAt(startAngle);
    path.moveTo(start.x, start.y);
    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);
    return path;
  };
  Object.defineProperties(Path9.prototype, prototypeAccessors4);
  return Path9;
}(paintable_default(measurable_default(element_default)));
var MultiPath = function(superclass) {
  function MultiPath2(options2) {
    superclass.call(this, options2);
    this.paths = new geometry_elements_array_default();
    this.paths.addObserver(this);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass)
    MultiPath2.__proto__ = superclass;
  MultiPath2.prototype = Object.create(superclass && superclass.prototype);
  MultiPath2.prototype.constructor = MultiPath2;
  var prototypeAccessors$12 = { nodeType: { configurable: true } };
  MultiPath2.parse = function parse3(str, options2) {
    var instance4 = new MultiPath2(options2);
    return parse_path_default(instance4, str);
  };
  MultiPath2.prototype.toString = function toString4(digits) {
    var paths = this.paths;
    var output = "";
    if (paths.length > 0) {
      var result = [];
      for (var i = 0; i < paths.length; i++) {
        result.push(paths[i].toString(digits));
      }
      output = result.join(SPACE2);
    }
    return output;
  };
  prototypeAccessors$12.nodeType.get = function() {
    return "MultiPath";
  };
  MultiPath2.prototype.moveTo = function moveTo(x, y) {
    var path = new Path();
    path.moveTo(x, y);
    this.paths.push(path);
    return this;
  };
  MultiPath2.prototype.lineTo = function lineTo(x, y) {
    if (this.paths.length > 0) {
      last(this.paths).lineTo(x, y);
    }
    return this;
  };
  MultiPath2.prototype.curveTo = function curveTo(controlOut, controlIn, point2) {
    if (this.paths.length > 0) {
      last(this.paths).curveTo(controlOut, controlIn, point2);
    }
    return this;
  };
  MultiPath2.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {
    if (this.paths.length > 0) {
      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);
    }
    return this;
  };
  MultiPath2.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {
    if (this.paths.length > 0) {
      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);
    }
    return this;
  };
  MultiPath2.prototype.close = function close2() {
    if (this.paths.length > 0) {
      last(this.paths).close();
    }
    return this;
  };
  MultiPath2.prototype._bbox = function _bbox(matrix) {
    return elementsBoundingBox(this.paths, true, matrix);
  };
  MultiPath2.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.paths, false);
  };
  MultiPath2.prototype._containsPoint = function _containsPoint(point2) {
    var paths = this.paths;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._containsPoint(point2)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._isOnPath = function _isOnPath(point2) {
    var paths = this.paths;
    var width = this.options.stroke.width;
    for (var idx = 0; idx < paths.length; idx++) {
      if (paths[idx]._isOnPath(point2, width)) {
        return true;
      }
    }
    return false;
  };
  MultiPath2.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));
  };
  Object.defineProperties(MultiPath2.prototype, prototypeAccessors$12);
  return MultiPath2;
}(paintable_default(measurable_default(element_default)));

// node_modules/@progress/kendo-drawing/dist/es/shapes/arc.js
var DEFAULT_STROKE2 = "#000";
var Arc2 = function(superclass) {
  function Arc4(geometry, options2) {
    if (geometry === void 0)
      geometry = new arc_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke(DEFAULT_STROKE2);
    }
  }
  if (superclass)
    Arc4.__proto__ = superclass;
  Arc4.prototype = Object.create(superclass && superclass.prototype);
  Arc4.prototype.constructor = Arc4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Arc";
  };
  Arc4.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Arc4.prototype.rawBBox = function rawBBox() {
    return this.geometry().bbox();
  };
  Arc4.prototype.toPath = function toPath() {
    var path = new Path();
    var curvePoints = this.geometry().curvePoints();
    if (curvePoints.length > 0) {
      path.moveTo(curvePoints[0].x, curvePoints[0].y);
      for (var i = 1; i < curvePoints.length; i += 3) {
        path.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);
      }
    }
    return path;
  };
  Arc4.prototype._containsPoint = function _containsPoint(point2) {
    return this.geometry().containsPoint(point2);
  };
  Arc4.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Arc4.prototype, prototypeAccessors4);
  return Arc4;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var arc_default2 = Arc2;

// node_modules/@progress/kendo-drawing/dist/es/shapes/text.js
var DEFAULT_FONT2 = "12px sans-serif";
var DEFAULT_FILL = "#000";
var Text = function(superclass) {
  function Text4(content, position, options2) {
    if (position === void 0)
      position = new point_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.content(content);
    this.position(position);
    if (!this.options.font) {
      this.options.font = DEFAULT_FONT2;
    }
    if (!defined(this.options.fill)) {
      this.fill(DEFAULT_FILL);
    }
  }
  if (superclass)
    Text4.__proto__ = superclass;
  Text4.prototype = Object.create(superclass && superclass.prototype);
  Text4.prototype.constructor = Text4;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Text";
  };
  Text4.prototype.content = function content(value) {
    if (defined(value)) {
      this.options.set("content", value);
      return this;
    }
    return this.options.get("content");
  };
  Text4.prototype.measure = function measure() {
    var metrics = measureText(this.content(), {
      font: this.options.get("font")
    });
    return metrics;
  };
  Text4.prototype.rect = function rect() {
    var size = this.measure();
    var pos = this.position().clone();
    return new rect_default(pos, [size.width, size.height]);
  };
  Text4.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this.rect().bbox(combinedMatrix);
  };
  Text4.prototype.rawBBox = function rawBBox() {
    return this.rect().bbox();
  };
  Text4.prototype._containsPoint = function _containsPoint(point2) {
    return this.rect().containsPoint(point2);
  };
  Object.defineProperties(Text4.prototype, prototypeAccessors4);
  return Text4;
}(paintable_default(with_points_default(element_default, ["position"])));
var text_default = Text;

// node_modules/@progress/kendo-drawing/dist/es/shapes/image.js
var Image2 = function(superclass) {
  function Image3(src, rect, options2) {
    if (rect === void 0)
      rect = new rect_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.src(src);
    this.rect(rect);
  }
  if (superclass)
    Image3.__proto__ = superclass;
  Image3.prototype = Object.create(superclass && superclass.prototype);
  Image3.prototype.constructor = Image3;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Image";
  };
  Image3.prototype.src = function src(value) {
    if (defined(value)) {
      this.options.set("src", value);
      return this;
    }
    return this.options.get("src");
  };
  Image3.prototype.bbox = function bbox(transformation) {
    var combinedMatrix = toMatrix(this.currentTransform(transformation));
    return this._rect.bbox(combinedMatrix);
  };
  Image3.prototype.rawBBox = function rawBBox() {
    return this._rect.bbox();
  };
  Image3.prototype._containsPoint = function _containsPoint(point2) {
    return this._rect.containsPoint(point2);
  };
  Image3.prototype._hasFill = function _hasFill() {
    return this.src();
  };
  Object.defineProperties(Image3.prototype, prototypeAccessors4);
  return Image3;
}(with_geometry_default(element_default, ["rect"]));
var image_default = Image2;

// node_modules/@progress/kendo-drawing/dist/es/mixins/traversable.js
var traversable = function(TBase, childrenField) {
  return function(TBase2) {
    function anonymous() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      anonymous.__proto__ = TBase2;
    anonymous.prototype = Object.create(TBase2 && TBase2.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.traverse = function traverse(callback) {
      var children = this[childrenField];
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        if (child.traverse) {
          child.traverse(callback);
        } else {
          callback(child);
        }
      }
      return this;
    };
    return anonymous;
  }(TBase);
};
var traversable_default = traversable;

// node_modules/@progress/kendo-drawing/dist/es/shapes/group.js
var Group = function(superclass) {
  function Group10(options2) {
    superclass.call(this, options2);
    this.children = [];
  }
  if (superclass)
    Group10.__proto__ = superclass;
  Group10.prototype = Object.create(superclass && superclass.prototype);
  Group10.prototype.constructor = Group10;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Group";
  };
  Group10.prototype.childrenChange = function childrenChange(action, items, index) {
    this.trigger("childrenChange", {
      action,
      items,
      index
    });
  };
  Group10.prototype.append = function append$1() {
    append(this.children, arguments);
    this._reparent(arguments, this);
    this.childrenChange("add", arguments);
    return this;
  };
  Group10.prototype.insert = function insert(index, element) {
    this.children.splice(index, 0, element);
    element.parent = this;
    this.childrenChange("add", [element], index);
    return this;
  };
  Group10.prototype.insertAt = function insertAt(element, index) {
    return this.insert(index, element);
  };
  Group10.prototype.remove = function remove(element) {
    var index = this.children.indexOf(element);
    if (index >= 0) {
      this.children.splice(index, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index);
    }
    return this;
  };
  Group10.prototype.removeAt = function removeAt(index) {
    if (0 <= index && index < this.children.length) {
      var element = this.children[index];
      this.children.splice(index, 1);
      element.parent = null;
      this.childrenChange("remove", [element], index);
    }
    return this;
  };
  Group10.prototype.clear = function clear4() {
    var items = this.children;
    this.children = [];
    this._reparent(items, null);
    this.childrenChange("remove", items, 0);
    return this;
  };
  Group10.prototype.bbox = function bbox(transformation) {
    return elementsBoundingBox(this.children, true, this.currentTransform(transformation));
  };
  Group10.prototype.rawBBox = function rawBBox() {
    return elementsBoundingBox(this.children, false);
  };
  Group10.prototype._clippedBBox = function _clippedBBox(transformation) {
    return elementsClippedBoundingBox(this.children, this.currentTransform(transformation));
  };
  Group10.prototype.currentTransform = function currentTransform(transformation) {
    return element_default.prototype.currentTransform.call(this, transformation) || null;
  };
  Group10.prototype.containsPoint = function containsPoint(point2, parentTransform) {
    if (this.visible()) {
      var children = this.children;
      var transform2 = this.currentTransform(parentTransform);
      for (var idx = 0; idx < children.length; idx++) {
        if (children[idx].containsPoint(point2, transform2)) {
          return true;
        }
      }
    }
    return false;
  };
  Group10.prototype._reparent = function _reparent(elements, newParent) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var child = elements[i];
      var parent = child.parent;
      if (parent && parent !== this$1 && parent.remove) {
        parent.remove(child);
      }
      child.parent = newParent;
    }
  };
  Object.defineProperties(Group10.prototype, prototypeAccessors4);
  return Group10;
}(traversable_default(element_default, "children"));
var group_default = Group;

// node_modules/@progress/kendo-drawing/dist/es/alignment/translate-to-point.js
function translateToPoint(point2, bbox, element) {
  var transofrm = element.transform() || transform();
  var matrix = transofrm.matrix();
  matrix.e += point2.x - bbox.origin.x;
  matrix.f += point2.y - bbox.origin.y;
  transofrm.matrix(matrix);
  element.transform(transofrm);
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start.js
function alignStart(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis];
  } else if (align2 === "end") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-start-reverse.js
function alignStartReverse(size, rect, align2, axis, sizeField) {
  var start;
  if (align2 === "start") {
    start = rect.origin[axis] + rect.size[sizeField] - size;
  } else if (align2 === "end") {
    start = rect.origin[axis];
  } else {
    start = rect.origin[axis] + (rect.size[sizeField] - size) / 2;
  }
  return start;
}

// node_modules/@progress/kendo-drawing/dist/es/shapes/layout.js
var DEFAULT_OPTIONS2 = {
  alignContent: "start",
  justifyContent: "start",
  alignItems: "start",
  spacing: 0,
  orientation: "horizontal",
  lineSpacing: 0,
  wrap: true,
  revers: false
};
var forEach = function(elements, callback) {
  elements.forEach(callback);
};
var forEachReverse = function(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx);
  }
};
var Layout = function(Group10) {
  function Layout2(rect, options2) {
    Group10.call(this, Object.assign({}, DEFAULT_OPTIONS2, options2));
    this._rect = rect;
    this._fieldMap = {};
  }
  if (Group10)
    Layout2.__proto__ = Group10;
  Layout2.prototype = Object.create(Group10 && Group10.prototype);
  Layout2.prototype.constructor = Layout2;
  Layout2.prototype.rect = function rect(value) {
    if (value) {
      this._rect = value;
      return this;
    }
    return this._rect;
  };
  Layout2.prototype._initMap = function _initMap() {
    var options2 = this.options;
    var fieldMap = this._fieldMap;
    if (options2.orientation === "horizontal") {
      fieldMap.sizeField = "width";
      fieldMap.groupsSizeField = "height";
      fieldMap.groupAxis = "x";
      fieldMap.groupsAxis = "y";
    } else {
      fieldMap.sizeField = "height";
      fieldMap.groupsSizeField = "width";
      fieldMap.groupAxis = "y";
      fieldMap.groupsAxis = "x";
    }
    if (options2.reverse) {
      this.forEach = forEachReverse;
      this.justifyAlign = alignStartReverse;
    } else {
      this.forEach = forEach;
      this.justifyAlign = alignStart;
    }
  };
  Layout2.prototype.reflow = function reflow() {
    var this$1 = this;
    if (!this._rect || this.children.length === 0) {
      return;
    }
    this._initMap();
    if (this.options.transform) {
      this.transform(null);
    }
    var options2 = this.options;
    var rect = this._rect;
    var ref2 = this._initGroups();
    var groups = ref2.groups;
    var groupsSize = ref2.groupsSize;
    var ref$1 = this._fieldMap;
    var sizeField = ref$1.sizeField;
    var groupsSizeField = ref$1.groupsSizeField;
    var groupAxis = ref$1.groupAxis;
    var groupsAxis = ref$1.groupsAxis;
    var groupOrigin = new point_default();
    var elementOrigin = new point_default();
    var size = new size_default();
    var groupStart = alignStart(groupsSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
    var elementStart, group, groupBox;
    var arrangeElements = function(bbox, idx) {
      var element = group.elements[idx];
      elementOrigin[groupAxis] = elementStart;
      elementOrigin[groupsAxis] = alignStart(bbox.size[groupsSizeField], groupBox, options2.alignItems, groupsAxis, groupsSizeField);
      translateToPoint(elementOrigin, bbox, element);
      elementStart += bbox.size[sizeField] + options2.spacing;
    };
    for (var groupIdx = 0; groupIdx < groups.length; groupIdx++) {
      group = groups[groupIdx];
      groupOrigin[groupAxis] = elementStart = this$1.justifyAlign(group.size, rect, options2.justifyContent, groupAxis, sizeField);
      groupOrigin[groupsAxis] = groupStart;
      size[sizeField] = group.size;
      size[groupsSizeField] = group.lineSize;
      groupBox = new rect_default(groupOrigin, size);
      this$1.forEach(group.bboxes, arrangeElements);
      groupStart += group.lineSize + options2.lineSpacing;
    }
    if (!options2.wrap && group.size > rect.size[sizeField]) {
      var scale = rect.size[sizeField] / groupBox.size[sizeField];
      var scaledStart = groupBox.topLeft().scale(scale, scale);
      var scaledSize = groupBox.size[groupsSizeField] * scale;
      var newStart = alignStart(scaledSize, rect, options2.alignContent, groupsAxis, groupsSizeField);
      var transform2 = transform();
      if (groupAxis === "x") {
        transform2.translate(rect.origin.x - scaledStart.x, newStart - scaledStart.y);
      } else {
        transform2.translate(newStart - scaledStart.x, rect.origin.y - scaledStart.y);
      }
      transform2.scale(scale, scale);
      this.transform(transform2);
    }
  };
  Layout2.prototype._initGroups = function _initGroups() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var lineSpacing = options2.lineSpacing;
    var wrap2 = options2.wrap;
    var spacing = options2.spacing;
    var sizeField = this._fieldMap.sizeField;
    var group = this._newGroup();
    var groups = [];
    var addGroup = function() {
      groups.push(group);
      groupsSize += group.lineSize + lineSpacing;
    };
    var groupsSize = -lineSpacing;
    for (var idx = 0; idx < children.length; idx++) {
      var element = children[idx];
      var bbox = children[idx].clippedBBox();
      if (element.visible() && bbox) {
        if (wrap2 && group.size + bbox.size[sizeField] + spacing > this$1._rect.size[sizeField]) {
          if (group.bboxes.length === 0) {
            this$1._addToGroup(group, bbox, element);
            addGroup();
            group = this$1._newGroup();
          } else {
            addGroup();
            group = this$1._newGroup();
            this$1._addToGroup(group, bbox, element);
          }
        } else {
          this$1._addToGroup(group, bbox, element);
        }
      }
    }
    if (group.bboxes.length) {
      addGroup();
    }
    return {
      groups,
      groupsSize
    };
  };
  Layout2.prototype._addToGroup = function _addToGroup(group, bbox, element) {
    group.size += bbox.size[this._fieldMap.sizeField] + this.options.spacing;
    group.lineSize = Math.max(bbox.size[this._fieldMap.groupsSizeField], group.lineSize);
    group.bboxes.push(bbox);
    group.elements.push(element);
  };
  Layout2.prototype._newGroup = function _newGroup() {
    return {
      lineSize: 0,
      size: -this.options.spacing,
      bboxes: [],
      elements: []
    };
  };
  return Layout2;
}(group_default);
var layout_default = Layout;

// node_modules/@progress/kendo-drawing/dist/es/shapes/rect.js
var Rect2 = function(superclass) {
  function Rect3(geometry, options2) {
    if (geometry === void 0)
      geometry = new rect_default();
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.geometry(geometry);
    if (!defined(this.options.stroke)) {
      this.stroke("#000");
    }
  }
  if (superclass)
    Rect3.__proto__ = superclass;
  Rect3.prototype = Object.create(superclass && superclass.prototype);
  Rect3.prototype.constructor = Rect3;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Rect";
  };
  Rect3.prototype._bbox = function _bbox(matrix) {
    return this._geometry.bbox(matrix);
  };
  Rect3.prototype.rawBBox = function rawBBox() {
    return this._geometry.bbox();
  };
  Rect3.prototype._containsPoint = function _containsPoint(point2) {
    return this._geometry.containsPoint(point2);
  };
  Rect3.prototype._isOnPath = function _isOnPath(point2) {
    return this.geometry()._isOnPath(point2, this.options.stroke.width / 2);
  };
  Object.defineProperties(Rect3.prototype, prototypeAccessors4);
  return Rect3;
}(paintable_default(measurable_default(with_geometry_default(element_default))));
var rect_default2 = Rect2;

// node_modules/@progress/kendo-drawing/dist/es/alignment/align-elements.js
function alignElements(elements, rect, alignment, axis, sizeField) {
  for (var idx = 0; idx < elements.length; idx++) {
    var bbox = elements[idx].clippedBBox();
    if (bbox) {
      var point2 = bbox.origin.clone();
      point2[axis] = alignStart(bbox.size[sizeField], rect, alignment || "start", axis, sizeField);
      translateToPoint(point2, bbox, elements[idx]);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/align.js
function align(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "x", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-align.js
function vAlign(elements, rect, alignment) {
  alignElements(elements, rect, alignment, "y", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack-elements.js
function stackElements(elements, stackAxis, otherAxis, sizeField) {
  if (elements.length > 1) {
    var origin = new point_default();
    var previousBBox = elements[0].bbox;
    for (var idx = 1; idx < elements.length; idx++) {
      var element = elements[idx].element;
      var bbox = elements[idx].bbox;
      origin[stackAxis] = previousBBox.origin[stackAxis] + previousBBox.size[sizeField];
      origin[otherAxis] = bbox.origin[otherAxis];
      translateToPoint(origin, bbox, element);
      bbox.origin[stackAxis] = origin[stackAxis];
      previousBBox = bbox;
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/create-stack-elements.js
function createStackElements(elements) {
  var stackElements2 = [];
  for (var idx = 0; idx < elements.length; idx++) {
    var element = elements[idx];
    var bbox = element.clippedBBox();
    if (bbox) {
      stackElements2.push({
        element,
        bbox
      });
    }
  }
  return stackElements2;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/stack.js
function stack(elements) {
  stackElements(createStackElements(elements), "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-stack.js
function vStack(elements) {
  stackElements(createStackElements(elements), "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap-elements.js
function getStacks(elements, rect, sizeField) {
  var maxSize = rect.size[sizeField];
  var stacks = [];
  var stack2 = [];
  var stackSize = 0;
  var element, bbox;
  var addElementToStack = function() {
    stack2.push({
      element,
      bbox
    });
  };
  for (var idx = 0; idx < elements.length; idx++) {
    element = elements[idx];
    bbox = element.clippedBBox();
    if (bbox) {
      var size = bbox.size[sizeField];
      if (stackSize + size > maxSize) {
        if (stack2.length) {
          stacks.push(stack2);
          stack2 = [];
          addElementToStack();
          stackSize = size;
        } else {
          addElementToStack();
          stacks.push(stack2);
          stack2 = [];
          stackSize = 0;
        }
      } else {
        addElementToStack();
        stackSize += size;
      }
    }
  }
  if (stack2.length) {
    stacks.push(stack2);
  }
  return stacks;
}
function wrapElements(elements, rect, axis, otherAxis, sizeField) {
  var stacks = getStacks(elements, rect, sizeField);
  var origin = rect.origin.clone();
  var result = [];
  for (var idx = 0; idx < stacks.length; idx++) {
    var stack2 = stacks[idx];
    var startElement = stack2[0];
    origin[otherAxis] = startElement.bbox.origin[otherAxis];
    translateToPoint(origin, startElement.bbox, startElement.element);
    startElement.bbox.origin[axis] = origin[axis];
    stackElements(stack2, axis, otherAxis, sizeField);
    result.push([]);
    for (var elementIdx = 0; elementIdx < stack2.length; elementIdx++) {
      result[idx].push(stack2[elementIdx].element);
    }
  }
  return result;
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/wrap.js
function wrap(elements, rect) {
  return wrapElements(elements, rect, "x", "y", "width");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/v-wrap.js
function vWrap(elements, rect) {
  return wrapElements(elements, rect, "y", "x", "height");
}

// node_modules/@progress/kendo-drawing/dist/es/alignment/fit.js
function fit(element, rect) {
  var bbox = element.clippedBBox();
  if (bbox) {
    var elementSize3 = bbox.size;
    var rectSize = rect.size;
    if (rectSize.width < elementSize3.width || rectSize.height < elementSize3.height) {
      var scale = Math.min(rectSize.width / elementSize3.width, rectSize.height / elementSize3.height);
      var transform2 = element.transform() || transform();
      transform2.scale(scale, scale);
      element.transform(transform2);
    }
  }
}

// node_modules/@progress/kendo-drawing/dist/es/gradients/stops-array.js
var StopsArray = function(ElementsArray2) {
  function StopsArray2() {
    ElementsArray2.apply(this, arguments);
  }
  if (ElementsArray2)
    StopsArray2.__proto__ = ElementsArray2;
  StopsArray2.prototype = Object.create(ElementsArray2 && ElementsArray2.prototype);
  StopsArray2.prototype.constructor = StopsArray2;
  StopsArray2.prototype._change = function _change() {
    this.optionsChange({
      field: "stops"
    });
  };
  return StopsArray2;
}(elements_array_default);
var stops_array_default = StopsArray;

// node_modules/@progress/kendo-drawing/dist/es/mixins/with-options.js
function optionsAccessor(name3) {
  return function(value) {
    if (defined(value)) {
      this.options.set(name3, value);
      return this;
    }
    return this.options.get(name3);
  };
}
function defineOptionsAccessors(fn, names) {
  for (var i = 0; i < names.length; i++) {
    fn[names[i]] = optionsAccessor(names[i]);
  }
}
var withOptions = function(TBase, names) {
  var result = function(TBase2) {
    function result2() {
      TBase2.apply(this, arguments);
    }
    if (TBase2)
      result2.__proto__ = TBase2;
    result2.prototype = Object.create(TBase2 && TBase2.prototype);
    result2.prototype.constructor = result2;
    return result2;
  }(TBase);
  defineOptionsAccessors(result.prototype, names);
  return result;
};
var with_options_default = withOptions;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient-stop.js
var options = ["offset", "color", "opacity"];
var GradientStop = function(superclass) {
  function GradientStop2(offset, color, opacity) {
    superclass.call(this);
    this.options = new options_store_default({
      offset,
      color,
      opacity: defined(opacity) ? opacity : 1
    });
    this.options.addObserver(this);
  }
  if (superclass)
    GradientStop2.__proto__ = superclass;
  GradientStop2.prototype = Object.create(superclass && superclass.prototype);
  GradientStop2.prototype.constructor = GradientStop2;
  GradientStop2.create = function create2(arg) {
    if (defined(arg)) {
      var stop;
      if (arg instanceof GradientStop2) {
        stop = arg;
      } else if (arg.length > 1) {
        stop = new GradientStop2(arg[0], arg[1], arg[2]);
      } else {
        stop = new GradientStop2(arg.offset, arg.color, arg.opacity);
      }
      return stop;
    }
  };
  return GradientStop2;
}(with_options_default(has_observers_default, options));
var gradient_stop_default = GradientStop;

// node_modules/@progress/kendo-drawing/dist/es/gradients/gradient.js
var Gradient = function(HasObservers2) {
  function Gradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    HasObservers2.call(this);
    this.stops = new stops_array_default(this._createStops(options2.stops));
    this.stops.addObserver(this);
    this._userSpace = options2.userSpace;
    this.id = definitionId();
  }
  if (HasObservers2)
    Gradient2.__proto__ = HasObservers2;
  Gradient2.prototype = Object.create(HasObservers2 && HasObservers2.prototype);
  Gradient2.prototype.constructor = Gradient2;
  var prototypeAccessors4 = { nodeType: { configurable: true } };
  prototypeAccessors4.nodeType.get = function() {
    return "Gradient";
  };
  Gradient2.prototype.userSpace = function userSpace(value) {
    if (defined(value)) {
      this._userSpace = value;
      this.optionsChange();
      return this;
    }
    return this._userSpace;
  };
  Gradient2.prototype._createStops = function _createStops(stops) {
    if (stops === void 0)
      stops = [];
    var result = [];
    for (var idx = 0; idx < stops.length; idx++) {
      result.push(gradient_stop_default.create(stops[idx]));
    }
    return result;
  };
  Gradient2.prototype.addStop = function addStop(offset, color, opacity) {
    this.stops.push(new gradient_stop_default(offset, color, opacity));
  };
  Gradient2.prototype.removeStop = function removeStop(stop) {
    var index = this.stops.indexOf(stop);
    if (index >= 0) {
      this.stops.splice(index, 1);
    }
  };
  Gradient2.prototype.optionsChange = function optionsChange(e) {
    this.trigger("optionsChange", {
      field: "gradient" + (e ? "." + e.field : ""),
      value: this
    });
  };
  Gradient2.prototype.geometryChange = function geometryChange() {
    this.optionsChange();
  };
  Object.defineProperties(Gradient2.prototype, prototypeAccessors4);
  return Gradient2;
}(has_observers_default);
var gradient_default = Gradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/linear-gradient.js
var points2 = ["start", "end"];
var LinearGradient = function(superclass) {
  function LinearGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.start(options2.start || new point_default());
    this.end(options2.end || new point_default(1, 0));
  }
  if (superclass)
    LinearGradient2.__proto__ = superclass;
  LinearGradient2.prototype = Object.create(superclass && superclass.prototype);
  LinearGradient2.prototype.constructor = LinearGradient2;
  return LinearGradient2;
}(with_points_default(gradient_default, points2));
var linear_gradient_default = LinearGradient;

// node_modules/@progress/kendo-drawing/dist/es/gradients/radial-gradient.js
var RadialGradient = function(superclass) {
  function RadialGradient2(options2) {
    if (options2 === void 0)
      options2 = {};
    superclass.call(this, options2);
    this.center(options2.center || new point_default());
    this._radius = defined(options2.radius) ? options2.radius : 1;
    this._fallbackFill = options2.fallbackFill;
  }
  if (superclass)
    RadialGradient2.__proto__ = superclass;
  RadialGradient2.prototype = Object.create(superclass && superclass.prototype);
  RadialGradient2.prototype.constructor = RadialGradient2;
  RadialGradient2.prototype.radius = function radius(value) {
    if (defined(value)) {
      this._radius = value;
      this.geometryChange();
      return this;
    }
    return this._radius;
  };
  RadialGradient2.prototype.fallbackFill = function fallbackFill(value) {
    if (defined(value)) {
      this._fallbackFill = value;
      this.optionsChange();
      return this;
    }
    return this._fallbackFill;
  };
  return RadialGradient2;
}(with_points_default(gradient_default, ["center"]));
var radial_gradient_default = RadialGradient;

// node_modules/@progress/kendo-drawing/dist/es/animations/easing-functions.js
var easing_functions_exports = {};
__export(easing_functions_exports, {
  easeOutElastic: () => easeOutElastic,
  linear: () => linear,
  swing: () => swing
});
function swing(position) {
  return 0.5 - Math.cos(position * Math.PI) / 2;
}
function linear(position) {
  return position;
}
function easeOutElastic(position, time, start, diff) {
  var s = 1.70158, p2 = 0, a = diff;
  if (position === 0) {
    return start;
  }
  if (position === 1) {
    return start + diff;
  }
  if (!p2) {
    p2 = 0.5;
  }
  if (a < Math.abs(diff)) {
    a = diff;
    s = p2 / 4;
  } else {
    s = p2 / (2 * Math.PI) * Math.asin(diff / a);
  }
  return a * Math.pow(2, -10 * position) * Math.sin((Number(position) - s) * (1.1 * Math.PI) / p2) + diff + start;
}

// node_modules/@progress/kendo-drawing/dist/es/animations/animation-factory.js
var instance;
var AnimationFactory = function(Class3) {
  function AnimationFactory2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    AnimationFactory2.__proto__ = Class3;
  AnimationFactory2.prototype = Object.create(Class3 && Class3.prototype);
  AnimationFactory2.prototype.constructor = AnimationFactory2;
  var staticAccessors2 = { current: { configurable: true } };
  staticAccessors2.current.get = function() {
    if (!instance) {
      instance = new AnimationFactory2();
    }
    return instance;
  };
  AnimationFactory2.prototype.register = function register4(name3, type) {
    this._items.push({
      name: name3,
      type
    });
  };
  AnimationFactory2.prototype.create = function create2(element, options2) {
    var items = this._items;
    var match;
    if (options2 && options2.type) {
      var type = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name.toLowerCase() === type) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element, options2);
    }
  };
  Object.defineProperties(AnimationFactory2, staticAccessors2);
  return AnimationFactory2;
}(class_default);
var animation_factory_default = AnimationFactory;

// node_modules/@progress/kendo-drawing/dist/es/animations/animation.js
var Animation = function(Class3) {
  function Animation3(element, options2) {
    Class3.call(this);
    this.options = Object.assign({}, this.options, options2);
    this.element = element;
  }
  if (Class3)
    Animation3.__proto__ = Class3;
  Animation3.prototype = Object.create(Class3 && Class3.prototype);
  Animation3.prototype.constructor = Animation3;
  var prototypeAccessors4 = { options: { configurable: true } };
  Animation3.create = function create2(type, element, options2) {
    return animation_factory_default.current.create(type, element, options2);
  };
  prototypeAccessors4.options.get = function() {
    return this._options || {
      duration: 500,
      easing: "swing"
    };
  };
  prototypeAccessors4.options.set = function(value) {
    this._options = value;
  };
  Animation3.prototype.setup = function setup() {
  };
  Animation3.prototype.step = function step() {
  };
  Animation3.prototype.play = function play() {
    var this$1 = this;
    var options2 = this.options;
    var duration2 = options2.duration;
    var delay = options2.delay;
    if (delay === void 0)
      delay = 0;
    var easing = easing_functions_exports[options2.easing];
    var start = now_default() + delay;
    var finish = start + duration2;
    if (duration2 === 0) {
      this.step(1);
      this.abort();
    } else {
      setTimeout(function() {
        var loop = function() {
          if (this$1._stopped) {
            return;
          }
          var wallTime = now_default();
          var time = limitValue(wallTime - start, 0, duration2);
          var position = time / duration2;
          var easingPosition = easing(position, time, 0, 1, duration2);
          this$1.step(easingPosition);
          if (wallTime < finish) {
            animation_frame_default(loop);
          } else {
            this$1.abort();
          }
        };
        loop();
      }, delay);
    }
  };
  Animation3.prototype.abort = function abort() {
    this._stopped = true;
  };
  Animation3.prototype.destroy = function destroy2() {
    this.abort();
  };
  Object.defineProperties(Animation3.prototype, prototypeAccessors4);
  return Animation3;
}(class_default);
var animation_default = Animation;

// node_modules/@progress/kendo-drawing/dist/es/parsing/path-parser.js
var instance2;
var PathParser = function(Class3) {
  function PathParser2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    PathParser2.__proto__ = Class3;
  PathParser2.prototype = Object.create(Class3 && Class3.prototype);
  PathParser2.prototype.constructor = PathParser2;
  var staticAccessors2 = { current: { configurable: true } };
  staticAccessors2.current.get = function() {
    if (!instance2) {
      instance2 = new PathParser2();
    }
    return instance2;
  };
  PathParser2.prototype.parse = function parse3(str, options2) {
    var multiPath = new MultiPath(options2);
    return parse_path_default(multiPath, str);
  };
  Object.defineProperties(PathParser2, staticAccessors2);
  return PathParser2;
}(class_default);
var path_parser_default = PathParser;

// node_modules/@progress/kendo-drawing/dist/es/core/base-node.js
var BaseNode = function(Class3) {
  function BaseNode2(srcElement) {
    Class3.call(this);
    this.childNodes = [];
    this.parent = null;
    if (srcElement) {
      this.srcElement = srcElement;
      this.observe();
    }
  }
  if (Class3)
    BaseNode2.__proto__ = Class3;
  BaseNode2.prototype = Object.create(Class3 && Class3.prototype);
  BaseNode2.prototype.constructor = BaseNode2;
  BaseNode2.prototype.destroy = function destroy2() {
    var this$1 = this;
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      this$1.childNodes[i].destroy();
    }
    this.parent = null;
  };
  BaseNode2.prototype.load = function load2() {
  };
  BaseNode2.prototype.observe = function observe() {
    if (this.srcElement) {
      this.srcElement.addObserver(this);
    }
  };
  BaseNode2.prototype.append = function append3(node) {
    this.childNodes.push(node);
    node.parent = this;
  };
  BaseNode2.prototype.insertAt = function insertAt(node, pos) {
    this.childNodes.splice(pos, 0, node);
    node.parent = this;
  };
  BaseNode2.prototype.remove = function remove(index, count) {
    var this$1 = this;
    var end = index + count;
    for (var i = index; i < end; i++) {
      this$1.childNodes[i].removeSelf();
    }
    this.childNodes.splice(index, count);
  };
  BaseNode2.prototype.removeSelf = function removeSelf() {
    this.clear();
    this.destroy();
  };
  BaseNode2.prototype.clear = function clear4() {
    this.remove(0, this.childNodes.length);
  };
  BaseNode2.prototype.invalidate = function invalidate() {
    if (this.parent) {
      this.parent.invalidate();
    }
  };
  BaseNode2.prototype.geometryChange = function geometryChange() {
    this.invalidate();
  };
  BaseNode2.prototype.optionsChange = function optionsChange() {
    this.invalidate();
  };
  BaseNode2.prototype.childrenChange = function childrenChange(e) {
    if (e.action === "add") {
      this.load(e.items, e.index);
    } else if (e.action === "remove") {
      this.remove(e.index, e.items.length);
    }
    this.invalidate();
  };
  return BaseNode2;
}(class_default);
var base_node_default = BaseNode;

// node_modules/@progress/kendo-drawing/dist/es/core/surface.js
var events = [
  "click",
  "mouseenter",
  "mouseleave",
  "mousemove",
  "resize"
];
var Surface = function(Observable3) {
  function Surface6(element, options2) {
    Observable3.call(this);
    this.options = Object.assign({}, options2);
    this.element = element;
    this.element._kendoExportVisual = this.exportVisual.bind(this);
    this._click = this._handler("click");
    this._mouseenter = this._handler("mouseenter");
    this._mouseleave = this._handler("mouseleave");
    this._mousemove = this._handler("mousemove");
    this._visual = new group_default();
    elementSize(element, this.options);
    this.bind(events, this.options);
    this._enableTracking();
  }
  if (Observable3)
    Surface6.__proto__ = Observable3;
  Surface6.prototype = Object.create(Observable3 && Observable3.prototype);
  Surface6.prototype.constructor = Surface6;
  Surface6.prototype.draw = function draw(element) {
    this._visual.children.push(element);
  };
  Surface6.prototype.clear = function clear4() {
    this._visual.children = [];
  };
  Surface6.prototype.destroy = function destroy2() {
    this._visual = null;
    this.element._kendoExportVisual = null;
    this.unbind();
  };
  Surface6.prototype.eventTarget = function eventTarget(e) {
    var this$1 = this;
    var domNode = eventElement(e);
    var node;
    while (!node && domNode) {
      node = domNode._kendoNode;
      if (domNode === this$1.element) {
        break;
      }
      domNode = domNode.parentElement;
    }
    if (node) {
      return node.srcElement;
    }
  };
  Surface6.prototype.exportVisual = function exportVisual() {
    return this._visual;
  };
  Surface6.prototype.getSize = function getSize() {
    return elementSize(this.element);
  };
  Surface6.prototype.currentSize = function currentSize(size) {
    if (size) {
      this._size = size;
    } else {
      return this._size;
    }
  };
  Surface6.prototype.setSize = function setSize(size) {
    elementSize(this.element, size);
    this.currentSize(size);
    this._resize();
  };
  Surface6.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this.currentSize();
    if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this.currentSize(size);
      this._resize(size, force);
      this.trigger("resize", size);
    }
  };
  Surface6.prototype.size = function size(value) {
    if (!value) {
      return this.getSize();
    }
    this.setSize(value);
  };
  Surface6.prototype.suspendTracking = function suspendTracking() {
    this._suspendedTracking = true;
  };
  Surface6.prototype.resumeTracking = function resumeTracking() {
    this._suspendedTracking = false;
  };
  Surface6.prototype._enableTracking = function _enableTracking() {
  };
  Surface6.prototype._resize = function _resize() {
  };
  Surface6.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      var node = this$1.eventTarget(e);
      if (node && !this$1._suspendedTracking) {
        this$1.trigger(eventName, {
          element: node,
          originalEvent: e,
          type: eventName
        });
      }
    };
  };
  Surface6.prototype._elementOffset = function _elementOffset() {
    var element = this.element;
    var padding = elementPadding(element);
    var ref2 = elementOffset(element);
    var left = ref2.left;
    var top = ref2.top;
    return {
      left: left + padding.left,
      top: top + padding.top
    };
  };
  Surface6.prototype._surfacePoint = function _surfacePoint(e) {
    var offset = this._elementOffset();
    var coord = eventCoordinates(e);
    var x = coord.x - offset.left;
    var y = coord.y - offset.top;
    var inverseTransform = elementScale(this.element).invert();
    var point2 = new point_default(
      x,
      y
    ).transform(inverseTransform);
    return point2;
  };
  return Surface6;
}(observable_default);
var surface_default = Surface;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-attribute.js
function renderAttr(name3, value) {
  return defined(value) && value !== null ? " " + name3 + '="' + value + '" ' : "";
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-all-attributes.js
function renderAllAttr(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    output += renderAttr(attrs[i][0], attrs[i][1]);
  }
  return output;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-style.js
function renderStyle(attrs) {
  var output = "";
  for (var i = 0; i < attrs.length; i++) {
    var value = attrs[i][1];
    if (defined(value)) {
      output += attrs[i][0] + ":" + value + ";";
    }
  }
  if (output !== "") {
    return output;
  }
}

// node_modules/@progress/kendo-drawing/dist/es/svg/node-map.js
var NODE_MAP = {};
var node_map_default = NODE_MAP;

// node_modules/@progress/kendo-drawing/dist/es/svg/constants.js
var SVG_NS = "http://www.w3.org/2000/svg";
var NONE2 = "none";
var POINT_DIGITS = 3;

// node_modules/@progress/kendo-drawing/dist/es/svg/utils/render-svg.js
var applyStyle = function(styleString, element) {
  return styleString.split(";").filter(function(s) {
    return s !== "";
  }).forEach(function(s) {
    var parts = s.split(":");
    element.style[parts[0].trim()] = parts[1].trim();
  });
};
var styleAttr = "data-style";
var replaceStyleAttr = function(html) {
  return html.replace(/\sstyle=/g, " " + styleAttr + "=");
};
var restoreStyleAttr = function(container) {
  Array.from(container.querySelectorAll("[" + styleAttr + "]")).forEach(function(element) {
    var styleString = element.getAttribute(styleAttr);
    element.removeAttribute(styleAttr);
    applyStyle(styleString, element);
  });
};
var renderSVG = function(container, svg) {
  container.innerHTML = replaceStyleAttr(svg);
  restoreStyleAttr(container);
};
if (typeof document !== "undefined") {
  testFragment = "<svg xmlns='" + SVG_NS + "'></svg>";
  testContainer = document.createElement("div");
  hasParser = typeof DOMParser !== "undefined";
  testContainer.innerHTML = testFragment;
  if (hasParser && testContainer.firstChild.namespaceURI !== SVG_NS) {
    renderSVG = function(container, svg) {
      var parser = new DOMParser();
      var chartDoc = parser.parseFromString(replaceStyleAttr(svg), "text/xml");
      restoreStyleAttr(chartDoc);
      var importedDoc = document.adoptNode(chartDoc.documentElement);
      container.innerHTML = "";
      container.appendChild(importedDoc);
    };
  }
}
var testFragment;
var testContainer;
var hasParser;
var render_svg_default = renderSVG;

// node_modules/@progress/kendo-drawing/dist/es/svg/node.js
var TRANSFORM = "transform";
var DefinitionMap = {
  clip: "clip-path",
  fill: "fill"
};
function isDefinition(type, value) {
  return type === "clip" || type === "fill" && (!value || value.nodeType === "Gradient");
}
function baseUrl() {
  var base = document.getElementsByTagName("base")[0];
  var href = document.location.href;
  var url = "";
  if (base && !(support_default.browser || {}).msie) {
    var hashIndex = href.indexOf("#");
    if (hashIndex !== -1) {
      href = href.substring(0, hashIndex);
    }
    url = href;
  }
  return url;
}
var Node2 = function(BaseNode2) {
  function Node4(srcElement, options2) {
    BaseNode2.call(this, srcElement);
    this.definitions = {};
    this.options = options2;
  }
  if (BaseNode2)
    Node4.__proto__ = BaseNode2;
  Node4.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node4.prototype.constructor = Node4;
  Node4.prototype.destroy = function destroy2() {
    if (this.element) {
      this.element._kendoNode = null;
      this.element = null;
    }
    this.clearDefinitions();
    BaseNode2.prototype.destroy.call(this);
  };
  Node4.prototype.load = function load2(elements, pos) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default[srcElement.nodeType](srcElement, this$1.options);
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
      childNode.createDefinitions();
      if (children && children.length > 0) {
        childNode.load(children);
      }
      var element = this$1.element;
      if (element) {
        childNode.attachTo(element, pos);
      }
    }
  };
  Node4.prototype.root = function root() {
    var root2 = this;
    while (root2.parent) {
      root2 = root2.parent;
    }
    return root2;
  };
  Node4.prototype.attachTo = function attachTo(domElement, pos) {
    var container = document.createElement("div");
    render_svg_default(
      container,
      "<svg xmlns='" + SVG_NS + "' version='1.1'>" + this.render() + "</svg>"
    );
    var element = container.firstChild.firstChild;
    if (element) {
      if (defined(pos)) {
        domElement.insertBefore(element, domElement.childNodes[pos] || null);
      } else {
        domElement.appendChild(element);
      }
      this.setElement(element);
    }
  };
  Node4.prototype.setElement = function setElement(element) {
    if (this.element) {
      this.element._kendoNode = null;
    }
    this.element = element;
    this.element._kendoNode = this;
    var nodes = this.childNodes;
    for (var i = 0; i < nodes.length; i++) {
      var childElement = element.childNodes[i];
      nodes[i].setElement(childElement);
    }
  };
  Node4.prototype.clear = function clear4() {
    this.clearDefinitions();
    if (this.element) {
      this.element.innerHTML = "";
    }
    var children = this.childNodes;
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
    this.childNodes = [];
  };
  Node4.prototype.removeSelf = function removeSelf() {
    if (this.element) {
      var parentNode = this.element.parentNode;
      if (parentNode) {
        parentNode.removeChild(this.element);
      }
      this.element = null;
    }
    BaseNode2.prototype.removeSelf.call(this);
  };
  Node4.prototype.template = function template3() {
    return this.renderChildren();
  };
  Node4.prototype.render = function render3() {
    return this.template();
  };
  Node4.prototype.renderChildren = function renderChildren() {
    var nodes = this.childNodes;
    var output = "";
    for (var i = 0; i < nodes.length; i++) {
      output += nodes[i].render();
    }
    return output;
  };
  Node4.prototype.optionsChange = function optionsChange(e) {
    var field = e.field;
    var value = e.value;
    if (field === "visible") {
      this.css("display", value ? "" : NONE2);
    } else if (DefinitionMap[field] && isDefinition(field, value)) {
      this.updateDefinition(field, value);
    } else if (field === "opacity") {
      this.attr("opacity", value);
    } else if (field === "cursor") {
      this.css("cursor", value);
    } else if (field === "id") {
      if (value) {
        this.attr("id", value);
      } else {
        this.removeAttr("id");
      }
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node4.prototype.attr = function attr(name3, value) {
    if (this.element) {
      this.element.setAttribute(name3, value);
    }
  };
  Node4.prototype.allAttr = function allAttr(attrs) {
    var this$1 = this;
    for (var i = 0; i < attrs.length; i++) {
      this$1.attr(attrs[i][0], attrs[i][1]);
    }
  };
  Node4.prototype.css = function css(name3, value) {
    if (this.element) {
      this.element.style[name3] = value;
    }
  };
  Node4.prototype.allCss = function allCss(styles) {
    var this$1 = this;
    for (var i = 0; i < styles.length; i++) {
      this$1.css(styles[i][0], styles[i][1]);
    }
  };
  Node4.prototype.removeAttr = function removeAttr(name3) {
    if (this.element) {
      this.element.removeAttribute(name3);
    }
  };
  Node4.prototype.mapTransform = function mapTransform(transform2) {
    var attrs = [];
    if (transform2) {
      attrs.push([
        TRANSFORM,
        "matrix(" + transform2.matrix().toString(6) + ")"
      ]);
    }
    return attrs;
  };
  Node4.prototype.renderTransform = function renderTransform() {
    return renderAllAttr(
      this.mapTransform(this.srcElement.transform())
    );
  };
  Node4.prototype.transformChange = function transformChange(value) {
    if (value) {
      this.allAttr(this.mapTransform(value));
    } else {
      this.removeAttr(TRANSFORM);
    }
  };
  Node4.prototype.mapStyle = function mapStyle() {
    var options2 = this.srcElement.options;
    var style = [["cursor", options2.cursor]];
    if (options2.visible === false) {
      style.push(["display", NONE2]);
    }
    return style;
  };
  Node4.prototype.renderStyle = function renderStyle$1() {
    return renderAttr("style", renderStyle(this.mapStyle(true)));
  };
  Node4.prototype.renderOpacity = function renderOpacity() {
    return renderAttr("opacity", this.srcElement.options.opacity);
  };
  Node4.prototype.renderId = function renderId() {
    return renderAttr("id", this.srcElement.options.id);
  };
  Node4.prototype.createDefinitions = function createDefinitions() {
    var srcElement = this.srcElement;
    var definitions = this.definitions;
    if (srcElement) {
      var options2 = srcElement.options;
      var hasDefinitions;
      for (var field in DefinitionMap) {
        var definition = options2.get(field);
        if (definition && isDefinition(field, definition)) {
          definitions[field] = definition;
          hasDefinitions = true;
        }
      }
      if (hasDefinitions) {
        this.definitionChange({
          action: "add",
          definitions
        });
      }
    }
  };
  Node4.prototype.definitionChange = function definitionChange(e) {
    if (this.parent) {
      this.parent.definitionChange(e);
    }
  };
  Node4.prototype.updateDefinition = function updateDefinition(type, value) {
    var definitions = this.definitions;
    var current4 = definitions[type];
    var attr = DefinitionMap[type];
    var definition = {};
    if (current4) {
      definition[type] = current4;
      this.definitionChange({
        action: "remove",
        definitions: definition
      });
      delete definitions[type];
    }
    if (!value) {
      if (current4) {
        this.removeAttr(attr);
      }
    } else {
      definition[type] = value;
      this.definitionChange({
        action: "add",
        definitions: definition
      });
      definitions[type] = value;
      this.attr(attr, this.refUrl(value.id));
    }
  };
  Node4.prototype.clearDefinitions = function clearDefinitions() {
    var definitions = this.definitions;
    this.definitionChange({
      action: "remove",
      definitions
    });
    this.definitions = {};
  };
  Node4.prototype.renderDefinitions = function renderDefinitions() {
    return renderAllAttr(this.mapDefinitions());
  };
  Node4.prototype.mapDefinitions = function mapDefinitions() {
    var this$1 = this;
    var definitions = this.definitions;
    var attrs = [];
    for (var field in definitions) {
      attrs.push([DefinitionMap[field], this$1.refUrl(definitions[field].id)]);
    }
    return attrs;
  };
  Node4.prototype.refUrl = function refUrl(id) {
    var skipBaseHref = (this.options || {}).skipBaseHref;
    var baseHref = this.baseUrl().replace(/'/g, "\\'");
    var base = skipBaseHref ? "" : baseHref;
    return "url(" + base + "#" + id + ")";
  };
  Node4.prototype.baseUrl = function baseUrl$1() {
    return baseUrl();
  };
  return Node4;
}(base_node_default);
var node_default = Node2;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-stop-node.js
var GradientStopNode = function(Node4) {
  function GradientStopNode2() {
    Node4.apply(this, arguments);
  }
  if (Node4)
    GradientStopNode2.__proto__ = Node4;
  GradientStopNode2.prototype = Object.create(Node4 && Node4.prototype);
  GradientStopNode2.prototype.constructor = GradientStopNode2;
  GradientStopNode2.prototype.template = function template3() {
    return "<stop " + this.renderOffset() + " " + this.renderStyle() + " />";
  };
  GradientStopNode2.prototype.renderOffset = function renderOffset() {
    return renderAttr("offset", this.srcElement.offset());
  };
  GradientStopNode2.prototype.mapStyle = function mapStyle() {
    var srcElement = this.srcElement;
    return [
      ["stop-color", srcElement.color()],
      ["stop-opacity", srcElement.opacity()]
    ];
  };
  GradientStopNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "offset") {
      this.attr(e.field, e.value);
    } else if (e.field === "color" || e.field === "opacity") {
      this.css("stop-" + e.field, e.value);
    }
  };
  return GradientStopNode2;
}(node_default);
var gradient_stop_node_default = GradientStopNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/gradient-node.js
var GradientNode = function(Node4) {
  function GradientNode2(srcElement) {
    Node4.call(this, srcElement);
    this.id = srcElement.id;
    this.loadStops();
  }
  if (Node4)
    GradientNode2.__proto__ = Node4;
  GradientNode2.prototype = Object.create(Node4 && Node4.prototype);
  GradientNode2.prototype.constructor = GradientNode2;
  GradientNode2.prototype.loadStops = function loadStops() {
    var this$1 = this;
    var stops = this.srcElement.stops;
    var element = this.element;
    for (var idx = 0; idx < stops.length; idx++) {
      var stopNode = new gradient_stop_node_default(stops[idx]);
      this$1.append(stopNode);
      if (element) {
        stopNode.attachTo(element);
      }
    }
  };
  GradientNode2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "gradient.stops") {
      base_node_default.prototype.clear.call(this);
      this.loadStops();
    } else if (e.field === "gradient") {
      this.allAttr(this.mapCoordinates());
    }
  };
  GradientNode2.prototype.renderCoordinates = function renderCoordinates() {
    return renderAllAttr(this.mapCoordinates());
  };
  GradientNode2.prototype.mapSpace = function mapSpace() {
    return ["gradientUnits", this.srcElement.userSpace() ? "userSpaceOnUse" : "objectBoundingBox"];
  };
  return GradientNode2;
}(node_default);
var gradient_node_default = GradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/linear-gradient-node.js
var LinearGradientNode = function(GradientNode2) {
  function LinearGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    LinearGradientNode2.__proto__ = GradientNode2;
  LinearGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  LinearGradientNode2.prototype.constructor = LinearGradientNode2;
  LinearGradientNode2.prototype.template = function template3() {
    return "<linearGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</linearGradient>";
  };
  LinearGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var start = srcElement.start();
    var end = srcElement.end();
    var attrs = [
      ["x1", start.x],
      ["y1", start.y],
      ["x2", end.x],
      ["y2", end.y],
      this.mapSpace()
    ];
    return attrs;
  };
  return LinearGradientNode2;
}(gradient_node_default);
var linear_gradient_node_default = LinearGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/radial-gradient-node.js
var RadialGradientNode = function(GradientNode2) {
  function RadialGradientNode2() {
    GradientNode2.apply(this, arguments);
  }
  if (GradientNode2)
    RadialGradientNode2.__proto__ = GradientNode2;
  RadialGradientNode2.prototype = Object.create(GradientNode2 && GradientNode2.prototype);
  RadialGradientNode2.prototype.constructor = RadialGradientNode2;
  RadialGradientNode2.prototype.template = function template3() {
    return "<radialGradient id='" + this.id + "' " + this.renderCoordinates() + ">" + this.renderChildren() + "</radialGradient>";
  };
  RadialGradientNode2.prototype.mapCoordinates = function mapCoordinates() {
    var srcElement = this.srcElement;
    var center = srcElement.center();
    var radius = srcElement.radius();
    var attrs = [
      ["cx", center.x],
      ["cy", center.y],
      ["r", radius],
      this.mapSpace()
    ];
    return attrs;
  };
  return RadialGradientNode2;
}(gradient_node_default);
var radial_gradient_node_default = RadialGradientNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/clip-node.js
var ClipNode = function(Node4) {
  function ClipNode2(srcElement) {
    Node4.call(this);
    this.srcElement = srcElement;
    this.id = srcElement.id;
    this.load([srcElement]);
  }
  if (Node4)
    ClipNode2.__proto__ = Node4;
  ClipNode2.prototype = Object.create(Node4 && Node4.prototype);
  ClipNode2.prototype.constructor = ClipNode2;
  ClipNode2.prototype.template = function template3() {
    return "<clipPath id='" + this.id + "'>" + this.renderChildren() + "</clipPath>";
  };
  return ClipNode2;
}(node_default);
var clip_node_default = ClipNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/definition-node.js
var DefinitionNode = function(Node4) {
  function DefinitionNode2() {
    Node4.call(this);
    this.definitionMap = {};
  }
  if (Node4)
    DefinitionNode2.__proto__ = Node4;
  DefinitionNode2.prototype = Object.create(Node4 && Node4.prototype);
  DefinitionNode2.prototype.constructor = DefinitionNode2;
  DefinitionNode2.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
  };
  DefinitionNode2.prototype.template = function template3() {
    return "<defs>" + this.renderChildren() + "</defs>";
  };
  DefinitionNode2.prototype.definitionChange = function definitionChange(e) {
    var definitions = e.definitions;
    var action = e.action;
    if (action === "add") {
      this.addDefinitions(definitions);
    } else if (action === "remove") {
      this.removeDefinitions(definitions);
    }
  };
  DefinitionNode2.prototype.createDefinition = function createDefinition(type, item) {
    var nodeType;
    if (type === "clip") {
      nodeType = clip_node_default;
    } else if (type === "fill") {
      if (item instanceof linear_gradient_default) {
        nodeType = linear_gradient_node_default;
      } else if (item instanceof radial_gradient_default) {
        nodeType = radial_gradient_node_default;
      }
    }
    return new nodeType(item);
  };
  DefinitionNode2.prototype.addDefinitions = function addDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.addDefinition(field, definitions[field]);
    }
  };
  DefinitionNode2.prototype.addDefinition = function addDefinition(type, srcElement) {
    var ref2 = this;
    var element = ref2.element;
    var definitionMap = ref2.definitionMap;
    var id = srcElement.id;
    var mapItem = definitionMap[id];
    if (!mapItem) {
      var node = this.createDefinition(type, srcElement);
      definitionMap[id] = {
        element: node,
        count: 1
      };
      this.append(node);
      if (element) {
        node.attachTo(this.element);
      }
    } else {
      mapItem.count++;
    }
  };
  DefinitionNode2.prototype.removeDefinitions = function removeDefinitions(definitions) {
    var this$1 = this;
    for (var field in definitions) {
      this$1.removeDefinition(definitions[field]);
    }
  };
  DefinitionNode2.prototype.removeDefinition = function removeDefinition(srcElement) {
    var definitionMap = this.definitionMap;
    var id = srcElement.id;
    var mapItem = definitionMap[id];
    if (mapItem) {
      mapItem.count--;
      if (mapItem.count === 0) {
        this.remove(this.childNodes.indexOf(mapItem.element), 1);
        delete definitionMap[id];
      }
    }
  };
  return DefinitionNode2;
}(node_default);
var definition_node_default = DefinitionNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/root-node.js
var RootNode = function(Node4) {
  function RootNode3(options2) {
    Node4.call(this);
    this.options = options2;
    this.defs = new definition_node_default();
  }
  if (Node4)
    RootNode3.__proto__ = Node4;
  RootNode3.prototype = Object.create(Node4 && Node4.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.attachTo = function attachTo(domElement) {
    this.element = domElement;
    this.defs.attachTo(domElement.firstElementChild);
  };
  RootNode3.prototype.clear = function clear4() {
    base_node_default.prototype.clear.call(this);
  };
  RootNode3.prototype.template = function template3() {
    return this.defs.render() + this.renderChildren();
  };
  RootNode3.prototype.definitionChange = function definitionChange(e) {
    this.defs.definitionChange(e);
  };
  return RootNode3;
}(node_default);
var root_node_default = RootNode;

// node_modules/@progress/kendo-drawing/dist/es/core/constants.js
var DASH_ARRAYS = {
  dot: [1.5, 3.5],
  dash: [4, 3.5],
  longdash: [8, 3.5],
  dashdot: [3.5, 3.5, 1.5, 3.5],
  longdashdot: [8, 3.5, 1.5, 3.5],
  longdashdotdot: [8, 3.5, 1.5, 3.5, 1.5, 3.5]
};
var SOLID = "solid";
var BUTT = "butt";

// node_modules/@progress/kendo-drawing/dist/es/svg/path-node.js
var ATTRIBUTE_MAP = {
  "fill.opacity": "fill-opacity",
  "stroke.color": "stroke",
  "stroke.width": "stroke-width",
  "stroke.opacity": "stroke-opacity"
};
var PathNode = function(Node4) {
  function PathNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4)
    PathNode3.__proto__ = Node4;
  PathNode3.prototype = Object.create(Node4 && Node4.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.geometryChange = function geometryChange() {
    this.attr("d", this.renderData());
    this.invalidate();
  };
  PathNode3.prototype.optionsChange = function optionsChange(e) {
    switch (e.field) {
      case "fill":
        if (e.value) {
          this.allAttr(this.mapFill(e.value));
        } else {
          this.removeAttr("fill");
        }
        break;
      case "fill.color":
        this.allAttr(this.mapFill({ color: e.value }));
        break;
      case "stroke":
        if (e.value) {
          this.allAttr(this.mapStroke(e.value));
        } else {
          this.removeAttr("stroke");
        }
        break;
      case "transform":
        this.transformChange(e.value);
        break;
      default:
        var name3 = ATTRIBUTE_MAP[e.field];
        if (name3) {
          this.attr(name3, e.value);
        }
        break;
    }
    Node4.prototype.optionsChange.call(this, e);
  };
  PathNode3.prototype.content = function content() {
    if (this.element) {
      this.element.textContent = this.srcElement.content();
    }
  };
  PathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || void 0;
  };
  PathNode3.prototype.mapStroke = function mapStroke(stroke) {
    var attrs = [];
    if (stroke && !isTransparent(stroke.color)) {
      attrs.push(["stroke", stroke.color]);
      attrs.push(["stroke-width", stroke.width]);
      attrs.push(["stroke-linecap", this.renderLinecap(stroke)]);
      attrs.push(["stroke-linejoin", stroke.lineJoin]);
      if (defined(stroke.opacity)) {
        attrs.push(["stroke-opacity", stroke.opacity]);
      }
      if (defined(stroke.dashType)) {
        attrs.push(["stroke-dasharray", this.renderDashType(stroke)]);
      }
    } else {
      attrs.push(["stroke", NONE2]);
    }
    return attrs;
  };
  PathNode3.prototype.renderStroke = function renderStroke() {
    return renderAllAttr(
      this.mapStroke(this.srcElement.options.stroke)
    );
  };
  PathNode3.prototype.renderDashType = function renderDashType(stroke) {
    var dashType = stroke.dashType;
    var width = stroke.width;
    if (width === void 0)
      width = 1;
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType.toLowerCase()];
      var result = [];
      for (var i = 0; i < dashArray.length; i++) {
        result.push(dashArray[i] * width);
      }
      return result.join(" ");
    }
  };
  PathNode3.prototype.renderLinecap = function renderLinecap(stroke) {
    var dashType = stroke.dashType;
    var lineCap = stroke.lineCap;
    return dashType && dashType !== "solid" ? BUTT : lineCap;
  };
  PathNode3.prototype.mapFill = function mapFill(fill) {
    var attrs = [];
    if (!(fill && fill.nodeType === "Gradient")) {
      if (fill && !isTransparent(fill.color)) {
        attrs.push(["fill", fill.color]);
        if (defined(fill.opacity)) {
          attrs.push(["fill-opacity", fill.opacity]);
        }
      } else {
        attrs.push(["fill", NONE2]);
      }
    }
    return attrs;
  };
  PathNode3.prototype.renderFill = function renderFill() {
    return renderAllAttr(
      this.mapFill(this.srcElement.options.fill)
    );
  };
  PathNode3.prototype.template = function template3() {
    return "<path " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " " + renderAttr("d", this.renderData()) + this.renderStroke() + this.renderFill() + this.renderDefinitions() + this.renderTransform() + "></path>";
  };
  return PathNode3;
}(node_default);
var path_node_default = PathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/arc-node.js
var ArcNode = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderData = function renderData() {
    return this.srcElement.toPath().toString(POINT_DIGITS);
  };
  return ArcNode3;
}(path_node_default);
var arc_node_default = ArcNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/circle-node.js
var CircleNode = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.geometryChange = function geometryChange() {
    var center = this.center();
    this.attr("cx", center.x);
    this.attr("cy", center.y);
    this.attr("r", this.radius());
    this.invalidate();
  };
  CircleNode3.prototype.center = function center() {
    return this.srcElement.geometry().center;
  };
  CircleNode3.prototype.radius = function radius() {
    return this.srcElement.geometry().radius;
  };
  CircleNode3.prototype.template = function template3() {
    return "<circle " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + "cx='" + this.center().x + "' cy='" + this.center().y + "' r='" + this.radius() + "'" + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + this.renderTransform() + " ></circle>";
  };
  return CircleNode3;
}(path_node_default);
var circle_node_default = CircleNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/group-node.js
var GroupNode = function(Node4) {
  function GroupNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4)
    GroupNode3.__proto__ = Node4;
  GroupNode3.prototype = Object.create(Node4 && Node4.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.template = function template3() {
    return "<g" + (this.renderId() + this.renderTransform() + this.renderStyle() + this.renderOpacity() + this.renderDefinitions()) + ">" + this.renderChildren() + "</g>";
  };
  GroupNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "transform") {
      this.transformChange(e.value);
    }
    Node4.prototype.optionsChange.call(this, e);
  };
  return GroupNode3;
}(node_default);
var group_node_default = GroupNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/image-node.js
var ImageNode = function(PathNode3) {
  function ImageNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.geometryChange = function geometryChange() {
    this.allAttr(this.mapPosition());
    this.invalidate();
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.allAttr(this.mapSource());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  ImageNode3.prototype.mapPosition = function mapPosition() {
    var rect = this.srcElement.rect();
    var tl = rect.topLeft();
    return [
      ["x", tl.x],
      ["y", tl.y],
      ["width", rect.width() + "px"],
      ["height", rect.height() + "px"]
    ];
  };
  ImageNode3.prototype.renderPosition = function renderPosition() {
    return renderAllAttr(this.mapPosition());
  };
  ImageNode3.prototype.mapSource = function mapSource(encode) {
    var src = this.srcElement.src();
    if (encode) {
      src = htmlEncode(src);
    }
    return [["xlink:href", src]];
  };
  ImageNode3.prototype.renderSource = function renderSource() {
    return renderAllAttr(this.mapSource(true));
  };
  ImageNode3.prototype.template = function template3() {
    return "<image preserveAspectRatio='none' " + this.renderId() + " " + this.renderStyle() + " " + this.renderTransform() + " " + this.renderOpacity() + this.renderPosition() + " " + this.renderSource() + " " + this.renderDefinitions() + "></image>";
  };
  return ImageNode3;
}(path_node_default);
var image_node_default = ImageNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/multi-path-node.js
var MultiPathNode = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderData = function renderData() {
    return this.srcElement.toString(POINT_DIGITS) || "undefined";
  };
  return MultiPathNode3;
}(path_node_default);
var multi_path_node_default = MultiPathNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/rect-node.js
var RectNode = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.geometryChange = function geometryChange() {
    var geometry = this.srcElement.geometry();
    this.attr("x", geometry.origin.x);
    this.attr("y", geometry.origin.y);
    this.attr("width", geometry.size.width);
    this.attr("height", geometry.size.height);
    this.attr("rx", geometry.cornerRadius[0]);
    this.attr("ry", geometry.cornerRadius[1]);
    this.invalidate();
  };
  RectNode3.prototype.size = function size() {
    return this.srcElement.geometry().size;
  };
  RectNode3.prototype.origin = function origin() {
    return this.srcElement.geometry().origin;
  };
  RectNode3.prototype.rx = function rx() {
    return this.srcElement.geometry().cornerRadius[0];
  };
  RectNode3.prototype.ry = function ry() {
    return this.srcElement.geometry().cornerRadius[1];
  };
  RectNode3.prototype.template = function template3() {
    return "<rect " + this.renderId() + " " + this.renderStyle() + " " + this.renderOpacity() + " x='" + this.origin().x + "' y='" + this.origin().y + "' rx='" + this.rx() + "' ry='" + this.ry() + "' width='" + this.size().width + "' height='" + this.size().height + "' " + this.renderStroke() + " " + this.renderFill() + " " + this.renderDefinitions() + " " + this.renderTransform() + " />";
  };
  return RectNode3;
}(path_node_default);
var rect_node_default = RectNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/text-node.js
var ENTITY_REGEX = /&(?:[a-zA-Z]+|#\d+);/g;
function decodeEntities(text) {
  if (!text || typeof text !== "string" || !ENTITY_REGEX.test(text)) {
    return text;
  }
  var element = decodeEntities._element;
  ENTITY_REGEX.lastIndex = 0;
  return text.replace(ENTITY_REGEX, function(match) {
    element.innerHTML = match;
    return element.textContent || element.innerText;
  });
}
if (typeof document !== "undefined") {
  decodeEntities._element = document.createElement("span");
}
var TextNode = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.geometryChange = function geometryChange() {
    var pos = this.pos();
    this.attr("x", pos.x);
    this.attr("y", pos.y);
    this.invalidate();
  };
  TextNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "font") {
      this.attr("style", renderStyle(this.mapStyle()));
      this.geometryChange();
    } else if (e.field === "content") {
      PathNode3.prototype.content.call(this, this.srcElement.content());
    }
    PathNode3.prototype.optionsChange.call(this, e);
  };
  TextNode3.prototype.mapStyle = function mapStyle(encode) {
    var style = PathNode3.prototype.mapStyle.call(this, encode);
    var font = this.srcElement.options.font;
    if (encode) {
      font = htmlEncode(font);
    }
    style.push(["font", font], ["white-space", "pre"]);
    return style;
  };
  TextNode3.prototype.pos = function pos() {
    var pos2 = this.srcElement.position();
    var size = this.srcElement.measure();
    return pos2.clone().setY(pos2.y + size.baseline);
  };
  TextNode3.prototype.renderContent = function renderContent() {
    var content = this.srcElement.content();
    content = decodeEntities(content);
    content = htmlEncode(content);
    return normalizeText(content);
  };
  TextNode3.prototype.renderTextAnchor = function renderTextAnchor() {
    var anchor;
    if ((this.options || {}).rtl && !(support_default.browser.msie || support_default.browser.edge)) {
      anchor = "end";
    }
    return renderAttr("text-anchor", anchor);
  };
  TextNode3.prototype.template = function template3() {
    return "<text " + this.renderId() + " " + this.renderTextAnchor() + " " + this.renderStyle() + " " + this.renderOpacity() + "x='" + this.pos().x + "' y='" + this.pos().y + "' " + this.renderStroke() + " " + this.renderTransform() + " " + this.renderDefinitions() + this.renderFill() + ">" + this.renderContent() + "</text>";
  };
  return TextNode3;
}(path_node_default);
var text_node_default = TextNode;

// node_modules/@progress/kendo-drawing/dist/es/svg/surface.js
node_map_default.Arc = arc_node_default;
node_map_default.Circle = circle_node_default;
node_map_default.Group = group_node_default;
node_map_default.Image = image_node_default;
node_map_default.MultiPath = multi_path_node_default;
node_map_default.Path = path_node_default;
node_map_default.Rect = rect_node_default;
node_map_default.Text = text_node_default;
var RTL = "rtl";
function alignToScreen(element) {
  var ctm;
  try {
    ctm = element.getScreenCTM ? element.getScreenCTM() : null;
  } catch (e) {
  }
  if (ctm) {
    var left = -ctm.e % 1;
    var top = -ctm.f % 1;
    var style = element.style;
    if (left !== 0 || top !== 0) {
      style.left = left + "px";
      style.top = top + "px";
    }
  }
}
var Surface2 = function(BaseSurface) {
  function Surface6(element, options2) {
    BaseSurface.call(this, element, options2);
    this._root = new root_node_default(Object.assign({
      rtl: elementStyles(element, "direction").direction === RTL
    }, this.options));
    render_svg_default(this.element, this._template(""));
    this._rootElement = this.element.firstElementChild;
    this._rootElement.style.width = "100%";
    this._rootElement.style.height = "100%";
    this._rootElement.style.overflow = "hidden";
    alignToScreen(this._rootElement);
    this._root.attachTo(this._rootElement);
    bindEvents(this.element, {
      click: this._click,
      mouseover: this._mouseenter,
      mouseout: this._mouseleave,
      mousemove: this._mousemove
    });
    this.resize();
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var prototypeAccessors4 = { type: { configurable: true } };
  prototypeAccessors4.type.get = function() {
    return "svg";
  };
  Surface6.prototype.destroy = function destroy2() {
    if (this._root) {
      this._root.destroy();
      this._root = null;
      this._rootElement = null;
      unbindEvents(this.element, {
        click: this._click,
        mouseover: this._mouseenter,
        mouseout: this._mouseleave,
        mousemove: this._mousemove
      });
    }
    BaseSurface.prototype.destroy.call(this);
  };
  Surface6.prototype.translate = function translate2(offset) {
    var viewBox = Math.round(offset.x) + " " + Math.round(offset.y) + " " + this._size.width + " " + this._size.height;
    this._offset = offset;
    this._rootElement.setAttribute("viewBox", viewBox);
  };
  Surface6.prototype.draw = function draw(element) {
    BaseSurface.prototype.draw.call(this, element);
    this._root.load([element]);
  };
  Surface6.prototype.clear = function clear4() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
  };
  Surface6.prototype.svg = function svg() {
    return "<?xml version='1.0' ?>" + this._template();
  };
  Surface6.prototype.exportVisual = function exportVisual() {
    var ref2 = this;
    var visual = ref2._visual;
    var offset = ref2._offset;
    if (offset) {
      var wrap2 = new group_default();
      wrap2.children.push(visual);
      wrap2.transform(
        transform().translate(-offset.x, -offset.y)
      );
      visual = wrap2;
    }
    return visual;
  };
  Surface6.prototype._resize = function _resize() {
    if (this._offset) {
      this.translate(this._offset);
    }
  };
  Surface6.prototype._template = function _template(svgStyles) {
    var styles = typeof svgStyles === "string" ? svgStyles : "style='width: 100%; height: 100%; overflow: hidden;' ";
    return "<svg " + styles + "xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + this._root.render() + "</svg>";
  };
  Object.defineProperties(Surface6.prototype, prototypeAccessors4);
  return Surface6;
}(surface_default);
var surface_default2 = Surface2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/node-map.js
var NODE_MAP2 = {};
var node_map_default2 = NODE_MAP2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/utils/render-path.js
function renderPath(ctx, path) {
  var segments = path.segments;
  if (segments.length === 0) {
    return;
  }
  var segment = segments[0];
  var anchor = segment.anchor();
  ctx.moveTo(anchor.x, anchor.y);
  for (var i = 1; i < segments.length; i++) {
    segment = segments[i];
    anchor = segment.anchor();
    var prevSeg = segments[i - 1];
    var prevOut = prevSeg.controlOut();
    var controlIn = segment.controlIn();
    if (prevOut && controlIn) {
      ctx.bezierCurveTo(
        prevOut.x,
        prevOut.y,
        controlIn.x,
        controlIn.y,
        anchor.x,
        anchor.y
      );
    } else {
      ctx.lineTo(anchor.x, anchor.y);
    }
  }
  if (path.options.closed) {
    ctx.closePath();
  }
}

// node_modules/@progress/kendo-drawing/dist/es/canvas/node.js
var Node3 = function(BaseNode2) {
  function Node4(srcElement) {
    BaseNode2.call(this, srcElement);
    if (srcElement) {
      this.initClip();
    }
  }
  if (BaseNode2)
    Node4.__proto__ = BaseNode2;
  Node4.prototype = Object.create(BaseNode2 && BaseNode2.prototype);
  Node4.prototype.constructor = Node4;
  Node4.prototype.initClip = function initClip() {
    var clip = this.srcElement.clip();
    if (clip) {
      this.clip = clip;
      clip.addObserver(this);
    }
  };
  Node4.prototype.clear = function clear4() {
    if (this.srcElement) {
      this.srcElement.removeObserver(this);
    }
    this.clearClip();
    BaseNode2.prototype.clear.call(this);
  };
  Node4.prototype.clearClip = function clearClip() {
    if (this.clip) {
      this.clip.removeObserver(this);
      delete this.clip;
    }
  };
  Node4.prototype.setClip = function setClip(ctx) {
    if (this.clip) {
      ctx.beginPath();
      renderPath(ctx, this.clip);
      ctx.clip();
    }
  };
  Node4.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "clip") {
      this.clearClip();
      this.initClip();
    }
    BaseNode2.prototype.optionsChange.call(this, e);
  };
  Node4.prototype.setTransform = function setTransform2(ctx) {
    if (this.srcElement) {
      var transform2 = this.srcElement.transform();
      if (transform2) {
        ctx.transform.apply(ctx, transform2.matrix().toArray(6));
      }
    }
  };
  Node4.prototype.loadElements = function loadElements(elements, pos, cors) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var srcElement = elements[i];
      var children = srcElement.children;
      var childNode = new node_map_default2[srcElement.nodeType](srcElement, cors);
      if (children && children.length > 0) {
        childNode.load(children, pos, cors);
      }
      if (defined(pos)) {
        this$1.insertAt(childNode, pos);
      } else {
        this$1.append(childNode);
      }
    }
  };
  Node4.prototype.load = function load2(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this.invalidate();
  };
  Node4.prototype.setOpacity = function setOpacity(ctx) {
    if (this.srcElement) {
      var opacity = this.srcElement.opacity();
      if (defined(opacity)) {
        this.globalAlpha(ctx, opacity);
      }
    }
  };
  Node4.prototype.globalAlpha = function globalAlpha(ctx, value) {
    var opactity = value;
    if (opactity && ctx.globalAlpha) {
      opactity *= ctx.globalAlpha;
    }
    ctx.globalAlpha = opactity;
  };
  Node4.prototype.visible = function visible() {
    var src = this.srcElement;
    return !src || src && src.options.visible !== false;
  };
  return Node4;
}(base_node_default);
var node_default2 = Node3;

// node_modules/@progress/kendo-drawing/dist/es/canvas/group-node.js
var GroupNode2 = function(superclass) {
  function GroupNode3() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    GroupNode3.__proto__ = superclass;
  GroupNode3.prototype = Object.create(superclass && superclass.prototype);
  GroupNode3.prototype.constructor = GroupNode3;
  GroupNode3.prototype.renderTo = function renderTo(ctx) {
    if (!this.visible()) {
      return;
    }
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    var childNodes = this.childNodes;
    for (var i = 0; i < childNodes.length; i++) {
      var child = childNodes[i];
      if (child.visible()) {
        child.renderTo(ctx);
      }
    }
    ctx.restore();
  };
  return GroupNode3;
}(traversable_default(node_default2, "childNodes"));
var group_node_default2 = GroupNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/root-node.js
var FRAME_DELAY = 1e3 / 60;
var RootNode2 = function(superclass) {
  function RootNode3(canvas, size) {
    superclass.call(this);
    this.canvas = canvas;
    this.size = size;
    this.ctx = canvas.getContext("2d");
    var invalidateHandler = this._invalidate.bind(this);
    this.invalidate = throttle(function() {
      animation_frame_default(invalidateHandler);
    }, FRAME_DELAY);
  }
  if (superclass)
    RootNode3.__proto__ = superclass;
  RootNode3.prototype = Object.create(superclass && superclass.prototype);
  RootNode3.prototype.constructor = RootNode3;
  RootNode3.prototype.destroy = function destroy2() {
    superclass.prototype.destroy.call(this);
    this.canvas = null;
    this.ctx = null;
  };
  RootNode3.prototype.load = function load2(elements, pos, cors) {
    this.loadElements(elements, pos, cors);
    this._invalidate();
  };
  RootNode3.prototype._rescale = function _rescale(scale) {
    var ref2 = this;
    var canvas = ref2.canvas;
    var size = ref2.size;
    canvas.width = size.width * scale;
    canvas.height = size.height * scale;
    this.ctx.scale(scale, scale);
  };
  RootNode3.prototype._devicePixelRatio = function _devicePixelRatio() {
    if (typeof window.devicePixelRatio === "number") {
      return window.devicePixelRatio;
    }
    return 1;
  };
  RootNode3.prototype._invalidate = function _invalidate(options2) {
    if (!this.ctx) {
      return;
    }
    var fixedScale = options2 && options2.fixedScale;
    var scale = fixedScale ? 1 : this._devicePixelRatio();
    this._rescale(scale);
    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
    this.renderTo(this.ctx);
  };
  return RootNode3;
}(traversable_default(group_node_default2, "childNodes"));
var root_node_default2 = RootNode2;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-root.js
var QuadRoot = function(Class3) {
  function QuadRoot2() {
    Class3.call(this);
    this.shapes = [];
  }
  if (Class3)
    QuadRoot2.__proto__ = Class3;
  QuadRoot2.prototype = Object.create(Class3 && Class3.prototype);
  QuadRoot2.prototype.constructor = QuadRoot2;
  QuadRoot2.prototype._add = function _add(shape2, bbox) {
    this.shapes.push({
      bbox,
      shape: shape2
    });
    shape2._quadNode = this;
  };
  QuadRoot2.prototype.pointShapes = function pointShapes(point2) {
    var shapes = this.shapes;
    var length = shapes.length;
    var result = [];
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].bbox.containsPoint(point2)) {
        result.push(shapes[idx].shape);
      }
    }
    return result;
  };
  QuadRoot2.prototype.insert = function insert(shape2, bbox) {
    this._add(shape2, bbox);
  };
  QuadRoot2.prototype.remove = function remove(shape2) {
    var shapes = this.shapes;
    var length = shapes.length;
    for (var idx = 0; idx < length; idx++) {
      if (shapes[idx].shape === shape2) {
        shapes.splice(idx, 1);
        break;
      }
    }
  };
  return QuadRoot2;
}(class_default);
var quad_root_default = QuadRoot;

// node_modules/@progress/kendo-drawing/dist/es/search/quad-node.js
var QuadNode = function(QuadRoot2) {
  function QuadNode2(rect) {
    QuadRoot2.call(this);
    this.children = [];
    this.rect = rect;
  }
  if (QuadRoot2)
    QuadNode2.__proto__ = QuadRoot2;
  QuadNode2.prototype = Object.create(QuadRoot2 && QuadRoot2.prototype);
  QuadNode2.prototype.constructor = QuadNode2;
  QuadNode2.prototype.inBounds = function inBounds(rect) {
    var nodeRect = this.rect;
    var nodeBottomRight = nodeRect.bottomRight();
    var bottomRight = rect.bottomRight();
    var inBounds2 = nodeRect.origin.x <= rect.origin.x && nodeRect.origin.y <= rect.origin.y && bottomRight.x <= nodeBottomRight.x && bottomRight.y <= nodeBottomRight.y;
    return inBounds2;
  };
  QuadNode2.prototype.pointShapes = function pointShapes(point2) {
    var children = this.children;
    var length = children.length;
    var result = QuadRoot2.prototype.pointShapes.call(this, point2);
    for (var idx = 0; idx < length; idx++) {
      append(result, children[idx].pointShapes(point2));
    }
    return result;
  };
  QuadNode2.prototype.insert = function insert(shape2, bbox) {
    var children = this.children;
    var inserted = false;
    if (this.inBounds(bbox)) {
      if (this.shapes.length < 4) {
        this._add(shape2, bbox);
      } else {
        if (!children.length) {
          this._initChildren();
        }
        for (var idx = 0; idx < children.length; idx++) {
          if (children[idx].insert(shape2, bbox)) {
            inserted = true;
            break;
          }
        }
        if (!inserted) {
          this._add(shape2, bbox);
        }
      }
      inserted = true;
    }
    return inserted;
  };
  QuadNode2.prototype._initChildren = function _initChildren() {
    var ref2 = this;
    var rect = ref2.rect;
    var children = ref2.children;
    var center = rect.center();
    var halfWidth = rect.width() / 2;
    var halfHeight = rect.height() / 2;
    children.push(
      new QuadNode2(new rect_default([rect.origin.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([center.x, rect.origin.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([rect.origin.x, center.y], [halfWidth, halfHeight])),
      new QuadNode2(new rect_default([center.x, center.y], [halfWidth, halfHeight]))
    );
  };
  return QuadNode2;
}(quad_root_default);
var quad_node_default = QuadNode;

// node_modules/@progress/kendo-drawing/dist/es/search/shapes-quad-tree.js
var ROOT_SIZE = 3e3;
var LEVEL_STEP = 1e4;
var MAX_LEVEL = 75;
var ShapesQuadTree = function(Class3) {
  function ShapesQuadTree2() {
    Class3.call(this);
    this.initRoots();
  }
  if (Class3)
    ShapesQuadTree2.__proto__ = Class3;
  ShapesQuadTree2.prototype = Object.create(Class3 && Class3.prototype);
  ShapesQuadTree2.prototype.constructor = ShapesQuadTree2;
  ShapesQuadTree2.prototype.initRoots = function initRoots() {
    this.rootMap = {};
    this.root = new quad_root_default();
    this.rootElements = [];
  };
  ShapesQuadTree2.prototype.clear = function clear4() {
    var this$1 = this;
    var rootElements = this.rootElements;
    for (var idx = 0; idx < rootElements.length; idx++) {
      this$1.remove(rootElements[idx]);
    }
    this.initRoots();
  };
  ShapesQuadTree2.prototype.pointShape = function pointShape(point2) {
    var sectorRoot = (this.rootMap[Math.floor(point2.x / ROOT_SIZE)] || {})[Math.floor(point2.y / ROOT_SIZE)];
    var result = this.root.pointShapes(point2);
    if (sectorRoot) {
      result = result.concat(sectorRoot.pointShapes(point2));
    }
    this.assignZindex(result);
    result.sort(zIndexComparer);
    for (var idx = 0; idx < result.length; idx++) {
      if (result[idx].containsPoint(point2)) {
        return result[idx];
      }
    }
  };
  ShapesQuadTree2.prototype.assignZindex = function assignZindex(elements) {
    var this$1 = this;
    for (var idx = 0; idx < elements.length; idx++) {
      var element = elements[idx];
      var zIndex = 0;
      var levelWeight = Math.pow(LEVEL_STEP, MAX_LEVEL);
      var parents = [];
      while (element) {
        parents.push(element);
        element = element.parent;
      }
      while (parents.length) {
        element = parents.pop();
        zIndex += ((element.parent ? element.parent.children : this$1.rootElements).indexOf(element) + 1) * levelWeight;
        levelWeight /= LEVEL_STEP;
      }
      elements[idx]._zIndex = zIndex;
    }
  };
  ShapesQuadTree2.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "transform" || e.field === "stroke.width") {
      this.bboxChange(e.element);
    }
  };
  ShapesQuadTree2.prototype.geometryChange = function geometryChange(e) {
    this.bboxChange(e.element);
  };
  ShapesQuadTree2.prototype.bboxChange = function bboxChange(element) {
    var this$1 = this;
    if (element.nodeType === "Group") {
      for (var idx = 0; idx < element.children.length; idx++) {
        this$1.bboxChange(element.children[idx]);
      }
    } else {
      if (element._quadNode) {
        element._quadNode.remove(element);
      }
      this._insertShape(element);
    }
  };
  ShapesQuadTree2.prototype.add = function add3(elements) {
    var elementsArray = Array.isArray(elements) ? elements.slice(0) : [elements];
    append(this.rootElements, elementsArray);
    this._insert(elementsArray);
  };
  ShapesQuadTree2.prototype.childrenChange = function childrenChange(e) {
    var this$1 = this;
    if (e.action === "remove") {
      for (var idx = 0; idx < e.items.length; idx++) {
        this$1.remove(e.items[idx]);
      }
    } else {
      this._insert(Array.prototype.slice.call(e.items, 0));
    }
  };
  ShapesQuadTree2.prototype._insert = function _insert(elements) {
    var this$1 = this;
    var element;
    while (elements.length > 0) {
      element = elements.pop();
      element.addObserver(this$1);
      if (element.nodeType === "Group") {
        append(elements, element.children);
      } else {
        this$1._insertShape(element);
      }
    }
  };
  ShapesQuadTree2.prototype._insertShape = function _insertShape(shape2) {
    var bbox = shape2.bbox();
    if (bbox) {
      var sectors = this.getSectors(bbox);
      var x = sectors[0][0];
      var y = sectors[1][0];
      if (this.inRoot(sectors)) {
        this.root.insert(shape2, bbox);
      } else {
        var rootMap = this.rootMap;
        if (!rootMap[x]) {
          rootMap[x] = {};
        }
        if (!rootMap[x][y]) {
          rootMap[x][y] = new quad_node_default(
            new rect_default([x * ROOT_SIZE, y * ROOT_SIZE], [ROOT_SIZE, ROOT_SIZE])
          );
        }
        rootMap[x][y].insert(shape2, bbox);
      }
    }
  };
  ShapesQuadTree2.prototype.remove = function remove(element) {
    var this$1 = this;
    element.removeObserver(this);
    if (element.nodeType === "Group") {
      var children = element.children;
      for (var idx = 0; idx < children.length; idx++) {
        this$1.remove(children[idx]);
      }
    } else if (element._quadNode) {
      element._quadNode.remove(element);
      delete element._quadNode;
    }
  };
  ShapesQuadTree2.prototype.inRoot = function inRoot(sectors) {
    return sectors[0].length > 1 || sectors[1].length > 1;
  };
  ShapesQuadTree2.prototype.getSectors = function getSectors(rect) {
    var bottomRight = rect.bottomRight();
    var bottomX = Math.floor(bottomRight.x / ROOT_SIZE);
    var bottomY = Math.floor(bottomRight.y / ROOT_SIZE);
    var sectors = [[], []];
    for (var x = Math.floor(rect.origin.x / ROOT_SIZE); x <= bottomX; x++) {
      sectors[0].push(x);
    }
    for (var y = Math.floor(rect.origin.y / ROOT_SIZE); y <= bottomY; y++) {
      sectors[1].push(y);
    }
    return sectors;
  };
  return ShapesQuadTree2;
}(class_default);
function zIndexComparer(x1, x2) {
  if (x1._zIndex < x2._zIndex) {
    return 1;
  }
  if (x1._zIndex > x2._zIndex) {
    return -1;
  }
  return 0;
}
var shapes_quad_tree_default = ShapesQuadTree;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface-cursor.js
var SurfaceCursor = function SurfaceCursor2(surface) {
  surface.bind("mouseenter", this._mouseenter.bind(this));
  surface.bind("mouseleave", this._mouseleave.bind(this));
  this.element = surface.element;
};
SurfaceCursor.prototype.clear = function clear() {
  this._resetCursor();
};
SurfaceCursor.prototype.destroy = function destroy() {
  this._resetCursor();
  delete this.element;
};
SurfaceCursor.prototype._mouseenter = function _mouseenter(e) {
  var cursor = this._shapeCursor(e);
  if (!cursor) {
    this._resetCursor();
  } else {
    if (!this._current) {
      this._defaultCursor = this._getCursor();
    }
    this._setCursor(cursor);
  }
};
SurfaceCursor.prototype._mouseleave = function _mouseleave() {
  this._resetCursor();
};
SurfaceCursor.prototype._shapeCursor = function _shapeCursor(e) {
  var shape2 = e.element;
  while (shape2 && !defined(shape2.options.cursor)) {
    shape2 = shape2.parent;
  }
  if (shape2) {
    return shape2.options.cursor;
  }
};
SurfaceCursor.prototype._getCursor = function _getCursor() {
  if (this.element) {
    return this.element.style.cursor;
  }
};
SurfaceCursor.prototype._setCursor = function _setCursor(cursor) {
  if (this.element) {
    this.element.style.cursor = cursor;
    this._current = cursor;
  }
};
SurfaceCursor.prototype._resetCursor = function _resetCursor() {
  if (this._current) {
    this._setCursor(this._defaultCursor || "");
    delete this._current;
  }
};
var surface_cursor_default = SurfaceCursor;

// node_modules/@progress/kendo-drawing/dist/es/canvas/path-node.js
function addGradientStops(gradient, stops) {
  for (var idx = 0; idx < stops.length; idx++) {
    var stop = stops[idx];
    var color = parseColor(stop.color());
    color.a *= stop.opacity();
    gradient.addColorStop(stop.offset(), color.toCssRgba());
  }
}
var PathNode2 = function(Node4) {
  function PathNode3() {
    Node4.apply(this, arguments);
  }
  if (Node4)
    PathNode3.__proto__ = Node4;
  PathNode3.prototype = Object.create(Node4 && Node4.prototype);
  PathNode3.prototype.constructor = PathNode3;
  PathNode3.prototype.renderTo = function renderTo(ctx) {
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    this.renderPoints(ctx, this.srcElement);
    this.setLineDash(ctx);
    this.setLineCap(ctx);
    this.setLineJoin(ctx);
    this.setFill(ctx);
    this.setStroke(ctx);
    ctx.restore();
  };
  PathNode3.prototype.setFill = function setFill(ctx) {
    var fill = this.srcElement.options.fill;
    var hasFill = false;
    if (fill) {
      if (fill.nodeType === "Gradient") {
        this.setGradientFill(ctx, fill);
        hasFill = true;
      } else if (!isTransparent(fill.color)) {
        ctx.fillStyle = fill.color;
        ctx.save();
        this.globalAlpha(ctx, fill.opacity);
        ctx.fill();
        ctx.restore();
        hasFill = true;
      }
    }
    return hasFill;
  };
  PathNode3.prototype.setGradientFill = function setGradientFill(ctx, fill) {
    var bbox = this.srcElement.rawBBox();
    var gradient;
    if (fill instanceof linear_gradient_default) {
      var start = fill.start();
      var end = fill.end();
      gradient = ctx.createLinearGradient(start.x, start.y, end.x, end.y);
    } else if (fill instanceof radial_gradient_default) {
      var center = fill.center();
      gradient = ctx.createRadialGradient(center.x, center.y, 0, center.x, center.y, fill.radius());
    }
    addGradientStops(gradient, fill.stops);
    ctx.save();
    if (!fill.userSpace()) {
      ctx.transform(bbox.width(), 0, 0, bbox.height(), bbox.origin.x, bbox.origin.y);
    }
    ctx.fillStyle = gradient;
    ctx.fill();
    ctx.restore();
  };
  PathNode3.prototype.setStroke = function setStroke(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && !isTransparent(stroke.color) && stroke.width > 0) {
      ctx.strokeStyle = stroke.color;
      ctx.lineWidth = valueOrDefault(stroke.width, 1);
      ctx.save();
      this.globalAlpha(ctx, stroke.opacity);
      ctx.stroke();
      ctx.restore();
      return true;
    }
  };
  PathNode3.prototype.dashType = function dashType() {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.dashType) {
      return stroke.dashType.toLowerCase();
    }
  };
  PathNode3.prototype.setLineDash = function setLineDash(ctx) {
    var dashType = this.dashType();
    if (dashType && dashType !== SOLID) {
      var dashArray = DASH_ARRAYS[dashType];
      if (ctx.setLineDash) {
        ctx.setLineDash(dashArray);
      } else {
        ctx.mozDash = dashArray;
        ctx.webkitLineDash = dashArray;
      }
    }
  };
  PathNode3.prototype.setLineCap = function setLineCap(ctx) {
    var dashType = this.dashType();
    var stroke = this.srcElement.options.stroke;
    if (dashType && dashType !== SOLID) {
      ctx.lineCap = BUTT;
    } else if (stroke && stroke.lineCap) {
      ctx.lineCap = stroke.lineCap;
    }
  };
  PathNode3.prototype.setLineJoin = function setLineJoin(ctx) {
    var stroke = this.srcElement.options.stroke;
    if (stroke && stroke.lineJoin) {
      ctx.lineJoin = stroke.lineJoin;
    }
  };
  PathNode3.prototype.renderPoints = function renderPoints(ctx, path) {
    renderPath(ctx, path);
  };
  return PathNode3;
}(node_default2);
var path_node_default2 = PathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/arc-node.js
var ArcNode2 = function(PathNode3) {
  function ArcNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    ArcNode3.__proto__ = PathNode3;
  ArcNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ArcNode3.prototype.constructor = ArcNode3;
  ArcNode3.prototype.renderPoints = function renderPoints(ctx) {
    var path = this.srcElement.toPath();
    renderPath(ctx, path);
  };
  return ArcNode3;
}(path_node_default2);
var arc_node_default2 = ArcNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/circle-node.js
var CircleNode2 = function(PathNode3) {
  function CircleNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    CircleNode3.__proto__ = PathNode3;
  CircleNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  CircleNode3.prototype.constructor = CircleNode3;
  CircleNode3.prototype.renderPoints = function renderPoints(ctx) {
    var ref2 = this.srcElement.geometry();
    var center = ref2.center;
    var radius = ref2.radius;
    ctx.arc(center.x, center.y, radius, 0, Math.PI * 2);
  };
  return CircleNode3;
}(path_node_default2);
var circle_node_default2 = CircleNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/image-node.js
var ImageNode2 = function(PathNode3) {
  function ImageNode3(srcElement, cors) {
    PathNode3.call(this, srcElement);
    this.onLoad = this.onLoad.bind(this);
    this.onError = this.onError.bind(this);
    this.loading = createPromise();
    var img = this.img = new Image();
    var src = srcElement.src();
    if (cors && !/^data:/i.test(src)) {
      img.crossOrigin = cors;
    }
    if (src) {
      img.src = src;
    }
    if (img.complete) {
      this.onLoad();
    } else {
      img.onload = this.onLoad;
      img.onerror = this.onError;
    }
  }
  if (PathNode3)
    ImageNode3.__proto__ = PathNode3;
  ImageNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  ImageNode3.prototype.constructor = ImageNode3;
  ImageNode3.prototype.renderTo = function renderTo(ctx) {
    if (this.loading.state() === "resolved") {
      ctx.save();
      this.setTransform(ctx);
      this.setClip(ctx);
      this.drawImage(ctx);
      ctx.restore();
    }
  };
  ImageNode3.prototype.optionsChange = function optionsChange(e) {
    if (e.field === "src") {
      this.loading = createPromise();
      this.img.src = this.srcElement.src();
    } else {
      PathNode3.prototype.optionsChange.call(this, e);
    }
  };
  ImageNode3.prototype.onLoad = function onLoad() {
    this.loading.resolve();
    this.invalidate();
  };
  ImageNode3.prototype.onError = function onError() {
    this.loading.reject(new Error(
      "Unable to load image '" + this.img.src + "'. Check for connectivity and verify CORS headers."
    ));
  };
  ImageNode3.prototype.drawImage = function drawImage(ctx) {
    var rect = this.srcElement.rect();
    var topLeft = rect.topLeft();
    ctx.drawImage(
      this.img,
      topLeft.x,
      topLeft.y,
      rect.width(),
      rect.height()
    );
  };
  return ImageNode3;
}(path_node_default2);
var image_node_default2 = ImageNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/multi-path-node.js
var MultiPathNode2 = function(PathNode3) {
  function MultiPathNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    MultiPathNode3.__proto__ = PathNode3;
  MultiPathNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  MultiPathNode3.prototype.constructor = MultiPathNode3;
  MultiPathNode3.prototype.renderPoints = function renderPoints(ctx) {
    var paths = this.srcElement.paths;
    for (var i = 0; i < paths.length; i++) {
      renderPath(ctx, paths[i]);
    }
  };
  return MultiPathNode3;
}(path_node_default2);
var multi_path_node_default2 = MultiPathNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/rect-node.js
var RectNode2 = function(PathNode3) {
  function RectNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    RectNode3.__proto__ = PathNode3;
  RectNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  RectNode3.prototype.constructor = RectNode3;
  RectNode3.prototype.renderPoints = function renderPoints(ctx) {
    var geometry = this.srcElement.geometry();
    var ref2 = geometry.cornerRadius;
    var rx = ref2[0];
    var ry = ref2[1];
    if (rx === 0 && ry === 0) {
      var origin = geometry.origin;
      var size = geometry.size;
      ctx.rect(origin.x, origin.y, size.width, size.height);
    } else {
      PathNode3.prototype.renderPoints.call(this, ctx, Path.fromRect(geometry));
    }
  };
  return RectNode3;
}(path_node_default2);
var rect_node_default2 = RectNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/text-node.js
var TextNode2 = function(PathNode3) {
  function TextNode3() {
    PathNode3.apply(this, arguments);
  }
  if (PathNode3)
    TextNode3.__proto__ = PathNode3;
  TextNode3.prototype = Object.create(PathNode3 && PathNode3.prototype);
  TextNode3.prototype.constructor = TextNode3;
  TextNode3.prototype.renderTo = function renderTo(ctx) {
    var text = this.srcElement;
    var pos = text.position();
    var size = text.measure();
    ctx.save();
    this.setTransform(ctx);
    this.setClip(ctx);
    this.setOpacity(ctx);
    ctx.beginPath();
    ctx.font = text.options.font;
    ctx.textAlign = "left";
    if (this.setFill(ctx)) {
      ctx.fillText(text.content(), pos.x, pos.y + size.baseline);
    }
    if (this.setStroke(ctx)) {
      this.setLineDash(ctx);
      ctx.strokeText(text.content(), pos.x, pos.y + size.baseline);
    }
    ctx.restore();
  };
  return TextNode3;
}(path_node_default2);
var text_node_default2 = TextNode2;

// node_modules/@progress/kendo-drawing/dist/es/canvas/surface.js
node_map_default2.Arc = arc_node_default2;
node_map_default2.Circle = circle_node_default2;
node_map_default2.Group = group_node_default2;
node_map_default2.Image = image_node_default2;
node_map_default2.MultiPath = multi_path_node_default2;
node_map_default2.Path = path_node_default2;
node_map_default2.Rect = rect_node_default2;
node_map_default2.Text = text_node_default2;
var Surface3 = function(BaseSurface) {
  function Surface6(element, options2) {
    BaseSurface.call(this, element, options2);
    this.element.innerHTML = this._template(this);
    var canvas = this.element.firstElementChild;
    canvas.style.width = "100%";
    canvas.style.height = "100%";
    var size = elementSize(element);
    canvas.width = size.width;
    canvas.height = size.height;
    this._rootElement = canvas;
    this._root = new root_node_default2(canvas, size);
    this._mouseTrackHandler = this._trackMouse.bind(this);
    bindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var prototypeAccessors4 = { type: { configurable: true } };
  prototypeAccessors4.type.get = function() {
    return "canvas";
  };
  Surface6.prototype.destroy = function destroy2() {
    BaseSurface.prototype.destroy.call(this);
    if (this._root) {
      this._root.destroy();
      this._root = null;
    }
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
    if (this._cursor) {
      this._cursor.destroy();
      delete this._cursor;
    }
    unbindEvents(this.element, {
      click: this._mouseTrackHandler,
      mousemove: this._mouseTrackHandler
    });
  };
  Surface6.prototype.draw = function draw(element) {
    BaseSurface.prototype.draw.call(this, element);
    this._root.load([element], void 0, this.options.cors);
    if (this._searchTree) {
      this._searchTree.add([element]);
    }
  };
  Surface6.prototype.clear = function clear4() {
    BaseSurface.prototype.clear.call(this);
    this._root.clear();
    if (this._searchTree) {
      this._searchTree.clear();
    }
    if (this._cursor) {
      this._cursor.clear();
    }
  };
  Surface6.prototype.eventTarget = function eventTarget(e) {
    if (this._searchTree) {
      var point2 = this._surfacePoint(e);
      var shape2 = this._searchTree.pointShape(point2);
      return shape2;
    }
  };
  Surface6.prototype.image = function image() {
    var ref2 = this;
    var root = ref2._root;
    var rootElement = ref2._rootElement;
    var loadingStates = [];
    root.traverse(function(childNode) {
      if (childNode.loading) {
        loadingStates.push(childNode.loading);
      }
    });
    var promise = createPromise();
    var resolveDataURL = function() {
      root._invalidate({ fixedScale: true });
      try {
        var data = rootElement.toDataURL();
        promise.resolve(data);
      } catch (e) {
        promise.reject(e);
      }
    };
    promiseAll(loadingStates).then(resolveDataURL, resolveDataURL);
    return promise;
  };
  Surface6.prototype.suspendTracking = function suspendTracking() {
    BaseSurface.prototype.suspendTracking.call(this);
    if (this._searchTree) {
      this._searchTree.clear();
      delete this._searchTree;
    }
  };
  Surface6.prototype.resumeTracking = function resumeTracking() {
    BaseSurface.prototype.resumeTracking.call(this);
    if (!this._searchTree) {
      this._searchTree = new shapes_quad_tree_default();
      var childNodes = this._root.childNodes;
      var rootElements = [];
      for (var idx = 0; idx < childNodes.length; idx++) {
        rootElements.push(childNodes[idx].srcElement);
      }
      this._searchTree.add(rootElements);
    }
  };
  Surface6.prototype._resize = function _resize() {
    this._rootElement.width = this._size.width;
    this._rootElement.height = this._size.height;
    this._root.size = this._size;
    this._root.invalidate();
  };
  Surface6.prototype._template = function _template() {
    return "<canvas></canvas>";
  };
  Surface6.prototype._enableTracking = function _enableTracking() {
    this._searchTree = new shapes_quad_tree_default();
    this._cursor = new surface_cursor_default(this);
    BaseSurface.prototype._enableTracking.call(this);
  };
  Surface6.prototype._trackMouse = function _trackMouse(e) {
    if (this._suspendedTracking) {
      return;
    }
    var shape2 = this.eventTarget(e);
    if (e.type !== "click") {
      var currentShape = this._currentShape;
      if (currentShape && currentShape !== shape2) {
        this.trigger("mouseleave", {
          element: currentShape,
          originalEvent: e,
          type: "mouseleave"
        });
      }
      if (shape2 && currentShape !== shape2) {
        this.trigger("mouseenter", {
          element: shape2,
          originalEvent: e,
          type: "mouseenter"
        });
      }
      this.trigger("mousemove", {
        element: shape2,
        originalEvent: e,
        type: "mousemove"
      });
      this._currentShape = shape2;
    } else if (shape2) {
      this.trigger("click", {
        element: shape2,
        originalEvent: e,
        type: "click"
      });
    }
  };
  Object.defineProperties(Surface6.prototype, prototypeAccessors4);
  return Surface6;
}(surface_default);
var surface_default3 = Surface3;

// node_modules/@progress/kendo-drawing/dist/es/surface-factory.js
var instance3;
var support2;
var hasDocument = function() {
  return typeof document !== "undefined";
};
var supportsCanvas = function() {
  return hasDocument() && document.createElement("canvas").getContext;
};
var supportsSVG = function() {
  return hasDocument() && document.implementation.hasFeature("http://www.w3.org/TR/SVG11/feature#BasicStructure", "1.1");
};
var SurfaceFactory = function(Class3) {
  function SurfaceFactory2() {
    Class3.call(this);
    this._items = [{
      name: "svg",
      type: surface_default2
    }, {
      name: "canvas",
      type: surface_default3
    }];
  }
  if (Class3)
    SurfaceFactory2.__proto__ = Class3;
  SurfaceFactory2.prototype = Object.create(Class3 && Class3.prototype);
  SurfaceFactory2.prototype.constructor = SurfaceFactory2;
  var staticAccessors2 = { support: { configurable: true }, current: { configurable: true } };
  staticAccessors2.support.get = function() {
    if (!support2) {
      support2 = {
        canvas: supportsCanvas(),
        svg: supportsSVG()
      };
    }
    return support2;
  };
  staticAccessors2.current.get = function() {
    if (!instance3) {
      instance3 = new SurfaceFactory2();
    }
    return instance3;
  };
  SurfaceFactory2.prototype.create = function create2(element, options2) {
    var items = this._items;
    var match = items[0];
    if (options2 && options2.type) {
      var preferred = options2.type.toLowerCase();
      for (var i = 0; i < items.length; i++) {
        if (items[i].name === preferred) {
          match = items[i];
          break;
        }
      }
    }
    if (match) {
      return new match.type(element, options2);
    }
    logToConsole(
      "Warning: Unable to create Kendo UI Drawing Surface. Possible causes:\n- The browser does not support SVG and Canvas. User agent: " + navigator.userAgent
    );
  };
  Object.defineProperties(SurfaceFactory2, staticAccessors2);
  return SurfaceFactory2;
}(class_default);
var surface_factory_default = SurfaceFactory;

// node_modules/@progress/kendo-drawing/dist/es/surface.js
var Surface4 = function(BaseSurface) {
  function Surface6() {
    BaseSurface.apply(this, arguments);
  }
  if (BaseSurface)
    Surface6.__proto__ = BaseSurface;
  Surface6.prototype = Object.create(BaseSurface && BaseSurface.prototype);
  Surface6.prototype.constructor = Surface6;
  var staticAccessors2 = { support: { configurable: true } };
  staticAccessors2.support.get = function() {
    return surface_factory_default.support;
  };
  Surface6.create = function create2(element, options2) {
    return surface_factory_default.current.create(element, options2);
  };
  Object.defineProperties(Surface6, staticAccessors2);
  return Surface6;
}(surface_default);
var surface_default4 = Surface4;

// node_modules/@progress/kendo-drawing/dist/es/svg.js
var svg_exports = {};
__export(svg_exports, {
  ArcNode: () => arc_node_default,
  CircleNode: () => circle_node_default,
  ClipNode: () => clip_node_default,
  DefinitionNode: () => definition_node_default,
  GradientStopNode: () => gradient_stop_node_default,
  GroupNode: () => group_node_default,
  ImageNode: () => image_node_default,
  LinearGradientNode: () => linear_gradient_node_default,
  MultiPathNode: () => multi_path_node_default,
  Node: () => node_default,
  PathNode: () => path_node_default,
  RadialGradientNode: () => radial_gradient_node_default,
  RectNode: () => rect_node_default,
  RootNode: () => root_node_default,
  Surface: () => surface_default2,
  TextNode: () => text_node_default,
  exportGroup: () => exportGroup
});

// node_modules/@progress/kendo-drawing/dist/es/svg/export-group.js
function exportGroup(group) {
  var root = new root_node_default({
    skipBaseHref: true
  });
  var bbox = group.clippedBBox();
  var rootGroup = group;
  if (bbox) {
    var origin = bbox.getOrigin();
    var exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    rootGroup = exportRoot;
  }
  root.load([rootGroup]);
  var svg = "<?xml version='1.0' ?><svg xmlns='" + SVG_NS + "' xmlns:xlink='http://www.w3.org/1999/xlink' version='1.1'>" + root.render() + "</svg>";
  root.destroy();
  return svg;
}

// node_modules/@progress/kendo-drawing/dist/es/canvas.js
var canvas_exports = {};
__export(canvas_exports, {
  ArcNode: () => arc_node_default2,
  CircleNode: () => circle_node_default2,
  GroupNode: () => group_node_default2,
  ImageNode: () => image_node_default2,
  MultiPathNode: () => multi_path_node_default2,
  Node: () => node_default2,
  PathNode: () => path_node_default2,
  RectNode: () => rect_node_default2,
  RootNode: () => root_node_default2,
  Surface: () => surface_default3,
  TextNode: () => text_node_default2
});

// node_modules/@progress/kendo-drawing/dist/es/canvas/export-image.js
function exportImage(group, options2) {
  var defaults = {
    width: "800px",
    height: "600px",
    cors: "Anonymous"
  };
  var exportRoot = group;
  var bbox = group.clippedBBox();
  if (bbox) {
    var origin = bbox.getOrigin();
    exportRoot = new group_default();
    exportRoot.transform(transform().translate(-origin.x, -origin.y));
    exportRoot.children.push(group);
    var size = bbox.getSize();
    defaults.width = size.width + "px";
    defaults.height = size.height + "px";
  }
  var surfaceOptions = Object.assign(defaults, options2);
  var container = document.createElement("div");
  var style = container.style;
  style.display = "none";
  style.width = surfaceOptions.width;
  style.height = surfaceOptions.height;
  document.body.appendChild(container);
  var surface = new surface_default3(container, surfaceOptions);
  surface.suspendTracking();
  surface.draw(exportRoot);
  var promise = surface.image();
  var destroy2 = function() {
    surface.destroy();
    document.body.removeChild(container);
  };
  promise.then(destroy2, destroy2);
  return promise;
}

// node_modules/@progress/kendo-drawing/dist/es/svg/export-svg.js
function exportSVG(group, options2) {
  var svg = exportGroup(group);
  if (!options2 || !options2.raw) {
    svg = "data:image/svg+xml;base64," + encodeBase64(svg);
  }
  return createPromise().resolve(svg);
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/utils.js
var HAS_TYPED_ARRAYS = typeof Uint8Array !== "undefined" && support_default.browser && (!support_default.browser.msie || support_default.browser.version > 9);
var BASE64 = function() {
  var keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
  return {
    decode: function(str) {
      var input = str.replace(/[^A-Za-z0-9\+\/\=]/g, ""), i = 0, n = input.length, output = [];
      while (i < n) {
        var enc1 = keyStr.indexOf(input.charAt(i++));
        var enc2 = keyStr.indexOf(input.charAt(i++));
        var enc3 = keyStr.indexOf(input.charAt(i++));
        var enc4 = keyStr.indexOf(input.charAt(i++));
        var chr1 = enc1 << 2 | enc2 >>> 4;
        var chr2 = (enc2 & 15) << 4 | enc3 >>> 2;
        var chr3 = (enc3 & 3) << 6 | enc4;
        output.push(chr1);
        if (enc3 != 64) {
          output.push(chr2);
        }
        if (enc4 != 64) {
          output.push(chr3);
        }
      }
      return output;
    },
    encode: function(bytes) {
      var i = 0, n = bytes.length;
      var output = "";
      while (i < n) {
        var chr1 = bytes[i++];
        var chr2 = bytes[i++];
        var chr3 = bytes[i++];
        var enc1 = chr1 >>> 2;
        var enc2 = (chr1 & 3) << 4 | chr2 >>> 4;
        var enc3 = (chr2 & 15) << 2 | chr3 >>> 6;
        var enc4 = chr3 & 63;
        if (i - n == 2) {
          enc3 = enc4 = 64;
        } else if (i - n == 1) {
          enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
      }
      return output;
    }
  };
}();
function BinaryStream(data) {
  var offset = 0, length = 0;
  if (data == null) {
    data = HAS_TYPED_ARRAYS ? new Uint8Array(256) : [];
  } else {
    length = data.length;
  }
  var ensure = HAS_TYPED_ARRAYS ? function(len) {
    if (len >= data.length) {
      var tmp = new Uint8Array(Math.max(len + 256, data.length * 2));
      tmp.set(data, 0);
      data = tmp;
    }
  } : function() {
  };
  var get2 = HAS_TYPED_ARRAYS ? function() {
    return new Uint8Array(data.buffer, 0, length);
  } : function() {
    return data;
  };
  var write = HAS_TYPED_ARRAYS ? function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    var len = bytes.length;
    ensure(offset + len);
    data.set(bytes, offset);
    offset += len;
    if (offset > length) {
      length = offset;
    }
  } : function(bytes) {
    if (typeof bytes == "string") {
      return writeString(bytes);
    }
    for (var i = 0; i < bytes.length; ++i) {
      writeByte(bytes[i]);
    }
  };
  var slice3 = HAS_TYPED_ARRAYS ? function(start, length2) {
    if (data.buffer.slice) {
      return new Uint8Array(data.buffer.slice(start, start + length2));
    } else {
      var x = new Uint8Array(length2);
      x.set(new Uint8Array(data.buffer, start, length2));
      return x;
    }
  } : function(start, length2) {
    return data.slice(start, start + length2);
  };
  function eof() {
    return offset >= length;
  }
  function readByte() {
    return offset < length ? data[offset++] : 0;
  }
  function writeByte(b) {
    ensure(offset);
    data[offset++] = b & 255;
    if (offset > length) {
      length = offset;
    }
  }
  function readShort() {
    return readByte() << 8 | readByte();
  }
  function writeShort(w) {
    writeByte(w >> 8);
    writeByte(w);
  }
  function readShort_() {
    var w = readShort();
    return w >= 32768 ? w - 65536 : w;
  }
  function writeShort_(w) {
    writeShort(w < 0 ? w + 65536 : w);
  }
  function readLong() {
    return readShort() * 65536 + readShort();
  }
  function writeLong(w) {
    writeShort(w >>> 16 & 65535);
    writeShort(w & 65535);
  }
  function readLong_() {
    var w = readLong();
    return w >= 2147483648 ? w - 4294967296 : w;
  }
  function writeLong_(w) {
    writeLong(w < 0 ? w + 4294967296 : w);
  }
  function readFixed() {
    return readLong() / 65536;
  }
  function writeFixed(f) {
    writeLong(Math.round(f * 65536));
  }
  function readFixed_() {
    return readLong_() / 65536;
  }
  function writeFixed_(f) {
    writeLong_(Math.round(f * 65536));
  }
  function read(len) {
    return times(len, readByte);
  }
  function readString(len) {
    return String.fromCharCode.apply(String, read(len));
  }
  function writeString(str) {
    for (var i = 0; i < str.length; ++i) {
      writeByte(str.charCodeAt(i));
    }
  }
  function times(n, reader) {
    for (var ret = new Array(n), i = 0; i < n; ++i) {
      ret[i] = reader();
    }
    return ret;
  }
  var stream2 = {
    eof,
    readByte,
    writeByte,
    readShort,
    writeShort,
    readLong,
    writeLong,
    readFixed,
    writeFixed,
    // signed numbers.
    readShort_,
    writeShort_,
    readLong_,
    writeLong_,
    readFixed_,
    writeFixed_,
    read,
    write,
    readString,
    writeString,
    times,
    get: get2,
    slice: slice3,
    offset: function(pos) {
      if (pos != null) {
        offset = pos;
        return stream2;
      }
      return offset;
    },
    skip: function(nbytes) {
      offset += nbytes;
    },
    toString: function() {
      throw new Error("FIX CALLER.  BinaryStream is no longer convertible to string!");
    },
    length: function() {
      return length;
    },
    saveExcursion: function(f) {
      var pos = offset;
      try {
        return f();
      } finally {
        offset = pos;
      }
    },
    writeBase64: function(base64) {
      if (window.atob) {
        writeString(window.atob(base64));
      } else {
        write(BASE64.decode(base64));
      }
    },
    base64: function() {
      return BASE64.encode(get2());
    }
  };
  return stream2;
}
function ucs2decode(string8) {
  var output = [], counter = 0, length = string8.length, value, extra;
  while (counter < length) {
    value = string8.charCodeAt(counter++);
    if (value >= 55296 && value <= 56319 && counter < length) {
      extra = string8.charCodeAt(counter++);
      if ((extra & 64512) == 56320) {
        output.push(((value & 1023) << 10) + (extra & 1023) + 65536);
      } else {
        output.push(value);
        counter--;
      }
    } else {
      output.push(value);
    }
  }
  return output;
}
function ucs2encode(array) {
  return array.map(function(value) {
    var output = "";
    if (value > 65535) {
      value -= 65536;
      output += String.fromCharCode(value >>> 10 & 1023 | 55296);
      value = 56320 | value & 1023;
    }
    output += String.fromCharCode(value);
    return output;
  }).join("");
}
function atobUint8Array(base64) {
  var data = window.atob(base64);
  var result = new Uint8Array(data.length);
  for (var idx = 0; idx < data.length; idx++) {
    result[idx] = data.charCodeAt(idx);
  }
  return result;
}
function createUint8Array(data) {
  var result = new Uint8Array(data.length);
  for (var idx = 0; idx < data.length; idx++) {
    result[idx] = data[idx];
  }
  return result;
}
function base64ToUint8Array(base64) {
  if (window.atob) {
    return atobUint8Array(base64);
  }
  return createUint8Array(BASE64.decode(base64));
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/ttf.js
function hasOwnProperty(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function sortedKeys(obj) {
  return Object.keys(obj).sort(function(a, b) {
    return a - b;
  }).map(parseFloat);
}
var Directory = function Directory2(data) {
  this.raw = data;
  this.scalerType = data.readLong();
  this.tableCount = data.readShort();
  this.searchRange = data.readShort();
  this.entrySelector = data.readShort();
  this.rangeShift = data.readShort();
  var tables = this.tables = {};
  for (var i = 0; i < this.tableCount; ++i) {
    var entry = {
      tag: data.readString(4),
      checksum: data.readLong(),
      offset: data.readLong(),
      length: data.readLong()
    };
    tables[entry.tag] = entry;
  }
};
Directory.prototype.readTable = function readTable(name3, Ctor) {
  var def = this.tables[name3];
  if (!def) {
    throw new Error("Table " + name3 + " not found in directory");
  }
  return this[name3] = def.table = new Ctor(this, def);
};
Directory.prototype.render = function render(tables) {
  var this$1 = this;
  var tableCount = Object.keys(tables).length;
  var maxpow2 = Math.pow(2, Math.floor(Math.log(tableCount) / Math.LN2));
  var searchRange = maxpow2 * 16;
  var entrySelector = Math.floor(Math.log(maxpow2) / Math.LN2);
  var rangeShift = tableCount * 16 - searchRange;
  var out = BinaryStream();
  out.writeLong(this.scalerType);
  out.writeShort(tableCount);
  out.writeShort(searchRange);
  out.writeShort(entrySelector);
  out.writeShort(rangeShift);
  var directoryLength = tableCount * 16;
  var offset = out.offset() + directoryLength;
  var headOffset = null;
  var tableData = BinaryStream();
  for (var tag in tables) {
    if (hasOwnProperty(tables, tag)) {
      var table = tables[tag];
      out.writeString(tag);
      out.writeLong(this$1.checksum(table));
      out.writeLong(offset);
      out.writeLong(table.length);
      tableData.write(table);
      if (tag == "head") {
        headOffset = offset;
      }
      offset += table.length;
      while (offset % 4) {
        tableData.writeByte(0);
        offset++;
      }
    }
  }
  out.write(tableData.get());
  var sum = this.checksum(out.get());
  var adjustment = 2981146554 - sum;
  out.offset(headOffset + 8);
  out.writeLong(adjustment);
  return out.get();
};
Directory.prototype.checksum = function checksum(data) {
  data = BinaryStream(data);
  var sum = 0;
  while (!data.eof()) {
    sum += data.readLong();
  }
  return sum & 4294967295;
};
var Table = function Table2(file, def) {
  this.definition = def;
  this.length = def.length;
  this.offset = def.offset;
  this.file = file;
  this.rawData = file.raw;
  this.parse(file.raw);
};
Table.prototype.raw = function raw() {
  return this.rawData.slice(this.offset, this.length);
};
Table.prototype.parse = function parse() {
};
var HeadTable = function(Table3) {
  function HeadTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    HeadTable2.__proto__ = Table3;
  HeadTable2.prototype = Object.create(Table3 && Table3.prototype);
  HeadTable2.prototype.constructor = HeadTable2;
  HeadTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.revision = data.readLong();
    this.checkSumAdjustment = data.readLong();
    this.magicNumber = data.readLong();
    this.flags = data.readShort();
    this.unitsPerEm = data.readShort();
    this.created = data.read(8);
    this.modified = data.read(8);
    this.xMin = data.readShort_();
    this.yMin = data.readShort_();
    this.xMax = data.readShort_();
    this.yMax = data.readShort_();
    this.macStyle = data.readShort();
    this.lowestRecPPEM = data.readShort();
    this.fontDirectionHint = data.readShort_();
    this.indexToLocFormat = data.readShort_();
    this.glyphDataFormat = data.readShort_();
  };
  HeadTable2.prototype.render = function render3(indexToLocFormat) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeLong(this.revision);
    out.writeLong(0);
    out.writeLong(this.magicNumber);
    out.writeShort(this.flags);
    out.writeShort(this.unitsPerEm);
    out.write(this.created);
    out.write(this.modified);
    out.writeShort_(this.xMin);
    out.writeShort_(this.yMin);
    out.writeShort_(this.xMax);
    out.writeShort_(this.yMax);
    out.writeShort(this.macStyle);
    out.writeShort(this.lowestRecPPEM);
    out.writeShort_(this.fontDirectionHint);
    out.writeShort_(indexToLocFormat);
    out.writeShort_(this.glyphDataFormat);
    return out.get();
  };
  return HeadTable2;
}(Table);
var LocaTable = function(Table3) {
  function LocaTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    LocaTable2.__proto__ = Table3;
  LocaTable2.prototype = Object.create(Table3 && Table3.prototype);
  LocaTable2.prototype.constructor = LocaTable2;
  LocaTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    var format2 = this.file.head.indexToLocFormat;
    if (format2 === 0) {
      this.offsets = data.times(this.length / 2, function() {
        return 2 * data.readShort();
      });
    } else {
      this.offsets = data.times(this.length / 4, data.readLong);
    }
  };
  LocaTable2.prototype.offsetOf = function offsetOf(id) {
    return this.offsets[id];
  };
  LocaTable2.prototype.lengthOf = function lengthOf(id) {
    return this.offsets[id + 1] - this.offsets[id];
  };
  LocaTable2.prototype.render = function render3(offsets) {
    var out = BinaryStream();
    var needsLongFormat = offsets[offsets.length - 1] > 65535;
    for (var i = 0; i < offsets.length; ++i) {
      if (needsLongFormat) {
        out.writeLong(offsets[i]);
      } else {
        out.writeShort(offsets[i] / 2);
      }
    }
    return {
      format: needsLongFormat ? 1 : 0,
      table: out.get()
    };
  };
  return LocaTable2;
}(Table);
var HheaTable = function(Table3) {
  function HheaTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    HheaTable2.__proto__ = Table3;
  HheaTable2.prototype = Object.create(Table3 && Table3.prototype);
  HheaTable2.prototype.constructor = HheaTable2;
  HheaTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.ascent = data.readShort_();
    this.descent = data.readShort_();
    this.lineGap = data.readShort_();
    this.advanceWidthMax = data.readShort();
    this.minLeftSideBearing = data.readShort_();
    this.minRightSideBearing = data.readShort_();
    this.xMaxExtent = data.readShort_();
    this.caretSlopeRise = data.readShort_();
    this.caretSlopeRun = data.readShort_();
    this.caretOffset = data.readShort_();
    data.skip(4 * 2);
    this.metricDataFormat = data.readShort_();
    this.numOfLongHorMetrics = data.readShort();
  };
  HheaTable2.prototype.render = function render3(ids) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort_(this.ascent);
    out.writeShort_(this.descent);
    out.writeShort_(this.lineGap);
    out.writeShort(this.advanceWidthMax);
    out.writeShort_(this.minLeftSideBearing);
    out.writeShort_(this.minRightSideBearing);
    out.writeShort_(this.xMaxExtent);
    out.writeShort_(this.caretSlopeRise);
    out.writeShort_(this.caretSlopeRun);
    out.writeShort_(this.caretOffset);
    out.write([0, 0, 0, 0, 0, 0, 0, 0]);
    out.writeShort_(this.metricDataFormat);
    out.writeShort(ids.length);
    return out.get();
  };
  return HheaTable2;
}(Table);
var MaxpTable = function(Table3) {
  function MaxpTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    MaxpTable2.__proto__ = Table3;
  MaxpTable2.prototype = Object.create(Table3 && Table3.prototype);
  MaxpTable2.prototype.constructor = MaxpTable2;
  MaxpTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readLong();
    this.numGlyphs = data.readShort();
    this.maxPoints = data.readShort();
    this.maxContours = data.readShort();
    this.maxComponentPoints = data.readShort();
    this.maxComponentContours = data.readShort();
    this.maxZones = data.readShort();
    this.maxTwilightPoints = data.readShort();
    this.maxStorage = data.readShort();
    this.maxFunctionDefs = data.readShort();
    this.maxInstructionDefs = data.readShort();
    this.maxStackElements = data.readShort();
    this.maxSizeOfInstructions = data.readShort();
    this.maxComponentElements = data.readShort();
    this.maxComponentDepth = data.readShort();
  };
  MaxpTable2.prototype.render = function render3(glyphIds2) {
    var out = BinaryStream();
    out.writeLong(this.version);
    out.writeShort(glyphIds2.length);
    out.writeShort(this.maxPoints);
    out.writeShort(this.maxContours);
    out.writeShort(this.maxComponentPoints);
    out.writeShort(this.maxComponentContours);
    out.writeShort(this.maxZones);
    out.writeShort(this.maxTwilightPoints);
    out.writeShort(this.maxStorage);
    out.writeShort(this.maxFunctionDefs);
    out.writeShort(this.maxInstructionDefs);
    out.writeShort(this.maxStackElements);
    out.writeShort(this.maxSizeOfInstructions);
    out.writeShort(this.maxComponentElements);
    out.writeShort(this.maxComponentDepth);
    return out.get();
  };
  return MaxpTable2;
}(Table);
var HmtxTable = function(Table3) {
  function HmtxTable2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    HmtxTable2.__proto__ = Table3;
  HmtxTable2.prototype = Object.create(Table3 && Table3.prototype);
  HmtxTable2.prototype.constructor = HmtxTable2;
  HmtxTable2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    var dir = this.file, hhea = dir.hhea;
    this.metrics = data.times(hhea.numOfLongHorMetrics, function() {
      return {
        advance: data.readShort(),
        lsb: data.readShort_()
      };
    });
    var lsbCount = dir.maxp.numGlyphs - dir.hhea.numOfLongHorMetrics;
    this.leftSideBearings = data.times(lsbCount, data.readShort_);
  };
  HmtxTable2.prototype.forGlyph = function forGlyph(id) {
    var metrics = this.metrics;
    var n = metrics.length;
    if (id < n) {
      return metrics[id];
    }
    return {
      advance: metrics[n - 1].advance,
      lsb: this.leftSideBearings[id - n]
    };
  };
  HmtxTable2.prototype.render = function render3(glyphIds2) {
    var this$1 = this;
    var out = BinaryStream();
    for (var i = 0; i < glyphIds2.length; ++i) {
      var m = this$1.forGlyph(glyphIds2[i]);
      out.writeShort(m.advance);
      out.writeShort_(m.lsb);
    }
    return out.get();
  };
  return HmtxTable2;
}(Table);
var GlyfTable = function() {
  var SimpleGlyph = function SimpleGlyph2(raw2) {
    this.raw = raw2;
  };
  var prototypeAccessors4 = { compound: { configurable: true } };
  prototypeAccessors4.compound.get = function() {
    return false;
  };
  SimpleGlyph.prototype.render = function render3() {
    return this.raw.get();
  };
  Object.defineProperties(SimpleGlyph.prototype, prototypeAccessors4);
  var ARG_1_AND_2_ARE_WORDS = 1;
  var WE_HAVE_A_SCALE = 8;
  var MORE_COMPONENTS = 32;
  var WE_HAVE_AN_X_AND_Y_SCALE = 64;
  var WE_HAVE_A_TWO_BY_TWO = 128;
  var CompoundGlyph = function CompoundGlyph2(data) {
    this.raw = data;
    var ids = this.glyphIds = [];
    var offsets = this.idOffsets = [];
    while (true) {
      var flags = data.readShort();
      offsets.push(data.offset());
      ids.push(data.readShort());
      if (!(flags & MORE_COMPONENTS)) {
        break;
      }
      data.skip(flags & ARG_1_AND_2_ARE_WORDS ? 4 : 2);
      if (flags & WE_HAVE_A_TWO_BY_TWO) {
        data.skip(8);
      } else if (flags & WE_HAVE_AN_X_AND_Y_SCALE) {
        data.skip(4);
      } else if (flags & WE_HAVE_A_SCALE) {
        data.skip(2);
      }
    }
  };
  var prototypeAccessors$12 = { compound: { configurable: true } };
  prototypeAccessors$12.compound.get = function() {
    return true;
  };
  CompoundGlyph.prototype.render = function render3(old2new) {
    var this$1 = this;
    var out = BinaryStream(this.raw.get());
    for (var i = 0; i < this.glyphIds.length; ++i) {
      var id = this$1.glyphIds[i];
      out.offset(this$1.idOffsets[i]);
      out.writeShort(old2new[id]);
    }
    return out.get();
  };
  Object.defineProperties(CompoundGlyph.prototype, prototypeAccessors$12);
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3)
      anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3() {
      this.cache = {};
    };
    anonymous.prototype.glyphFor = function glyphFor(id) {
      var cache2 = this.cache;
      if (hasOwnProperty(cache2, id)) {
        return cache2[id];
      }
      var loca = this.file.loca;
      var length = loca.lengthOf(id);
      if (length === 0) {
        return cache2[id] = null;
      }
      var data = this.rawData;
      var offset = this.offset + loca.offsetOf(id);
      var raw2 = BinaryStream(data.slice(offset, length));
      var numberOfContours = raw2.readShort_();
      var xMin = raw2.readShort_();
      var yMin = raw2.readShort_();
      var xMax = raw2.readShort_();
      var yMax = raw2.readShort_();
      var glyph = cache2[id] = numberOfContours < 0 ? new CompoundGlyph(raw2) : new SimpleGlyph(raw2);
      glyph.numberOfContours = numberOfContours;
      glyph.xMin = xMin;
      glyph.yMin = yMin;
      glyph.xMax = xMax;
      glyph.yMax = yMax;
      return glyph;
    };
    anonymous.prototype.render = function render3(glyphs, oldIds, old2new) {
      var out = BinaryStream(), offsets = [];
      for (var i = 0; i < oldIds.length; ++i) {
        var id = oldIds[i];
        var glyph = glyphs[id];
        if (out.offset() % 2) {
          out.writeByte(0);
        }
        offsets.push(out.offset());
        if (glyph) {
          out.write(glyph.render(old2new));
        }
      }
      if (out.offset() % 2) {
        out.writeByte(0);
      }
      offsets.push(out.offset());
      return {
        table: out.get(),
        offsets
      };
    };
    return anonymous;
  }(Table);
}();
var NameTable = function() {
  var NameEntry = function NameEntry2(text, entry) {
    this.text = text;
    this.length = text.length;
    this.platformID = entry.platformID;
    this.platformSpecificID = entry.platformSpecificID;
    this.languageID = entry.languageID;
    this.nameID = entry.nameID;
  };
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3)
      anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      data.offset(this.offset);
      data.readShort();
      var count = data.readShort();
      var stringOffset = this.offset + data.readShort();
      var nameRecords = data.times(count, function() {
        return {
          platformID: data.readShort(),
          platformSpecificID: data.readShort(),
          languageID: data.readShort(),
          nameID: data.readShort(),
          length: data.readShort(),
          offset: data.readShort() + stringOffset
        };
      });
      var strings = this.strings = {};
      for (var i = 0; i < nameRecords.length; ++i) {
        var rec = nameRecords[i];
        data.offset(rec.offset);
        var text = data.readString(rec.length);
        if (!strings[rec.nameID]) {
          strings[rec.nameID] = [];
        }
        strings[rec.nameID].push(new NameEntry(text, rec));
      }
      this.postscriptEntry = strings[6][0];
      this.postscriptName = this.postscriptEntry.text.replace(/[^\x20-\x7F]/g, "");
    };
    anonymous.prototype.render = function render3(psName) {
      var this$1 = this;
      var strings = this.strings;
      var strCount = 0;
      for (var i in strings) {
        if (hasOwnProperty(strings, i)) {
          strCount += strings[i].length;
        }
      }
      var out = BinaryStream();
      var strTable = BinaryStream();
      out.writeShort(0);
      out.writeShort(strCount);
      out.writeShort(6 + 12 * strCount);
      for (i in strings) {
        if (hasOwnProperty(strings, i)) {
          var list = i == 6 ? [
            new NameEntry(psName, this$1.postscriptEntry)
          ] : strings[i];
          for (var j = 0; j < list.length; ++j) {
            var str = list[j];
            out.writeShort(str.platformID);
            out.writeShort(str.platformSpecificID);
            out.writeShort(str.languageID);
            out.writeShort(str.nameID);
            out.writeShort(str.length);
            out.writeShort(strTable.offset());
            strTable.writeString(str.text);
          }
        }
      }
      out.write(strTable.get());
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var PostTable = function() {
  var POSTSCRIPT_GLYPHS = ".notdef .null nonmarkingreturn space exclam quotedbl numbersign dollar percent ampersand quotesingle parenleft parenright asterisk plus comma hyphen period slash zero one two three four five six seven eight nine colon semicolon less equal greater question at A B C D E F G H I J K L M N O P Q R S T U V W X Y Z bracketleft backslash bracketright asciicircum underscore grave a b c d e f g h i j k l m n o p q r s t u v w x y z braceleft bar braceright asciitilde Adieresis Aring Ccedilla Eacute Ntilde Odieresis Udieresis aacute agrave acircumflex adieresis atilde aring ccedilla eacute egrave ecircumflex edieresis iacute igrave icircumflex idieresis ntilde oacute ograve ocircumflex odieresis otilde uacute ugrave ucircumflex udieresis dagger degree cent sterling section bullet paragraph germandbls registered copyright trademark acute dieresis notequal AE Oslash infinity plusminus lessequal greaterequal yen mu partialdiff summation product pi integral ordfeminine ordmasculine Omega ae oslash questiondown exclamdown logicalnot radical florin approxequal Delta guillemotleft guillemotright ellipsis nonbreakingspace Agrave Atilde Otilde OE oe endash emdash quotedblleft quotedblright quoteleft quoteright divide lozenge ydieresis Ydieresis fraction currency guilsinglleft guilsinglright fi fl daggerdbl periodcentered quotesinglbase quotedblbase perthousand Acircumflex Ecircumflex Aacute Edieresis Egrave Iacute Icircumflex Idieresis Igrave Oacute Ocircumflex apple Ograve Uacute Ucircumflex Ugrave dotlessi circumflex tilde macron breve dotaccent ring cedilla hungarumlaut ogonek caron Lslash lslash Scaron scaron Zcaron zcaron brokenbar Eth eth Yacute yacute Thorn thorn minus multiply onesuperior twosuperior threesuperior onehalf onequarter threequarters franc Gbreve gbreve Idotaccent Scedilla scedilla Cacute cacute Ccaron ccaron dcroat".split(/\s+/g);
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3)
      anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      var this$1 = this;
      data.offset(this.offset);
      this.format = data.readLong();
      this.italicAngle = data.readFixed_();
      this.underlinePosition = data.readShort_();
      this.underlineThickness = data.readShort_();
      this.isFixedPitch = data.readLong();
      this.minMemType42 = data.readLong();
      this.maxMemType42 = data.readLong();
      this.minMemType1 = data.readLong();
      this.maxMemType1 = data.readLong();
      var numberOfGlyphs;
      switch (this.format) {
        case 65536:
        case 196608:
          break;
        case 131072:
          numberOfGlyphs = data.readShort();
          this.glyphNameIndex = data.times(numberOfGlyphs, data.readShort);
          this.names = [];
          var limit = this.offset + this.length;
          while (data.offset() < limit) {
            this$1.names.push(data.readString(data.readByte()));
          }
          break;
        case 151552:
          numberOfGlyphs = data.readShort();
          this.offsets = data.read(numberOfGlyphs);
          break;
        case 262144:
          this.map = data.times(this.file.maxp.numGlyphs, data.readShort);
          break;
      }
    };
    anonymous.prototype.glyphFor = function glyphFor(code2) {
      switch (this.format) {
        case 65536:
          return POSTSCRIPT_GLYPHS[code2] || ".notdef";
        case 131072:
          var index = this.glyphNameIndex[code2];
          if (index < POSTSCRIPT_GLYPHS.length) {
            return POSTSCRIPT_GLYPHS[index];
          }
          return this.names[index - POSTSCRIPT_GLYPHS.length] || ".notdef";
        case 151552:
        case 196608:
          return ".notdef";
        case 262144:
          return this.map[code2] || 65535;
      }
    };
    anonymous.prototype.render = function render3(mapping) {
      var this$1 = this;
      if (this.format == 196608) {
        return this.raw();
      }
      var out = BinaryStream(this.rawData.slice(this.offset, 32));
      out.writeLong(131072);
      out.offset(32);
      var indexes = [];
      var strings = [];
      for (var i = 0; i < mapping.length; ++i) {
        var id = mapping[i];
        var post = this$1.glyphFor(id);
        var index = POSTSCRIPT_GLYPHS.indexOf(post);
        if (index >= 0) {
          indexes.push(index);
        } else {
          indexes.push(POSTSCRIPT_GLYPHS.length + strings.length);
          strings.push(post);
        }
      }
      out.writeShort(mapping.length);
      for (i = 0; i < indexes.length; ++i) {
        out.writeShort(indexes[i]);
      }
      for (i = 0; i < strings.length; ++i) {
        out.writeByte(strings[i].length);
        out.writeString(strings[i]);
      }
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var CmapTable = function() {
  var CmapEntry = function CmapEntry2(data, offset, codeMap) {
    var self = this;
    self.platformID = data.readShort();
    self.platformSpecificID = data.readShort();
    self.offset = offset + data.readLong();
    data.saveExcursion(function() {
      var code2;
      data.offset(self.offset);
      self.format = data.readShort();
      switch (self.format) {
        case 0:
          self.length = data.readShort();
          self.language = data.readShort();
          for (var i = 0; i < 256; ++i) {
            codeMap[i] = data.readByte();
          }
          break;
        case 4:
          self.length = data.readShort();
          self.language = data.readShort();
          var segCount = data.readShort() / 2;
          data.skip(6);
          var endCode = data.times(segCount, data.readShort);
          data.skip(2);
          var startCode = data.times(segCount, data.readShort);
          var idDelta = data.times(segCount, data.readShort_);
          var idRangeOffset = data.times(segCount, data.readShort);
          var count = (self.length + self.offset - data.offset()) / 2;
          var glyphIds2 = data.times(count, data.readShort);
          for (i = 0; i < segCount; ++i) {
            var start = startCode[i], end = endCode[i];
            for (code2 = start; code2 <= end; ++code2) {
              var glyphId;
              if (idRangeOffset[i] === 0) {
                glyphId = code2 + idDelta[i];
              } else {
                var index = idRangeOffset[i] / 2 - (segCount - i) + (code2 - start);
                glyphId = glyphIds2[index] || 0;
                if (glyphId !== 0) {
                  glyphId += idDelta[i];
                }
              }
              codeMap[code2] = glyphId & 65535;
            }
          }
          break;
        case 6:
          self.length = data.readShort();
          self.language = data.readShort();
          code2 = data.readShort();
          var length = data.readShort();
          while (length-- > 0) {
            codeMap[code2++] = data.readShort();
          }
          break;
        case 12:
          data.readShort();
          self.length = data.readLong();
          self.language = data.readLong();
          var ngroups = data.readLong();
          while (ngroups-- > 0) {
            code2 = data.readLong();
            var endCharCode = data.readLong();
            var glyphCode = data.readLong();
            while (code2 <= endCharCode) {
              codeMap[code2++] = glyphCode++;
            }
          }
          break;
        default:
          if (window.console) {
            window.console.error("Unhandled CMAP format: " + self.format);
          }
      }
    });
  };
  function renderCharmap(ncid2ogid, ogid2ngid) {
    var codes = sortedKeys(ncid2ogid);
    var startCodes = [];
    var endCodes = [];
    var last3 = null;
    var diff = null;
    function new_gid(charcode) {
      return ogid2ngid[ncid2ogid[charcode]];
    }
    for (var i = 0; i < codes.length; ++i) {
      var code2 = codes[i];
      var gid = new_gid(code2);
      var delta = gid - code2;
      if (last3 == null || delta !== diff) {
        if (last3) {
          endCodes.push(last3);
        }
        startCodes.push(code2);
        diff = delta;
      }
      last3 = code2;
    }
    if (last3) {
      endCodes.push(last3);
    }
    endCodes.push(65535);
    startCodes.push(65535);
    var segCount = startCodes.length;
    var segCountX2 = segCount * 2;
    var searchRange = 2 * Math.pow(2, Math.floor(Math.log(segCount) / Math.LN2));
    var entrySelector = Math.log(searchRange / 2) / Math.LN2;
    var rangeShift = segCountX2 - searchRange;
    var deltas = [];
    var rangeOffsets = [];
    var glyphIds2 = [];
    for (i = 0; i < segCount; ++i) {
      var startCode = startCodes[i];
      var endCode = endCodes[i];
      if (startCode == 65535) {
        deltas.push(0);
        rangeOffsets.push(0);
        break;
      }
      var startGlyph = new_gid(startCode);
      if (startCode - startGlyph >= 32768) {
        deltas.push(0);
        rangeOffsets.push(2 * (glyphIds2.length + segCount - i));
        for (var j = startCode; j <= endCode; ++j) {
          glyphIds2.push(new_gid(j));
        }
      } else {
        deltas.push(startGlyph - startCode);
        rangeOffsets.push(0);
      }
    }
    var out = BinaryStream();
    out.writeShort(3);
    out.writeShort(1);
    out.writeLong(12);
    out.writeShort(4);
    out.writeShort(16 + segCount * 8 + glyphIds2.length * 2);
    out.writeShort(0);
    out.writeShort(segCountX2);
    out.writeShort(searchRange);
    out.writeShort(entrySelector);
    out.writeShort(rangeShift);
    endCodes.forEach(out.writeShort);
    out.writeShort(0);
    startCodes.forEach(out.writeShort);
    deltas.forEach(out.writeShort_);
    rangeOffsets.forEach(out.writeShort);
    glyphIds2.forEach(out.writeShort);
    return out.get();
  }
  return function(Table3) {
    function anonymous() {
      Table3.apply(this, arguments);
    }
    if (Table3)
      anonymous.__proto__ = Table3;
    anonymous.prototype = Object.create(Table3 && Table3.prototype);
    anonymous.prototype.constructor = anonymous;
    anonymous.prototype.parse = function parse3(data) {
      var self = this;
      var offset = self.offset;
      data.offset(offset);
      self.codeMap = {};
      self.version = data.readShort();
      var tableCount = data.readShort();
      self.tables = data.times(tableCount, function() {
        return new CmapEntry(data, offset, self.codeMap);
      });
    };
    anonymous.render = function render3(ncid2ogid, ogid2ngid) {
      var out = BinaryStream();
      out.writeShort(0);
      out.writeShort(1);
      out.write(renderCharmap(ncid2ogid, ogid2ngid));
      return out.get();
    };
    return anonymous;
  }(Table);
}();
var OS2Table = function(Table3) {
  function OS2Table2() {
    Table3.apply(this, arguments);
  }
  if (Table3)
    OS2Table2.__proto__ = Table3;
  OS2Table2.prototype = Object.create(Table3 && Table3.prototype);
  OS2Table2.prototype.constructor = OS2Table2;
  OS2Table2.prototype.parse = function parse3(data) {
    data.offset(this.offset);
    this.version = data.readShort();
    this.averageCharWidth = data.readShort_();
    this.weightClass = data.readShort();
    this.widthClass = data.readShort();
    this.type = data.readShort();
    this.ySubscriptXSize = data.readShort_();
    this.ySubscriptYSize = data.readShort_();
    this.ySubscriptXOffset = data.readShort_();
    this.ySubscriptYOffset = data.readShort_();
    this.ySuperscriptXSize = data.readShort_();
    this.ySuperscriptYSize = data.readShort_();
    this.ySuperscriptXOffset = data.readShort_();
    this.ySuperscriptYOffset = data.readShort_();
    this.yStrikeoutSize = data.readShort_();
    this.yStrikeoutPosition = data.readShort_();
    this.familyClass = data.readShort_();
    this.panose = data.times(10, data.readByte);
    this.charRange = data.times(4, data.readLong);
    this.vendorID = data.readString(4);
    this.selection = data.readShort();
    this.firstCharIndex = data.readShort();
    this.lastCharIndex = data.readShort();
    if (this.version > 0) {
      this.ascent = data.readShort_();
      this.descent = data.readShort_();
      this.lineGap = data.readShort_();
      this.winAscent = data.readShort();
      this.winDescent = data.readShort();
      this.codePageRange = data.times(2, data.readLong);
      if (this.version > 1) {
        this.xHeight = data.readShort();
        this.capHeight = data.readShort();
        this.defaultChar = data.readShort();
        this.breakChar = data.readShort();
        this.maxContext = data.readShort();
      }
    }
  };
  OS2Table2.prototype.render = function render3() {
    return this.raw();
  };
  return OS2Table2;
}(Table);
var subsetTag = 1e5;
function nextSubsetTag() {
  var ret = "", n = String(subsetTag);
  for (var i = 0; i < n.length; ++i) {
    ret += String.fromCharCode(n.charCodeAt(i) - 48 + 65);
  }
  ++subsetTag;
  return ret;
}
var Subfont = function Subfont2(font) {
  this.font = font;
  this.subset = {};
  this.unicodes = {};
  this.ogid2ngid = { 0: 0 };
  this.ngid2ogid = { 0: 0 };
  this.ncid2ogid = {};
  this.next = this.firstChar = 1;
  this.nextGid = 1;
  this.psName = nextSubsetTag() + "+" + this.font.psName;
};
Subfont.prototype.use = function use(ch) {
  var self = this;
  if (typeof ch == "string") {
    return ucs2decode(ch).reduce(function(ret, code3) {
      return ret + String.fromCharCode(self.use(code3));
    }, "");
  }
  var code2 = self.unicodes[ch];
  if (!code2) {
    code2 = self.next++;
    self.subset[code2] = ch;
    self.unicodes[ch] = code2;
    var old_gid = self.font.cmap.codeMap[ch];
    if (old_gid) {
      self.ncid2ogid[code2] = old_gid;
      if (self.ogid2ngid[old_gid] == null) {
        var new_gid = self.nextGid++;
        self.ogid2ngid[old_gid] = new_gid;
        self.ngid2ogid[new_gid] = old_gid;
      }
    }
  }
  return code2;
};
Subfont.prototype.encodeText = function encodeText(text) {
  return this.use(text);
};
Subfont.prototype.glyphIds = function glyphIds() {
  return sortedKeys(this.ogid2ngid);
};
Subfont.prototype.glyphsFor = function glyphsFor(glyphIds2, result) {
  var this$1 = this;
  if (!result) {
    result = {};
  }
  for (var i = 0; i < glyphIds2.length; ++i) {
    var id = glyphIds2[i];
    if (!result[id]) {
      var glyph = result[id] = this$1.font.glyf.glyphFor(id);
      if (glyph && glyph.compound) {
        this$1.glyphsFor(glyph.glyphIds, result);
      }
    }
  }
  return result;
};
Subfont.prototype.render = function render2() {
  var this$1 = this;
  var glyphs = this.glyphsFor(this.glyphIds());
  for (var old_gid in glyphs) {
    if (hasOwnProperty(glyphs, old_gid)) {
      old_gid = parseInt(old_gid, 10);
      if (this$1.ogid2ngid[old_gid] == null) {
        var new_gid = this$1.nextGid++;
        this$1.ogid2ngid[old_gid] = new_gid;
        this$1.ngid2ogid[new_gid] = old_gid;
      }
    }
  }
  var new_gid_ids = sortedKeys(this.ngid2ogid);
  var old_gid_ids = new_gid_ids.map(function(id) {
    return this.ngid2ogid[id];
  }, this);
  var font = this.font;
  var glyf = font.glyf.render(glyphs, old_gid_ids, this.ogid2ngid);
  var loca = font.loca.render(glyf.offsets);
  this.lastChar = this.next - 1;
  var tables = {
    "cmap": CmapTable.render(this.ncid2ogid, this.ogid2ngid),
    "glyf": glyf.table,
    "loca": loca.table,
    "hmtx": font.hmtx.render(old_gid_ids),
    "hhea": font.hhea.render(old_gid_ids),
    "maxp": font.maxp.render(old_gid_ids),
    "post": font.post.render(old_gid_ids),
    "name": font.name.render(this.psName),
    "head": font.head.render(loca.format),
    "OS/2": font.os2.render()
  };
  return this.font.directory.render(tables);
};
Subfont.prototype.cidToGidMap = function cidToGidMap() {
  var this$1 = this;
  var out = BinaryStream(), len = 0;
  for (var cid = this.firstChar; cid < this.next; ++cid) {
    while (len < cid) {
      out.writeShort(0);
      len++;
    }
    var old_gid = this$1.ncid2ogid[cid];
    if (old_gid) {
      var new_gid = this$1.ogid2ngid[old_gid];
      out.writeShort(new_gid);
    } else {
      out.writeShort(0);
    }
    len++;
  }
  return out.get();
};
var TTFFont = function TTFFont2(rawData, name3) {
  var self = this;
  var data = self.contents = BinaryStream(rawData);
  if (data.readString(4) == "ttcf") {
    var offset;
    var parse3 = function() {
      data.offset(offset);
      self.parse();
    };
    if (!name3) {
      throw new Error("Must specify a name for TTC files");
    }
    data.readLong();
    var numFonts = data.readLong();
    for (var i = 0; i < numFonts; ++i) {
      offset = data.readLong();
      data.saveExcursion(parse3);
      if (self.psName == name3) {
        return;
      }
    }
    throw new Error("Font " + name3 + " not found in collection");
  } else {
    data.offset(0);
    self.parse();
  }
};
TTFFont.prototype.parse = function parse2() {
  var dir = this.directory = new Directory(this.contents);
  this.head = dir.readTable("head", HeadTable);
  this.loca = dir.readTable("loca", LocaTable);
  this.hhea = dir.readTable("hhea", HheaTable);
  this.maxp = dir.readTable("maxp", MaxpTable);
  this.hmtx = dir.readTable("hmtx", HmtxTable);
  this.glyf = dir.readTable("glyf", GlyfTable);
  this.name = dir.readTable("name", NameTable);
  this.post = dir.readTable("post", PostTable);
  this.cmap = dir.readTable("cmap", CmapTable);
  this.os2 = dir.readTable("OS/2", OS2Table);
  this.psName = this.name.postscriptName;
  this.ascent = this.os2.ascent || this.hhea.ascent;
  this.descent = this.os2.descent || this.hhea.descent;
  this.lineGap = this.os2.lineGap || this.hhea.lineGap;
  this.scale = 1e3 / this.head.unitsPerEm;
};
TTFFont.prototype.widthOfGlyph = function widthOfGlyph(glyph) {
  return this.hmtx.forGlyph(glyph).advance * this.scale;
};
TTFFont.prototype.makeSubset = function makeSubset() {
  return new Subfont(this);
};

// node_modules/@progress/pako-esm/dist/pako-esm5.js
var Z_NO_FLUSH = 0;
var Z_PARTIAL_FLUSH = 1;
var Z_SYNC_FLUSH = 2;
var Z_FULL_FLUSH = 3;
var Z_FINISH = 4;
var Z_BLOCK = 5;
var Z_OK = 0;
var Z_STREAM_END = 1;
var Z_NEED_DICT = 2;
var Z_STREAM_ERROR = -2;
var Z_DATA_ERROR = -3;
var Z_BUF_ERROR = -5;
var Z_DEFAULT_COMPRESSION = -1;
var Z_FILTERED = 1;
var Z_HUFFMAN_ONLY = 2;
var Z_RLE = 3;
var Z_FIXED = 4;
var Z_DEFAULT_STRATEGY = 0;
var Z_BINARY = 0;
var Z_TEXT = 1;
var Z_UNKNOWN = 2;
var Z_DEFLATED = 8;
function _has(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function assign(obj) {
  var sources = Array.prototype.slice.call(arguments, 1);
  while (sources.length) {
    var source = sources.shift();
    if (!source) {
      continue;
    }
    if (typeof source !== "object") {
      throw new TypeError(source + "must be non-object");
    }
    for (var p2 in source) {
      if (_has(source, p2)) {
        obj[p2] = source[p2];
      }
    }
  }
  return obj;
}
function shrinkBuf(buf, size) {
  if (buf.length === size) {
    return buf;
  }
  if (buf.subarray) {
    return buf.subarray(0, size);
  }
  buf.length = size;
  return buf;
}
var fnTyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    if (src.subarray && dest.subarray) {
      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);
      return;
    }
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    var i, l, len, pos, chunk, result;
    len = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      len += chunks[i].length;
    }
    result = new Uint8Array(len);
    pos = 0;
    for (i = 0, l = chunks.length; i < l; i++) {
      chunk = chunks[i];
      result.set(chunk, pos);
      pos += chunk.length;
    }
    return result;
  },
  Buf8: function(size) {
    return new Uint8Array(size);
  },
  Buf16: function(size) {
    return new Uint16Array(size);
  },
  Buf32: function(size) {
    return new Int32Array(size);
  }
};
var fnUntyped = {
  arraySet: function(dest, src, src_offs, len, dest_offs) {
    for (var i = 0; i < len; i++) {
      dest[dest_offs + i] = src[src_offs + i];
    }
  },
  // Join array of chunks to single array.
  flattenChunks: function(chunks) {
    return [].concat.apply([], chunks);
  },
  Buf8: function(size) {
    return new Array(size);
  },
  Buf16: function(size) {
    return new Array(size);
  },
  Buf32: function(size) {
    return new Array(size);
  }
};
var typedOK = function() {
  var supported = typeof Uint8Array !== "undefined" && typeof Uint16Array !== "undefined" && typeof Int32Array !== "undefined";
  typedOK = function() {
    return supported;
  };
  return supported;
};
var arraySet = function(dest, src, src_offs, len, dest_offs) {
  arraySet = typedOK() ? fnTyped.arraySet : fnUntyped.arraySet;
  return arraySet(dest, src, src_offs, len, dest_offs);
};
var flattenChunks = function(chunks) {
  flattenChunks = typedOK() ? fnTyped.flattenChunks : fnUntyped.flattenChunks;
  return flattenChunks(chunks);
};
var Buf8 = function(size) {
  Buf8 = typedOK() ? fnTyped.Buf8 : fnUntyped.Buf8;
  return Buf8(size);
};
var Buf16 = function(size) {
  Buf16 = typedOK() ? fnTyped.Buf16 : fnUntyped.Buf16;
  return Buf16(size);
};
var Buf32 = function(size) {
  Buf32 = typedOK() ? fnTyped.Buf32 : fnUntyped.Buf32;
  return Buf32(size);
};
var strApplyOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, [0]);
  } catch (_2) {
    result = false;
  }
  strApplyOK = function() {
    return result;
  };
  return result;
};
var strApplyUintOK = function() {
  var result = true;
  try {
    String.fromCharCode.apply(null, new Uint8Array(1));
  } catch (_2) {
    result = false;
  }
  strApplyUintOK = function() {
    return result;
  };
  return result;
};
var utf8len = function(c) {
  var table = Buf8(256);
  for (var q = 0; q < 256; q++) {
    table[q] = q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1;
  }
  table[254] = table[254] = 1;
  utf8len = function(arg) {
    return table[arg];
  };
  return table[c];
};
function string2buf(str) {
  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;
  for (m_pos = 0; m_pos < str_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    buf_len += c < 128 ? 1 : c < 2048 ? 2 : c < 65536 ? 3 : 4;
  }
  buf = new Uint8Array(buf_len);
  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {
    c = str.charCodeAt(m_pos);
    if ((c & 64512) === 55296 && m_pos + 1 < str_len) {
      c2 = str.charCodeAt(m_pos + 1);
      if ((c2 & 64512) === 56320) {
        c = 65536 + (c - 55296 << 10) + (c2 - 56320);
        m_pos++;
      }
    }
    if (c < 128) {
      buf[i++] = c;
    } else if (c < 2048) {
      buf[i++] = 192 | c >>> 6;
      buf[i++] = 128 | c & 63;
    } else if (c < 65536) {
      buf[i++] = 224 | c >>> 12;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    } else {
      buf[i++] = 240 | c >>> 18;
      buf[i++] = 128 | c >>> 12 & 63;
      buf[i++] = 128 | c >>> 6 & 63;
      buf[i++] = 128 | c & 63;
    }
  }
  return buf;
}
function _buf2binstring(buf, len) {
  if (len < 65534) {
    if (buf.subarray && strApplyUintOK() || !buf.subarray && strApplyOK()) {
      return String.fromCharCode.apply(null, shrinkBuf(buf, len));
    }
  }
  var result = "";
  for (var i = 0; i < len; i++) {
    result += String.fromCharCode(buf[i]);
  }
  return result;
}
function buf2binstring(buf) {
  return _buf2binstring(buf, buf.length);
}
function binstring2buf(str) {
  var buf = new Uint8Array(str.length);
  for (var i = 0, len = buf.length; i < len; i++) {
    buf[i] = str.charCodeAt(i);
  }
  return buf;
}
function buf2string(buf, max2) {
  var i, out, c, c_len;
  var len = max2 || buf.length;
  var utf16buf = new Array(len * 2);
  for (out = 0, i = 0; i < len; ) {
    c = buf[i++];
    if (c < 128) {
      utf16buf[out++] = c;
      continue;
    }
    c_len = utf8len(c);
    if (c_len > 4) {
      utf16buf[out++] = 65533;
      i += c_len - 1;
      continue;
    }
    c &= c_len === 2 ? 31 : c_len === 3 ? 15 : 7;
    while (c_len > 1 && i < len) {
      c = c << 6 | buf[i++] & 63;
      c_len--;
    }
    if (c_len > 1) {
      utf16buf[out++] = 65533;
      continue;
    }
    if (c < 65536) {
      utf16buf[out++] = c;
    } else {
      c -= 65536;
      utf16buf[out++] = 55296 | c >> 10 & 1023;
      utf16buf[out++] = 56320 | c & 1023;
    }
  }
  return _buf2binstring(utf16buf, out);
}
function utf8border(buf, max2) {
  var pos;
  max2 = max2 || buf.length;
  if (max2 > buf.length) {
    max2 = buf.length;
  }
  pos = max2 - 1;
  while (pos >= 0 && (buf[pos] & 192) === 128) {
    pos--;
  }
  if (pos < 0) {
    return max2;
  }
  if (pos === 0) {
    return max2;
  }
  return pos + utf8len(buf[pos]) > max2 ? pos : max2;
}
function adler32(adler, buf, len, pos) {
  var s1 = adler & 65535 | 0, s2 = adler >>> 16 & 65535 | 0, n = 0;
  while (len !== 0) {
    n = len > 2e3 ? 2e3 : len;
    len -= n;
    do {
      s1 = s1 + buf[pos++] | 0;
      s2 = s2 + s1 | 0;
    } while (--n);
    s1 %= 65521;
    s2 %= 65521;
  }
  return s1 | s2 << 16 | 0;
}
function makeTable() {
  var c, table = [];
  for (var n = 0; n < 256; n++) {
    c = n;
    for (var k = 0; k < 8; k++) {
      c = c & 1 ? 3988292384 ^ c >>> 1 : c >>> 1;
    }
    table[n] = c;
  }
  return table;
}
var crcTable = function() {
  var table = makeTable();
  crcTable = function() {
    return table;
  };
  return table;
};
function crc32(crc, buf, len, pos) {
  var t = crcTable(), end = pos + len;
  crc ^= -1;
  for (var i = pos; i < end; i++) {
    crc = crc >>> 8 ^ t[(crc ^ buf[i]) & 255];
  }
  return crc ^ -1;
}
var BAD = 30;
var TYPE = 12;
function inflate_fast(strm, start) {
  var state;
  var _in;
  var last3;
  var _out;
  var beg;
  var end;
  var dmax;
  var wsize;
  var whave;
  var wnext;
  var s_window;
  var hold;
  var bits;
  var lcode;
  var dcode;
  var lmask;
  var dmask;
  var here;
  var op;
  var len;
  var dist;
  var from;
  var from_source;
  var input, output;
  state = strm.state;
  _in = strm.next_in;
  input = strm.input;
  last3 = _in + (strm.avail_in - 5);
  _out = strm.next_out;
  output = strm.output;
  beg = _out - (start - strm.avail_out);
  end = _out + (strm.avail_out - 257);
  dmax = state.dmax;
  wsize = state.wsize;
  whave = state.whave;
  wnext = state.wnext;
  s_window = state.window;
  hold = state.hold;
  bits = state.bits;
  lcode = state.lencode;
  dcode = state.distcode;
  lmask = (1 << state.lenbits) - 1;
  dmask = (1 << state.distbits) - 1;
  top:
    do {
      if (bits < 15) {
        hold += input[_in++] << bits;
        bits += 8;
        hold += input[_in++] << bits;
        bits += 8;
      }
      here = lcode[hold & lmask];
      dolen:
        for (; ; ) {
          op = here >>> 24;
          hold >>>= op;
          bits -= op;
          op = here >>> 16 & 255;
          if (op === 0) {
            output[_out++] = here & 65535;
          } else if (op & 16) {
            len = here & 65535;
            op &= 15;
            if (op) {
              if (bits < op) {
                hold += input[_in++] << bits;
                bits += 8;
              }
              len += hold & (1 << op) - 1;
              hold >>>= op;
              bits -= op;
            }
            if (bits < 15) {
              hold += input[_in++] << bits;
              bits += 8;
              hold += input[_in++] << bits;
              bits += 8;
            }
            here = dcode[hold & dmask];
            dodist:
              for (; ; ) {
                op = here >>> 24;
                hold >>>= op;
                bits -= op;
                op = here >>> 16 & 255;
                if (op & 16) {
                  dist = here & 65535;
                  op &= 15;
                  if (bits < op) {
                    hold += input[_in++] << bits;
                    bits += 8;
                    if (bits < op) {
                      hold += input[_in++] << bits;
                      bits += 8;
                    }
                  }
                  dist += hold & (1 << op) - 1;
                  if (dist > dmax) {
                    strm.msg = "invalid distance too far back";
                    state.mode = BAD;
                    break top;
                  }
                  hold >>>= op;
                  bits -= op;
                  op = _out - beg;
                  if (dist > op) {
                    op = dist - op;
                    if (op > whave) {
                      if (state.sane) {
                        strm.msg = "invalid distance too far back";
                        state.mode = BAD;
                        break top;
                      }
                    }
                    from = 0;
                    from_source = s_window;
                    if (wnext === 0) {
                      from += wsize - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    } else if (wnext < op) {
                      from += wsize + wnext - op;
                      op -= wnext;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = 0;
                        if (wnext < len) {
                          op = wnext;
                          len -= op;
                          do {
                            output[_out++] = s_window[from++];
                          } while (--op);
                          from = _out - dist;
                          from_source = output;
                        }
                      }
                    } else {
                      from += wnext - op;
                      if (op < len) {
                        len -= op;
                        do {
                          output[_out++] = s_window[from++];
                        } while (--op);
                        from = _out - dist;
                        from_source = output;
                      }
                    }
                    while (len > 2) {
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      output[_out++] = from_source[from++];
                      len -= 3;
                    }
                    if (len) {
                      output[_out++] = from_source[from++];
                      if (len > 1) {
                        output[_out++] = from_source[from++];
                      }
                    }
                  } else {
                    from = _out - dist;
                    do {
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      output[_out++] = output[from++];
                      len -= 3;
                    } while (len > 2);
                    if (len) {
                      output[_out++] = output[from++];
                      if (len > 1) {
                        output[_out++] = output[from++];
                      }
                    }
                  }
                } else if ((op & 64) === 0) {
                  here = dcode[(here & 65535) + (hold & (1 << op) - 1)];
                  continue dodist;
                } else {
                  strm.msg = "invalid distance code";
                  state.mode = BAD;
                  break top;
                }
                break;
              }
          } else if ((op & 64) === 0) {
            here = lcode[(here & 65535) + (hold & (1 << op) - 1)];
            continue dolen;
          } else if (op & 32) {
            state.mode = TYPE;
            break top;
          } else {
            strm.msg = "invalid literal/length code";
            state.mode = BAD;
            break top;
          }
          break;
        }
    } while (_in < last3 && _out < end);
  len = bits >> 3;
  _in -= len;
  bits -= len << 3;
  hold &= (1 << bits) - 1;
  strm.next_in = _in;
  strm.next_out = _out;
  strm.avail_in = _in < last3 ? 5 + (last3 - _in) : 5 - (_in - last3);
  strm.avail_out = _out < end ? 257 + (end - _out) : 257 - (_out - end);
  state.hold = hold;
  state.bits = bits;
  return;
}
var MAXBITS = 15;
var ENOUGH_LENS = 852;
var ENOUGH_DISTS = 592;
var CODES = 0;
var LENS = 1;
var DISTS = 2;
var lbase = [
  /* Length codes 257..285 base */
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  13,
  15,
  17,
  19,
  23,
  27,
  31,
  35,
  43,
  51,
  59,
  67,
  83,
  99,
  115,
  131,
  163,
  195,
  227,
  258,
  0,
  0
];
var lext = [
  /* Length codes 257..285 extra */
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  16,
  17,
  17,
  17,
  17,
  18,
  18,
  18,
  18,
  19,
  19,
  19,
  19,
  20,
  20,
  20,
  20,
  21,
  21,
  21,
  21,
  16,
  72,
  78
];
var dbase = [
  /* Distance codes 0..29 base */
  1,
  2,
  3,
  4,
  5,
  7,
  9,
  13,
  17,
  25,
  33,
  49,
  65,
  97,
  129,
  193,
  257,
  385,
  513,
  769,
  1025,
  1537,
  2049,
  3073,
  4097,
  6145,
  8193,
  12289,
  16385,
  24577,
  0,
  0
];
var dext = [
  /* Distance codes 0..29 extra */
  16,
  16,
  16,
  16,
  17,
  17,
  18,
  18,
  19,
  19,
  20,
  20,
  21,
  21,
  22,
  22,
  23,
  23,
  24,
  24,
  25,
  25,
  26,
  26,
  27,
  27,
  28,
  28,
  29,
  29,
  64,
  64
];
function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts) {
  var bits = opts.bits;
  var len = 0;
  var sym = 0;
  var min3 = 0, max2 = 0;
  var root = 0;
  var curr = 0;
  var drop = 0;
  var left = 0;
  var used = 0;
  var huff = 0;
  var incr;
  var fill;
  var low;
  var mask;
  var next;
  var base = null;
  var base_index = 0;
  var end;
  var count = Buf16(MAXBITS + 1);
  var offs = Buf16(MAXBITS + 1);
  var extra = null;
  var extra_index = 0;
  var here_bits, here_op, here_val;
  for (len = 0; len <= MAXBITS; len++) {
    count[len] = 0;
  }
  for (sym = 0; sym < codes; sym++) {
    count[lens[lens_index + sym]]++;
  }
  root = bits;
  for (max2 = MAXBITS; max2 >= 1; max2--) {
    if (count[max2] !== 0) {
      break;
    }
  }
  if (root > max2) {
    root = max2;
  }
  if (max2 === 0) {
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    table[table_index++] = 1 << 24 | 64 << 16 | 0;
    opts.bits = 1;
    return 0;
  }
  for (min3 = 1; min3 < max2; min3++) {
    if (count[min3] !== 0) {
      break;
    }
  }
  if (root < min3) {
    root = min3;
  }
  left = 1;
  for (len = 1; len <= MAXBITS; len++) {
    left <<= 1;
    left -= count[len];
    if (left < 0) {
      return -1;
    }
  }
  if (left > 0 && (type === CODES || max2 !== 1)) {
    return -1;
  }
  offs[1] = 0;
  for (len = 1; len < MAXBITS; len++) {
    offs[len + 1] = offs[len] + count[len];
  }
  for (sym = 0; sym < codes; sym++) {
    if (lens[lens_index + sym] !== 0) {
      work[offs[lens[lens_index + sym]]++] = sym;
    }
  }
  if (type === CODES) {
    base = extra = work;
    end = 19;
  } else if (type === LENS) {
    base = lbase;
    base_index -= 257;
    extra = lext;
    extra_index -= 257;
    end = 256;
  } else {
    base = dbase;
    extra = dext;
    end = -1;
  }
  huff = 0;
  sym = 0;
  len = min3;
  next = table_index;
  curr = root;
  drop = 0;
  low = -1;
  used = 1 << root;
  mask = used - 1;
  if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
    return 1;
  }
  for (; ; ) {
    here_bits = len - drop;
    if (work[sym] < end) {
      here_op = 0;
      here_val = work[sym];
    } else if (work[sym] > end) {
      here_op = extra[extra_index + work[sym]];
      here_val = base[base_index + work[sym]];
    } else {
      here_op = 32 + 64;
      here_val = 0;
    }
    incr = 1 << len - drop;
    fill = 1 << curr;
    min3 = fill;
    do {
      fill -= incr;
      table[next + (huff >> drop) + fill] = here_bits << 24 | here_op << 16 | here_val | 0;
    } while (fill !== 0);
    incr = 1 << len - 1;
    while (huff & incr) {
      incr >>= 1;
    }
    if (incr !== 0) {
      huff &= incr - 1;
      huff += incr;
    } else {
      huff = 0;
    }
    sym++;
    if (--count[len] === 0) {
      if (len === max2) {
        break;
      }
      len = lens[lens_index + work[sym]];
    }
    if (len > root && (huff & mask) !== low) {
      if (drop === 0) {
        drop = root;
      }
      next += min3;
      curr = len - drop;
      left = 1 << curr;
      while (curr + drop < max2) {
        left -= count[curr + drop];
        if (left <= 0) {
          break;
        }
        curr++;
        left <<= 1;
      }
      used += 1 << curr;
      if (type === LENS && used > ENOUGH_LENS || type === DISTS && used > ENOUGH_DISTS) {
        return 1;
      }
      low = huff & mask;
      table[low] = root << 24 | curr << 16 | next - table_index | 0;
    }
  }
  if (huff !== 0) {
    table[next + huff] = len - drop << 24 | 64 << 16 | 0;
  }
  opts.bits = root;
  return 0;
}
var CODES$1 = 0;
var LENS$1 = 1;
var DISTS$1 = 2;
var Z_FINISH$1 = 4;
var Z_BLOCK$1 = 5;
var Z_TREES$1 = 6;
var Z_OK$1 = 0;
var Z_STREAM_END$1 = 1;
var Z_NEED_DICT$1 = 2;
var Z_STREAM_ERROR$1 = -2;
var Z_DATA_ERROR$1 = -3;
var Z_MEM_ERROR = -4;
var Z_BUF_ERROR$1 = -5;
var Z_DEFLATED$1 = 8;
var HEAD = 1;
var FLAGS = 2;
var TIME = 3;
var OS = 4;
var EXLEN = 5;
var EXTRA = 6;
var NAME = 7;
var COMMENT = 8;
var HCRC = 9;
var DICTID = 10;
var DICT = 11;
var TYPE$1 = 12;
var TYPEDO = 13;
var STORED = 14;
var COPY_ = 15;
var COPY = 16;
var TABLE = 17;
var LENLENS = 18;
var CODELENS = 19;
var LEN_ = 20;
var LEN = 21;
var LENEXT = 22;
var DIST = 23;
var DISTEXT = 24;
var MATCH = 25;
var LIT = 26;
var CHECK = 27;
var LENGTH = 28;
var DONE = 29;
var BAD$1 = 30;
var MEM = 31;
var SYNC = 32;
var ENOUGH_LENS$1 = 852;
var ENOUGH_DISTS$1 = 592;
function zswap32(q) {
  return (q >>> 24 & 255) + (q >>> 8 & 65280) + ((q & 65280) << 8) + ((q & 255) << 24);
}
function InflateState() {
  this.mode = 0;
  this.last = false;
  this.wrap = 0;
  this.havedict = false;
  this.flags = 0;
  this.dmax = 0;
  this.check = 0;
  this.total = 0;
  this.head = null;
  this.wbits = 0;
  this.wsize = 0;
  this.whave = 0;
  this.wnext = 0;
  this.window = null;
  this.hold = 0;
  this.bits = 0;
  this.length = 0;
  this.offset = 0;
  this.extra = 0;
  this.lencode = null;
  this.distcode = null;
  this.lenbits = 0;
  this.distbits = 0;
  this.ncode = 0;
  this.nlen = 0;
  this.ndist = 0;
  this.have = 0;
  this.next = null;
  this.lens = Buf16(320);
  this.work = Buf16(288);
  this.lendyn = null;
  this.distdyn = null;
  this.sane = 0;
  this.back = 0;
  this.was = 0;
}
function inflateResetKeep(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  strm.total_in = strm.total_out = state.total = 0;
  strm.msg = "";
  if (state.wrap) {
    strm.adler = state.wrap & 1;
  }
  state.mode = HEAD;
  state.last = 0;
  state.havedict = 0;
  state.dmax = 32768;
  state.head = null;
  state.hold = 0;
  state.bits = 0;
  state.lencode = state.lendyn = Buf32(ENOUGH_LENS$1);
  state.distcode = state.distdyn = Buf32(ENOUGH_DISTS$1);
  state.sane = 1;
  state.back = -1;
  return Z_OK$1;
}
function inflateReset(strm) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  state.wsize = 0;
  state.whave = 0;
  state.wnext = 0;
  return inflateResetKeep(strm);
}
function inflateReset2(strm, windowBits) {
  var wrap2;
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else {
    wrap2 = (windowBits >> 4) + 1;
    if (windowBits < 48) {
      windowBits &= 15;
    }
  }
  if (windowBits && (windowBits < 8 || windowBits > 15)) {
    return Z_STREAM_ERROR$1;
  }
  if (state.window !== null && state.wbits !== windowBits) {
    state.window = null;
  }
  state.wrap = wrap2;
  state.wbits = windowBits;
  return inflateReset(strm);
}
function inflateInit2(strm, windowBits) {
  var ret;
  var state;
  if (!strm) {
    return Z_STREAM_ERROR$1;
  }
  state = new InflateState();
  strm.state = state;
  state.window = null;
  ret = inflateReset2(strm, windowBits);
  if (ret !== Z_OK$1) {
    strm.state = null;
  }
  return ret;
}
var virgin = true;
var lenfix;
var distfix;
function fixedtables(state) {
  if (virgin) {
    var sym;
    lenfix = Buf32(512);
    distfix = Buf32(32);
    sym = 0;
    while (sym < 144) {
      state.lens[sym++] = 8;
    }
    while (sym < 256) {
      state.lens[sym++] = 9;
    }
    while (sym < 280) {
      state.lens[sym++] = 7;
    }
    while (sym < 288) {
      state.lens[sym++] = 8;
    }
    inflate_table(LENS$1, state.lens, 0, 288, lenfix, 0, state.work, { bits: 9 });
    sym = 0;
    while (sym < 32) {
      state.lens[sym++] = 5;
    }
    inflate_table(DISTS$1, state.lens, 0, 32, distfix, 0, state.work, { bits: 5 });
    virgin = false;
  }
  state.lencode = lenfix;
  state.lenbits = 9;
  state.distcode = distfix;
  state.distbits = 5;
}
function updatewindow(strm, src, end, copy) {
  var dist;
  var state = strm.state;
  if (state.window === null) {
    state.wsize = 1 << state.wbits;
    state.wnext = 0;
    state.whave = 0;
    state.window = Buf8(state.wsize);
  }
  if (copy >= state.wsize) {
    arraySet(state.window, src, end - state.wsize, state.wsize, 0);
    state.wnext = 0;
    state.whave = state.wsize;
  } else {
    dist = state.wsize - state.wnext;
    if (dist > copy) {
      dist = copy;
    }
    arraySet(state.window, src, end - copy, dist, state.wnext);
    copy -= dist;
    if (copy) {
      arraySet(state.window, src, end - copy, copy, 0);
      state.wnext = copy;
      state.whave = state.wsize;
    } else {
      state.wnext += dist;
      if (state.wnext === state.wsize) {
        state.wnext = 0;
      }
      if (state.whave < state.wsize) {
        state.whave += dist;
      }
    }
  }
  return 0;
}
function inflate(strm, flush) {
  var state;
  var input, output;
  var next;
  var put;
  var have, left;
  var hold;
  var bits;
  var _in, _out;
  var copy;
  var from;
  var from_source;
  var here = 0;
  var here_bits, here_op, here_val;
  var last_bits, last_op, last_val;
  var len;
  var ret;
  var hbuf = Buf8(4);
  var opts;
  var n;
  var order = (
    /* permutation of code lengths */
    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]
  );
  if (!strm || !strm.state || !strm.output || !strm.input && strm.avail_in !== 0) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.mode === TYPE$1) {
    state.mode = TYPEDO;
  }
  put = strm.next_out;
  output = strm.output;
  left = strm.avail_out;
  next = strm.next_in;
  input = strm.input;
  have = strm.avail_in;
  hold = state.hold;
  bits = state.bits;
  _in = have;
  _out = left;
  ret = Z_OK$1;
  inf_leave:
    for (; ; ) {
      switch (state.mode) {
        case HEAD:
          if (state.wrap === 0) {
            state.mode = TYPEDO;
            break;
          }
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.wrap & 2 && hold === 35615) {
            state.check = 0;
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
            hold = 0;
            bits = 0;
            state.mode = FLAGS;
            break;
          }
          state.flags = 0;
          if (state.head) {
            state.head.done = false;
          }
          if (!(state.wrap & 1) || /* check if zlib header allowed */
          (((hold & 255) << 8) + (hold >> 8)) % 31) {
            strm.msg = "incorrect header check";
            state.mode = BAD$1;
            break;
          }
          if ((hold & 15) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          hold >>>= 4;
          bits -= 4;
          len = (hold & 15) + 8;
          if (state.wbits === 0) {
            state.wbits = len;
          } else if (len > state.wbits) {
            strm.msg = "invalid window size";
            state.mode = BAD$1;
            break;
          }
          state.dmax = 1 << len;
          strm.adler = state.check = 1;
          state.mode = hold & 512 ? DICTID : TYPE$1;
          hold = 0;
          bits = 0;
          break;
        case FLAGS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.flags = hold;
          if ((state.flags & 255) !== Z_DEFLATED$1) {
            strm.msg = "unknown compression method";
            state.mode = BAD$1;
            break;
          }
          if (state.flags & 57344) {
            strm.msg = "unknown header flags set";
            state.mode = BAD$1;
            break;
          }
          if (state.head) {
            state.head.text = hold >> 8 & 1;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = TIME;
        case TIME:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.time = hold;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            hbuf[2] = hold >>> 16 & 255;
            hbuf[3] = hold >>> 24 & 255;
            state.check = crc32(state.check, hbuf, 4, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = OS;
        case OS:
          while (bits < 16) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (state.head) {
            state.head.xflags = hold & 255;
            state.head.os = hold >> 8;
          }
          if (state.flags & 512) {
            hbuf[0] = hold & 255;
            hbuf[1] = hold >>> 8 & 255;
            state.check = crc32(state.check, hbuf, 2, 0);
          }
          hold = 0;
          bits = 0;
          state.mode = EXLEN;
        case EXLEN:
          if (state.flags & 1024) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length = hold;
            if (state.head) {
              state.head.extra_len = hold;
            }
            if (state.flags & 512) {
              hbuf[0] = hold & 255;
              hbuf[1] = hold >>> 8 & 255;
              state.check = crc32(state.check, hbuf, 2, 0);
            }
            hold = 0;
            bits = 0;
          } else if (state.head) {
            state.head.extra = null;
          }
          state.mode = EXTRA;
        case EXTRA:
          if (state.flags & 1024) {
            copy = state.length;
            if (copy > have) {
              copy = have;
            }
            if (copy) {
              if (state.head) {
                len = state.head.extra_len - state.length;
                if (!state.head.extra) {
                  state.head.extra = new Array(state.head.extra_len);
                }
                arraySet(
                  state.head.extra,
                  input,
                  next,
                  // extra field is limited to 65536 bytes
                  // - no need for additional size check
                  copy,
                  /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/
                  len
                );
              }
              if (state.flags & 512) {
                state.check = crc32(state.check, input, copy, next);
              }
              have -= copy;
              next += copy;
              state.length -= copy;
            }
            if (state.length) {
              break inf_leave;
            }
          }
          state.length = 0;
          state.mode = NAME;
        case NAME:
          if (state.flags & 2048) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.name += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.name = null;
          }
          state.length = 0;
          state.mode = COMMENT;
        case COMMENT:
          if (state.flags & 4096) {
            if (have === 0) {
              break inf_leave;
            }
            copy = 0;
            do {
              len = input[next + copy++];
              if (state.head && len && state.length < 65536) {
                state.head.comment += String.fromCharCode(len);
              }
            } while (len && copy < have);
            if (state.flags & 512) {
              state.check = crc32(state.check, input, copy, next);
            }
            have -= copy;
            next += copy;
            if (len) {
              break inf_leave;
            }
          } else if (state.head) {
            state.head.comment = null;
          }
          state.mode = HCRC;
        case HCRC:
          if (state.flags & 512) {
            while (bits < 16) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.check & 65535)) {
              strm.msg = "header crc mismatch";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          if (state.head) {
            state.head.hcrc = state.flags >> 9 & 1;
            state.head.done = true;
          }
          strm.adler = state.check = 0;
          state.mode = TYPE$1;
          break;
        case DICTID:
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          strm.adler = state.check = zswap32(hold);
          hold = 0;
          bits = 0;
          state.mode = DICT;
        case DICT:
          if (state.havedict === 0) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            return Z_NEED_DICT$1;
          }
          strm.adler = state.check = 1;
          state.mode = TYPE$1;
        case TYPE$1:
          if (flush === Z_BLOCK$1 || flush === Z_TREES$1) {
            break inf_leave;
          }
        case TYPEDO:
          if (state.last) {
            hold >>>= bits & 7;
            bits -= bits & 7;
            state.mode = CHECK;
            break;
          }
          while (bits < 3) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.last = hold & 1;
          hold >>>= 1;
          bits -= 1;
          switch (hold & 3) {
            case 0:
              state.mode = STORED;
              break;
            case 1:
              fixedtables(state);
              state.mode = LEN_;
              if (flush === Z_TREES$1) {
                hold >>>= 2;
                bits -= 2;
                break inf_leave;
              }
              break;
            case 2:
              state.mode = TABLE;
              break;
            case 3:
              strm.msg = "invalid block type";
              state.mode = BAD$1;
          }
          hold >>>= 2;
          bits -= 2;
          break;
        case STORED:
          hold >>>= bits & 7;
          bits -= bits & 7;
          while (bits < 32) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((hold & 65535) !== (hold >>> 16 ^ 65535)) {
            strm.msg = "invalid stored block lengths";
            state.mode = BAD$1;
            break;
          }
          state.length = hold & 65535;
          hold = 0;
          bits = 0;
          state.mode = COPY_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case COPY_:
          state.mode = COPY;
        case COPY:
          copy = state.length;
          if (copy) {
            if (copy > have) {
              copy = have;
            }
            if (copy > left) {
              copy = left;
            }
            if (copy === 0) {
              break inf_leave;
            }
            arraySet(output, input, next, copy, put);
            have -= copy;
            next += copy;
            left -= copy;
            put += copy;
            state.length -= copy;
            break;
          }
          state.mode = TYPE$1;
          break;
        case TABLE:
          while (bits < 14) {
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          state.nlen = (hold & 31) + 257;
          hold >>>= 5;
          bits -= 5;
          state.ndist = (hold & 31) + 1;
          hold >>>= 5;
          bits -= 5;
          state.ncode = (hold & 15) + 4;
          hold >>>= 4;
          bits -= 4;
          if (state.nlen > 286 || state.ndist > 30) {
            strm.msg = "too many length or distance symbols";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = LENLENS;
        case LENLENS:
          while (state.have < state.ncode) {
            while (bits < 3) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.lens[order[state.have++]] = hold & 7;
            hold >>>= 3;
            bits -= 3;
          }
          while (state.have < 19) {
            state.lens[order[state.have++]] = 0;
          }
          state.lencode = state.lendyn;
          state.lenbits = 7;
          opts = { bits: state.lenbits };
          ret = inflate_table(CODES$1, state.lens, 0, 19, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid code lengths set";
            state.mode = BAD$1;
            break;
          }
          state.have = 0;
          state.mode = CODELENS;
        case CODELENS:
          while (state.have < state.nlen + state.ndist) {
            for (; ; ) {
              here = state.lencode[hold & (1 << state.lenbits) - 1];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (here_val < 16) {
              hold >>>= here_bits;
              bits -= here_bits;
              state.lens[state.have++] = here_val;
            } else {
              if (here_val === 16) {
                n = here_bits + 2;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                if (state.have === 0) {
                  strm.msg = "invalid bit length repeat";
                  state.mode = BAD$1;
                  break;
                }
                len = state.lens[state.have - 1];
                copy = 3 + (hold & 3);
                hold >>>= 2;
                bits -= 2;
              } else if (here_val === 17) {
                n = here_bits + 3;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 3 + (hold & 7);
                hold >>>= 3;
                bits -= 3;
              } else {
                n = here_bits + 7;
                while (bits < n) {
                  if (have === 0) {
                    break inf_leave;
                  }
                  have--;
                  hold += input[next++] << bits;
                  bits += 8;
                }
                hold >>>= here_bits;
                bits -= here_bits;
                len = 0;
                copy = 11 + (hold & 127);
                hold >>>= 7;
                bits -= 7;
              }
              if (state.have + copy > state.nlen + state.ndist) {
                strm.msg = "invalid bit length repeat";
                state.mode = BAD$1;
                break;
              }
              while (copy--) {
                state.lens[state.have++] = len;
              }
            }
          }
          if (state.mode === BAD$1) {
            break;
          }
          if (state.lens[256] === 0) {
            strm.msg = "invalid code -- missing end-of-block";
            state.mode = BAD$1;
            break;
          }
          state.lenbits = 9;
          opts = { bits: state.lenbits };
          ret = inflate_table(LENS$1, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);
          state.lenbits = opts.bits;
          if (ret) {
            strm.msg = "invalid literal/lengths set";
            state.mode = BAD$1;
            break;
          }
          state.distbits = 6;
          state.distcode = state.distdyn;
          opts = { bits: state.distbits };
          ret = inflate_table(DISTS$1, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);
          state.distbits = opts.bits;
          if (ret) {
            strm.msg = "invalid distances set";
            state.mode = BAD$1;
            break;
          }
          state.mode = LEN_;
          if (flush === Z_TREES$1) {
            break inf_leave;
          }
        case LEN_:
          state.mode = LEN;
        case LEN:
          if (have >= 6 && left >= 258) {
            strm.next_out = put;
            strm.avail_out = left;
            strm.next_in = next;
            strm.avail_in = have;
            state.hold = hold;
            state.bits = bits;
            inflate_fast(strm, _out);
            put = strm.next_out;
            output = strm.output;
            left = strm.avail_out;
            next = strm.next_in;
            input = strm.input;
            have = strm.avail_in;
            hold = state.hold;
            bits = state.bits;
            if (state.mode === TYPE$1) {
              state.back = -1;
            }
            break;
          }
          state.back = 0;
          for (; ; ) {
            here = state.lencode[hold & (1 << state.lenbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if (here_op && (here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.lencode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          state.length = here_val;
          if (here_op === 0) {
            state.mode = LIT;
            break;
          }
          if (here_op & 32) {
            state.back = -1;
            state.mode = TYPE$1;
            break;
          }
          if (here_op & 64) {
            strm.msg = "invalid literal/length code";
            state.mode = BAD$1;
            break;
          }
          state.extra = here_op & 15;
          state.mode = LENEXT;
        case LENEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.length += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          state.was = state.length;
          state.mode = DIST;
        case DIST:
          for (; ; ) {
            here = state.distcode[hold & (1 << state.distbits) - 1];
            here_bits = here >>> 24;
            here_op = here >>> 16 & 255;
            here_val = here & 65535;
            if (here_bits <= bits) {
              break;
            }
            if (have === 0) {
              break inf_leave;
            }
            have--;
            hold += input[next++] << bits;
            bits += 8;
          }
          if ((here_op & 240) === 0) {
            last_bits = here_bits;
            last_op = here_op;
            last_val = here_val;
            for (; ; ) {
              here = state.distcode[last_val + ((hold & (1 << last_bits + last_op) - 1) >> last_bits)];
              here_bits = here >>> 24;
              here_op = here >>> 16 & 255;
              here_val = here & 65535;
              if (last_bits + here_bits <= bits) {
                break;
              }
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            hold >>>= last_bits;
            bits -= last_bits;
            state.back += last_bits;
          }
          hold >>>= here_bits;
          bits -= here_bits;
          state.back += here_bits;
          if (here_op & 64) {
            strm.msg = "invalid distance code";
            state.mode = BAD$1;
            break;
          }
          state.offset = here_val;
          state.extra = here_op & 15;
          state.mode = DISTEXT;
        case DISTEXT:
          if (state.extra) {
            n = state.extra;
            while (bits < n) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            state.offset += hold & (1 << state.extra) - 1;
            hold >>>= state.extra;
            bits -= state.extra;
            state.back += state.extra;
          }
          if (state.offset > state.dmax) {
            strm.msg = "invalid distance too far back";
            state.mode = BAD$1;
            break;
          }
          state.mode = MATCH;
        case MATCH:
          if (left === 0) {
            break inf_leave;
          }
          copy = _out - left;
          if (state.offset > copy) {
            copy = state.offset - copy;
            if (copy > state.whave) {
              if (state.sane) {
                strm.msg = "invalid distance too far back";
                state.mode = BAD$1;
                break;
              }
            }
            if (copy > state.wnext) {
              copy -= state.wnext;
              from = state.wsize - copy;
            } else {
              from = state.wnext - copy;
            }
            if (copy > state.length) {
              copy = state.length;
            }
            from_source = state.window;
          } else {
            from_source = output;
            from = put - state.offset;
            copy = state.length;
          }
          if (copy > left) {
            copy = left;
          }
          left -= copy;
          state.length -= copy;
          do {
            output[put++] = from_source[from++];
          } while (--copy);
          if (state.length === 0) {
            state.mode = LEN;
          }
          break;
        case LIT:
          if (left === 0) {
            break inf_leave;
          }
          output[put++] = state.length;
          left--;
          state.mode = LEN;
          break;
        case CHECK:
          if (state.wrap) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold |= input[next++] << bits;
              bits += 8;
            }
            _out -= left;
            strm.total_out += _out;
            state.total += _out;
            if (_out) {
              strm.adler = state.check = /*UPDATE(state.check, put - _out, _out);*/
              state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out);
            }
            _out = left;
            if ((state.flags ? hold : zswap32(hold)) !== state.check) {
              strm.msg = "incorrect data check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = LENGTH;
        case LENGTH:
          if (state.wrap && state.flags) {
            while (bits < 32) {
              if (have === 0) {
                break inf_leave;
              }
              have--;
              hold += input[next++] << bits;
              bits += 8;
            }
            if (hold !== (state.total & 4294967295)) {
              strm.msg = "incorrect length check";
              state.mode = BAD$1;
              break;
            }
            hold = 0;
            bits = 0;
          }
          state.mode = DONE;
        case DONE:
          ret = Z_STREAM_END$1;
          break inf_leave;
        case BAD$1:
          ret = Z_DATA_ERROR$1;
          break inf_leave;
        case MEM:
          return Z_MEM_ERROR;
        case SYNC:
        default:
          return Z_STREAM_ERROR$1;
      }
    }
  strm.next_out = put;
  strm.avail_out = left;
  strm.next_in = next;
  strm.avail_in = have;
  state.hold = hold;
  state.bits = bits;
  if (state.wsize || _out !== strm.avail_out && state.mode < BAD$1 && (state.mode < CHECK || flush !== Z_FINISH$1)) {
    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out))
      ;
  }
  _in -= strm.avail_in;
  _out -= strm.avail_out;
  strm.total_in += _in;
  strm.total_out += _out;
  state.total += _out;
  if (state.wrap && _out) {
    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/
    state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out);
  }
  strm.data_type = state.bits + (state.last ? 64 : 0) + (state.mode === TYPE$1 ? 128 : 0) + (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);
  if ((_in === 0 && _out === 0 || flush === Z_FINISH$1) && ret === Z_OK$1) {
    ret = Z_BUF_ERROR$1;
  }
  return ret;
}
function inflateEnd(strm) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  var state = strm.state;
  if (state.window) {
    state.window = null;
  }
  strm.state = null;
  return Z_OK$1;
}
function inflateGetHeader(strm, head) {
  var state;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if ((state.wrap & 2) === 0) {
    return Z_STREAM_ERROR$1;
  }
  state.head = head;
  head.done = false;
  return Z_OK$1;
}
function inflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var state;
  var dictid;
  var ret;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR$1;
  }
  state = strm.state;
  if (state.wrap !== 0 && state.mode !== DICT) {
    return Z_STREAM_ERROR$1;
  }
  if (state.mode === DICT) {
    dictid = 1;
    dictid = adler32(dictid, dictionary, dictLength, 0);
    if (dictid !== state.check) {
      return Z_DATA_ERROR$1;
    }
  }
  ret = updatewindow(strm, dictionary, dictLength, dictLength);
  if (ret) {
    state.mode = MEM;
    return Z_MEM_ERROR;
  }
  state.havedict = 1;
  return Z_OK$1;
}
var msg = {
  2: "need dictionary",
  /* Z_NEED_DICT       2  */
  1: "stream end",
  /* Z_STREAM_END      1  */
  0: "",
  /* Z_OK              0  */
  "-1": "file error",
  /* Z_ERRNO         (-1) */
  "-2": "stream error",
  /* Z_STREAM_ERROR  (-2) */
  "-3": "data error",
  /* Z_DATA_ERROR    (-3) */
  "-4": "insufficient memory",
  /* Z_MEM_ERROR     (-4) */
  "-5": "buffer error",
  /* Z_BUF_ERROR     (-5) */
  "-6": "incompatible version"
  /* Z_VERSION_ERROR (-6) */
};
function ZStream() {
  this.input = null;
  this.next_in = 0;
  this.avail_in = 0;
  this.total_in = 0;
  this.output = null;
  this.next_out = 0;
  this.avail_out = 0;
  this.total_out = 0;
  this.msg = "";
  this.state = null;
  this.data_type = 2;
  this.adler = 0;
}
function GZheader() {
  this.text = 0;
  this.time = 0;
  this.xflags = 0;
  this.os = 0;
  this.extra = null;
  this.extra_len = 0;
  this.name = "";
  this.comment = "";
  this.hcrc = 0;
  this.done = false;
}
var toString3 = Object.prototype.toString;
var Inflate = function Inflate2(options2) {
  if (!(this instanceof Inflate2)) {
    return new Inflate2(options2);
  }
  this.options = assign({
    chunkSize: 16384,
    windowBits: 0,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits >= 0 && opt.windowBits < 16) {
    opt.windowBits = -opt.windowBits;
    if (opt.windowBits === 0) {
      opt.windowBits = -15;
    }
  }
  if (opt.windowBits >= 0 && opt.windowBits < 16 && !(options2 && options2.windowBits)) {
    opt.windowBits += 32;
  }
  if (opt.windowBits > 15 && opt.windowBits < 48) {
    if ((opt.windowBits & 15) === 0) {
      opt.windowBits |= 15;
    }
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = inflateInit2(
    this.strm,
    opt.windowBits
  );
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  this.header = new GZheader();
  inflateGetHeader(this.strm, this.header);
  if (opt.dictionary) {
    if (typeof opt.dictionary === "string") {
      opt.dictionary = string2buf(opt.dictionary);
    } else if (toString3.call(opt.dictionary) === "[object ArrayBuffer]") {
      opt.dictionary = new Uint8Array(opt.dictionary);
    }
    if (opt.raw) {
      status = inflateSetDictionary(this.strm, opt.dictionary);
      if (status !== Z_OK) {
        throw new Error(msg[status]);
      }
    }
  }
};
Inflate.prototype.push = function push2(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var dictionary = this.options.dictionary;
  var status, _mode;
  var next_out_utf8, tail, utf8str;
  var dict2;
  var allowBufError = false;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = binstring2buf(data);
  } else if (toString3.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = inflate(strm, Z_NO_FLUSH);
    if (status === Z_NEED_DICT && dictionary) {
      if (typeof dictionary === "string") {
        dict2 = string2buf(dictionary);
      } else if (toString3.call(dictionary) === "[object ArrayBuffer]") {
        dict2 = new Uint8Array(dictionary);
      } else {
        dict2 = dictionary;
      }
      status = inflateSetDictionary(this.strm, dict2);
    }
    if (status === Z_BUF_ERROR && allowBufError === true) {
      status = Z_OK;
      allowBufError = false;
    }
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.next_out) {
      if (strm.avail_out === 0 || status === Z_STREAM_END || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
        if (this.options.to === "string") {
          next_out_utf8 = utf8border(strm.output, strm.next_out);
          tail = strm.next_out - next_out_utf8;
          utf8str = buf2string(strm.output, next_out_utf8);
          strm.next_out = tail;
          strm.avail_out = chunkSize - tail;
          if (tail) {
            arraySet(strm.output, strm.output, next_out_utf8, tail, 0);
          }
          this.onData(utf8str);
        } else {
          this.onData(shrinkBuf(strm.output, strm.next_out));
        }
      }
    }
    if (strm.avail_in === 0 && strm.avail_out === 0) {
      allowBufError = true;
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (status === Z_STREAM_END) {
    _mode = Z_FINISH;
  }
  if (_mode === Z_FINISH) {
    status = inflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Inflate.prototype.onData = function onData(chunk) {
  this.chunks.push(chunk);
};
Inflate.prototype.onEnd = function onEnd(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function zero(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
var STORED_BLOCK = 0;
var STATIC_TREES = 1;
var DYN_TREES = 2;
var MIN_MATCH = 3;
var MAX_MATCH = 258;
var LENGTH_CODES = 29;
var LITERALS = 256;
var L_CODES = LITERALS + 1 + LENGTH_CODES;
var D_CODES = 30;
var BL_CODES = 19;
var HEAP_SIZE = 2 * L_CODES + 1;
var MAX_BITS = 15;
var Buf_size = 16;
var MAX_BL_BITS = 7;
var END_BLOCK = 256;
var REP_3_6 = 16;
var REPZ_3_10 = 17;
var REPZ_11_138 = 18;
var extra_lbits = (
  /* extra bits for each length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]
);
var extra_dbits = (
  /* extra bits for each distance code */
  [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]
);
var extra_blbits = (
  /* extra bits for each bit length code */
  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]
);
var bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];
var DIST_CODE_LEN = 512;
var static_ltree;
var static_dtree;
var _dist_code;
var _length_code;
var base_length;
var base_dist;
function StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {
  this.static_tree = static_tree;
  this.extra_bits = extra_bits;
  this.extra_base = extra_base;
  this.elems = elems;
  this.max_length = max_length;
  this.has_stree = static_tree && static_tree.length;
}
var static_l_desc;
var static_d_desc;
var static_bl_desc;
function TreeDesc(dyn_tree, stat_desc) {
  this.dyn_tree = dyn_tree;
  this.max_code = 0;
  this.stat_desc = stat_desc;
}
function d_code(dist) {
  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];
}
function put_short(s, w) {
  s.pending_buf[s.pending++] = w & 255;
  s.pending_buf[s.pending++] = w >>> 8 & 255;
}
function send_bits(s, value, length) {
  if (s.bi_valid > Buf_size - length) {
    s.bi_buf |= value << s.bi_valid & 65535;
    put_short(s, s.bi_buf);
    s.bi_buf = value >> Buf_size - s.bi_valid;
    s.bi_valid += length - Buf_size;
  } else {
    s.bi_buf |= value << s.bi_valid & 65535;
    s.bi_valid += length;
  }
}
function send_code(s, c, tree) {
  send_bits(
    s,
    tree[c * 2],
    tree[c * 2 + 1]
    /*.Len*/
  );
}
function bi_reverse(code2, len) {
  var res = 0;
  do {
    res |= code2 & 1;
    code2 >>>= 1;
    res <<= 1;
  } while (--len > 0);
  return res >>> 1;
}
function bi_flush(s) {
  if (s.bi_valid === 16) {
    put_short(s, s.bi_buf);
    s.bi_buf = 0;
    s.bi_valid = 0;
  } else if (s.bi_valid >= 8) {
    s.pending_buf[s.pending++] = s.bi_buf & 255;
    s.bi_buf >>= 8;
    s.bi_valid -= 8;
  }
}
function gen_bitlen(s, desc) {
  var tree = desc.dyn_tree;
  var max_code = desc.max_code;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var extra = desc.stat_desc.extra_bits;
  var base = desc.stat_desc.extra_base;
  var max_length = desc.stat_desc.max_length;
  var h;
  var n, m;
  var bits;
  var xbits;
  var f;
  var overflow = 0;
  for (bits = 0; bits <= MAX_BITS; bits++) {
    s.bl_count[bits] = 0;
  }
  tree[s.heap[s.heap_max] * 2 + 1] = 0;
  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {
    n = s.heap[h];
    bits = tree[tree[n * 2 + 1] * 2 + 1] + 1;
    if (bits > max_length) {
      bits = max_length;
      overflow++;
    }
    tree[n * 2 + 1] = bits;
    if (n > max_code) {
      continue;
    }
    s.bl_count[bits]++;
    xbits = 0;
    if (n >= base) {
      xbits = extra[n - base];
    }
    f = tree[n * 2];
    s.opt_len += f * (bits + xbits);
    if (has_stree) {
      s.static_len += f * (stree[n * 2 + 1] + xbits);
    }
  }
  if (overflow === 0) {
    return;
  }
  do {
    bits = max_length - 1;
    while (s.bl_count[bits] === 0) {
      bits--;
    }
    s.bl_count[bits]--;
    s.bl_count[bits + 1] += 2;
    s.bl_count[max_length]--;
    overflow -= 2;
  } while (overflow > 0);
  for (bits = max_length; bits !== 0; bits--) {
    n = s.bl_count[bits];
    while (n !== 0) {
      m = s.heap[--h];
      if (m > max_code) {
        continue;
      }
      if (tree[m * 2 + 1] !== bits) {
        s.opt_len += (bits - tree[m * 2 + 1]) * tree[m * 2];
        tree[m * 2 + 1] = bits;
      }
      n--;
    }
  }
}
function gen_codes(tree, max_code, bl_count) {
  var next_code = new Array(MAX_BITS + 1);
  var code2 = 0;
  var bits;
  var n;
  for (bits = 1; bits <= MAX_BITS; bits++) {
    next_code[bits] = code2 = code2 + bl_count[bits - 1] << 1;
  }
  for (n = 0; n <= max_code; n++) {
    var len = tree[n * 2 + 1];
    if (len === 0) {
      continue;
    }
    tree[n * 2] = bi_reverse(next_code[len]++, len);
  }
}
function tr_static_init() {
  var n;
  var bits;
  var length;
  var code2;
  var dist;
  var bl_count = new Array(MAX_BITS + 1);
  static_ltree = new Array((L_CODES + 2) * 2);
  zero(static_ltree);
  static_dtree = new Array(D_CODES * 2);
  zero(static_dtree);
  _dist_code = new Array(DIST_CODE_LEN);
  zero(_dist_code);
  _length_code = new Array(MAX_MATCH - MIN_MATCH + 1);
  zero(_length_code);
  base_length = new Array(LENGTH_CODES);
  zero(base_length);
  base_dist = new Array(D_CODES);
  zero(base_dist);
  length = 0;
  for (code2 = 0; code2 < LENGTH_CODES - 1; code2++) {
    base_length[code2] = length;
    for (n = 0; n < 1 << extra_lbits[code2]; n++) {
      _length_code[length++] = code2;
    }
  }
  _length_code[length - 1] = code2;
  dist = 0;
  for (code2 = 0; code2 < 16; code2++) {
    base_dist[code2] = dist;
    for (n = 0; n < 1 << extra_dbits[code2]; n++) {
      _dist_code[dist++] = code2;
    }
  }
  dist >>= 7;
  for (; code2 < D_CODES; code2++) {
    base_dist[code2] = dist << 7;
    for (n = 0; n < 1 << extra_dbits[code2] - 7; n++) {
      _dist_code[256 + dist++] = code2;
    }
  }
  for (bits = 0; bits <= MAX_BITS; bits++) {
    bl_count[bits] = 0;
  }
  n = 0;
  while (n <= 143) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  while (n <= 255) {
    static_ltree[n * 2 + 1] = 9;
    n++;
    bl_count[9]++;
  }
  while (n <= 279) {
    static_ltree[n * 2 + 1] = 7;
    n++;
    bl_count[7]++;
  }
  while (n <= 287) {
    static_ltree[n * 2 + 1] = 8;
    n++;
    bl_count[8]++;
  }
  gen_codes(static_ltree, L_CODES + 1, bl_count);
  for (n = 0; n < D_CODES; n++) {
    static_dtree[n * 2 + 1] = 5;
    static_dtree[n * 2] = bi_reverse(n, 5);
  }
  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);
  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0, D_CODES, MAX_BITS);
  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0, BL_CODES, MAX_BL_BITS);
}
function init_block(s) {
  var n;
  for (n = 0; n < L_CODES; n++) {
    s.dyn_ltree[n * 2] = 0;
  }
  for (n = 0; n < D_CODES; n++) {
    s.dyn_dtree[n * 2] = 0;
  }
  for (n = 0; n < BL_CODES; n++) {
    s.bl_tree[n * 2] = 0;
  }
  s.dyn_ltree[END_BLOCK * 2] = 1;
  s.opt_len = s.static_len = 0;
  s.last_lit = s.matches = 0;
}
function bi_windup(s) {
  if (s.bi_valid > 8) {
    put_short(s, s.bi_buf);
  } else if (s.bi_valid > 0) {
    s.pending_buf[s.pending++] = s.bi_buf;
  }
  s.bi_buf = 0;
  s.bi_valid = 0;
}
function copy_block(s, buf, len, header) {
  bi_windup(s);
  if (header) {
    put_short(s, len);
    put_short(s, ~len);
  }
  arraySet(s.pending_buf, s.window, buf, len, s.pending);
  s.pending += len;
}
function smaller(tree, n, m, depth) {
  var _n2 = n * 2;
  var _m2 = m * 2;
  return tree[_n2] < tree[_m2] || tree[_n2] === tree[_m2] && depth[n] <= depth[m];
}
function pqdownheap(s, tree, k) {
  var v = s.heap[k];
  var j = k << 1;
  while (j <= s.heap_len) {
    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {
      j++;
    }
    if (smaller(tree, v, s.heap[j], s.depth)) {
      break;
    }
    s.heap[k] = s.heap[j];
    k = j;
    j <<= 1;
  }
  s.heap[k] = v;
}
function compress_block(s, ltree, dtree) {
  var dist;
  var lc;
  var lx = 0;
  var code2;
  var extra;
  if (s.last_lit !== 0) {
    do {
      dist = s.pending_buf[s.d_buf + lx * 2] << 8 | s.pending_buf[s.d_buf + lx * 2 + 1];
      lc = s.pending_buf[s.l_buf + lx];
      lx++;
      if (dist === 0) {
        send_code(s, lc, ltree);
      } else {
        code2 = _length_code[lc];
        send_code(s, code2 + LITERALS + 1, ltree);
        extra = extra_lbits[code2];
        if (extra !== 0) {
          lc -= base_length[code2];
          send_bits(s, lc, extra);
        }
        dist--;
        code2 = d_code(dist);
        send_code(s, code2, dtree);
        extra = extra_dbits[code2];
        if (extra !== 0) {
          dist -= base_dist[code2];
          send_bits(s, dist, extra);
        }
      }
    } while (lx < s.last_lit);
  }
  send_code(s, END_BLOCK, ltree);
}
function build_tree(s, desc) {
  var tree = desc.dyn_tree;
  var stree = desc.stat_desc.static_tree;
  var has_stree = desc.stat_desc.has_stree;
  var elems = desc.stat_desc.elems;
  var n, m;
  var max_code = -1;
  var node;
  s.heap_len = 0;
  s.heap_max = HEAP_SIZE;
  for (n = 0; n < elems; n++) {
    if (tree[n * 2] !== 0) {
      s.heap[++s.heap_len] = max_code = n;
      s.depth[n] = 0;
    } else {
      tree[n * 2 + 1] = 0;
    }
  }
  while (s.heap_len < 2) {
    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0;
    tree[node * 2] = 1;
    s.depth[node] = 0;
    s.opt_len--;
    if (has_stree) {
      s.static_len -= stree[node * 2 + 1];
    }
  }
  desc.max_code = max_code;
  for (n = s.heap_len >> 1; n >= 1; n--) {
    pqdownheap(s, tree, n);
  }
  node = elems;
  do {
    n = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[
      1
      /*SMALLEST*/
    ] = s.heap[s.heap_len--];
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
    m = s.heap[
      1
      /*SMALLEST*/
    ];
    s.heap[--s.heap_max] = n;
    s.heap[--s.heap_max] = m;
    tree[node * 2] = tree[n * 2] + tree[m * 2];
    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;
    tree[n * 2 + 1] = tree[m * 2 + 1] = node;
    s.heap[
      1
      /*SMALLEST*/
    ] = node++;
    pqdownheap(
      s,
      tree,
      1
      /*SMALLEST*/
    );
  } while (s.heap_len >= 2);
  s.heap[--s.heap_max] = s.heap[
    1
    /*SMALLEST*/
  ];
  gen_bitlen(s, desc);
  gen_codes(tree, max_code, s.bl_count);
}
function scan_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  tree[(max_code + 1) * 2 + 1] = 65535;
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      s.bl_tree[curlen * 2] += count;
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        s.bl_tree[curlen * 2]++;
      }
      s.bl_tree[REP_3_6 * 2]++;
    } else if (count <= 10) {
      s.bl_tree[REPZ_3_10 * 2]++;
    } else {
      s.bl_tree[REPZ_11_138 * 2]++;
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function send_tree(s, tree, max_code) {
  var n;
  var prevlen = -1;
  var curlen;
  var nextlen = tree[0 * 2 + 1];
  var count = 0;
  var max_count = 7;
  var min_count = 4;
  if (nextlen === 0) {
    max_count = 138;
    min_count = 3;
  }
  for (n = 0; n <= max_code; n++) {
    curlen = nextlen;
    nextlen = tree[(n + 1) * 2 + 1];
    if (++count < max_count && curlen === nextlen) {
      continue;
    } else if (count < min_count) {
      do {
        send_code(s, curlen, s.bl_tree);
      } while (--count !== 0);
    } else if (curlen !== 0) {
      if (curlen !== prevlen) {
        send_code(s, curlen, s.bl_tree);
        count--;
      }
      send_code(s, REP_3_6, s.bl_tree);
      send_bits(s, count - 3, 2);
    } else if (count <= 10) {
      send_code(s, REPZ_3_10, s.bl_tree);
      send_bits(s, count - 3, 3);
    } else {
      send_code(s, REPZ_11_138, s.bl_tree);
      send_bits(s, count - 11, 7);
    }
    count = 0;
    prevlen = curlen;
    if (nextlen === 0) {
      max_count = 138;
      min_count = 3;
    } else if (curlen === nextlen) {
      max_count = 6;
      min_count = 3;
    } else {
      max_count = 7;
      min_count = 4;
    }
  }
}
function build_bl_tree(s) {
  var max_blindex;
  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);
  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);
  build_tree(s, s.bl_desc);
  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {
    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] !== 0) {
      break;
    }
  }
  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;
  return max_blindex;
}
function send_all_trees(s, lcodes, dcodes, blcodes) {
  var rank2;
  send_bits(s, lcodes - 257, 5);
  send_bits(s, dcodes - 1, 5);
  send_bits(s, blcodes - 4, 4);
  for (rank2 = 0; rank2 < blcodes; rank2++) {
    send_bits(s, s.bl_tree[bl_order[rank2] * 2 + 1], 3);
  }
  send_tree(s, s.dyn_ltree, lcodes - 1);
  send_tree(s, s.dyn_dtree, dcodes - 1);
}
function detect_data_type(s) {
  var black_mask = 4093624447;
  var n;
  for (n = 0; n <= 31; n++, black_mask >>>= 1) {
    if (black_mask & 1 && s.dyn_ltree[n * 2] !== 0) {
      return Z_BINARY;
    }
  }
  if (s.dyn_ltree[9 * 2] !== 0 || s.dyn_ltree[10 * 2] !== 0 || s.dyn_ltree[13 * 2] !== 0) {
    return Z_TEXT;
  }
  for (n = 32; n < LITERALS; n++) {
    if (s.dyn_ltree[n * 2] !== 0) {
      return Z_TEXT;
    }
  }
  return Z_BINARY;
}
var static_init_done = false;
function _tr_init(s) {
  if (!static_init_done) {
    tr_static_init();
    static_init_done = true;
  }
  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc);
  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc);
  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);
  s.bi_buf = 0;
  s.bi_valid = 0;
  init_block(s);
}
function _tr_stored_block(s, buf, stored_len, last3) {
  send_bits(s, (STORED_BLOCK << 1) + (last3 ? 1 : 0), 3);
  copy_block(s, buf, stored_len, true);
}
function _tr_align(s) {
  send_bits(s, STATIC_TREES << 1, 3);
  send_code(s, END_BLOCK, static_ltree);
  bi_flush(s);
}
function _tr_flush_block(s, buf, stored_len, last3) {
  var opt_lenb, static_lenb;
  var max_blindex = 0;
  if (s.level > 0) {
    if (s.strm.data_type === Z_UNKNOWN) {
      s.strm.data_type = detect_data_type(s);
    }
    build_tree(s, s.l_desc);
    build_tree(s, s.d_desc);
    max_blindex = build_bl_tree(s);
    opt_lenb = s.opt_len + 3 + 7 >>> 3;
    static_lenb = s.static_len + 3 + 7 >>> 3;
    if (static_lenb <= opt_lenb) {
      opt_lenb = static_lenb;
    }
  } else {
    opt_lenb = static_lenb = stored_len + 5;
  }
  if (stored_len + 4 <= opt_lenb && buf !== -1) {
    _tr_stored_block(s, buf, stored_len, last3);
  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {
    send_bits(s, (STATIC_TREES << 1) + (last3 ? 1 : 0), 3);
    compress_block(s, static_ltree, static_dtree);
  } else {
    send_bits(s, (DYN_TREES << 1) + (last3 ? 1 : 0), 3);
    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);
    compress_block(s, s.dyn_ltree, s.dyn_dtree);
  }
  init_block(s);
  if (last3) {
    bi_windup(s);
  }
}
function _tr_tally(s, dist, lc) {
  s.pending_buf[s.d_buf + s.last_lit * 2] = dist >>> 8 & 255;
  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 255;
  s.pending_buf[s.l_buf + s.last_lit] = lc & 255;
  s.last_lit++;
  if (dist === 0) {
    s.dyn_ltree[lc * 2]++;
  } else {
    s.matches++;
    dist--;
    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]++;
    s.dyn_dtree[d_code(dist) * 2]++;
  }
  return s.last_lit === s.lit_bufsize - 1;
}
var MAX_MEM_LEVEL = 9;
var LENGTH_CODES$1 = 29;
var LITERALS$1 = 256;
var L_CODES$1 = LITERALS$1 + 1 + LENGTH_CODES$1;
var D_CODES$1 = 30;
var BL_CODES$1 = 19;
var HEAP_SIZE$1 = 2 * L_CODES$1 + 1;
var MAX_BITS$1 = 15;
var MIN_MATCH$1 = 3;
var MAX_MATCH$1 = 258;
var MIN_LOOKAHEAD = MAX_MATCH$1 + MIN_MATCH$1 + 1;
var PRESET_DICT = 32;
var INIT_STATE = 42;
var EXTRA_STATE = 69;
var NAME_STATE = 73;
var COMMENT_STATE = 91;
var HCRC_STATE = 103;
var BUSY_STATE = 113;
var FINISH_STATE = 666;
var BS_NEED_MORE = 1;
var BS_BLOCK_DONE = 2;
var BS_FINISH_STARTED = 3;
var BS_FINISH_DONE = 4;
var OS_CODE = 3;
function err(strm, errorCode) {
  strm.msg = msg[errorCode];
  return errorCode;
}
function rank(f) {
  return (f << 1) - (f > 4 ? 9 : 0);
}
function zero$1(buf) {
  var len = buf.length;
  while (--len >= 0) {
    buf[len] = 0;
  }
}
function flush_pending(strm) {
  var s = strm.state;
  var len = s.pending;
  if (len > strm.avail_out) {
    len = strm.avail_out;
  }
  if (len === 0) {
    return;
  }
  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);
  strm.next_out += len;
  s.pending_out += len;
  strm.total_out += len;
  strm.avail_out -= len;
  s.pending -= len;
  if (s.pending === 0) {
    s.pending_out = 0;
  }
}
function flush_block_only(s, last3) {
  _tr_flush_block(s, s.block_start >= 0 ? s.block_start : -1, s.strstart - s.block_start, last3);
  s.block_start = s.strstart;
  flush_pending(s.strm);
}
function put_byte(s, b) {
  s.pending_buf[s.pending++] = b;
}
function putShortMSB(s, b) {
  s.pending_buf[s.pending++] = b >>> 8 & 255;
  s.pending_buf[s.pending++] = b & 255;
}
function read_buf(strm, buf, start, size) {
  var len = strm.avail_in;
  if (len > size) {
    len = size;
  }
  if (len === 0) {
    return 0;
  }
  strm.avail_in -= len;
  arraySet(buf, strm.input, strm.next_in, len, start);
  if (strm.state.wrap === 1) {
    strm.adler = adler32(strm.adler, buf, len, start);
  } else if (strm.state.wrap === 2) {
    strm.adler = crc32(strm.adler, buf, len, start);
  }
  strm.next_in += len;
  strm.total_in += len;
  return len;
}
function longest_match(s, cur_match) {
  var chain_length = s.max_chain_length;
  var scan = s.strstart;
  var match;
  var len;
  var best_len = s.prev_length;
  var nice_match = s.nice_match;
  var limit = s.strstart > s.w_size - MIN_LOOKAHEAD ? s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0;
  var _win = s.window;
  var wmask = s.w_mask;
  var prev = s.prev;
  var strend = s.strstart + MAX_MATCH$1;
  var scan_end1 = _win[scan + best_len - 1];
  var scan_end = _win[scan + best_len];
  if (s.prev_length >= s.good_match) {
    chain_length >>= 2;
  }
  if (nice_match > s.lookahead) {
    nice_match = s.lookahead;
  }
  do {
    match = cur_match;
    if (_win[match + best_len] !== scan_end || _win[match + best_len - 1] !== scan_end1 || _win[match] !== _win[scan] || _win[++match] !== _win[scan + 1]) {
      continue;
    }
    scan += 2;
    match++;
    do {
    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && _win[++scan] === _win[++match] && scan < strend);
    len = MAX_MATCH$1 - (strend - scan);
    scan = strend - MAX_MATCH$1;
    if (len > best_len) {
      s.match_start = cur_match;
      best_len = len;
      if (len >= nice_match) {
        break;
      }
      scan_end1 = _win[scan + best_len - 1];
      scan_end = _win[scan + best_len];
    }
  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);
  if (best_len <= s.lookahead) {
    return best_len;
  }
  return s.lookahead;
}
function fill_window(s) {
  var _w_size = s.w_size;
  var p2, n, m, more, str;
  do {
    more = s.window_size - s.lookahead - s.strstart;
    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {
      arraySet(s.window, s.window, _w_size, _w_size, 0);
      s.match_start -= _w_size;
      s.strstart -= _w_size;
      s.block_start -= _w_size;
      n = s.hash_size;
      p2 = n;
      do {
        m = s.head[--p2];
        s.head[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      n = _w_size;
      p2 = n;
      do {
        m = s.prev[--p2];
        s.prev[p2] = m >= _w_size ? m - _w_size : 0;
      } while (--n);
      more += _w_size;
    }
    if (s.strm.avail_in === 0) {
      break;
    }
    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);
    s.lookahead += n;
    if (s.lookahead + s.insert >= MIN_MATCH$1) {
      str = s.strstart - s.insert;
      s.ins_h = s.window[str];
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + 1]) & s.hash_mask;
      while (s.insert) {
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
        s.prev[str & s.w_mask] = s.head[s.ins_h];
        s.head[s.ins_h] = str;
        str++;
        s.insert--;
        if (s.lookahead + s.insert < MIN_MATCH$1) {
          break;
        }
      }
    }
  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);
}
function deflate_stored(s, flush) {
  var max_block_size = 65535;
  if (max_block_size > s.pending_buf_size - 5) {
    max_block_size = s.pending_buf_size - 5;
  }
  for (; ; ) {
    if (s.lookahead <= 1) {
      fill_window(s);
      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.strstart += s.lookahead;
    s.lookahead = 0;
    var max_start = s.block_start + max_block_size;
    if (s.strstart === 0 || s.strstart >= max_start) {
      s.lookahead = s.strstart - max_start;
      s.strstart = max_start;
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.strstart > s.block_start) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_NEED_MORE;
}
function deflate_fast(s, flush) {
  var hash_head;
  var bflush;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    if (hash_head !== 0 && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      if (s.match_length <= s.max_lazy_match && s.lookahead >= MIN_MATCH$1) {
        s.match_length--;
        do {
          s.strstart++;
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        } while (--s.match_length !== 0);
        s.strstart++;
      } else {
        s.strstart += s.match_length;
        s.match_length = 0;
        s.ins_h = s.window[s.strstart];
        s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + 1]) & s.hash_mask;
      }
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_slow(s, flush) {
  var hash_head;
  var bflush;
  var max_insert;
  for (; ; ) {
    if (s.lookahead < MIN_LOOKAHEAD) {
      fill_window(s);
      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    hash_head = 0;
    if (s.lookahead >= MIN_MATCH$1) {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = s.strstart;
    }
    s.prev_length = s.match_length;
    s.prev_match = s.match_start;
    s.match_length = MIN_MATCH$1 - 1;
    if (hash_head !== 0 && s.prev_length < s.max_lazy_match && s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD) {
      s.match_length = longest_match(s, hash_head);
      if (s.match_length <= 5 && (s.strategy === Z_FILTERED || s.match_length === MIN_MATCH$1 && s.strstart - s.match_start > 4096)) {
        s.match_length = MIN_MATCH$1 - 1;
      }
    }
    if (s.prev_length >= MIN_MATCH$1 && s.match_length <= s.prev_length) {
      max_insert = s.strstart + s.lookahead - MIN_MATCH$1;
      bflush = _tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH$1);
      s.lookahead -= s.prev_length - 1;
      s.prev_length -= 2;
      do {
        if (++s.strstart <= max_insert) {
          s.ins_h = (s.ins_h << s.hash_shift ^ s.window[s.strstart + MIN_MATCH$1 - 1]) & s.hash_mask;
          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];
          s.head[s.ins_h] = s.strstart;
        }
      } while (--s.prev_length !== 0);
      s.match_available = 0;
      s.match_length = MIN_MATCH$1 - 1;
      s.strstart++;
      if (bflush) {
        flush_block_only(s, false);
        if (s.strm.avail_out === 0) {
          return BS_NEED_MORE;
        }
      }
    } else if (s.match_available) {
      bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
      if (bflush) {
        flush_block_only(s, false);
      }
      s.strstart++;
      s.lookahead--;
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    } else {
      s.match_available = 1;
      s.strstart++;
      s.lookahead--;
    }
  }
  if (s.match_available) {
    bflush = _tr_tally(s, 0, s.window[s.strstart - 1]);
    s.match_available = 0;
  }
  s.insert = s.strstart < MIN_MATCH$1 - 1 ? s.strstart : MIN_MATCH$1 - 1;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_rle(s, flush) {
  var bflush;
  var prev;
  var scan, strend;
  var _win = s.window;
  for (; ; ) {
    if (s.lookahead <= MAX_MATCH$1) {
      fill_window(s);
      if (s.lookahead <= MAX_MATCH$1 && flush === Z_NO_FLUSH) {
        return BS_NEED_MORE;
      }
      if (s.lookahead === 0) {
        break;
      }
    }
    s.match_length = 0;
    if (s.lookahead >= MIN_MATCH$1 && s.strstart > 0) {
      scan = s.strstart - 1;
      prev = _win[scan];
      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {
        strend = s.strstart + MAX_MATCH$1;
        do {
        } while (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan] && scan < strend);
        s.match_length = MAX_MATCH$1 - (strend - scan);
        if (s.match_length > s.lookahead) {
          s.match_length = s.lookahead;
        }
      }
    }
    if (s.match_length >= MIN_MATCH$1) {
      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH$1);
      s.lookahead -= s.match_length;
      s.strstart += s.match_length;
      s.match_length = 0;
    } else {
      bflush = _tr_tally(s, 0, s.window[s.strstart]);
      s.lookahead--;
      s.strstart++;
    }
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function deflate_huff(s, flush) {
  var bflush;
  for (; ; ) {
    if (s.lookahead === 0) {
      fill_window(s);
      if (s.lookahead === 0) {
        if (flush === Z_NO_FLUSH) {
          return BS_NEED_MORE;
        }
        break;
      }
    }
    s.match_length = 0;
    bflush = _tr_tally(s, 0, s.window[s.strstart]);
    s.lookahead--;
    s.strstart++;
    if (bflush) {
      flush_block_only(s, false);
      if (s.strm.avail_out === 0) {
        return BS_NEED_MORE;
      }
    }
  }
  s.insert = 0;
  if (flush === Z_FINISH) {
    flush_block_only(s, true);
    if (s.strm.avail_out === 0) {
      return BS_FINISH_STARTED;
    }
    return BS_FINISH_DONE;
  }
  if (s.last_lit) {
    flush_block_only(s, false);
    if (s.strm.avail_out === 0) {
      return BS_NEED_MORE;
    }
  }
  return BS_BLOCK_DONE;
}
function Config(good_length, max_lazy, nice_length, max_chain, func) {
  this.good_length = good_length;
  this.max_lazy = max_lazy;
  this.nice_length = nice_length;
  this.max_chain = max_chain;
  this.func = func;
}
var configurationTable = function() {
  var table = [
    /*      good lazy nice chain */
    new Config(0, 0, 0, 0, deflate_stored),
    /* 0 store only */
    new Config(4, 4, 8, 4, deflate_fast),
    /* 1 max speed, no lazy matches */
    new Config(4, 5, 16, 8, deflate_fast),
    /* 2 */
    new Config(4, 6, 32, 32, deflate_fast),
    /* 3 */
    new Config(4, 4, 16, 16, deflate_slow),
    /* 4 lazy matches */
    new Config(8, 16, 32, 32, deflate_slow),
    /* 5 */
    new Config(8, 16, 128, 128, deflate_slow),
    /* 6 */
    new Config(8, 32, 128, 256, deflate_slow),
    /* 7 */
    new Config(32, 128, 258, 1024, deflate_slow),
    /* 8 */
    new Config(32, 258, 258, 4096, deflate_slow)
    /* 9 max compression */
  ];
  configurationTable = function() {
    return table;
  };
  return table;
};
function lm_init(s) {
  s.window_size = 2 * s.w_size;
  zero$1(s.head);
  var table = configurationTable();
  s.max_lazy_match = table[s.level].max_lazy;
  s.good_match = table[s.level].good_length;
  s.nice_match = table[s.level].nice_length;
  s.max_chain_length = table[s.level].max_chain;
  s.strstart = 0;
  s.block_start = 0;
  s.lookahead = 0;
  s.insert = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  s.ins_h = 0;
}
function DeflateState() {
  this.strm = null;
  this.status = 0;
  this.pending_buf = null;
  this.pending_buf_size = 0;
  this.pending_out = 0;
  this.pending = 0;
  this.wrap = 0;
  this.gzhead = null;
  this.gzindex = 0;
  this.method = Z_DEFLATED;
  this.last_flush = -1;
  this.w_size = 0;
  this.w_bits = 0;
  this.w_mask = 0;
  this.window = null;
  this.window_size = 0;
  this.prev = null;
  this.head = null;
  this.ins_h = 0;
  this.hash_size = 0;
  this.hash_bits = 0;
  this.hash_mask = 0;
  this.hash_shift = 0;
  this.block_start = 0;
  this.match_length = 0;
  this.prev_match = 0;
  this.match_available = 0;
  this.strstart = 0;
  this.match_start = 0;
  this.lookahead = 0;
  this.prev_length = 0;
  this.max_chain_length = 0;
  this.max_lazy_match = 0;
  this.level = 0;
  this.strategy = 0;
  this.good_match = 0;
  this.nice_match = 0;
  this.dyn_ltree = Buf16(HEAP_SIZE$1 * 2);
  this.dyn_dtree = Buf16((2 * D_CODES$1 + 1) * 2);
  this.bl_tree = Buf16((2 * BL_CODES$1 + 1) * 2);
  zero$1(this.dyn_ltree);
  zero$1(this.dyn_dtree);
  zero$1(this.bl_tree);
  this.l_desc = null;
  this.d_desc = null;
  this.bl_desc = null;
  this.bl_count = Buf16(MAX_BITS$1 + 1);
  this.heap = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.heap);
  this.heap_len = 0;
  this.heap_max = 0;
  this.depth = Buf16(2 * L_CODES$1 + 1);
  zero$1(this.depth);
  this.l_buf = 0;
  this.lit_bufsize = 0;
  this.last_lit = 0;
  this.d_buf = 0;
  this.opt_len = 0;
  this.static_len = 0;
  this.matches = 0;
  this.insert = 0;
  this.bi_buf = 0;
  this.bi_valid = 0;
}
function deflateResetKeep(strm) {
  var s;
  if (!strm || !strm.state) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.total_in = strm.total_out = 0;
  strm.data_type = Z_UNKNOWN;
  s = strm.state;
  s.pending = 0;
  s.pending_out = 0;
  if (s.wrap < 0) {
    s.wrap = -s.wrap;
  }
  s.status = s.wrap ? INIT_STATE : BUSY_STATE;
  strm.adler = s.wrap === 2 ? 0 : 1;
  s.last_flush = Z_NO_FLUSH;
  _tr_init(s);
  return Z_OK;
}
function deflateReset(strm) {
  var ret = deflateResetKeep(strm);
  if (ret === Z_OK) {
    lm_init(strm.state);
  }
  return ret;
}
function deflateSetHeader(strm, head) {
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  if (strm.state.wrap !== 2) {
    return Z_STREAM_ERROR;
  }
  strm.state.gzhead = head;
  return Z_OK;
}
function deflateInit2(strm, level, method, windowBits, memLevel, strategy) {
  if (!strm) {
    return Z_STREAM_ERROR;
  }
  var wrap2 = 1;
  if (level === Z_DEFAULT_COMPRESSION) {
    level = 6;
  }
  if (windowBits < 0) {
    wrap2 = 0;
    windowBits = -windowBits;
  } else if (windowBits > 15) {
    wrap2 = 2;
    windowBits -= 16;
  }
  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED || windowBits < 8 || windowBits > 15 || level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {
    return err(strm, Z_STREAM_ERROR);
  }
  if (windowBits === 8) {
    windowBits = 9;
  }
  var s = new DeflateState();
  strm.state = s;
  s.strm = strm;
  s.wrap = wrap2;
  s.gzhead = null;
  s.w_bits = windowBits;
  s.w_size = 1 << s.w_bits;
  s.w_mask = s.w_size - 1;
  s.hash_bits = memLevel + 7;
  s.hash_size = 1 << s.hash_bits;
  s.hash_mask = s.hash_size - 1;
  s.hash_shift = ~~((s.hash_bits + MIN_MATCH$1 - 1) / MIN_MATCH$1);
  s.window = Buf8(s.w_size * 2);
  s.head = Buf16(s.hash_size);
  s.prev = Buf16(s.w_size);
  s.lit_bufsize = 1 << memLevel + 6;
  s.pending_buf_size = s.lit_bufsize * 4;
  s.pending_buf = Buf8(s.pending_buf_size);
  s.d_buf = 1 * s.lit_bufsize;
  s.l_buf = (1 + 2) * s.lit_bufsize;
  s.level = level;
  s.strategy = strategy;
  s.method = method;
  return deflateReset(strm);
}
function deflate(strm, flush) {
  var old_flush, s;
  var beg, val;
  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {
    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;
  }
  s = strm.state;
  if (!strm.output || !strm.input && strm.avail_in !== 0 || s.status === FINISH_STATE && flush !== Z_FINISH) {
    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR);
  }
  s.strm = strm;
  old_flush = s.last_flush;
  s.last_flush = flush;
  if (s.status === INIT_STATE) {
    if (s.wrap === 2) {
      strm.adler = 0;
      put_byte(s, 31);
      put_byte(s, 139);
      put_byte(s, 8);
      if (!s.gzhead) {
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, 0);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, OS_CODE);
        s.status = BUSY_STATE;
      } else {
        put_byte(
          s,
          (s.gzhead.text ? 1 : 0) + (s.gzhead.hcrc ? 2 : 0) + (!s.gzhead.extra ? 0 : 4) + (!s.gzhead.name ? 0 : 8) + (!s.gzhead.comment ? 0 : 16)
        );
        put_byte(s, s.gzhead.time & 255);
        put_byte(s, s.gzhead.time >> 8 & 255);
        put_byte(s, s.gzhead.time >> 16 & 255);
        put_byte(s, s.gzhead.time >> 24 & 255);
        put_byte(s, s.level === 9 ? 2 : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ? 4 : 0);
        put_byte(s, s.gzhead.os & 255);
        if (s.gzhead.extra && s.gzhead.extra.length) {
          put_byte(s, s.gzhead.extra.length & 255);
          put_byte(s, s.gzhead.extra.length >> 8 & 255);
        }
        if (s.gzhead.hcrc) {
          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);
        }
        s.gzindex = 0;
        s.status = EXTRA_STATE;
      }
    } else {
      var header = Z_DEFLATED + (s.w_bits - 8 << 4) << 8;
      var level_flags = -1;
      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {
        level_flags = 0;
      } else if (s.level < 6) {
        level_flags = 1;
      } else if (s.level === 6) {
        level_flags = 2;
      } else {
        level_flags = 3;
      }
      header |= level_flags << 6;
      if (s.strstart !== 0) {
        header |= PRESET_DICT;
      }
      header += 31 - header % 31;
      s.status = BUSY_STATE;
      putShortMSB(s, header);
      if (s.strstart !== 0) {
        putShortMSB(s, strm.adler >>> 16);
        putShortMSB(s, strm.adler & 65535);
      }
      strm.adler = 1;
    }
  }
  if (s.status === EXTRA_STATE) {
    if (s.gzhead.extra) {
      beg = s.pending;
      while (s.gzindex < (s.gzhead.extra.length & 65535)) {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            break;
          }
        }
        put_byte(s, s.gzhead.extra[s.gzindex] & 255);
        s.gzindex++;
      }
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (s.gzindex === s.gzhead.extra.length) {
        s.gzindex = 0;
        s.status = NAME_STATE;
      }
    } else {
      s.status = NAME_STATE;
    }
  }
  if (s.status === NAME_STATE) {
    if (s.gzhead.name) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.name.length) {
          val = s.gzhead.name.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.gzindex = 0;
        s.status = COMMENT_STATE;
      }
    } else {
      s.status = COMMENT_STATE;
    }
  }
  if (s.status === COMMENT_STATE) {
    if (s.gzhead.comment) {
      beg = s.pending;
      do {
        if (s.pending === s.pending_buf_size) {
          if (s.gzhead.hcrc && s.pending > beg) {
            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
          }
          flush_pending(strm);
          beg = s.pending;
          if (s.pending === s.pending_buf_size) {
            val = 1;
            break;
          }
        }
        if (s.gzindex < s.gzhead.comment.length) {
          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 255;
        } else {
          val = 0;
        }
        put_byte(s, val);
      } while (val !== 0);
      if (s.gzhead.hcrc && s.pending > beg) {
        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);
      }
      if (val === 0) {
        s.status = HCRC_STATE;
      }
    } else {
      s.status = HCRC_STATE;
    }
  }
  if (s.status === HCRC_STATE) {
    if (s.gzhead.hcrc) {
      if (s.pending + 2 > s.pending_buf_size) {
        flush_pending(strm);
      }
      if (s.pending + 2 <= s.pending_buf_size) {
        put_byte(s, strm.adler & 255);
        put_byte(s, strm.adler >> 8 & 255);
        strm.adler = 0;
        s.status = BUSY_STATE;
      }
    } else {
      s.status = BUSY_STATE;
    }
  }
  if (s.pending !== 0) {
    flush_pending(strm);
    if (strm.avail_out === 0) {
      s.last_flush = -1;
      return Z_OK;
    }
  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) && flush !== Z_FINISH) {
    return err(strm, Z_BUF_ERROR);
  }
  if (s.status === FINISH_STATE && strm.avail_in !== 0) {
    return err(strm, Z_BUF_ERROR);
  }
  if (strm.avail_in !== 0 || s.lookahead !== 0 || flush !== Z_NO_FLUSH && s.status !== FINISH_STATE) {
    var bstate = s.strategy === Z_HUFFMAN_ONLY ? deflate_huff(s, flush) : s.strategy === Z_RLE ? deflate_rle(s, flush) : configurationTable()[s.level].func(s, flush);
    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {
      s.status = FINISH_STATE;
    }
    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {
      if (strm.avail_out === 0) {
        s.last_flush = -1;
      }
      return Z_OK;
    }
    if (bstate === BS_BLOCK_DONE) {
      if (flush === Z_PARTIAL_FLUSH) {
        _tr_align(s);
      } else if (flush !== Z_BLOCK) {
        _tr_stored_block(s, 0, 0, false);
        if (flush === Z_FULL_FLUSH) {
          zero$1(s.head);
          if (s.lookahead === 0) {
            s.strstart = 0;
            s.block_start = 0;
            s.insert = 0;
          }
        }
      }
      flush_pending(strm);
      if (strm.avail_out === 0) {
        s.last_flush = -1;
        return Z_OK;
      }
    }
  }
  if (flush !== Z_FINISH) {
    return Z_OK;
  }
  if (s.wrap <= 0) {
    return Z_STREAM_END;
  }
  if (s.wrap === 2) {
    put_byte(s, strm.adler & 255);
    put_byte(s, strm.adler >> 8 & 255);
    put_byte(s, strm.adler >> 16 & 255);
    put_byte(s, strm.adler >> 24 & 255);
    put_byte(s, strm.total_in & 255);
    put_byte(s, strm.total_in >> 8 & 255);
    put_byte(s, strm.total_in >> 16 & 255);
    put_byte(s, strm.total_in >> 24 & 255);
  } else {
    putShortMSB(s, strm.adler >>> 16);
    putShortMSB(s, strm.adler & 65535);
  }
  flush_pending(strm);
  if (s.wrap > 0) {
    s.wrap = -s.wrap;
  }
  return s.pending !== 0 ? Z_OK : Z_STREAM_END;
}
function deflateEnd(strm) {
  var status;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  status = strm.state.status;
  if (status !== INIT_STATE && status !== EXTRA_STATE && status !== NAME_STATE && status !== COMMENT_STATE && status !== HCRC_STATE && status !== BUSY_STATE && status !== FINISH_STATE) {
    return err(strm, Z_STREAM_ERROR);
  }
  strm.state = null;
  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;
}
function deflateSetDictionary(strm, dictionary) {
  var dictLength = dictionary.length;
  var s;
  var str, n;
  var wrap2;
  var avail;
  var next;
  var input;
  var tmpDict;
  if (!strm || !strm.state) {
    return Z_STREAM_ERROR;
  }
  s = strm.state;
  wrap2 = s.wrap;
  if (wrap2 === 2 || wrap2 === 1 && s.status !== INIT_STATE || s.lookahead) {
    return Z_STREAM_ERROR;
  }
  if (wrap2 === 1) {
    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);
  }
  s.wrap = 0;
  if (dictLength >= s.w_size) {
    if (wrap2 === 0) {
      zero$1(s.head);
      s.strstart = 0;
      s.block_start = 0;
      s.insert = 0;
    }
    tmpDict = Buf8(s.w_size);
    arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);
    dictionary = tmpDict;
    dictLength = s.w_size;
  }
  avail = strm.avail_in;
  next = strm.next_in;
  input = strm.input;
  strm.avail_in = dictLength;
  strm.next_in = 0;
  strm.input = dictionary;
  fill_window(s);
  while (s.lookahead >= MIN_MATCH$1) {
    str = s.strstart;
    n = s.lookahead - (MIN_MATCH$1 - 1);
    do {
      s.ins_h = (s.ins_h << s.hash_shift ^ s.window[str + MIN_MATCH$1 - 1]) & s.hash_mask;
      s.prev[str & s.w_mask] = s.head[s.ins_h];
      s.head[s.ins_h] = str;
      str++;
    } while (--n);
    s.strstart = str;
    s.lookahead = MIN_MATCH$1 - 1;
    fill_window(s);
  }
  s.strstart += s.lookahead;
  s.block_start = s.strstart;
  s.insert = s.lookahead;
  s.lookahead = 0;
  s.match_length = s.prev_length = MIN_MATCH$1 - 1;
  s.match_available = 0;
  strm.next_in = next;
  strm.input = input;
  strm.avail_in = avail;
  s.wrap = wrap2;
  return Z_OK;
}
var toString$1 = Object.prototype.toString;
var Deflate = function Deflate2(options2) {
  this.options = assign({
    level: Z_DEFAULT_COMPRESSION,
    method: Z_DEFLATED,
    chunkSize: 16384,
    windowBits: 15,
    memLevel: 8,
    strategy: Z_DEFAULT_STRATEGY,
    to: ""
  }, options2 || {});
  var opt = this.options;
  if (opt.raw && opt.windowBits > 0) {
    opt.windowBits = -opt.windowBits;
  } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {
    opt.windowBits += 16;
  }
  this.err = 0;
  this.msg = "";
  this.ended = false;
  this.chunks = [];
  this.strm = new ZStream();
  this.strm.avail_out = 0;
  var status = deflateInit2(
    this.strm,
    opt.level,
    opt.method,
    opt.windowBits,
    opt.memLevel,
    opt.strategy
  );
  if (status !== Z_OK) {
    throw new Error(msg[status]);
  }
  if (opt.header) {
    deflateSetHeader(this.strm, opt.header);
  }
  if (opt.dictionary) {
    var dict2;
    if (typeof opt.dictionary === "string") {
      dict2 = string2buf(opt.dictionary);
    } else if (toString$1.call(opt.dictionary) === "[object ArrayBuffer]") {
      dict2 = new Uint8Array(opt.dictionary);
    } else {
      dict2 = opt.dictionary;
    }
    status = deflateSetDictionary(this.strm, dict2);
    if (status !== Z_OK) {
      throw new Error(msg[status]);
    }
    this._dict_set = true;
  }
};
Deflate.prototype.push = function push3(data, mode) {
  var strm = this.strm;
  var chunkSize = this.options.chunkSize;
  var status, _mode;
  if (this.ended) {
    return false;
  }
  _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH;
  if (typeof data === "string") {
    strm.input = string2buf(data);
  } else if (toString$1.call(data) === "[object ArrayBuffer]") {
    strm.input = new Uint8Array(data);
  } else {
    strm.input = data;
  }
  strm.next_in = 0;
  strm.avail_in = strm.input.length;
  do {
    if (strm.avail_out === 0) {
      strm.output = Buf8(chunkSize);
      strm.next_out = 0;
      strm.avail_out = chunkSize;
    }
    status = deflate(strm, _mode);
    if (status !== Z_STREAM_END && status !== Z_OK) {
      this.onEnd(status);
      this.ended = true;
      return false;
    }
    if (strm.avail_out === 0 || strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH)) {
      if (this.options.to === "string") {
        this.onData(buf2binstring(shrinkBuf(strm.output, strm.next_out)));
      } else {
        this.onData(shrinkBuf(strm.output, strm.next_out));
      }
    }
  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);
  if (_mode === Z_FINISH) {
    status = deflateEnd(this.strm);
    this.onEnd(status);
    this.ended = true;
    return status === Z_OK;
  }
  if (_mode === Z_SYNC_FLUSH) {
    this.onEnd(Z_OK);
    strm.avail_out = 0;
    return true;
  }
  return true;
};
Deflate.prototype.onData = function onData2(chunk) {
  this.chunks.push(chunk);
};
Deflate.prototype.onEnd = function onEnd2(status) {
  if (status === Z_OK) {
    if (this.options.to === "string") {
      this.result = this.chunks.join("");
    } else {
      this.result = flattenChunks(this.chunks);
    }
  }
  this.chunks = [];
  this.err = status;
  this.msg = this.strm.msg;
};
function deflate$1(input, options2) {
  var deflator = new Deflate(options2);
  deflator.push(input, true);
  if (deflator.err) {
    throw deflator.msg || msg[deflator.err];
  }
  return deflator.result;
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/deflate.js
var deflate2 = deflate$1;
function supportsDeflate() {
  return true;
}

// node_modules/@progress/kendo-drawing/dist/es/pdf/core.js
var browser3 = support_default.browser;
var NL = "\n";
var RESOURCE_COUNTER = 0;
var PAPER_SIZE = {
  a0: [2383.94, 3370.39],
  a1: [1683.78, 2383.94],
  a2: [1190.55, 1683.78],
  a3: [841.89, 1190.55],
  a4: [595.28, 841.89],
  a5: [419.53, 595.28],
  a6: [297.64, 419.53],
  a7: [209.76, 297.64],
  a8: [147.4, 209.76],
  a9: [104.88, 147.4],
  a10: [73.7, 104.88],
  b0: [2834.65, 4008.19],
  b1: [2004.09, 2834.65],
  b2: [1417.32, 2004.09],
  b3: [1000.63, 1417.32],
  b4: [708.66, 1000.63],
  b5: [498.9, 708.66],
  b6: [354.33, 498.9],
  b7: [249.45, 354.33],
  b8: [175.75, 249.45],
  b9: [124.72, 175.75],
  b10: [87.87, 124.72],
  c0: [2599.37, 3676.54],
  c1: [1836.85, 2599.37],
  c2: [1298.27, 1836.85],
  c3: [918.43, 1298.27],
  c4: [649.13, 918.43],
  c5: [459.21, 649.13],
  c6: [323.15, 459.21],
  c7: [229.61, 323.15],
  c8: [161.57, 229.61],
  c9: [113.39, 161.57],
  c10: [79.37, 113.39],
  executive: [521.86, 756],
  folio: [612, 936],
  legal: [612, 1008],
  letter: [612, 792],
  tabloid: [792, 1224]
};
function makeOutput() {
  var indentLevel = 0, output = BinaryStream();
  function out() {
    var arguments$1 = arguments;
    for (var i = 0; i < arguments.length; ++i) {
      var x = arguments$1[i];
      if (x === void 0) {
        throw new Error("Cannot output undefined to PDF");
      } else if (x instanceof PDFValue) {
        x.beforeRender(out);
        x.render(out);
      } else if (isArray2(x)) {
        renderArray(x, out);
      } else if (isDate2(x)) {
        renderDate(x, out);
      } else if (typeof x == "number") {
        if (isNaN(x)) {
          throw new Error("Cannot output NaN to PDF");
        }
        var num = x.toFixed(7);
        if (num.indexOf(".") >= 0) {
          num = num.replace(/\.?0+$/, "");
        }
        if (num == "-0") {
          num = "0";
        }
        output.writeString(num);
      } else if (/string|boolean/.test(typeof x)) {
        output.writeString(String(x));
      } else if (typeof x.get == "function") {
        output.write(x.get());
      } else if (typeof x == "object") {
        if (!x) {
          output.writeString("null");
        } else {
          out(new PDFDictionary(x));
        }
      }
    }
  }
  out.writeData = function(data) {
    output.write(data);
  };
  out.withIndent = function(f) {
    ++indentLevel;
    f(out);
    --indentLevel;
  };
  out.indent = function() {
    out(NL, pad2("", indentLevel * 2, "  "));
    out.apply(null, arguments);
  };
  out.offset = function() {
    return output.offset();
  };
  out.toString = function() {
    throw new Error("FIX CALLER");
  };
  out.get = function() {
    return output.get();
  };
  out.stream = function() {
    return output;
  };
  return out;
}
function wrapObject(value, id) {
  var beforeRender2 = value.beforeRender;
  var renderValue = value.render;
  value.beforeRender = function() {
  };
  value.render = function(out) {
    out(id, " 0 R");
  };
  value.renderFull = function(out) {
    value._offset = out.offset();
    out(id, " 0 obj ");
    beforeRender2.call(value, out);
    renderValue.call(value, out);
    out(" endobj");
  };
}
function getPaperOptions(getOption) {
  if (typeof getOption != "function") {
    var options2 = getOption;
    getOption = function(key, def) {
      return key in options2 ? options2[key] : def;
    };
  }
  var paperSize = getOption("paperSize", PAPER_SIZE.a4);
  if (!paperSize) {
    return {};
  }
  if (typeof paperSize == "string") {
    paperSize = PAPER_SIZE[paperSize.toLowerCase()];
    if (paperSize == null) {
      throw new Error("Unknown paper size");
    }
  }
  paperSize[0] = unitsToPoints(paperSize[0]);
  paperSize[1] = unitsToPoints(paperSize[1]);
  if (getOption("landscape", false)) {
    paperSize = [
      Math.max(paperSize[0], paperSize[1]),
      Math.min(paperSize[0], paperSize[1])
    ];
  }
  var margin = getOption("margin");
  if (margin) {
    if (typeof margin == "string" || typeof margin == "number") {
      margin = unitsToPoints(margin, 0);
      margin = { left: margin, top: margin, right: margin, bottom: margin };
    } else {
      margin = {
        left: unitsToPoints(margin.left, 0),
        top: unitsToPoints(margin.top, 0),
        right: unitsToPoints(margin.right, 0),
        bottom: unitsToPoints(margin.bottom, 0)
      };
    }
    if (getOption("addMargin")) {
      paperSize[0] += margin.left + margin.right;
      paperSize[1] += margin.top + margin.bottom;
    }
  }
  return { paperSize, margin };
}
var FONT_CACHE = {
  "Times-Roman": true,
  "Times-Bold": true,
  "Times-Italic": true,
  "Times-BoldItalic": true,
  "Helvetica": true,
  "Helvetica-Bold": true,
  "Helvetica-Oblique": true,
  "Helvetica-BoldOblique": true,
  "Courier": true,
  "Courier-Bold": true,
  "Courier-Oblique": true,
  "Courier-BoldOblique": true,
  "Symbol": true,
  "ZapfDingbats": true
};
function loadBinary(url, cont) {
  var m;
  if (browser3.msie && (m = /^data:.*?;base64,/i.exec(url))) {
    cont(base64ToUint8Array(url.substr(m[0].length)));
    return;
  }
  function error2() {
    if (window.console) {
      if (window.console.error) {
        window.console.error("Cannot load URL: %s", url);
      } else {
        window.console.log("Cannot load URL: %s", url);
      }
    }
    cont(null);
  }
  var req = new XMLHttpRequest();
  req.open("GET", url, true);
  if (HAS_TYPED_ARRAYS) {
    req.responseType = "arraybuffer";
  }
  req.onload = function() {
    if (req.status == 200 || req.status == 304) {
      if (HAS_TYPED_ARRAYS) {
        cont(new Uint8Array(req.response));
      } else {
        cont(new window.VBArray(req.responseBody).toArray());
      }
    } else {
      error2();
    }
  };
  req.onerror = error2;
  req.send(null);
}
function loadFont(url, cont) {
  var font = FONT_CACHE[url];
  if (font) {
    cont(font);
  } else {
    loadBinary(url, function(data) {
      if (data == null) {
        throw new Error("Cannot load font from " + url);
      } else {
        var font2 = new TTFFont(data);
        FONT_CACHE[url] = font2;
        cont(font2);
      }
    });
  }
}
var IMAGE_CACHE = {};
function loadImage(url, size, cont, options2) {
  var img = IMAGE_CACHE[url], bloburl, blob;
  if (img) {
    cont(img);
  } else {
    img = new Image();
    if (!/^data:/i.test(url)) {
      img.crossOrigin = "Anonymous";
    }
    if (HAS_TYPED_ARRAYS && !/^data:/i.test(url)) {
      var xhr = new XMLHttpRequest();
      xhr.onload = function() {
        blob = xhr.response;
        if (browser3.mozilla && blob.type == "image/svg+xml") {
          var reader = new FileReader();
          reader.onload = function() {
            var doc = new window.DOMParser().parseFromString(this.result, "image/svg+xml");
            var svg = doc.documentElement;
            if (svg.getAttribute("width") && svg.getAttribute("height")) {
              bloburl = URL.createObjectURL(blob);
              _load(bloburl);
            } else {
              svg.setAttribute("width", size.width);
              svg.setAttribute("height", size.height);
              var xml = new window.XMLSerializer().serializeToString(svg);
              var dataURL = "data:image/svg+xml;base64," + encodeBase64(xml);
              _load(dataURL);
            }
          };
          reader.readAsText(blob);
        } else {
          bloburl = URL.createObjectURL(blob);
          _load(bloburl);
        }
      };
      xhr.onerror = _onerror;
      xhr.open("GET", url, true);
      xhr.responseType = "blob";
      xhr.send();
    } else {
      _load(url);
    }
  }
  function _load(url2) {
    img.src = url2;
    if (img.complete && !browser3.msie) {
      _onload.call(img);
    } else {
      img.onload = _onload;
      img.onerror = _onerror;
    }
  }
  function _trycanvas() {
    if (!size) {
      size = { width: img.width, height: img.height };
    }
    var canvas = document.createElement("canvas");
    canvas.width = size.width;
    canvas.height = size.height;
    var ctx = canvas.getContext("2d");
    ctx.drawImage(img, 0, 0, size.width, size.height);
    var imgdata;
    try {
      imgdata = ctx.getImageData(0, 0, size.width, size.height);
    } catch (ex) {
      _onerror();
      return;
    } finally {
      if (bloburl) {
        URL.revokeObjectURL(bloburl);
      }
    }
    var hasAlpha = false, rgb = BinaryStream(), alpha = BinaryStream();
    var rawbytes = imgdata.data;
    var i = 0;
    while (i < rawbytes.length) {
      rgb.writeByte(rawbytes[i++]);
      rgb.writeByte(rawbytes[i++]);
      rgb.writeByte(rawbytes[i++]);
      var a = rawbytes[i++];
      if (a < 255) {
        hasAlpha = true;
      }
      alpha.writeByte(a);
    }
    if (hasAlpha || options2.keepPNG) {
      img = new PDFRawImage(size.width, size.height, rgb, alpha);
    } else {
      var data = canvas.toDataURL("image/jpeg", options2.jpegQuality);
      data = data.substr(data.indexOf(";base64,") + 8);
      var stream2 = BinaryStream();
      stream2.writeBase64(data);
      img = new PDFJpegImage(stream2);
    }
    cont(IMAGE_CACHE[url] = img);
  }
  function _onerror() {
    cont(IMAGE_CACHE[url] = "ERROR");
  }
  function _onload() {
    if (size) {
      var svg = blob && blob.type === "image/svg+xml" || /^data:image\/svg\+xml;/i.test(this.src.substring(0, 19));
      var upscale = size.width >= img.width || size.height >= img.height;
      if (!svg && upscale) {
        size = null;
      }
    }
    if (!size && blob && /^image\/jpe?g$/i.test(blob.type)) {
      var reader = new FileReader();
      reader.onload = function() {
        try {
          var img2 = new PDFJpegImage(BinaryStream(new Uint8Array(this.result)));
          URL.revokeObjectURL(bloburl);
          cont(IMAGE_CACHE[url] = img2);
        } catch (ex) {
          _trycanvas();
        }
      };
      reader.readAsArrayBuffer(blob);
    } else {
      _trycanvas();
    }
  }
}
function manyLoader(loadOne) {
  return function(urls, callback) {
    var n = urls.length, i = n;
    if (n === 0) {
      return callback();
    }
    function next() {
      if (--n === 0) {
        callback();
      }
    }
    while (i-- > 0) {
      loadOne(urls[i], next);
    }
  };
}
var loadFonts = manyLoader(loadFont);
var loadImages = function(images, callback, options2) {
  options2 = Object.assign({
    jpegQuality: 0.92,
    keepPNG: false
  }, options2);
  var urls = Object.keys(images), n = urls.length;
  if (n === 0) {
    return callback();
  }
  function next() {
    if (--n === 0) {
      callback();
    }
  }
  urls.forEach(function(url) {
    loadImage(url, images[url], next, options2);
  });
};
var PDFDocument = function PDFDocument2(options2) {
  var self = this;
  var out = makeOutput();
  var objcount = 0;
  var objects = [];
  function getOption(name3, defval) {
    return options2 && options2[name3] != null ? options2[name3] : defval;
  }
  self.getOption = getOption;
  self.attach = function(value) {
    if (objects.indexOf(value) < 0) {
      wrapObject(value, ++objcount);
      objects.push(value);
    }
    return value;
  };
  self.pages = [];
  self.FONTS = {};
  self.IMAGES = {};
  self.GRAD_COL_FUNCTIONS = {};
  self.GRAD_OPC_FUNCTIONS = {};
  self.GRAD_COL = {};
  self.GRAD_OPC = {};
  var catalog = self.attach(new PDFCatalog());
  var pageTree = self.attach(new PDFPageTree());
  if (getOption("autoPrint")) {
    var nameTree = {};
    nameTree.JavaScript = new PDFDictionary({ Names: [
      new PDFString("JS"),
      self.attach(new PDFDictionary({
        S: _("JavaScript"),
        JS: new PDFString("print(true);")
      }))
    ] });
    catalog.props.Names = new PDFDictionary(nameTree);
  }
  catalog.setPages(pageTree);
  var info = self.attach(new PDFDictionary({
    Producer: new PDFString(getOption("producer", "Kendo UI PDF Generator"), true),
    // XXX: kendo.version?
    Title: new PDFString(getOption("title", ""), true),
    Author: new PDFString(getOption("author", ""), true),
    Subject: new PDFString(getOption("subject", ""), true),
    Keywords: new PDFString(getOption("keywords", ""), true),
    Creator: new PDFString(getOption("creator", "Kendo UI PDF Generator"), true),
    CreationDate: getOption("date", new Date())
  }));
  self.addPage = function(options3) {
    var paperOptions = getPaperOptions(function(name3, defval) {
      return options3 && options3[name3] != null ? options3[name3] : defval;
    });
    var paperSize = paperOptions.paperSize;
    var margin = paperOptions.margin;
    var contentWidth = paperSize[0];
    var contentHeight = paperSize[1];
    if (margin) {
      contentWidth -= margin.left + margin.right;
      contentHeight -= margin.top + margin.bottom;
    }
    var content = new PDFStream(makeOutput(), null, true);
    var props = {
      Contents: self.attach(content),
      Parent: pageTree,
      MediaBox: [0, 0, paperSize[0], paperSize[1]]
    };
    var page = new PDFPage(self, props);
    page._content = content;
    pageTree.addPage(self.attach(page));
    page.transform(1, 0, 0, -1, 0, paperSize[1]);
    if (margin) {
      page.translate(margin.left, margin.top);
      page.rect(0, 0, contentWidth, contentHeight);
      page.clip();
    }
    self.pages.push(page);
    return page;
  };
  self.render = function() {
    var i;
    out("%PDF-1.4", NL, "%ÂÁÚÏÎ", NL, NL);
    for (i = 0; i < objects.length; ++i) {
      objects[i].renderFull(out);
      out(NL, NL);
    }
    var xrefOffset = out.offset();
    out("xref", NL, 0, " ", objects.length + 1, NL);
    out("0000000000 65535 f ", NL);
    for (i = 0; i < objects.length; ++i) {
      out(zeropad(objects[i]._offset, 10), " 00000 n ", NL);
    }
    out(NL);
    out("trailer", NL);
    out(new PDFDictionary({
      Size: objects.length + 1,
      Root: catalog,
      Info: info
    }), NL, NL);
    out("startxref", NL, xrefOffset, NL);
    out("%%EOF", NL);
    return out.stream().offset(0);
  };
  self.loadFonts = loadFonts;
  self.loadImages = loadImages;
};
PDFDocument.prototype.getFont = function getFont(url) {
  var font = this.FONTS[url];
  if (!font) {
    font = FONT_CACHE[url];
    if (!font) {
      throw new Error("Font " + url + " has not been loaded");
    }
    if (font === true) {
      font = this.attach(new PDFStandardFont(url));
    } else {
      font = this.attach(new PDFFont(this, font));
    }
    this.FONTS[url] = font;
  }
  return font;
};
PDFDocument.prototype.getImage = function getImage(url) {
  var img = this.IMAGES[url];
  if (!img) {
    img = IMAGE_CACHE[url];
    if (!img) {
      throw new Error("Image " + url + " has not been loaded");
    }
    if (img === "ERROR") {
      return null;
    }
    img = this.IMAGES[url] = this.attach(img.asStream(this));
  }
  return img;
};
PDFDocument.prototype.getOpacityGS = function getOpacityGS(opacity, forStroke) {
  var id = parseFloat(opacity).toFixed(3);
  opacity = parseFloat(id);
  id += forStroke ? "S" : "F";
  var cache2 = this._opacityGSCache || (this._opacityGSCache = {});
  var gs = cache2[id];
  if (!gs) {
    var props = {
      Type: _("ExtGState")
    };
    if (forStroke) {
      props.CA = opacity;
    } else {
      props.ca = opacity;
    }
    gs = this.attach(new PDFDictionary(props));
    gs._resourceName = _("GS" + ++RESOURCE_COUNTER);
    cache2[id] = gs;
  }
  return gs;
};
PDFDocument.prototype.dict = function dict(props) {
  return new PDFDictionary(props);
};
PDFDocument.prototype.name = function name2(str) {
  return _(str);
};
PDFDocument.prototype.stream = function stream(props, content) {
  return new PDFStream(content, props);
};
function pad2(str, len, ch) {
  while (str.length < len) {
    str = ch + str;
  }
  return str;
}
function zeropad(n, len) {
  return pad2(String(n), len, "0");
}
function hasOwnProperty2(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
var isArray2 = Array.isArray || function(obj) {
  return obj instanceof Array;
};
function isDate2(obj) {
  return obj instanceof Date;
}
function renderArray(a, out) {
  out("[");
  if (a.length > 0) {
    out.withIndent(function() {
      for (var i = 0; i < a.length; ++i) {
        if (i > 0 && i % 8 === 0) {
          out.indent(a[i]);
        } else {
          out(" ", a[i]);
        }
      }
    });
  }
  out(" ]");
}
function renderDate(date, out) {
  out(
    "(D:",
    zeropad(date.getUTCFullYear(), 4),
    zeropad(date.getUTCMonth() + 1, 2),
    zeropad(date.getUTCDate(), 2),
    zeropad(date.getUTCHours(), 2),
    zeropad(date.getUTCMinutes(), 2),
    zeropad(date.getUTCSeconds(), 2),
    "Z)"
  );
}
function mm2pt(mm) {
  return mm * (72 / 25.4);
}
function cm2pt(cm) {
  return mm2pt(cm * 10);
}
function in2pt(inch) {
  return inch * 72;
}
function unitsToPoints(x, def) {
  if (typeof x == "number") {
    return x;
  }
  if (typeof x == "string") {
    var m;
    m = /^\s*([0-9.]+)\s*(mm|cm|in|pt)\s*$/.exec(x);
    if (m) {
      var num = parseFloat(m[1]);
      if (!isNaN(num)) {
        if (m[2] == "pt") {
          return num;
        }
        return {
          "mm": mm2pt,
          "cm": cm2pt,
          "in": in2pt
        }[m[2]](num);
      }
    }
  }
  if (def != null) {
    return def;
  }
  throw new Error("Can't parse unit: " + x);
}
var PDFValue = function PDFValue2() {
};
PDFValue.prototype.beforeRender = function beforeRender() {
};
var PDFString = function(PDFValue3) {
  function PDFString2(value, utf16be) {
    PDFValue3.call(this);
    this.value = value;
    this.utf16be = Boolean(utf16be);
  }
  if (PDFValue3)
    PDFString2.__proto__ = PDFValue3;
  PDFString2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFString2.prototype.constructor = PDFString2;
  PDFString2.prototype.render = function render3(out) {
    var txt = this.value;
    if (this.utf16be) {
      txt = BOM + encodeUTF16BE(txt);
      txt = txt.replace(/([\(\)\\])/g, "\\$1");
      out("(", txt, ")");
    } else {
      var data = [40];
      for (var i = 0; i < txt.length; ++i) {
        var code2 = txt.charCodeAt(i) & 255;
        if (code2 == 40 || code2 == 41 || code2 == 92) {
          data.push(92);
        }
        data.push(code2);
      }
      data.push(41);
      out.writeData(data);
    }
  };
  PDFString2.prototype.toString = function toString4() {
    return this.value;
  };
  return PDFString2;
}(PDFValue);
var PDFHexString = function(PDFString2) {
  function PDFHexString2(value) {
    PDFString2.call(this, value);
    this.value = value;
  }
  if (PDFString2)
    PDFHexString2.__proto__ = PDFString2;
  PDFHexString2.prototype = Object.create(PDFString2 && PDFString2.prototype);
  PDFHexString2.prototype.constructor = PDFHexString2;
  PDFHexString2.prototype.render = function render3(out) {
    var this$1 = this;
    out("<");
    for (var i = 0; i < this.value.length; ++i) {
      out(zeropad(this$1.value.charCodeAt(i).toString(16), 4));
    }
    out(">");
  };
  return PDFHexString2;
}(PDFString);
var PDFName = function(PDFValue3) {
  function PDFName2(name3) {
    PDFValue3.call(this);
    this.name = name3;
  }
  if (PDFValue3)
    PDFName2.__proto__ = PDFValue3;
  PDFName2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFName2.prototype.constructor = PDFName2;
  PDFName2.get = function get2(name3) {
    return _(name3);
  };
  PDFName2.prototype.render = function render3(out) {
    out("/" + this.escape());
  };
  PDFName2.prototype.escape = function escape() {
    return this.name.replace(/[^\x21-\x7E]/g, function(c) {
      return "#" + zeropad(c.charCodeAt(0).toString(16), 2);
    });
  };
  PDFName2.prototype.toString = function toString4() {
    return this.name;
  };
  return PDFName2;
}(PDFValue);
var PDFName_cache = {};
function _(name3) {
  if (hasOwnProperty2(PDFName_cache, name3)) {
    return PDFName_cache[name3];
  }
  return PDFName_cache[name3] = new PDFName(name3);
}
var PDFDictionary = function(PDFValue3) {
  function PDFDictionary2(props) {
    PDFValue3.call(this);
    this.props = props;
  }
  if (PDFValue3)
    PDFDictionary2.__proto__ = PDFValue3;
  PDFDictionary2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFDictionary2.prototype.constructor = PDFDictionary2;
  PDFDictionary2.prototype.render = function render3(out) {
    var props = this.props, empty = true;
    out("<<");
    out.withIndent(function() {
      for (var i in props) {
        if (hasOwnProperty2(props, i) && !/^_/.test(i)) {
          empty = false;
          out.indent(_(i), " ", props[i]);
        }
      }
    });
    if (!empty) {
      out.indent();
    }
    out(">>");
  };
  return PDFDictionary2;
}(PDFValue);
var PDFStream = function(PDFValue3) {
  function PDFStream2(data, props, compress) {
    PDFValue3.call(this);
    if (typeof data == "string") {
      var tmp = BinaryStream();
      tmp.write(data);
      data = tmp;
    }
    this.data = data;
    this.props = props || {};
    this.compress = compress;
  }
  if (PDFValue3)
    PDFStream2.__proto__ = PDFValue3;
  PDFStream2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFStream2.prototype.constructor = PDFStream2;
  PDFStream2.prototype.render = function render3(out) {
    var data = this.data.get(), props = this.props;
    if (this.compress && supportsDeflate()) {
      if (!props.Filter) {
        props.Filter = [];
      } else if (!(props.Filter instanceof Array)) {
        props.Filter = [props.Filter];
      }
      props.Filter.unshift(_("FlateDecode"));
      data = deflate2(data);
    }
    props.Length = data.length;
    out(new PDFDictionary(props), " stream", NL);
    out.writeData(data);
    out(NL, "endstream");
  };
  return PDFStream2;
}(PDFValue);
var PDFCatalog = function(PDFDictionary2) {
  function PDFCatalog2() {
    PDFDictionary2.call(this, {
      Type: _("Catalog")
    });
  }
  if (PDFDictionary2)
    PDFCatalog2.__proto__ = PDFDictionary2;
  PDFCatalog2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFCatalog2.prototype.constructor = PDFCatalog2;
  PDFCatalog2.prototype.setPages = function setPages(pagesObj) {
    this.props.Pages = pagesObj;
  };
  return PDFCatalog2;
}(PDFDictionary);
var PDFPageTree = function(PDFDictionary2) {
  function PDFPageTree2() {
    PDFDictionary2.call(this, {
      Type: _("Pages"),
      Kids: [],
      Count: 0
    });
  }
  if (PDFDictionary2)
    PDFPageTree2.__proto__ = PDFDictionary2;
  PDFPageTree2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFPageTree2.prototype.constructor = PDFPageTree2;
  PDFPageTree2.prototype.addPage = function addPage(pageObj) {
    this.props.Kids.push(pageObj);
    this.props.Count++;
  };
  return PDFPageTree2;
}(PDFDictionary);
var SOF_CODES = [192, 193, 194, 195, 197, 198, 199, 201, 202, 203, 205, 206, 207];
var PDFJpegImage = function PDFJpegImage2(data) {
  data.offset(0);
  var width, height, colorSpace, bitsPerComponent;
  var soi = data.readShort();
  if (soi != 65496) {
    throw new Error("Invalid JPEG image");
  }
  while (!data.eof()) {
    var ff = data.readByte();
    if (ff != 255) {
      throw new Error("Invalid JPEG image");
    }
    var marker = data.readByte();
    var length = data.readShort();
    if (SOF_CODES.indexOf(marker) >= 0) {
      bitsPerComponent = data.readByte();
      height = data.readShort();
      width = data.readShort();
      colorSpace = data.readByte();
      break;
    }
    data.skip(length - 2);
  }
  if (colorSpace == null) {
    throw new Error("Invalid JPEG image");
  }
  var props = {
    Type: _("XObject"),
    Subtype: _("Image"),
    Width: width,
    Height: height,
    BitsPerComponent: bitsPerComponent,
    Filter: _("DCTDecode")
  };
  switch (colorSpace) {
    case 1:
      props.ColorSpace = _("DeviceGray");
      break;
    case 3:
      props.ColorSpace = _("DeviceRGB");
      break;
    case 4:
      props.ColorSpace = _("DeviceCMYK");
      props.Decode = [1, 0, 1, 0, 1, 0, 1, 0];
      break;
  }
  this.asStream = function() {
    data.offset(0);
    var stream2 = new PDFStream(data, props);
    stream2._resourceName = _("I" + ++RESOURCE_COUNTER);
    return stream2;
  };
};
var PDFRawImage = function PDFRawImage2(width, height, rgb, alpha) {
  this.asStream = function(pdf) {
    var mask = new PDFStream(alpha, {
      Type: _("XObject"),
      Subtype: _("Image"),
      Width: width,
      Height: height,
      BitsPerComponent: 8,
      ColorSpace: _("DeviceGray")
    }, true);
    var stream2 = new PDFStream(rgb, {
      Type: _("XObject"),
      Subtype: _("Image"),
      Width: width,
      Height: height,
      BitsPerComponent: 8,
      ColorSpace: _("DeviceRGB"),
      SMask: pdf.attach(mask)
    }, true);
    stream2._resourceName = _("I" + ++RESOURCE_COUNTER);
    return stream2;
  };
};
var PDFStandardFont = function(PDFDictionary2) {
  function PDFStandardFont2(name3) {
    PDFDictionary2.call(this, {
      Type: _("Font"),
      Subtype: _("Type1"),
      BaseFont: _(name3)
    });
    this._resourceName = _("F" + ++RESOURCE_COUNTER);
  }
  if (PDFDictionary2)
    PDFStandardFont2.__proto__ = PDFDictionary2;
  PDFStandardFont2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFStandardFont2.prototype.constructor = PDFStandardFont2;
  PDFStandardFont2.prototype.encodeText = function encodeText2(str) {
    return new PDFString(String(str));
  };
  return PDFStandardFont2;
}(PDFDictionary);
var PDFFont = function(PDFDictionary2) {
  function PDFFont2(pdf, font, props) {
    PDFDictionary2.call(this, {});
    props = this.props;
    props.Type = _("Font");
    props.Subtype = _("Type0");
    props.Encoding = _("Identity-H");
    this._pdf = pdf;
    this._font = font;
    this._sub = font.makeSubset();
    this._resourceName = _("F" + ++RESOURCE_COUNTER);
    var head = font.head;
    this.name = font.psName;
    var scale = this.scale = font.scale;
    this.bbox = [
      head.xMin * scale,
      head.yMin * scale,
      head.xMax * scale,
      head.yMax * scale
    ];
    this.italicAngle = font.post.italicAngle;
    this.ascent = font.ascent * scale;
    this.descent = font.descent * scale;
    this.lineGap = font.lineGap * scale;
    this.capHeight = font.os2.capHeight || this.ascent;
    this.xHeight = font.os2.xHeight || 0;
    this.stemV = 0;
    this.familyClass = (font.os2.familyClass || 0) >> 8;
    this.isSerif = this.familyClass >= 1 && this.familyClass <= 7;
    this.isScript = this.familyClass == 10;
    this.flags = (font.post.isFixedPitch ? 1 : 0) | (this.isSerif ? 1 << 1 : 0) | (this.isScript ? 1 << 3 : 0) | (this.italicAngle !== 0 ? 1 << 6 : 0) | 1 << 5;
  }
  if (PDFDictionary2)
    PDFFont2.__proto__ = PDFDictionary2;
  PDFFont2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFFont2.prototype.constructor = PDFFont2;
  PDFFont2.prototype.encodeText = function encodeText2(text) {
    return new PDFHexString(this._sub.encodeText(String(text)));
  };
  PDFFont2.prototype.getTextWidth = function getTextWidth(fontSize, text) {
    var this$1 = this;
    var width = 0, codeMap = this._font.cmap.codeMap;
    for (var i = 0; i < text.length; ++i) {
      var glyphId = codeMap[text.charCodeAt(i)];
      width += this$1._font.widthOfGlyph(glyphId || 0);
    }
    return width * fontSize / 1e3;
  };
  PDFFont2.prototype.beforeRender = function beforeRender2() {
    var self = this;
    var sub = self._sub;
    var data = sub.render();
    var fontStream = new PDFStream(BinaryStream(data), {
      Length1: data.length
    }, true);
    var descriptor = self._pdf.attach(new PDFDictionary2({
      Type: _("FontDescriptor"),
      FontName: _(self._sub.psName),
      FontBBox: self.bbox,
      Flags: self.flags,
      StemV: self.stemV,
      ItalicAngle: self.italicAngle,
      Ascent: self.ascent,
      Descent: self.descent,
      CapHeight: self.capHeight,
      XHeight: self.xHeight,
      FontFile2: self._pdf.attach(fontStream)
    }));
    var cmap = sub.ncid2ogid;
    var firstChar = sub.firstChar;
    var lastChar = sub.lastChar;
    var charWidths = [];
    (function loop(i, chunk) {
      if (i <= lastChar) {
        var gid = cmap[i];
        if (gid == null) {
          loop(i + 1);
        } else {
          if (!chunk) {
            charWidths.push(i, chunk = []);
          }
          chunk.push(self._font.widthOfGlyph(gid));
          loop(i + 1, chunk);
        }
      }
    })(firstChar);
    var descendant = new PDFDictionary2({
      Type: _("Font"),
      Subtype: _("CIDFontType2"),
      BaseFont: _(self._sub.psName),
      CIDSystemInfo: new PDFDictionary2({
        Registry: new PDFString("Adobe"),
        Ordering: new PDFString("Identity"),
        Supplement: 0
      }),
      FontDescriptor: descriptor,
      FirstChar: firstChar,
      LastChar: lastChar,
      DW: Math.round(self._font.widthOfGlyph(0)),
      W: charWidths,
      CIDToGIDMap: self._pdf.attach(self._makeCidToGidMap())
    });
    var dict2 = self.props;
    dict2.BaseFont = _(self._sub.psName);
    dict2.DescendantFonts = [self._pdf.attach(descendant)];
    var unimap = new PDFToUnicodeCmap(firstChar, lastChar, sub.subset);
    var unimapStream = new PDFStream(makeOutput(), null, true);
    unimapStream.data(unimap);
    dict2.ToUnicode = self._pdf.attach(unimapStream);
  };
  PDFFont2.prototype._makeCidToGidMap = function _makeCidToGidMap() {
    return new PDFStream(BinaryStream(this._sub.cidToGidMap()), null, true);
  };
  return PDFFont2;
}(PDFDictionary);
var PDFToUnicodeCmap = function(PDFValue3) {
  function PDFToUnicodeCmap2(firstChar, lastChar, map2) {
    PDFValue3.call(this);
    this.firstChar = firstChar;
    this.lastChar = lastChar;
    this.map = map2;
  }
  if (PDFValue3)
    PDFToUnicodeCmap2.__proto__ = PDFValue3;
  PDFToUnicodeCmap2.prototype = Object.create(PDFValue3 && PDFValue3.prototype);
  PDFToUnicodeCmap2.prototype.constructor = PDFToUnicodeCmap2;
  PDFToUnicodeCmap2.prototype.render = function render3(out) {
    out.indent("/CIDInit /ProcSet findresource begin");
    out.indent("12 dict begin");
    out.indent("begincmap");
    out.indent("/CIDSystemInfo <<");
    out.indent("  /Registry (Adobe)");
    out.indent("  /Ordering (UCS)");
    out.indent("  /Supplement 0");
    out.indent(">> def");
    out.indent("/CMapName /Adobe-Identity-UCS def");
    out.indent("/CMapType 2 def");
    out.indent("1 begincodespacerange");
    out.indent("  <0000><ffff>");
    out.indent("endcodespacerange");
    var self = this;
    out.indent(self.lastChar - self.firstChar + 1, " beginbfchar");
    out.withIndent(function() {
      for (var code2 = self.firstChar; code2 <= self.lastChar; ++code2) {
        var unicode = self.map[code2];
        var str = ucs2encode([unicode]);
        out.indent("<", zeropad(code2.toString(16), 4), ">", "<");
        for (var i = 0; i < str.length; ++i) {
          out(zeropad(str.charCodeAt(i).toString(16), 4));
        }
        out(">");
      }
    });
    out.indent("endbfchar");
    out.indent("endcmap");
    out.indent("CMapName currentdict /CMap defineresource pop");
    out.indent("end");
    out.indent("end");
  };
  return PDFToUnicodeCmap2;
}(PDFValue);
function makeHash(a) {
  return a.map(function(x) {
    return isArray2(x) ? makeHash(x) : typeof x == "number" ? (Math.round(x * 1e3) / 1e3).toFixed(3) : x;
  }).join(" ");
}
function cacheColorGradientFunction(pdf, r1, g1, b1, r2, g2, b2) {
  var hash = makeHash([r1, g1, b1, r2, g2, b2]);
  var func = pdf.GRAD_COL_FUNCTIONS[hash];
  if (!func) {
    func = pdf.GRAD_COL_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({
      FunctionType: 2,
      Domain: [0, 1],
      Range: [0, 1, 0, 1, 0, 1],
      N: 1,
      C0: [r1, g1, b1],
      C1: [r2, g2, b2]
    }));
  }
  return func;
}
function cacheOpacityGradientFunction(pdf, a1, a2) {
  var hash = makeHash([a1, a2]);
  var func = pdf.GRAD_OPC_FUNCTIONS[hash];
  if (!func) {
    func = pdf.GRAD_OPC_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({
      FunctionType: 2,
      Domain: [0, 1],
      Range: [0, 1],
      N: 1,
      C0: [a1],
      C1: [a2]
    }));
  }
  return func;
}
function makeGradientFunctions(pdf, stops) {
  var hasAlpha = false;
  var opacities = [];
  var colors = [];
  var offsets = [];
  var encode = [];
  var i, prev, cur, prevColor, curColor;
  for (i = 1; i < stops.length; ++i) {
    prev = stops[i - 1];
    cur = stops[i];
    prevColor = prev.color;
    curColor = cur.color;
    colors.push(cacheColorGradientFunction(
      pdf,
      prevColor.r,
      prevColor.g,
      prevColor.b,
      curColor.r,
      curColor.g,
      curColor.b
    ));
    if (prevColor.a < 1 || curColor.a < 1) {
      hasAlpha = true;
    }
    offsets.push(cur.offset);
    encode.push(0, 1);
  }
  if (hasAlpha) {
    for (i = 1; i < stops.length; ++i) {
      prev = stops[i - 1];
      cur = stops[i];
      prevColor = prev.color;
      curColor = cur.color;
      opacities.push(cacheOpacityGradientFunction(
        pdf,
        prevColor.a,
        curColor.a
      ));
    }
  }
  offsets.pop();
  return {
    hasAlpha,
    colors: assemble(colors),
    opacities: hasAlpha ? assemble(opacities) : null
  };
  function assemble(funcs) {
    if (funcs.length == 1) {
      return funcs[0];
    }
    return {
      FunctionType: 3,
      Functions: funcs,
      Domain: [0, 1],
      Bounds: offsets,
      Encode: encode
    };
  }
}
function cacheColorGradient(pdf, isRadial, stops, coords, funcs, box) {
  var shading, hash;
  if (!box) {
    var a = [isRadial].concat(coords);
    stops.forEach(function(x) {
      a.push(x.offset, x.color.r, x.color.g, x.color.b);
    });
    hash = makeHash(a);
    shading = pdf.GRAD_COL[hash];
  }
  if (!shading) {
    shading = new PDFDictionary({
      Type: _("Shading"),
      ShadingType: isRadial ? 3 : 2,
      ColorSpace: _("DeviceRGB"),
      Coords: coords,
      Domain: [0, 1],
      Function: funcs,
      Extend: [true, true]
    });
    pdf.attach(shading);
    shading._resourceName = "S" + ++RESOURCE_COUNTER;
    if (hash) {
      pdf.GRAD_COL[hash] = shading;
    }
  }
  return shading;
}
function cacheOpacityGradient(pdf, isRadial, stops, coords, funcs, box) {
  var opacity, hash;
  if (!box) {
    var a = [isRadial].concat(coords);
    stops.forEach(function(x) {
      a.push(x.offset, x.color.a);
    });
    hash = makeHash(a);
    opacity = pdf.GRAD_OPC[hash];
  }
  if (!opacity) {
    opacity = new PDFDictionary({
      Type: _("ExtGState"),
      AIS: false,
      CA: 1,
      ca: 1,
      SMask: {
        Type: _("Mask"),
        S: _("Luminosity"),
        G: pdf.attach(new PDFStream("/a0 gs /s0 sh", {
          Type: _("XObject"),
          Subtype: _("Form"),
          FormType: 1,
          BBox: box ? [
            box.left,
            box.top + box.height,
            box.left + box.width,
            box.top
          ] : [0, 1, 1, 0],
          Group: {
            Type: _("Group"),
            S: _("Transparency"),
            CS: _("DeviceGray"),
            I: true
          },
          Resources: {
            ExtGState: {
              a0: { CA: 1, ca: 1 }
            },
            Shading: {
              s0: {
                ColorSpace: _("DeviceGray"),
                Coords: coords,
                Domain: [0, 1],
                ShadingType: isRadial ? 3 : 2,
                Function: funcs,
                Extend: [true, true]
              }
            }
          }
        }))
      }
    });
    pdf.attach(opacity);
    opacity._resourceName = "O" + ++RESOURCE_COUNTER;
    if (hash) {
      pdf.GRAD_OPC[hash] = opacity;
    }
  }
  return opacity;
}
function cacheGradient(pdf, gradient, box) {
  var isRadial = gradient.type == "radial";
  var funcs = makeGradientFunctions(pdf, gradient.stops);
  var coords = isRadial ? [
    gradient.start.x,
    gradient.start.y,
    gradient.start.r,
    gradient.end.x,
    gradient.end.y,
    gradient.end.r
  ] : [
    gradient.start.x,
    gradient.start.y,
    gradient.end.x,
    gradient.end.y
  ];
  var shading = cacheColorGradient(
    pdf,
    isRadial,
    gradient.stops,
    coords,
    funcs.colors,
    gradient.userSpace && box
  );
  var opacity = funcs.hasAlpha ? cacheOpacityGradient(
    pdf,
    isRadial,
    gradient.stops,
    coords,
    funcs.opacities,
    gradient.userSpace && box
  ) : null;
  return {
    hasAlpha: funcs.hasAlpha,
    shading,
    opacity
  };
}
var PDFPage = function(PDFDictionary2) {
  function PDFPage2(pdf, props) {
    PDFDictionary2.call(this, props);
    this._pdf = pdf;
    this._rcount = 0;
    this._textMode = false;
    this._fontResources = {};
    this._gsResources = {};
    this._xResources = {};
    this._patResources = {};
    this._shResources = {};
    this._opacity = 1;
    this._matrix = [1, 0, 0, 1, 0, 0];
    this._annotations = [];
    this._font = null;
    this._fontSize = null;
    this._contextStack = [];
    props = this.props;
    props.Type = _("Page");
    props.ProcSet = [
      _("PDF"),
      _("Text"),
      _("ImageB"),
      _("ImageC"),
      _("ImageI")
    ];
    props.Resources = new PDFDictionary2({
      Font: new PDFDictionary2(this._fontResources),
      ExtGState: new PDFDictionary2(this._gsResources),
      XObject: new PDFDictionary2(this._xResources),
      Pattern: new PDFDictionary2(this._patResources),
      Shading: new PDFDictionary2(this._shResources)
    });
    props.Annots = this._annotations;
  }
  if (PDFDictionary2)
    PDFPage2.__proto__ = PDFDictionary2;
  PDFPage2.prototype = Object.create(PDFDictionary2 && PDFDictionary2.prototype);
  PDFPage2.prototype.constructor = PDFPage2;
  PDFPage2.prototype._out = function _out() {
    this._content.data.apply(null, arguments);
  };
  PDFPage2.prototype.transform = function transform2(a, b, c, d, e, f) {
    if (!isIdentityMatrix(arguments)) {
      this._matrix = mmul(arguments, this._matrix);
      this._out(a, " ", b, " ", c, " ", d, " ", e, " ", f, " cm");
      this._out(NL);
    }
  };
  PDFPage2.prototype.translate = function translate2(dx, dy) {
    this.transform(1, 0, 0, 1, dx, dy);
  };
  PDFPage2.prototype.scale = function scale(sx, sy) {
    this.transform(sx, 0, 0, sy, 0, 0);
  };
  PDFPage2.prototype.rotate = function rotate(angle) {
    var cos2 = Math.cos(angle), sin3 = Math.sin(angle);
    this.transform(cos2, sin3, -sin3, cos2, 0, 0);
  };
  PDFPage2.prototype.beginText = function beginText() {
    this._textMode = true;
    this._out("BT", NL);
  };
  PDFPage2.prototype.endText = function endText() {
    this._textMode = false;
    this._out("ET", NL);
  };
  PDFPage2.prototype._requireTextMode = function _requireTextMode() {
    if (!this._textMode) {
      throw new Error("Text mode required; call page.beginText() first");
    }
  };
  PDFPage2.prototype._requireFont = function _requireFont() {
    if (!this._font) {
      throw new Error("No font selected; call page.setFont() first");
    }
  };
  PDFPage2.prototype.setFont = function setFont(font, size) {
    this._requireTextMode();
    if (font == null) {
      font = this._font;
    } else if (!(font instanceof PDFFont)) {
      font = this._pdf.getFont(font);
    }
    if (size == null) {
      size = this._fontSize;
    }
    this._fontResources[font._resourceName] = font;
    this._font = font;
    this._fontSize = size;
    this._out(font._resourceName, " ", size, " Tf", NL);
  };
  PDFPage2.prototype.setTextLeading = function setTextLeading(size) {
    this._requireTextMode();
    this._out(size, " TL", NL);
  };
  PDFPage2.prototype.setTextRenderingMode = function setTextRenderingMode(mode) {
    this._requireTextMode();
    this._out(mode, " Tr", NL);
  };
  PDFPage2.prototype.showText = function showText(text, requestedWidth) {
    this._requireFont();
    if (text.length > 1 && requestedWidth && this._font instanceof PDFFont) {
      var outputWidth = this._font.getTextWidth(this._fontSize, text);
      var scale = requestedWidth / outputWidth * 100;
      this._out(scale, " Tz ");
    }
    this._out(this._font.encodeText(text), " Tj", NL);
  };
  PDFPage2.prototype.showTextNL = function showTextNL(text) {
    this._requireFont();
    this._out(this._font.encodeText(text), " '", NL);
  };
  PDFPage2.prototype.addLink = function addLink(uri, box) {
    var ll = this._toPage({ x: box.left, y: box.bottom });
    var ur = this._toPage({ x: box.right, y: box.top });
    this._annotations.push(new PDFDictionary2({
      Type: _("Annot"),
      Subtype: _("Link"),
      Rect: [ll.x, ll.y, ur.x, ur.y],
      Border: [0, 0, 0],
      A: new PDFDictionary2({
        Type: _("Action"),
        S: _("URI"),
        URI: new PDFString(uri)
      })
    }));
  };
  PDFPage2.prototype.setStrokeColor = function setStrokeColor(r, g, b) {
    this._out(r, " ", g, " ", b, " RG", NL);
  };
  PDFPage2.prototype.setOpacity = function setOpacity(opacity) {
    this.setFillOpacity(opacity);
    this.setStrokeOpacity(opacity);
    this._opacity *= opacity;
  };
  PDFPage2.prototype.setStrokeOpacity = function setStrokeOpacity(opacity) {
    if (opacity < 1) {
      var gs = this._pdf.getOpacityGS(this._opacity * opacity, true);
      this._gsResources[gs._resourceName] = gs;
      this._out(gs._resourceName, " gs", NL);
    }
  };
  PDFPage2.prototype.setFillColor = function setFillColor(r, g, b) {
    this._out(r, " ", g, " ", b, " rg", NL);
  };
  PDFPage2.prototype.setFillOpacity = function setFillOpacity(opacity) {
    if (opacity < 1) {
      var gs = this._pdf.getOpacityGS(this._opacity * opacity, false);
      this._gsResources[gs._resourceName] = gs;
      this._out(gs._resourceName, " gs", NL);
    }
  };
  PDFPage2.prototype.gradient = function gradient(gradient$1, box) {
    this.save();
    this.rect(box.left, box.top, box.width, box.height);
    this.clip();
    if (!gradient$1.userSpace) {
      this.transform(box.width, 0, 0, box.height, box.left, box.top);
    }
    var g = cacheGradient(this._pdf, gradient$1, box);
    var sname = g.shading._resourceName, oname;
    this._shResources[sname] = g.shading;
    if (g.hasAlpha) {
      oname = g.opacity._resourceName;
      this._gsResources[oname] = g.opacity;
      this._out("/" + oname + " gs ");
    }
    this._out("/" + sname + " sh", NL);
    this.restore();
  };
  PDFPage2.prototype.setDashPattern = function setDashPattern(dashArray, dashPhase) {
    this._out(dashArray, " ", dashPhase, " d", NL);
  };
  PDFPage2.prototype.setLineWidth = function setLineWidth(width) {
    this._out(width, " w", NL);
  };
  PDFPage2.prototype.setLineCap = function setLineCap(lineCap) {
    this._out(lineCap, " J", NL);
  };
  PDFPage2.prototype.setLineJoin = function setLineJoin(lineJoin) {
    this._out(lineJoin, " j", NL);
  };
  PDFPage2.prototype.setMitterLimit = function setMitterLimit(mitterLimit) {
    this._out(mitterLimit, " M", NL);
  };
  PDFPage2.prototype.save = function save() {
    this._contextStack.push(this._context());
    this._out("q", NL);
  };
  PDFPage2.prototype.restore = function restore() {
    this._out("Q", NL);
    this._context(this._contextStack.pop());
  };
  PDFPage2.prototype.moveTo = function moveTo(x, y) {
    this._out(x, " ", y, " m", NL);
  };
  PDFPage2.prototype.lineTo = function lineTo(x, y) {
    this._out(x, " ", y, " l", NL);
  };
  PDFPage2.prototype.bezier = function bezier(x1, y1, x2, y2, x3, y3) {
    this._out(x1, " ", y1, " ", x2, " ", y2, " ", x3, " ", y3, " c", NL);
  };
  PDFPage2.prototype.bezier1 = function bezier1(x1, y1, x3, y3) {
    this._out(x1, " ", y1, " ", x3, " ", y3, " y", NL);
  };
  PDFPage2.prototype.bezier2 = function bezier2(x2, y2, x3, y3) {
    this._out(x2, " ", y2, " ", x3, " ", y3, " v", NL);
  };
  PDFPage2.prototype.close = function close2() {
    this._out("h", NL);
  };
  PDFPage2.prototype.rect = function rect(x, y, w, h) {
    this._out(x, " ", y, " ", w, " ", h, " re", NL);
  };
  PDFPage2.prototype.ellipse = function ellipse(x, y, rx, ry) {
    function _X(v) {
      return x + v;
    }
    function _Y(v) {
      return y + v;
    }
    var k = 0.5522847498307936;
    this.moveTo(_X(0), _Y(ry));
    this.bezier(
      _X(rx * k),
      _Y(ry),
      _X(rx),
      _Y(ry * k),
      _X(rx),
      _Y(0)
    );
    this.bezier(
      _X(rx),
      _Y(-ry * k),
      _X(rx * k),
      _Y(-ry),
      _X(0),
      _Y(-ry)
    );
    this.bezier(
      _X(-rx * k),
      _Y(-ry),
      _X(-rx),
      _Y(-ry * k),
      _X(-rx),
      _Y(0)
    );
    this.bezier(
      _X(-rx),
      _Y(ry * k),
      _X(-rx * k),
      _Y(ry),
      _X(0),
      _Y(ry)
    );
  };
  PDFPage2.prototype.circle = function circle(x, y, r) {
    this.ellipse(x, y, r, r);
  };
  PDFPage2.prototype.stroke = function stroke() {
    this._out("S", NL);
  };
  PDFPage2.prototype.nop = function nop() {
    this._out("n", NL);
  };
  PDFPage2.prototype.clip = function clip() {
    this._out("W n", NL);
  };
  PDFPage2.prototype.clipStroke = function clipStroke() {
    this._out("W S", NL);
  };
  PDFPage2.prototype.closeStroke = function closeStroke() {
    this._out("s", NL);
  };
  PDFPage2.prototype.fill = function fill() {
    this._out("f", NL);
  };
  PDFPage2.prototype.fillStroke = function fillStroke() {
    this._out("B", NL);
  };
  PDFPage2.prototype.drawImage = function drawImage(url) {
    var img = this._pdf.getImage(url);
    if (img) {
      this._xResources[img._resourceName] = img;
      this._out(img._resourceName, " Do", NL);
    }
  };
  PDFPage2.prototype.comment = function comment(txt) {
    var self = this;
    txt.split(/\r?\n/g).forEach(function(line) {
      self._out("% ", line, NL);
    });
  };
  PDFPage2.prototype._context = function _context(val) {
    if (val != null) {
      this._opacity = val.opacity;
      this._matrix = val.matrix;
    } else {
      return {
        opacity: this._opacity,
        matrix: this._matrix
      };
    }
  };
  PDFPage2.prototype._toPage = function _toPage(p2) {
    var m = this._matrix;
    var a = m[0], b = m[1], c = m[2], d = m[3], e = m[4], f = m[5];
    return {
      x: a * p2.x + c * p2.y + e,
      y: b * p2.x + d * p2.y + f
    };
  };
  return PDFPage2;
}(PDFDictionary);
var FONT_MAPPINGS = {
  "serif": "Times-Roman",
  "serif|bold": "Times-Bold",
  "serif|italic": "Times-Italic",
  "serif|bold|italic": "Times-BoldItalic",
  "sans-serif": "Helvetica",
  "sans-serif|bold": "Helvetica-Bold",
  "sans-serif|italic": "Helvetica-Oblique",
  "sans-serif|bold|italic": "Helvetica-BoldOblique",
  "monospace": "Courier",
  "monospace|bold": "Courier-Bold",
  "monospace|italic": "Courier-Oblique",
  "monospace|bold|italic": "Courier-BoldOblique",
  "zapfdingbats": "ZapfDingbats",
  "zapfdingbats|bold": "ZapfDingbats",
  "zapfdingbats|italic": "ZapfDingbats",
  "zapfdingbats|bold|italic": "ZapfDingbats"
};
function fontAlias(alias, name3) {
  alias = alias.toLowerCase();
  FONT_MAPPINGS[alias] = function() {
    return FONT_MAPPINGS[name3];
  };
  FONT_MAPPINGS[alias + "|bold"] = function() {
    return FONT_MAPPINGS[name3 + "|bold"];
  };
  FONT_MAPPINGS[alias + "|italic"] = function() {
    return FONT_MAPPINGS[name3 + "|italic"];
  };
  FONT_MAPPINGS[alias + "|bold|italic"] = function() {
    return FONT_MAPPINGS[name3 + "|bold|italic"];
  };
}
fontAlias("Times New Roman", "serif");
fontAlias("Courier New", "monospace");
fontAlias("Arial", "sans-serif");
fontAlias("Helvetica", "sans-serif");
fontAlias("Verdana", "sans-serif");
fontAlias("Tahoma", "sans-serif");
fontAlias("Georgia", "sans-serif");
fontAlias("Monaco", "monospace");
fontAlias("Andale Mono", "monospace");
function defineFont(name3, url) {
  if (arguments.length == 1) {
    for (var i in name3) {
      if (hasOwnProperty2(name3, i)) {
        defineFont(i, name3[i]);
      }
    }
  } else {
    name3 = name3.toLowerCase();
    FONT_MAPPINGS[name3] = url;
    switch (name3) {
      case "dejavu sans":
        FONT_MAPPINGS["sans-serif"] = url;
        break;
      case "dejavu sans|bold":
        FONT_MAPPINGS["sans-serif|bold"] = url;
        break;
      case "dejavu sans|italic":
        FONT_MAPPINGS["sans-serif|italic"] = url;
        break;
      case "dejavu sans|bold|italic":
        FONT_MAPPINGS["sans-serif|bold|italic"] = url;
        break;
      case "dejavu serif":
        FONT_MAPPINGS["serif"] = url;
        break;
      case "dejavu serif|bold":
        FONT_MAPPINGS["serif|bold"] = url;
        break;
      case "dejavu serif|italic":
        FONT_MAPPINGS["serif|italic"] = url;
        break;
      case "dejavu serif|bold|italic":
        FONT_MAPPINGS["serif|bold|italic"] = url;
        break;
      case "dejavu mono":
        FONT_MAPPINGS["monospace"] = url;
        break;
      case "dejavu mono|bold":
        FONT_MAPPINGS["monospace|bold"] = url;
        break;
      case "dejavu mono|italic":
        FONT_MAPPINGS["monospace|italic"] = url;
        break;
      case "dejavu mono|bold|italic":
        FONT_MAPPINGS["monospace|bold|italic"] = url;
        break;
    }
  }
}
function mmul(a, b) {
  var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];
  var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];
  return [
    a1 * a2 + b1 * c2,
    a1 * b2 + b1 * d2,
    c1 * a2 + d1 * c2,
    c1 * b2 + d1 * d2,
    e1 * a2 + f1 * c2 + e2,
    e1 * b2 + f1 * d2 + f2
  ];
}
function isIdentityMatrix(m) {
  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;
}

// node_modules/@progress/kendo-drawing/dist/es/html/core.js
var browser4 = support_default.browser || {};
function slice2(thing) {
  return Array.prototype.slice.call(thing);
}
var KENDO_PSEUDO_ELEMENT = "KENDO-PSEUDO-ELEMENT";
var IMAGE_CACHE2 = {};
var nodeInfo = {};
nodeInfo._root = nodeInfo;
var inBrowser = typeof window !== "undefined";
var microsoft = inBrowser ? browser4.msie || browser4.edge : false;
var TextRect = function(Text4) {
  function TextRect2(str, rect, options2) {
    Text4.call(this, str, rect.getOrigin(), options2);
    this._pdfRect = rect;
  }
  if (Text4)
    TextRect2.__proto__ = Text4;
  TextRect2.prototype = Object.create(Text4 && Text4.prototype);
  TextRect2.prototype.constructor = TextRect2;
  TextRect2.prototype.rect = function rect() {
    return this._pdfRect;
  };
  TextRect2.prototype.rawBBox = function rawBBox() {
    return this._pdfRect;
  };
  return TextRect2;
}(text_default);
function addClass2(el, cls) {
  if (el.classList) {
    el.classList.add(cls);
  } else {
    el.className += " " + cls;
  }
}
function removeClass2(el, cls) {
  if (el.classList) {
    el.classList.remove(cls);
  } else {
    el.className = el.className.split(/\s+/).reduce(function(a, word) {
      if (word != cls) {
        a.push(word);
      }
      return a;
    }, []).join(" ");
  }
}
function setCSS(el, styles) {
  Object.keys(styles).forEach(function(key) {
    el.style[key] = styles[key];
  });
}
var matches = typeof Element !== "undefined" && Element.prototype && function(p2) {
  if (p2.matches) {
    return function(el, selector) {
      return el.matches(selector);
    };
  }
  if (p2.webkitMatchesSelector) {
    return function(el, selector) {
      return el.webkitMatchesSelector(selector);
    };
  }
  if (p2.mozMatchesSelector) {
    return function(el, selector) {
      return el.mozMatchesSelector(selector);
    };
  }
  if (p2.msMatchesSelector) {
    return function(el, selector) {
      return el.msMatchesSelector(selector);
    };
  }
  return function(s) {
    return [].indexOf.call(document.querySelectorAll(s), this) !== -1;
  };
}(Element.prototype);
function closest(el, selector) {
  if (el.closest) {
    return el.closest(selector);
  }
  while (el && !/^\[object (?:HTML)?Document\]$/.test(String(el))) {
    if (el.nodeType == 1 && matches(el, selector)) {
      return el;
    }
    el = el.parentNode;
  }
}
var cloneNodes = function($) {
  if ($) {
    return function cloneNodes2(el) {
      var clone2 = el.cloneNode(false);
      if (el.nodeType == 1) {
        var $el = $(el), $clone = $(clone2), i;
        var data = $el.data();
        for (i in data) {
          $clone.data(i, data[i]);
        }
        if (/^canvas$/i.test(el.tagName)) {
          clone2.getContext("2d").drawImage(el, 0, 0);
        } else if (/^(?:input|select|textarea|option)$/i.test(el.tagName)) {
          clone2.removeAttribute("id");
          clone2.removeAttribute("name");
          if (!/^textarea$/i.test(el.tagName)) {
            clone2.value = el.value;
          }
          clone2.checked = el.checked;
          clone2.selected = el.selected;
        }
        for (i = el.firstChild; i; i = i.nextSibling) {
          clone2.appendChild(cloneNodes2(i));
        }
      }
      return clone2;
    };
  } else {
    return function cloneNodes2(el) {
      var clone2 = function dive(node) {
        var clone3 = node.cloneNode(false);
        if (node._kendoExportVisual) {
          clone3._kendoExportVisual = node._kendoExportVisual;
        }
        for (var i = node.firstChild; i; i = i.nextSibling) {
          clone3.appendChild(dive(i));
        }
        return clone3;
      }(el);
      var canvases = el.querySelectorAll("canvas");
      if (canvases.length) {
        slice2(clone2.querySelectorAll("canvas")).forEach(function(canvas, i) {
          canvas.getContext("2d").drawImage(canvases[i], 0, 0);
        });
      }
      var orig = el.querySelectorAll("input, select, textarea, option");
      slice2(clone2.querySelectorAll("input, select, textarea, option")).forEach(function(el2, i) {
        el2.removeAttribute("id");
        el2.removeAttribute("name");
        if (!/^textarea$/i.test(el2.tagName)) {
          el2.value = orig[i].value;
        }
        el2.checked = orig[i].checked;
        el2.selected = orig[i].selected;
      });
      return clone2;
    };
  }
}(typeof window !== "undefined" && window.kendo && window.kendo.jQuery);
function getXY(thing) {
  if (typeof thing == "number") {
    return { x: thing, y: thing };
  }
  if (Array.isArray(thing)) {
    return { x: thing[0], y: thing[1] };
  }
  return { x: thing.x, y: thing.y };
}
function drawDOM(element, options2) {
  if (!options2) {
    options2 = {};
  }
  var promise = createPromise();
  if (!element) {
    return promise.reject("No element to export");
  }
  if (typeof window.getComputedStyle != "function") {
    throw new Error("window.getComputedStyle is missing.  You are using an unsupported browser, or running in IE8 compatibility mode.  Drawing HTML is supported in Chrome, Firefox, Safari and IE9+.");
  }
  defineFont(getFontFaces(element.ownerDocument));
  var scale = getXY(options2.scale || 1);
  function doOne(element2) {
    var group = new group_default();
    var pos = element2.getBoundingClientRect();
    setTransform(group, [
      scale.x,
      0,
      0,
      scale.y,
      -pos.left * scale.x,
      -pos.top * scale.y
    ]);
    nodeInfo._clipbox = false;
    nodeInfo._matrix = matrix_default.unit();
    nodeInfo._stackingContext = {
      element: element2,
      group
    };
    if (options2.avoidLinks === true) {
      nodeInfo._avoidLinks = "a";
    } else {
      nodeInfo._avoidLinks = options2.avoidLinks;
    }
    addClass2(element2, "k-pdf-export");
    renderElement(element2, group);
    removeClass2(element2, "k-pdf-export");
    return group;
  }
  cacheImages([element], function() {
    var forceBreak = options2 && options2.forcePageBreak;
    var hasPaperSize = options2 && options2.paperSize && options2.paperSize != "auto";
    var paperOptions = getPaperOptions(function(key, def) {
      if (key == "paperSize") {
        return hasPaperSize ? options2[key] : "A4";
      }
      return key in options2 ? options2[key] : def;
    });
    var pageWidth = hasPaperSize && paperOptions.paperSize[0];
    var pageHeight = hasPaperSize && paperOptions.paperSize[1];
    var margin = options2.margin && paperOptions.margin;
    var hasMargin = Boolean(margin);
    if (forceBreak || pageHeight) {
      if (!margin) {
        margin = { left: 0, top: 0, right: 0, bottom: 0 };
      }
      if (pageWidth) {
        pageWidth /= scale.x;
      }
      if (pageHeight) {
        pageHeight /= scale.y;
      }
      margin.left /= scale.x;
      margin.right /= scale.x;
      margin.top /= scale.y;
      margin.bottom /= scale.y;
      var group = new group_default({
        pdf: {
          multiPage: true,
          paperSize: hasPaperSize ? paperOptions.paperSize : "auto",
          _ignoreMargin: hasMargin
          // HACK!  see exportPDF in pdf/drawing.js
        }
      });
      handlePageBreaks(
        function(x) {
          if (options2.progress) {
            var canceled = false, pageNum = 0;
            (function next() {
              if (pageNum < x.pages.length) {
                var page = doOne(x.pages[pageNum]);
                group.append(page);
                options2.progress({
                  page,
                  pageNum: ++pageNum,
                  totalPages: x.pages.length,
                  cancel: function() {
                    canceled = true;
                  }
                });
                if (!canceled) {
                  setTimeout(next);
                } else {
                  x.container.parentNode.removeChild(x.container);
                }
              } else {
                x.container.parentNode.removeChild(x.container);
                promise.resolve(group);
              }
            })();
          } else {
            x.pages.forEach(function(page) {
              group.append(doOne(page));
            });
            x.container.parentNode.removeChild(x.container);
            promise.resolve(group);
          }
        },
        element,
        forceBreak,
        pageWidth ? pageWidth - margin.left - margin.right : null,
        pageHeight ? pageHeight - margin.top - margin.bottom : null,
        margin,
        options2
      );
    } else {
      promise.resolve(doOne(element));
    }
  });
  function makeTemplate(template3) {
    if (template3 != null) {
      if (typeof template3 == "string") {
        template3 = template(template3.replace(/^\s+|\s+$/g, ""));
      }
      if (typeof template3 == "function") {
        return function(data) {
          var el = template3(data);
          if (el && typeof el == "string") {
            var div = document.createElement("div");
            div.innerHTML = el;
            el = div.firstElementChild;
          }
          return el;
        };
      }
      return function() {
        return template3.cloneNode(true);
      };
    }
  }
  function handlePageBreaks(callback, element2, forceBreak, pageWidth, pageHeight, margin, options3) {
    var template3 = makeTemplate(options3.template);
    var doc = element2.ownerDocument;
    var pages = [];
    var copy = options3._destructive ? element2 : cloneNodes(element2);
    var container = doc.createElement("KENDO-PDF-DOCUMENT");
    var adjust = 0;
    slice2(copy.querySelectorAll("tfoot")).forEach(function(tfoot) {
      tfoot.parentNode.appendChild(tfoot);
    });
    slice2(copy.querySelectorAll("ol")).forEach(function(ol) {
      slice2(ol.children).forEach(function(li, index) {
        li.setAttribute("kendo-split-index", index);
      });
    });
    setCSS(container, {
      display: "block",
      position: "absolute",
      boxSizing: "content-box",
      left: "-10000px",
      top: "-10000px"
    });
    if (pageWidth) {
      setCSS(container, {
        width: pageWidth + "px",
        paddingLeft: margin.left + "px",
        paddingRight: margin.right + "px"
      });
      setCSS(copy, { overflow: "hidden" });
    }
    element2.parentNode.insertBefore(container, element2);
    container.appendChild(copy);
    if (options3.beforePageBreak) {
      whenImagesAreActuallyLoaded([container], function() {
        options3.beforePageBreak(container, doPageBreak);
      });
    } else {
      whenImagesAreActuallyLoaded([container], doPageBreak);
    }
    function doPageBreak() {
      if (forceBreak != "-" || pageHeight) {
        splitElement(copy);
      }
      {
        var page = makePage();
        copy.parentNode.insertBefore(page, copy);
        page.appendChild(copy);
      }
      if (template3) {
        pages.forEach(function(page2, i) {
          var el = template3({
            element: page2,
            pageNum: i + 1,
            totalPages: pages.length
          });
          if (el) {
            page2.appendChild(el);
          }
        });
      }
      cacheImages(pages, callback.bind(null, { pages, container }));
    }
    function keepTogether(el) {
      if (options3.keepTogether && matches(el, options3.keepTogether) && el.offsetHeight <= pageHeight - adjust) {
        return true;
      }
      var tag = el.tagName;
      if (/^h[1-6]$/i.test(tag) && el.offsetHeight >= pageHeight - adjust) {
        return false;
      }
      return el.getAttribute("data-kendo-chart") || /^(?:img|tr|thead|th|tfoot|iframe|svg|object|canvas|input|textarea|select|video|h[1-6])/i.test(el.tagName);
    }
    function splitElement(element3) {
      if (element3.tagName == "TABLE") {
        setCSS(element3, { tableLayout: "fixed" });
      }
      if (keepTogether(element3)) {
        return;
      }
      var style = getComputedStyle2(element3);
      var bottomPadding = parseFloat(getPropertyValue(style, "padding-bottom"));
      var bottomBorder = parseFloat(getPropertyValue(style, "border-bottom-width"));
      var saveAdjust = adjust;
      adjust += bottomPadding + bottomBorder;
      var isFirst = true;
      for (var el = element3.firstChild; el; el = el.nextSibling) {
        if (el.nodeType == 1) {
          isFirst = false;
          if (matches(el, forceBreak)) {
            breakAtElement(el);
            continue;
          }
          if (!pageHeight) {
            splitElement(el);
            continue;
          }
          if (!/^(?:static|relative)$/.test(getPropertyValue(getComputedStyle2(el), "position"))) {
            continue;
          }
          var fall = fallsOnMargin(el);
          if (fall == 1) {
            breakAtElement(el);
          } else if (fall) {
            if (keepTogether(el)) {
              breakAtElement(el);
            } else {
              splitElement(el);
            }
          } else {
            splitElement(el);
          }
        } else if (el.nodeType == 3 && pageHeight) {
          splitText(el, isFirst);
          isFirst = false;
        }
      }
      adjust = saveAdjust;
    }
    function firstInParent(el) {
      var p2 = el.parentNode, first = p2.firstChild;
      if (el === first) {
        return true;
      }
      if (el === p2.children[0]) {
        if (first.nodeType == 7 || first.nodeType == 8) {
          return true;
        }
        if (first.nodeType == 3) {
          return !/\S/.test(first.data);
        }
      }
      return false;
    }
    function breakAtElement(el) {
      if (el.nodeType == 1 && el !== copy && firstInParent(el)) {
        return breakAtElement(el.parentNode);
      }
      var table, colgroup, thead, grid, gridHead;
      table = closest(el, "table");
      colgroup = table && table.querySelector("colgroup");
      if (options3.repeatHeaders) {
        thead = table && table.querySelector("thead");
        grid = closest(el, ".k-grid.k-widget");
        if (grid && grid.querySelector(".k-auto-scrollable")) {
          gridHead = grid.querySelector(".k-grid-header");
        }
      }
      var page = makePage();
      var range = doc.createRange();
      range.setStartBefore(copy);
      range.setEndBefore(el);
      page.appendChild(range.extractContents());
      copy.parentNode.insertBefore(page, copy);
      preventBulletOnListItem(el.parentNode);
      if (table) {
        table = closest(el, "table");
        if (options3.repeatHeaders && thead) {
          table.insertBefore(thead.cloneNode(true), table.firstChild);
        }
        if (colgroup) {
          table.insertBefore(colgroup.cloneNode(true), table.firstChild);
        }
      }
      if (options3.repeatHeaders && gridHead) {
        grid = closest(el, ".k-grid.k-widget");
        grid.insertBefore(gridHead.cloneNode(true), grid.firstChild);
      }
    }
    function makePage() {
      var page = doc.createElement("KENDO-PDF-PAGE");
      setCSS(page, {
        display: "block",
        boxSizing: "content-box",
        width: pageWidth ? pageWidth + "px" : "auto",
        padding: margin.top + "px " + margin.right + "px " + margin.bottom + "px " + margin.left + "px",
        // allow absolutely positioned elements to be relative to current page
        position: "relative",
        // without the following we might affect layout of subsequent pages
        height: pageHeight ? pageHeight + "px" : "auto",
        overflow: pageHeight || pageWidth ? "hidden" : "visible",
        clear: "both"
      });
      if (options3 && options3.pageClassName) {
        page.className = options3.pageClassName;
      }
      pages.push(page);
      return page;
    }
    function fallsOnMargin(thing) {
      var box = thing.getBoundingClientRect();
      if (box.width === 0 || box.height === 0) {
        return 0;
      }
      var top = copy.getBoundingClientRect().top;
      var available = pageHeight - adjust;
      return box.height > available ? 3 : box.top - top > available ? 1 : box.bottom - top > available ? 2 : 0;
    }
    function splitText(node, isFirst) {
      if (!/\S/.test(node.data)) {
        return;
      }
      var len = node.data.length;
      var range = doc.createRange();
      range.selectNodeContents(node);
      var fall = fallsOnMargin(range);
      if (!fall) {
        return;
      }
      var nextnode = node;
      if (fall == 1) {
        if (isFirst) {
          breakAtElement(node.parentNode);
        } else {
          breakAtElement(node);
        }
      } else {
        (function findEOP(min3, pos, max2) {
          range.setEnd(node, pos);
          if (min3 == pos || pos == max2) {
            return pos;
          }
          if (fallsOnMargin(range)) {
            return findEOP(min3, min3 + pos >> 1, pos);
          } else {
            return findEOP(pos, pos + max2 >> 1, max2);
          }
        })(0, len >> 1, len);
        if (!/\S/.test(range.toString()) && isFirst) {
          breakAtElement(node.parentNode);
        } else {
          nextnode = node.splitText(range.endOffset);
          var page = makePage();
          range.setStartBefore(copy);
          page.appendChild(range.extractContents());
          copy.parentNode.insertBefore(page, copy);
          preventBulletOnListItem(nextnode.parentNode);
        }
      }
      splitText(nextnode);
    }
    function preventBulletOnListItem(el) {
      var li = closest(el, "li");
      if (li) {
        li.setAttribute("kendo-no-bullet", "1");
        preventBulletOnListItem(li.parentNode);
      }
    }
  }
  return promise;
}
var parseBackgroundImage = function() {
  var tok_linear_gradient = /^((-webkit-|-moz-|-o-|-ms-)?linear-gradient\s*)\(/;
  var tok_percent = /^([-0-9.]+%)/;
  var tok_length = /^([-0-9.]+px)/;
  var tok_keyword = /^(left|right|top|bottom|to|center)\W/;
  var tok_angle = /^([-0-9.]+(deg|grad|rad|turn)|0)/;
  var tok_whitespace = /^(\s+)/;
  var tok_popen = /^(\()/;
  var tok_pclose = /^(\))/;
  var tok_comma = /^(,)/;
  var tok_url = /^(url)\(/;
  var tok_content = /^(.*?)\)/;
  var cache1 = {}, cache2 = {};
  function parse3(input) {
    var orig = input;
    if (hasOwnProperty3(cache1, orig)) {
      return cache1[orig];
    }
    function skip_ws() {
      var m = tok_whitespace.exec(input);
      if (m) {
        input = input.substr(m[1].length);
      }
    }
    function read(token) {
      skip_ws();
      var m = token.exec(input);
      if (m) {
        input = input.substr(m[1].length);
        return m[1];
      }
    }
    function read_stop() {
      var color = parseColor(input, true);
      var length, percent;
      if (color) {
        var match = /^#[0-9a-f]+/i.exec(input) || /^rgba?\(.*?\)/i.exec(input) || /^..*?\b/.exec(input);
        input = input.substr(match[0].length);
        color = color.toRGB();
        if (!(length = read(tok_length))) {
          percent = read(tok_percent);
        }
        return { color, length, percent };
      }
    }
    function read_linear_gradient(propName) {
      var angle;
      var to1, to2;
      var stops = [];
      var reverse = false;
      if (read(tok_popen)) {
        angle = read(tok_angle);
        if (angle == "0") {
          angle = "0deg";
        }
        if (angle) {
          angle = parseAngle(angle);
          read(tok_comma);
        } else {
          to1 = read(tok_keyword);
          if (to1 == "to") {
            to1 = read(tok_keyword);
          } else if (to1 && /^-/.test(propName)) {
            reverse = true;
          }
          to2 = read(tok_keyword);
          read(tok_comma);
        }
        if (/-moz-/.test(propName) && angle == null && to1 == null) {
          var x = read(tok_percent), y = read(tok_percent);
          reverse = true;
          if (x == "0%") {
            to1 = "left";
          } else if (x == "100%") {
            to1 = "right";
          }
          if (y == "0%") {
            to2 = "top";
          } else if (y == "100%") {
            to2 = "bottom";
          }
          read(tok_comma);
        }
        while (input && !read(tok_pclose)) {
          var stop = read_stop();
          if (!stop) {
            break;
          }
          stops.push(stop);
          read(tok_comma);
        }
        return {
          type: "linear",
          angle,
          to: to1 && to2 ? to1 + " " + to2 : to1 ? to1 : to2 ? to2 : null,
          stops,
          reverse
        };
      }
    }
    function read_url() {
      if (read(tok_popen)) {
        var url = read(tok_content);
        url = url.replace(/^['"]+|["']+$/g, "");
        read(tok_pclose);
        return { type: "url", url };
      }
    }
    var tok;
    if (tok = read(tok_linear_gradient)) {
      tok = read_linear_gradient(tok);
    } else if (tok = read(tok_url)) {
      tok = read_url();
    }
    return cache1[orig] = tok || { type: "none" };
  }
  return function(input) {
    if (hasOwnProperty3(cache2, input)) {
      return cache2[input];
    }
    return cache2[input] = splitProperty(input).map(parse3);
  };
}();
var splitProperty = function() {
  var cache2 = {};
  return function(input, separator) {
    if (!separator) {
      separator = /^\s*,\s*/;
    }
    var cacheKey = input + separator;
    if (hasOwnProperty3(cache2, cacheKey)) {
      return cache2[cacheKey];
    }
    var ret = [];
    var last3 = 0, pos = 0;
    var in_paren = 0;
    var in_string = false;
    var m;
    function looking_at(rx) {
      return m = rx.exec(input.substr(pos));
    }
    function trim(str) {
      return str.replace(/^\s+|\s+$/g, "");
    }
    while (pos < input.length) {
      if (!in_string && looking_at(/^[\(\[\{]/)) {
        in_paren++;
        pos++;
      } else if (!in_string && looking_at(/^[\)\]\}]/)) {
        in_paren--;
        pos++;
      } else if (!in_string && looking_at(/^[\"\']/)) {
        in_string = m[0];
        pos++;
      } else if (in_string == "'" && looking_at(/^\\\'/)) {
        pos += 2;
      } else if (in_string == '"' && looking_at(/^\\\"/)) {
        pos += 2;
      } else if (in_string == "'" && looking_at(/^\'/)) {
        in_string = false;
        pos++;
      } else if (in_string == '"' && looking_at(/^\"/)) {
        in_string = false;
        pos++;
      } else if (looking_at(separator)) {
        if (!in_string && !in_paren && pos > last3) {
          ret.push(trim(input.substring(last3, pos)));
          last3 = pos + m[0].length;
        }
        pos += m[0].length;
      } else {
        pos++;
      }
    }
    if (last3 < pos) {
      ret.push(trim(input.substring(last3, pos)));
    }
    return cache2[cacheKey] = ret;
  };
}();
var getFontURL2 = function(cache2) {
  return function(el) {
    var url = cache2[el];
    if (!url) {
      var m;
      if (m = /url\((['"]?)([^'")]*?)\1\)\s+format\((['"]?)truetype\3\)/.exec(el)) {
        url = cache2[el] = m[2];
      } else if (m = /url\((['"]?)([^'")]*?\.ttf)\1\)/.exec(el)) {
        url = cache2[el] = m[2];
      }
    }
    return url;
  };
}(/* @__PURE__ */ Object.create(null));
var getFontHeight = function(cache2) {
  return function(font) {
    var height = cache2[font];
    if (height == null) {
      height = cache2[font] = measureText("Mapq", { font }).height;
    }
    return height;
  };
}(/* @__PURE__ */ Object.create(null));
function getFontFaces(doc) {
  if (doc == null) {
    doc = document;
  }
  var result = {};
  for (var i = 0; i < doc.styleSheets.length; ++i) {
    doStylesheet(doc.styleSheets[i]);
  }
  return result;
  function doStylesheet(ss) {
    if (ss) {
      var rules = null;
      try {
        rules = ss.cssRules;
      } catch (ex) {
      }
      if (rules) {
        addRules(ss, rules);
      }
    }
  }
  function findFonts(rule) {
    var src = getPropertyValue(rule.style, "src");
    if (src) {
      return splitProperty(src).reduce(function(a, el) {
        var font2 = getFontURL2(el);
        if (font2) {
          a.push(font2);
        }
        return a;
      }, []);
    } else {
      var font = getFontURL2(rule.cssText);
      return font ? [font] : [];
    }
  }
  function addRules(styleSheet, rules) {
    for (var i2 = 0; i2 < rules.length; ++i2) {
      var r = rules[i2];
      switch (r.type) {
        case 3:
          doStylesheet(r.styleSheet);
          break;
        case 5:
          var style = r.style;
          var family = splitProperty(getPropertyValue(style, "font-family"));
          var bold = /^([56789]00|bold)$/i.test(getPropertyValue(style, "font-weight"));
          var italic = "italic" == getPropertyValue(style, "font-style");
          var src = findFonts(r);
          if (src.length > 0) {
            addRule(styleSheet, family, bold, italic, src[0]);
          }
      }
    }
  }
  function addRule(styleSheet, names, bold, italic, url) {
    if (!/^data:/i.test(url)) {
      if (!(/^[^\/:]+:\/\//.test(url) || /^\//.test(url))) {
        url = String(styleSheet.href).replace(/[^\/]*$/, "") + url;
      }
    }
    names.forEach(function(name3) {
      name3 = name3.replace(/^(['"]?)(.*?)\1$/, "$2");
      if (bold) {
        name3 += "|bold";
      }
      if (italic) {
        name3 += "|italic";
      }
      result[name3] = url;
    });
  }
}
function hasOwnProperty3(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function getCounter(name3) {
  name3 = "_counter_" + name3;
  return nodeInfo[name3];
}
function getAllCounters(name3) {
  var values5 = [], p2 = nodeInfo;
  name3 = "_counter_" + name3;
  while (p2) {
    if (hasOwnProperty3(p2, name3)) {
      values5.push(p2[name3]);
    }
    p2 = Object.getPrototypeOf(p2);
  }
  return values5.reverse();
}
function incCounter(name3, inc) {
  var p2 = nodeInfo;
  name3 = "_counter_" + name3;
  while (p2 && !hasOwnProperty3(p2, name3)) {
    p2 = Object.getPrototypeOf(p2);
  }
  if (!p2) {
    p2 = nodeInfo._root;
  }
  p2[name3] = (p2[name3] || 0) + (inc == null ? 1 : inc);
}
function resetCounter(name3, val) {
  name3 = "_counter_" + name3;
  nodeInfo[name3] = val == null ? 0 : val;
}
function doCounters(a, f, def) {
  for (var i = 0; i < a.length; ) {
    var name3 = a[i++];
    var val = parseFloat(a[i]);
    if (isNaN(val)) {
      f(name3, def);
    } else {
      f(name3, val);
      ++i;
    }
  }
}
function updateCounters(style) {
  var counterReset = getPropertyValue(style, "counter-reset");
  if (counterReset) {
    doCounters(splitProperty(counterReset, /^\s+/), resetCounter, 0);
  }
  var counterIncrement = getPropertyValue(style, "counter-increment");
  if (counterIncrement) {
    doCounters(splitProperty(counterIncrement, /^\s+/), incCounter, 1);
  }
}
function parseColor2(str, css) {
  var color = parseColor(str, true);
  if (color) {
    color = color.toRGB();
    if (css) {
      color = color.toCssRgba();
    } else if (color.a === 0) {
      color = null;
    }
  }
  return color;
}
function whenImagesAreActuallyLoaded(elements, callback) {
  var pending = 0;
  var done = false;
  elements.forEach(function(el) {
    var images = el.querySelectorAll("img");
    for (var i = 0; i < images.length; ++i) {
      var img = images[i];
      if (!img.complete) {
        pending++;
        img.onload = img.onerror = next;
      }
    }
  });
  next();
  function next() {
    if (!done && --pending <= 0) {
      callback();
      done = true;
    }
  }
}
function cacheImages(elements, callback) {
  var urls = [];
  function add3(url) {
    if (!IMAGE_CACHE2[url]) {
      IMAGE_CACHE2[url] = true;
      urls.push(url);
    }
  }
  elements.forEach(function dive(element) {
    if (/^img$/i.test(element.tagName)) {
      add3(element.src);
    }
    parseBackgroundImage(
      getPropertyValue(
        getComputedStyle2(element),
        "background-image"
      )
    ).forEach(function(bg) {
      if (bg.type == "url") {
        add3(bg.url);
      }
    });
    if (element.children) {
      slice2(element.children).forEach(dive);
    }
  });
  var count = urls.length;
  function next() {
    if (--count <= 0) {
      whenImagesAreActuallyLoaded(elements, callback);
    }
  }
  if (count === 0) {
    next();
  }
  urls.forEach(function(url) {
    var img = IMAGE_CACHE2[url] = new window.Image();
    if (!/^data:/i.test(url)) {
      img.crossOrigin = "Anonymous";
    }
    img.src = url;
    if (img.complete) {
      next();
    } else {
      img.onload = next;
      img.onerror = function() {
        IMAGE_CACHE2[url] = null;
        next();
      };
    }
  });
}
function alphaNumeral(n) {
  var result = "";
  do {
    var r = n % 26;
    result = String.fromCharCode(97 + r) + result;
    n = Math.floor(n / 26);
  } while (n > 0);
  return result;
}
function pushNodeInfo(element, style, group) {
  nodeInfo = Object.create(nodeInfo);
  nodeInfo[element.tagName.toLowerCase()] = {
    element,
    style
  };
  var decoration = getPropertyValue(style, "text-decoration");
  if (decoration && decoration != "none") {
    var color = getPropertyValue(style, "color");
    decoration.split(/\s+/g).forEach(function(name3) {
      if (!nodeInfo[name3]) {
        nodeInfo[name3] = color;
      }
    });
  }
  if (createsStackingContext(style)) {
    nodeInfo._stackingContext = {
      element,
      group
    };
  }
}
function popNodeInfo() {
  nodeInfo = Object.getPrototypeOf(nodeInfo);
}
function updateClipbox(path) {
  if (nodeInfo._clipbox != null) {
    var box = path.bbox(nodeInfo._matrix);
    if (nodeInfo._clipbox) {
      nodeInfo._clipbox = rect_default.intersect(nodeInfo._clipbox, box);
    } else {
      nodeInfo._clipbox = box;
    }
  }
}
function emptyClipbox() {
  var cb = nodeInfo._clipbox;
  if (cb == null) {
    return true;
  }
  if (cb) {
    return cb.width() === 0 || cb.height() === 0;
  }
}
function createsStackingContext(style) {
  function prop(name3) {
    return getPropertyValue(style, name3);
  }
  if (prop("transform") != "none" || prop("position") != "static" || prop("z-index") != "auto" || prop("opacity") < 1) {
    return true;
  }
}
function getComputedStyle2(element, pseudoElt) {
  return window.getComputedStyle(element, pseudoElt || null);
}
function getPropertyValue(style, prop, defa) {
  var val = style.getPropertyValue(prop);
  if (val == null || val === "") {
    if (browser4.webkit) {
      val = style.getPropertyValue("-webkit-" + prop);
    } else if (browser4.mozilla) {
      val = style.getPropertyValue("-moz-" + prop);
    } else if (browser4.opera) {
      val = style.getPropertyValue("-o-" + prop);
    } else if (microsoft) {
      val = style.getPropertyValue("-ms-" + prop);
    }
  }
  if (arguments.length > 2 && (val == null || val === "")) {
    return defa;
  } else {
    return val;
  }
}
function pleaseSetPropertyValue(style, prop, value, important) {
  style.setProperty(prop, value, important);
  if (browser4.webkit) {
    style.setProperty("-webkit-" + prop, value, important);
  } else if (browser4.mozilla) {
    style.setProperty("-moz-" + prop, value, important);
  } else if (browser4.opera) {
    style.setProperty("-o-" + prop, value, important);
  } else if (microsoft) {
    style.setProperty("-ms-" + prop, value, important);
    prop = "ms" + prop.replace(/(^|-)([a-z])/g, function(s, p1, p2) {
      return p1 + p2.toUpperCase();
    });
    style[prop] = value;
  }
}
function getBorder(style, side) {
  side = "border-" + side;
  return {
    width: parseFloat(getPropertyValue(style, side + "-width")),
    style: getPropertyValue(style, side + "-style"),
    color: parseColor2(getPropertyValue(style, side + "-color"), true)
  };
}
function saveStyle(element, func) {
  var prev = element.style.cssText;
  var result = func();
  element.style.cssText = prev;
  return result;
}
function getBorderRadius(style, side) {
  var r = getPropertyValue(style, "border-" + side + "-radius").split(/\s+/g).map(parseFloat);
  if (r.length == 1) {
    r.push(r[0]);
  }
  return sanitizeRadius({ x: r[0], y: r[1] });
}
function getContentBox(element) {
  var box = element.getBoundingClientRect();
  box = innerBox(box, "border-*-width", element);
  box = innerBox(box, "padding-*", element);
  return box;
}
function innerBox(box, prop, element) {
  var style, wt, wr, wb, wl;
  if (typeof prop == "string") {
    style = getComputedStyle2(element);
    wt = parseFloat(getPropertyValue(style, prop.replace("*", "top")));
    wr = parseFloat(getPropertyValue(style, prop.replace("*", "right")));
    wb = parseFloat(getPropertyValue(style, prop.replace("*", "bottom")));
    wl = parseFloat(getPropertyValue(style, prop.replace("*", "left")));
  } else if (typeof prop == "number") {
    wt = wr = wb = wl = prop;
  }
  return {
    top: box.top + wt,
    right: box.right - wr,
    bottom: box.bottom - wb,
    left: box.left + wl,
    width: box.right - box.left - wr - wl,
    height: box.bottom - box.top - wb - wt
  };
}
function getTransform(style) {
  var transform2 = getPropertyValue(style, "transform");
  if (transform2 == "none") {
    return null;
  }
  var matrix = /^\s*matrix\(\s*(.*?)\s*\)\s*$/.exec(transform2);
  if (matrix) {
    var origin = getPropertyValue(style, "transform-origin");
    matrix = matrix[1].split(/\s*,\s*/g).map(parseFloat);
    origin = origin.split(/\s+/g).map(parseFloat);
    return {
      matrix,
      origin
    };
  }
}
function radiansToDegrees(radians) {
  return 180 * radians / Math.PI % 360;
}
function parseAngle(angle) {
  var num = parseFloat(angle);
  if (/grad$/.test(angle)) {
    return Math.PI * num / 200;
  } else if (/rad$/.test(angle)) {
    return num;
  } else if (/turn$/.test(angle)) {
    return Math.PI * num * 2;
  } else if (/deg$/.test(angle)) {
    return Math.PI * num / 180;
  }
}
function setTransform(shape2, m) {
  m = new matrix_default(m[0], m[1], m[2], m[3], m[4], m[5]);
  shape2.transform(m);
  return m;
}
function setClipping(shape2, clipPath) {
  shape2.clip(clipPath);
}
function addArcToPath(path, x, y, options2) {
  var points3 = new arc_default([x, y], options2).curvePoints(), i = 1;
  while (i < points3.length) {
    path.curveTo(points3[i++], points3[i++], points3[i++]);
  }
}
function sanitizeRadius(r) {
  if (r.x <= 0 || r.y <= 0) {
    r.x = r.y = 0;
  }
  return r;
}
function adjustBorderRadiusForBox(box, rTL, rTR, rBR, rBL) {
  var tl_x = Math.max(0, rTL.x), tl_y = Math.max(0, rTL.y);
  var tr_x = Math.max(0, rTR.x), tr_y = Math.max(0, rTR.y);
  var br_x = Math.max(0, rBR.x), br_y = Math.max(0, rBR.y);
  var bl_x = Math.max(0, rBL.x), bl_y = Math.max(0, rBL.y);
  var f = Math.min(
    box.width / (tl_x + tr_x),
    box.height / (tr_y + br_y),
    box.width / (br_x + bl_x),
    box.height / (bl_y + tl_y)
  );
  if (f < 1) {
    tl_x *= f;
    tl_y *= f;
    tr_x *= f;
    tr_y *= f;
    br_x *= f;
    br_y *= f;
    bl_x *= f;
    bl_y *= f;
  }
  return {
    tl: { x: tl_x, y: tl_y },
    tr: { x: tr_x, y: tr_y },
    br: { x: br_x, y: br_y },
    bl: { x: bl_x, y: bl_y }
  };
}
function elementRoundBox(element, box, type) {
  var style = getComputedStyle2(element);
  var rTL = getBorderRadius(style, "top-left");
  var rTR = getBorderRadius(style, "top-right");
  var rBL = getBorderRadius(style, "bottom-left");
  var rBR = getBorderRadius(style, "bottom-right");
  if (type == "padding" || type == "content") {
    var bt = getBorder(style, "top");
    var br = getBorder(style, "right");
    var bb = getBorder(style, "bottom");
    var bl = getBorder(style, "left");
    rTL.x -= bl.width;
    rTL.y -= bt.width;
    rTR.x -= br.width;
    rTR.y -= bt.width;
    rBR.x -= br.width;
    rBR.y -= bb.width;
    rBL.x -= bl.width;
    rBL.y -= bb.width;
    if (type == "content") {
      var pt = parseFloat(getPropertyValue(style, "padding-top"));
      var pr = parseFloat(getPropertyValue(style, "padding-right"));
      var pb = parseFloat(getPropertyValue(style, "padding-bottom"));
      var pl = parseFloat(getPropertyValue(style, "padding-left"));
      rTL.x -= pl;
      rTL.y -= pt;
      rTR.x -= pr;
      rTR.y -= pt;
      rBR.x -= pr;
      rBR.y -= pb;
      rBL.x -= pl;
      rBL.y -= pb;
    }
  }
  if (typeof type == "number") {
    rTL.x -= type;
    rTL.y -= type;
    rTR.x -= type;
    rTR.y -= type;
    rBR.x -= type;
    rBR.y -= type;
    rBL.x -= type;
    rBL.y -= type;
  }
  return roundBox(box, rTL, rTR, rBR, rBL);
}
function roundBox(box, rTL0, rTR0, rBR0, rBL0) {
  var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
  var rTL = tmp.tl;
  var rTR = tmp.tr;
  var rBR = tmp.br;
  var rBL = tmp.bl;
  var path = new Path({ fill: null, stroke: null });
  path.moveTo(box.left, box.top + rTL.y);
  if (rTL.x) {
    addArcToPath(path, box.left + rTL.x, box.top + rTL.y, {
      startAngle: -180,
      endAngle: -90,
      radiusX: rTL.x,
      radiusY: rTL.y
    });
  }
  path.lineTo(box.right - rTR.x, box.top);
  if (rTR.x) {
    addArcToPath(path, box.right - rTR.x, box.top + rTR.y, {
      startAngle: -90,
      endAngle: 0,
      radiusX: rTR.x,
      radiusY: rTR.y
    });
  }
  path.lineTo(box.right, box.bottom - rBR.y);
  if (rBR.x) {
    addArcToPath(path, box.right - rBR.x, box.bottom - rBR.y, {
      startAngle: 0,
      endAngle: 90,
      radiusX: rBR.x,
      radiusY: rBR.y
    });
  }
  path.lineTo(box.left + rBL.x, box.bottom);
  if (rBL.x) {
    addArcToPath(path, box.left + rBL.x, box.bottom - rBL.y, {
      startAngle: 90,
      endAngle: 180,
      radiusX: rBL.x,
      radiusY: rBL.y
    });
  }
  return path.close();
}
function formatCounter(val, style) {
  var str = String(parseFloat(val));
  switch (style) {
    case "decimal-leading-zero":
      if (str.length < 2) {
        str = "0" + str;
      }
      return str;
    case "lower-roman":
      return arabicToRoman(val).toLowerCase();
    case "upper-roman":
      return arabicToRoman(val).toUpperCase();
    case "lower-latin":
    case "lower-alpha":
      return alphaNumeral(val - 1);
    case "upper-latin":
    case "upper-alpha":
      return alphaNumeral(val - 1).toUpperCase();
    default:
      return str;
  }
}
function evalPseudoElementContent(element, content) {
  function displayCounter(name3, style, separator) {
    if (!separator) {
      return formatCounter(getCounter(name3) || 0, style);
    }
    separator = separator.replace(/^\s*(["'])(.*)\1\s*$/, "$2");
    return getAllCounters(name3).map(function(val) {
      return formatCounter(val, style);
    }).join(separator);
  }
  var a = splitProperty(content, /^\s+/);
  var result = [], m;
  a.forEach(function(el) {
    var tmp;
    if (m = /^\s*(["'])(.*)\1\s*$/.exec(el)) {
      result.push(m[2].replace(/\\([0-9a-f]{4})/gi, function(s, p2) {
        return String.fromCharCode(parseInt(p2, 16));
      }));
    } else if (m = /^\s*counter\((.*?)\)\s*$/.exec(el)) {
      tmp = splitProperty(m[1]);
      result.push(displayCounter(tmp[0], tmp[1]));
    } else if (m = /^\s*counters\((.*?)\)\s*$/.exec(el)) {
      tmp = splitProperty(m[1]);
      result.push(displayCounter(tmp[0], tmp[2], tmp[1]));
    } else if (m = /^\s*attr\((.*?)\)\s*$/.exec(el)) {
      result.push(element.getAttribute(m[1]) || "");
    } else {
      result.push(el);
    }
  });
  return result.join("");
}
function getCssText(style) {
  if (style.cssText) {
    return style.cssText;
  }
  var result = [];
  for (var i = 0; i < style.length; ++i) {
    result.push(style[i] + ": " + getPropertyValue(style, style[i]));
  }
  return result.join(";\n");
}
function _renderWithPseudoElements(element, group) {
  if (element.tagName == KENDO_PSEUDO_ELEMENT) {
    _renderElement(element, group);
    return;
  }
  var fake = [];
  function pseudo(kind, place) {
    var style = getComputedStyle2(element, kind), content = style.content;
    updateCounters(style);
    if (content && content != "normal" && content != "none" && style.width != "0px") {
      var psel = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
      psel.style.cssText = getCssText(style);
      psel.textContent = evalPseudoElementContent(element, content);
      element.insertBefore(psel, place);
      fake.push(psel);
    }
  }
  pseudo(":before", element.firstChild);
  pseudo(":after", null);
  if (fake.length > 0) {
    var saveClass = element.className;
    element.className += " kendo-pdf-hide-pseudo-elements";
    _renderElement(element, group);
    element.className = saveClass;
    fake.forEach(function(el) {
      element.removeChild(el);
    });
  } else {
    _renderElement(element, group);
  }
}
function _renderElement(element, group) {
  var style = getComputedStyle2(element);
  var top = getBorder(style, "top");
  var right = getBorder(style, "right");
  var bottom = getBorder(style, "bottom");
  var left = getBorder(style, "left");
  var rTL0 = getBorderRadius(style, "top-left");
  var rTR0 = getBorderRadius(style, "top-right");
  var rBL0 = getBorderRadius(style, "bottom-left");
  var rBR0 = getBorderRadius(style, "bottom-right");
  var dir = getPropertyValue(style, "direction");
  var backgroundColor = getPropertyValue(style, "background-color");
  backgroundColor = parseColor2(backgroundColor);
  var backgroundImage = parseBackgroundImage(getPropertyValue(style, "background-image"));
  var backgroundRepeat = splitProperty(getPropertyValue(style, "background-repeat"));
  var backgroundPosition = splitProperty(getPropertyValue(style, "background-position"));
  var backgroundOrigin = splitProperty(getPropertyValue(style, "background-origin"));
  var backgroundSize = splitProperty(getPropertyValue(style, "background-size"));
  var textOverflow, saveTextOverflow;
  if (microsoft) {
    textOverflow = style.textOverflow;
    if (textOverflow == "ellipsis") {
      saveTextOverflow = element.style.textOverflow;
      element.style.textOverflow = "clip";
    }
  }
  if (browser4.msie && browser4.version < 10) {
    backgroundPosition = splitProperty(element.currentStyle.backgroundPosition);
  }
  var innerbox = innerBox(element.getBoundingClientRect(), "border-*-width", element);
  (function() {
    var clip = getPropertyValue(style, "clip");
    var m = /^\s*rect\((.*)\)\s*$/.exec(clip);
    if (m) {
      var a = m[1].split(/[ ,]+/g);
      var top2 = a[0] == "auto" ? innerbox.top : parseFloat(a[0]) + innerbox.top;
      var right2 = a[1] == "auto" ? innerbox.right : parseFloat(a[1]) + innerbox.left;
      var bottom2 = a[2] == "auto" ? innerbox.bottom : parseFloat(a[2]) + innerbox.top;
      var left2 = a[3] == "auto" ? innerbox.left : parseFloat(a[3]) + innerbox.left;
      var tmp = new group_default();
      var clipPath = new Path().moveTo(left2, top2).lineTo(right2, top2).lineTo(right2, bottom2).lineTo(left2, bottom2).close();
      setClipping(tmp, clipPath);
      group.append(tmp);
      group = tmp;
      updateClipbox(clipPath);
    }
  })();
  var boxes, i, cells;
  var display = getPropertyValue(style, "display");
  if (display == "table-row") {
    boxes = [];
    for (i = 0, cells = element.children; i < cells.length; ++i) {
      boxes.push(cells[i].getBoundingClientRect());
    }
  } else {
    boxes = element.getClientRects();
    if (boxes.length == 1) {
      boxes = [element.getBoundingClientRect()];
    }
  }
  boxes = adjustBoxes(boxes);
  for (i = 0; i < boxes.length; ++i) {
    drawOneBox(boxes[i], i === 0, i == boxes.length - 1);
  }
  if (element.tagName == "A" && element.href && !/^#?$/.test(element.getAttribute("href"))) {
    if (!nodeInfo._avoidLinks || !matches(element, nodeInfo._avoidLinks)) {
      var r = document.createRange();
      r.selectNodeContents(element);
      slice2(r.getClientRects()).forEach(function(box) {
        var g = new group_default();
        g._pdfLink = {
          url: element.href,
          top: box.top,
          right: box.right,
          bottom: box.bottom,
          left: box.left
        };
        group.append(g);
      });
    }
  }
  if (boxes.length > 0 && display == "list-item" && !element.getAttribute("kendo-no-bullet")) {
    drawBullet(boxes[0]);
  }
  (function() {
    function clipit() {
      var clipPath = elementRoundBox(element, innerbox, "padding");
      var tmp = new group_default();
      setClipping(tmp, clipPath);
      group.append(tmp);
      group = tmp;
      updateClipbox(clipPath);
    }
    if (isFormField(element)) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow"))) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow-x"))) {
      clipit();
    } else if (/^(hidden|auto|scroll)/.test(getPropertyValue(style, "overflow-y"))) {
      clipit();
    }
  })();
  if (!maybeRenderWidget(element, group)) {
    renderContents(element, group);
  }
  if (microsoft && textOverflow == "ellipsis") {
    element.style.textOverflow = saveTextOverflow;
  }
  return group;
  function adjustBoxes(boxes2) {
    if (/^td$/i.test(element.tagName)) {
      var table = nodeInfo.table;
      if (table && getPropertyValue(table.style, "border-collapse") == "collapse") {
        var tableBorderLeft = getBorder(table.style, "left").width;
        var tableBorderTop = getBorder(table.style, "top").width;
        if (tableBorderLeft === 0 && tableBorderTop === 0) {
          return boxes2;
        }
        var tableBox = table.element.getBoundingClientRect();
        var firstCell = table.element.rows[0].cells[0];
        var firstCellBox = firstCell.getBoundingClientRect();
        if (firstCellBox.top == tableBox.top || firstCellBox.left == tableBox.left) {
          return slice2(boxes2).map(function(box) {
            return {
              left: box.left + tableBorderLeft,
              top: box.top + tableBorderTop,
              right: box.right + tableBorderLeft,
              bottom: box.bottom + tableBorderTop,
              height: box.height,
              width: box.width
            };
          });
        }
      }
    }
    return boxes2;
  }
  function drawEdge(color, len, Wtop, Wleft, Wright, rl, rr, transform2) {
    if (Wtop <= 0) {
      return;
    }
    var path, edge = new group_default();
    setTransform(edge, transform2);
    group.append(edge);
    sanitizeRadius(rl);
    sanitizeRadius(rr);
    path = new Path({
      fill: { color },
      stroke: null
    });
    edge.append(path);
    path.moveTo(rl.x ? Math.max(rl.x, Wleft) : 0, 0).lineTo(len - (rr.x ? Math.max(rr.x, Wright) : 0), 0).lineTo(len - Math.max(rr.x, Wright), Wtop).lineTo(Math.max(rl.x, Wleft), Wtop).close();
    if (rl.x) {
      drawRoundCorner(Wleft, rl, [-1, 0, 0, 1, rl.x, 0]);
    }
    if (rr.x) {
      drawRoundCorner(Wright, rr, [1, 0, 0, 1, len - rr.x, 0]);
    }
    function drawRoundCorner(Wright2, r2, transform3) {
      var angle = Math.PI / 2 * Wright2 / (Wright2 + Wtop);
      var ri = {
        x: r2.x - Wright2,
        y: r2.y - Wtop
      };
      var path2 = new Path({
        fill: { color },
        stroke: null
      }).moveTo(0, 0);
      setTransform(path2, transform3);
      addArcToPath(path2, 0, r2.y, {
        startAngle: -90,
        endAngle: -radiansToDegrees(angle),
        radiusX: r2.x,
        radiusY: r2.y
      });
      if (ri.x > 0 && ri.y > 0) {
        path2.lineTo(ri.x * Math.cos(angle), r2.y - ri.y * Math.sin(angle));
        addArcToPath(path2, 0, r2.y, {
          startAngle: -radiansToDegrees(angle),
          endAngle: -90,
          radiusX: ri.x,
          radiusY: ri.y,
          anticlockwise: true
        });
      } else if (ri.x > 0) {
        path2.lineTo(ri.x, Wtop).lineTo(0, Wtop);
      } else {
        path2.lineTo(ri.x, Wtop).lineTo(ri.x, 0);
      }
      edge.append(path2.close());
    }
  }
  function drawBackground(box) {
    var background = new group_default();
    setClipping(background, roundBox(box, rTL0, rTR0, rBR0, rBL0));
    group.append(background);
    if (backgroundColor) {
      var path = new Path({
        fill: { color: backgroundColor.toCssRgba() },
        stroke: null
      });
      path.moveTo(box.left, box.top).lineTo(box.right, box.top).lineTo(box.right, box.bottom).lineTo(box.left, box.bottom).close();
      background.append(path);
    }
    for (var i2 = backgroundImage.length; --i2 >= 0; ) {
      drawOneBackground(
        background,
        box,
        backgroundImage[i2],
        backgroundRepeat[i2 % backgroundRepeat.length],
        backgroundPosition[i2 % backgroundPosition.length],
        backgroundOrigin[i2 % backgroundOrigin.length],
        backgroundSize[i2 % backgroundSize.length]
      );
    }
  }
  function drawOneBackground(group2, box, background, backgroundRepeat2, backgroundPosition2, backgroundOrigin2, backgroundSize2) {
    if (!background || background == "none") {
      return;
    }
    if (background.type == "url") {
      var img = IMAGE_CACHE2[background.url];
      if (img && img.width > 0 && img.height > 0) {
        drawBackgroundImage(group2, box, img.width, img.height, function(group3, rect) {
          group3.append(new image_default(background.url, rect));
        });
      }
    } else if (background.type == "linear") {
      drawBackgroundImage(group2, box, box.width, box.height, gradientRenderer(background));
    } else {
      return;
    }
    function drawBackgroundImage(group3, box2, img_width, img_height, renderBG) {
      var aspect_ratio = img_width / img_height, f;
      var orgBox = box2;
      if (backgroundOrigin2 == "content-box") {
        orgBox = innerBox(orgBox, "border-*-width", element);
        orgBox = innerBox(orgBox, "padding-*", element);
      } else if (backgroundOrigin2 == "padding-box") {
        orgBox = innerBox(orgBox, "border-*-width", element);
      }
      if (!/^\s*auto(\s+auto)?\s*$/.test(backgroundSize2)) {
        if (backgroundSize2 == "contain") {
          f = Math.min(
            orgBox.width / img_width,
            orgBox.height / img_height
          );
          img_width *= f;
          img_height *= f;
        } else if (backgroundSize2 == "cover") {
          f = Math.max(
            orgBox.width / img_width,
            orgBox.height / img_height
          );
          img_width *= f;
          img_height *= f;
        } else {
          var size = backgroundSize2.split(/\s+/g);
          if (/%$/.test(size[0])) {
            img_width = orgBox.width * parseFloat(size[0]) / 100;
          } else {
            img_width = parseFloat(size[0]);
          }
          if (size.length == 1 || size[1] == "auto") {
            img_height = img_width / aspect_ratio;
          } else if (/%$/.test(size[1])) {
            img_height = orgBox.height * parseFloat(size[1]) / 100;
          } else {
            img_height = parseFloat(size[1]);
          }
        }
      }
      var pos = String(backgroundPosition2);
      switch (pos) {
        case "bottom":
          pos = "50% 100%";
          break;
        case "top":
          pos = "50% 0";
          break;
        case "left":
          pos = "0 50%";
          break;
        case "right":
          pos = "100% 50%";
          break;
        case "center":
          pos = "50% 50%";
          break;
      }
      pos = pos.split(/\s+/);
      if (pos.length == 1) {
        pos[1] = "50%";
      }
      if (/%$/.test(pos[0])) {
        pos[0] = parseFloat(pos[0]) / 100 * (orgBox.width - img_width);
      } else {
        pos[0] = parseFloat(pos[0]);
      }
      if (/%$/.test(pos[1])) {
        pos[1] = parseFloat(pos[1]) / 100 * (orgBox.height - img_height);
      } else {
        pos[1] = parseFloat(pos[1]);
      }
      var rect = new rect_default([orgBox.left + pos[0], orgBox.top + pos[1]], [img_width, img_height]);
      function rewX() {
        while (rect.origin.x > box2.left) {
          rect.origin.x -= img_width;
        }
      }
      function rewY() {
        while (rect.origin.y > box2.top) {
          rect.origin.y -= img_height;
        }
      }
      function repeatX() {
        while (rect.origin.x < box2.right) {
          renderBG(group3, rect.clone());
          rect.origin.x += img_width;
        }
      }
      if (backgroundRepeat2 == "no-repeat") {
        renderBG(group3, rect);
      } else if (backgroundRepeat2 == "repeat-x") {
        rewX();
        repeatX();
      } else if (backgroundRepeat2 == "repeat-y") {
        rewY();
        while (rect.origin.y < box2.bottom) {
          renderBG(group3, rect.clone());
          rect.origin.y += img_height;
        }
      } else if (backgroundRepeat2 == "repeat") {
        rewX();
        rewY();
        var origin = rect.origin.clone();
        while (rect.origin.y < box2.bottom) {
          rect.origin.x = origin.x;
          repeatX();
          rect.origin.y += img_height;
        }
      }
    }
  }
  function drawBullet() {
    var listStyleType = getPropertyValue(style, "list-style-type");
    if (listStyleType == "none") {
      return;
    }
    var listStylePosition = getPropertyValue(style, "list-style-position");
    function _drawBullet(f) {
      saveStyle(element, function() {
        element.style.position = "relative";
        var bullet = element.ownerDocument.createElement(KENDO_PSEUDO_ELEMENT);
        bullet.style.position = "absolute";
        bullet.style.boxSizing = "border-box";
        if (listStylePosition == "outside") {
          bullet.style.width = "6em";
          bullet.style.left = "-6.8em";
          bullet.style.textAlign = "right";
        } else {
          bullet.style.left = "0px";
        }
        f(bullet);
        element.insertBefore(bullet, element.firstChild);
        renderElement(bullet, group);
        element.removeChild(bullet);
      });
    }
    function elementIndex(f) {
      var a = element.parentNode.children;
      var k = element.getAttribute("kendo-split-index");
      if (k != null) {
        return f(k | 0, a.length);
      }
      for (var i2 = 0; i2 < a.length; ++i2) {
        if (a[i2] === element) {
          return f(i2, a.length);
        }
      }
    }
    switch (listStyleType) {
      case "circle":
      case "disc":
      case "square":
        _drawBullet(function(bullet) {
          bullet.style.fontSize = "60%";
          bullet.style.lineHeight = "200%";
          bullet.style.paddingRight = "0.5em";
          bullet.style.fontFamily = "DejaVu Serif";
          bullet.innerHTML = {
            "disc": "●",
            "circle": "◯",
            "square": "■"
          }[listStyleType];
        });
        break;
      case "decimal":
      case "decimal-leading-zero":
        _drawBullet(function(bullet) {
          elementIndex(function(idx) {
            ++idx;
            if (listStyleType == "decimal-leading-zero" && idx < 10) {
              idx = "0" + idx;
            }
            bullet.innerHTML = idx + ".";
          });
        });
        break;
      case "lower-roman":
      case "upper-roman":
        _drawBullet(function(bullet) {
          elementIndex(function(idx) {
            idx = arabicToRoman(idx + 1);
            if (listStyleType == "upper-roman") {
              idx = idx.toUpperCase();
            }
            bullet.innerHTML = idx + ".";
          });
        });
        break;
      case "lower-latin":
      case "lower-alpha":
      case "upper-latin":
      case "upper-alpha":
        _drawBullet(function(bullet) {
          elementIndex(function(idx) {
            idx = alphaNumeral(idx);
            if (/^upper/i.test(listStyleType)) {
              idx = idx.toUpperCase();
            }
            bullet.innerHTML = idx + ".";
          });
        });
        break;
    }
  }
  function drawOneBox(box, isFirst, isLast) {
    if (box.width === 0 || box.height === 0) {
      return;
    }
    drawBackground(box);
    var shouldDrawLeft = left.width > 0 && (isFirst && dir == "ltr" || isLast && dir == "rtl");
    var shouldDrawRight = right.width > 0 && (isLast && dir == "ltr" || isFirst && dir == "rtl");
    if (top.width === 0 && left.width === 0 && right.width === 0 && bottom.width === 0) {
      return;
    }
    if (top.color == right.color && top.color == bottom.color && top.color == left.color) {
      if (top.width == right.width && top.width == bottom.width && top.width == left.width) {
        if (shouldDrawLeft && shouldDrawRight) {
          box = innerBox(box, top.width / 2);
          var path = elementRoundBox(element, box, top.width / 2);
          path.options.stroke = {
            color: top.color,
            width: top.width
          };
          group.append(path);
          return;
        }
      }
    }
    if (rTL0.x === 0 && rTR0.x === 0 && rBR0.x === 0 && rBL0.x === 0) {
      if (top.width < 2 && left.width < 2 && right.width < 2 && bottom.width < 2) {
        if (top.width > 0) {
          group.append(
            new Path({
              stroke: { width: top.width, color: top.color }
            }).moveTo(box.left, box.top + top.width / 2).lineTo(box.right, box.top + top.width / 2)
          );
        }
        if (bottom.width > 0) {
          group.append(
            new Path({
              stroke: { width: bottom.width, color: bottom.color }
            }).moveTo(box.left, box.bottom - bottom.width / 2).lineTo(box.right, box.bottom - bottom.width / 2)
          );
        }
        if (shouldDrawLeft) {
          group.append(
            new Path({
              stroke: { width: left.width, color: left.color }
            }).moveTo(box.left + left.width / 2, box.top).lineTo(box.left + left.width / 2, box.bottom)
          );
        }
        if (shouldDrawRight) {
          group.append(
            new Path({
              stroke: { width: right.width, color: right.color }
            }).moveTo(box.right - right.width / 2, box.top).lineTo(box.right - right.width / 2, box.bottom)
          );
        }
        return;
      }
    }
    var tmp = adjustBorderRadiusForBox(box, rTL0, rTR0, rBR0, rBL0);
    var rTL = tmp.tl;
    var rTR = tmp.tr;
    var rBR = tmp.br;
    var rBL = tmp.bl;
    drawEdge(
      top.color,
      box.width,
      top.width,
      left.width,
      right.width,
      rTL,
      rTR,
      [1, 0, 0, 1, box.left, box.top]
    );
    drawEdge(
      bottom.color,
      box.width,
      bottom.width,
      right.width,
      left.width,
      rBR,
      rBL,
      [-1, 0, 0, -1, box.right, box.bottom]
    );
    function inv(p2) {
      return { x: p2.y, y: p2.x };
    }
    drawEdge(
      left.color,
      box.height,
      left.width,
      bottom.width,
      top.width,
      inv(rBL),
      inv(rTL),
      [0, -1, 1, 0, box.left, box.bottom]
    );
    drawEdge(
      right.color,
      box.height,
      right.width,
      top.width,
      bottom.width,
      inv(rTR),
      inv(rBR),
      [0, 1, -1, 0, box.right, box.top]
    );
  }
}
function gradientRenderer(gradient) {
  return function(group, rect) {
    var width = rect.width(), height = rect.height();
    switch (gradient.type) {
      case "linear":
        var angle = gradient.angle != null ? gradient.angle : Math.PI;
        switch (gradient.to) {
          case "top":
            angle = 0;
            break;
          case "left":
            angle = -Math.PI / 2;
            break;
          case "bottom":
            angle = Math.PI;
            break;
          case "right":
            angle = Math.PI / 2;
            break;
          case "top left":
          case "left top":
            angle = -Math.atan2(height, width);
            break;
          case "top right":
          case "right top":
            angle = Math.atan2(height, width);
            break;
          case "bottom left":
          case "left bottom":
            angle = Math.PI + Math.atan2(height, width);
            break;
          case "bottom right":
          case "right bottom":
            angle = Math.PI - Math.atan2(height, width);
            break;
        }
        if (gradient.reverse) {
          angle -= Math.PI;
        }
        angle %= 2 * Math.PI;
        if (angle < 0) {
          angle += 2 * Math.PI;
        }
        var pxlen = Math.abs(width * Math.sin(angle)) + Math.abs(height * Math.cos(angle));
        var scaledAngle = Math.atan(width * Math.tan(angle) / height);
        var sin3 = Math.sin(scaledAngle), cos2 = Math.cos(scaledAngle);
        var len = Math.abs(sin3) + Math.abs(cos2);
        var x = len / 2 * sin3;
        var y = len / 2 * cos2;
        if (angle > Math.PI / 2 && angle <= 3 * Math.PI / 2) {
          x = -x;
          y = -y;
        }
        var implicit = [], right = 0;
        var stops = gradient.stops.map(function(s, i) {
          var offset = s.percent;
          if (offset) {
            offset = parseFloat(offset) / 100;
          } else if (s.length) {
            offset = parseFloat(s.length) / pxlen;
          } else if (i === 0) {
            offset = 0;
          } else if (i == gradient.stops.length - 1) {
            offset = 1;
          }
          var stop = {
            color: s.color.toCssRgba(),
            offset
          };
          if (offset != null) {
            right = offset;
            implicit.forEach(function(s2, i2) {
              var stop2 = s2.stop;
              stop2.offset = s2.left + (right - s2.left) * (i2 + 1) / (implicit.length + 1);
            });
            implicit = [];
          } else {
            implicit.push({ left: right, stop });
          }
          return stop;
        });
        var start = [0.5 - x, 0.5 + y];
        var end = [0.5 + x, 0.5 - y];
        group.append(
          Path.fromRect(rect).stroke(null).fill(new linear_gradient_default({
            start,
            end,
            stops,
            userSpace: false
          }))
        );
        break;
      case "radial":
        if (window.console && window.console.log) {
          window.console.log("Radial gradients are not yet supported in HTML renderer");
        }
        break;
    }
  };
}
function maybeRenderWidget(element, group) {
  var visual;
  if (element._kendoExportVisual) {
    visual = element._kendoExportVisual();
  } else if (window.kendo && window.kendo.jQuery && element.getAttribute(window.kendo.attr("role"))) {
    var widget = window.kendo.widgetInstance(window.kendo.jQuery(element));
    if (widget && (widget.exportDOMVisual || widget.exportVisual)) {
      if (widget.exportDOMVisual) {
        visual = widget.exportDOMVisual();
      } else {
        visual = widget.exportVisual();
      }
    }
  }
  if (!visual) {
    return false;
  }
  var wrap2 = new group_default();
  wrap2.children.push(visual);
  var bbox = element.getBoundingClientRect();
  wrap2.transform(transform().translate(bbox.left, bbox.top));
  group.append(wrap2);
  return true;
}
function renderImage(element, url, group) {
  var box = getContentBox(element);
  var rect = new rect_default([box.left, box.top], [box.width, box.height]);
  var image = new image_default(url, rect);
  setClipping(image, elementRoundBox(element, box, "content"));
  group.append(image);
}
function zIndexSort(a, b) {
  var sa = getComputedStyle2(a);
  var sb = getComputedStyle2(b);
  var za = parseFloat(getPropertyValue(sa, "z-index"));
  var zb = parseFloat(getPropertyValue(sb, "z-index"));
  var pa = getPropertyValue(sa, "position");
  var pb = getPropertyValue(sb, "position");
  if (isNaN(za) && isNaN(zb)) {
    if (/static|absolute/.test(pa) && /static|absolute/.test(pb)) {
      return 0;
    }
    if (pa == "static") {
      return -1;
    }
    if (pb == "static") {
      return 1;
    }
    return 0;
  }
  if (isNaN(za)) {
    return zb === 0 ? 0 : zb > 0 ? -1 : 1;
  }
  if (isNaN(zb)) {
    return za === 0 ? 0 : za > 0 ? 1 : -1;
  }
  return parseFloat(za) - parseFloat(zb);
}
function isFormField(element) {
  return /^(?:textarea|select|input)$/i.test(element.tagName);
}
function getSelectedOption(element) {
  if (element.selectedOptions && element.selectedOptions.length > 0) {
    return element.selectedOptions[0];
  }
  return element.options[element.selectedIndex];
}
function renderCheckbox(element, group) {
  var style = getComputedStyle2(element);
  var color = getPropertyValue(style, "color");
  var box = element.getBoundingClientRect();
  if (element.type == "checkbox") {
    group.append(
      Path.fromRect(
        new rect_default(
          [box.left + 1, box.top + 1],
          [box.width - 2, box.height - 2]
        )
      ).stroke(color, 1)
    );
    if (element.checked) {
      group.append(
        new Path().stroke(color, 1.2).moveTo(
          box.left + 0.22 * box.width,
          box.top + 0.55 * box.height
        ).lineTo(
          box.left + 0.45 * box.width,
          box.top + 0.75 * box.height
        ).lineTo(
          box.left + 0.78 * box.width,
          box.top + 0.22 * box.width
        )
      );
    }
  } else {
    group.append(
      new circle_default2(
        new circle_default([
          (box.left + box.right) / 2,
          (box.top + box.bottom) / 2
        ], Math.min(box.width - 2, box.height - 2) / 2)
      ).stroke(color, 1)
    );
    if (element.checked) {
      group.append(
        new circle_default2(
          new circle_default([
            (box.left + box.right) / 2,
            (box.top + box.bottom) / 2
          ], Math.min(box.width - 8, box.height - 8) / 2)
        ).fill(color).stroke(null)
      );
    }
  }
}
function renderFormField(element, group) {
  var tag = element.tagName.toLowerCase();
  if (tag == "input" && (element.type == "checkbox" || element.type == "radio")) {
    return renderCheckbox(element, group);
  }
  var p2 = element.parentNode;
  var doc = element.ownerDocument;
  var el = doc.createElement(KENDO_PSEUDO_ELEMENT);
  var option;
  el.style.cssText = getCssText(getComputedStyle2(element));
  if (tag == "input") {
    el.style.whiteSpace = "pre";
  }
  if (tag == "select" || tag == "textarea") {
    el.style.overflow = "auto";
  }
  if (tag == "select") {
    if (element.multiple) {
      for (var i = 0; i < element.options.length; ++i) {
        option = doc.createElement(KENDO_PSEUDO_ELEMENT);
        option.style.cssText = getCssText(getComputedStyle2(element.options[i]));
        option.style.display = "block";
        option.textContent = element.options[i].textContent;
        el.appendChild(option);
      }
    } else {
      option = getSelectedOption(element);
      if (option) {
        el.textContent = option.textContent;
      }
    }
  } else {
    el.textContent = element.value;
  }
  p2.insertBefore(el, element);
  el.scrollLeft = element.scrollLeft;
  el.scrollTop = element.scrollTop;
  element.style.display = "none";
  renderContents(el, group);
  element.style.display = "";
  p2.removeChild(el);
}
function serializeSVG(element) {
  var serializer = new window.XMLSerializer();
  var xml = serializer.serializeToString(element);
  if (browser4.mozilla && !(element.getAttribute("width") && element.getAttribute("height"))) {
    var doc = new window.DOMParser().parseFromString(xml, "image/svg+xml");
    var svg = doc.documentElement;
    var box = getContentBox(element);
    svg.setAttribute("width", box.width);
    svg.setAttribute("height", box.height);
    xml = serializer.serializeToString(svg);
  }
  return xml;
}
function renderContents(element, group) {
  if (nodeInfo._stackingContext.element === element) {
    nodeInfo._stackingContext.group = group;
  }
  switch (element.tagName.toLowerCase()) {
    case "img":
      renderImage(element, element.src, group);
      break;
    case "svg":
      var xml = serializeSVG(element);
      var dataURL = "data:image/svg+xml;base64," + encodeBase64(xml);
      renderImage(element, dataURL, group);
      break;
    case "canvas":
      try {
        renderImage(element, element.toDataURL("image/png"), group);
      } catch (ex) {
      }
      break;
    case "textarea":
    case "input":
    case "select":
      renderFormField(element, group);
      break;
    default:
      var children = [], floats = [], positioned = [];
      for (var i = element.firstChild; i; i = i.nextSibling) {
        switch (i.nodeType) {
          case 3:
            if (/\S/.test(i.data)) {
              renderText(element, i, group);
            }
            break;
          case 1:
            var style = getComputedStyle2(i);
            var floating = getPropertyValue(style, "float");
            var position = getPropertyValue(style, "position");
            if (position != "static") {
              positioned.push(i);
            } else if (floating != "none") {
              floats.push(i);
            } else {
              children.push(i);
            }
            break;
        }
      }
      mergeSort(children, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
      mergeSort(floats, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
      mergeSort(positioned, zIndexSort).forEach(function(el) {
        renderElement(el, group);
      });
  }
}
function renderText(element, node, group) {
  if (emptyClipbox()) {
    return;
  }
  var style = getComputedStyle2(element);
  if (parseFloat(getPropertyValue(style, "text-indent")) < -500) {
    return;
  }
  var text = node.data;
  var start = 0;
  var end = text.search(/\S\s*$/) + 1;
  if (!end) {
    return;
  }
  var fontSize = getPropertyValue(style, "font-size");
  var lineHeight = getPropertyValue(style, "line-height");
  var font = [
    getPropertyValue(style, "font-style"),
    getPropertyValue(style, "font-variant"),
    getPropertyValue(style, "font-weight"),
    fontSize,
    // no need for line height here; it breaks layout in FF
    getPropertyValue(style, "font-family")
  ].join(" ");
  fontSize = parseFloat(fontSize);
  lineHeight = parseFloat(lineHeight);
  if (fontSize === 0 || isNaN(fontSize)) {
    return;
  }
  var color = getPropertyValue(style, "color");
  var range = element.ownerDocument.createRange();
  var align2 = getPropertyValue(style, "text-align");
  var isJustified = align2 == "justify";
  var columnCount = getPropertyValue(style, "column-count", 1);
  var whiteSpace = getPropertyValue(style, "white-space");
  var textTransform = getPropertyValue(style, "text-transform");
  var estimateLineLength = element.getBoundingClientRect().width / fontSize * 5;
  if (estimateLineLength === 0) {
    estimateLineLength = 500;
  }
  var prevLineBottom = null;
  var underline = nodeInfo["underline"];
  var lineThrough = nodeInfo["line-through"];
  var overline = nodeInfo["overline"];
  var hasDecoration = underline || lineThrough || overline;
  while (!doChunk()) {
  }
  if (hasDecoration) {
    range.selectNode(node);
    slice2(range.getClientRects()).forEach(decorate);
  }
  return;
  function actuallyGetRangeBoundingRect(range2) {
    if (microsoft || browser4.chrome || browser4.safari) {
      var rectangles = range2.getClientRects(), box = {
        top: Infinity,
        right: -Infinity,
        bottom: -Infinity,
        left: Infinity
      }, done = false;
      for (var i = 0; i < rectangles.length; ++i) {
        var b = rectangles[i];
        if (b.width <= 1 || b.bottom === prevLineBottom) {
          continue;
        }
        box.left = Math.min(b.left, box.left);
        box.top = Math.min(b.top, box.top);
        box.right = Math.max(b.right, box.right);
        box.bottom = Math.max(b.bottom, box.bottom);
        done = true;
      }
      if (!done) {
        return range2.getBoundingClientRect();
      }
      box.width = box.right - box.left;
      box.height = box.bottom - box.top;
      return box;
    }
    return range2.getBoundingClientRect();
  }
  function doChunk() {
    var origStart = start;
    var box, pos = text.substr(start).search(/\S/);
    start += pos;
    if (pos < 0 || start >= end) {
      return true;
    }
    range.setStart(node, start);
    range.setEnd(node, start + 1);
    box = actuallyGetRangeBoundingRect(range);
    var found = false;
    if (isJustified || columnCount > 1) {
      pos = text.substr(start).search(/\s/);
      if (pos >= 0) {
        range.setEnd(node, start + pos);
        var r = actuallyGetRangeBoundingRect(range);
        if (r.bottom == box.bottom) {
          box = r;
          found = true;
          start += pos;
        }
      }
    }
    if (!found) {
      pos = function findEOL(min3, eol, max2) {
        range.setEnd(node, eol);
        var r2 = actuallyGetRangeBoundingRect(range);
        if (r2.bottom != box.bottom && min3 < eol) {
          return findEOL(min3, min3 + eol >> 1, eol);
        } else if (r2.right != box.right) {
          box = r2;
          if (eol < max2) {
            return findEOL(eol, eol + max2 >> 1, max2);
          } else {
            return eol;
          }
        } else {
          return eol;
        }
      }(start, Math.min(end, start + estimateLineLength), end);
      if (pos == start) {
        return true;
      }
      start = pos;
      pos = range.toString().search(/\s+$/);
      if (pos === 0) {
        return false;
      }
      if (pos > 0) {
        range.setEnd(node, range.startOffset + pos);
        box = actuallyGetRangeBoundingRect(range);
      }
    }
    if (microsoft) {
      box = range.getClientRects()[0];
    }
    var str = range.toString();
    if (!/^(?:pre|pre-wrap)$/i.test(whiteSpace)) {
      str = str.replace(/\s+/g, " ");
    } else if (/\t/.test(str)) {
      var cc = 0;
      for (pos = origStart; pos < range.startOffset; ++pos) {
        var code2 = text.charCodeAt(pos);
        if (code2 == 9) {
          cc += 8 - cc % 8;
        } else if (code2 == 10 || code2 == 13) {
          cc = 0;
        } else {
          cc++;
        }
      }
      while ((pos = str.search("	")) >= 0) {
        var indent = "        ".substr(0, 8 - (cc + pos) % 8);
        str = str.substr(0, pos) + indent + str.substr(pos + 1);
      }
    }
    if (!found) {
      prevLineBottom = box.bottom;
    }
    drawText(str, box);
  }
  function drawText(str, box) {
    if (microsoft && !isNaN(lineHeight)) {
      var height = getFontHeight(font);
      var top = (box.top + box.bottom - height) / 2;
      box = {
        top,
        right: box.right,
        bottom: top + height,
        left: box.left,
        height,
        width: box.right - box.left
      };
    }
    switch (textTransform) {
      case "uppercase":
        str = str.toUpperCase();
        break;
      case "lowercase":
        str = str.toLowerCase();
        break;
      case "capitalize":
        str = str.replace(/(?:^|\s)\S/g, function(l) {
          return l.toUpperCase();
        });
        break;
    }
    var text2 = new TextRect(
      str,
      new rect_default(
        [box.left, box.top],
        [box.width, box.height]
      ),
      {
        font,
        fill: { color }
      }
    );
    group.append(text2);
  }
  function decorate(box) {
    line(underline, box.bottom);
    line(lineThrough, box.bottom - box.height / 2.7);
    line(overline, box.top);
    function line(color2, ypos) {
      if (color2) {
        var width = fontSize / 12;
        var path = new Path({ stroke: {
          width,
          color: color2
        } });
        ypos -= width;
        path.moveTo(box.left, ypos).lineTo(box.right, ypos);
        group.append(path);
      }
    }
  }
}
function groupInStackingContext(element, group, zIndex) {
  var main;
  if (zIndex != "auto") {
    main = nodeInfo._stackingContext.group;
    zIndex = parseFloat(zIndex);
  } else {
    main = group;
    zIndex = 0;
  }
  var a = main.children;
  for (var i = 0; i < a.length; ++i) {
    if (a[i]._dom_zIndex != null && a[i]._dom_zIndex > zIndex) {
      break;
    }
  }
  var tmp = new group_default();
  main.insert(i, tmp);
  tmp._dom_zIndex = zIndex;
  if (main !== group) {
    if (nodeInfo._clipbox) {
      var m = nodeInfo._matrix.invert();
      var r = nodeInfo._clipbox.transformCopy(m);
      setClipping(tmp, Path.fromRect(r));
    }
  }
  return tmp;
}
function renderElement(element, container) {
  var style = getComputedStyle2(element);
  updateCounters(style);
  if (/^(style|script|link|meta|iframe|col|colgroup)$/i.test(element.tagName)) {
    return;
  }
  if (nodeInfo._clipbox == null) {
    return;
  }
  var opacity = parseFloat(getPropertyValue(style, "opacity"));
  var visibility = getPropertyValue(style, "visibility");
  var display = getPropertyValue(style, "display");
  if (opacity === 0 || visibility == "hidden" || display == "none") {
    return;
  }
  var tr = getTransform(style);
  var group;
  var zIndex = getPropertyValue(style, "z-index");
  if ((tr || opacity < 1) && zIndex == "auto") {
    zIndex = 0;
  }
  group = groupInStackingContext(element, container, zIndex);
  if (opacity < 1) {
    group.opacity(opacity * group.opacity());
  }
  pushNodeInfo(element, style, group);
  if (!tr) {
    _renderWithPseudoElements(element, group);
  } else {
    saveStyle(element, function() {
      pleaseSetPropertyValue(element.style, "transform", "none", "important");
      pleaseSetPropertyValue(element.style, "transition", "none", "important");
      if (getPropertyValue(style, "position") == "static") {
        pleaseSetPropertyValue(element.style, "position", "relative", "important");
      }
      var bbox = element.getBoundingClientRect();
      var x = bbox.left + tr.origin[0];
      var y = bbox.top + tr.origin[1];
      var m = [1, 0, 0, 1, -x, -y];
      m = mmul2(m, tr.matrix);
      m = mmul2(m, [1, 0, 0, 1, x, y]);
      m = setTransform(group, m);
      nodeInfo._matrix = nodeInfo._matrix.multiplyCopy(m);
      _renderWithPseudoElements(element, group);
    });
  }
  popNodeInfo();
}
function mmul2(a, b) {
  var a1 = a[0], b1 = a[1], c1 = a[2], d1 = a[3], e1 = a[4], f1 = a[5];
  var a2 = b[0], b2 = b[1], c2 = b[2], d2 = b[3], e2 = b[4], f2 = b[5];
  return [
    a1 * a2 + b1 * c2,
    a1 * b2 + b1 * d2,
    c1 * a2 + d1 * c2,
    c1 * b2 + d1 * d2,
    e1 * a2 + f1 * c2 + e2,
    e1 * b2 + f1 * d2 + f2
  ];
}

// node_modules/@progress/kendo-charts/dist/es/common/align-path-to-pixel.js
function alignPathToPixel(path) {
  var offset = 0.5;
  if (path.options.stroke && drawing_exports.util.defined(path.options.stroke.width)) {
    if (path.options.stroke.width % 2 === 0) {
      offset = 0;
    }
  }
  for (var i = 0; i < path.segments.length; i++) {
    path.segments[i].anchor().round(0).translate(offset, offset);
  }
  return path;
}

// node_modules/@progress/kendo-charts/dist/es/common/clockwise.js
function clockwise(angle1, angle2) {
  return -angle1.x * angle2.y + angle1.y * angle2.x < 0;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-number.js
function isNumber2(value) {
  return typeof value === "number" && !isNaN(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-string.js
function isString2(value) {
  return typeof value === STRING;
}

// node_modules/@progress/kendo-charts/dist/es/common/convertable-to-number.js
function convertableToNumber(value) {
  return isNumber2(value) || isString2(value) && isFinite(value);
}

// node_modules/@progress/kendo-charts/dist/es/common/is-function.js
function isFunction3(fn) {
  return typeof fn === "function";
}

// node_modules/@progress/kendo-charts/dist/es/common/deep-extend.js
var OBJECT2 = "object";
var UNDEFINED2 = "undefined";
function deepExtendOne(destination, source) {
  for (var property in source) {
    var propValue = source[property];
    var propType = typeof propValue;
    var propInit = void 0;
    if (propType === OBJECT2 && propValue !== null) {
      propInit = propValue.constructor;
    } else {
      propInit = null;
    }
    if (propInit && propInit !== Array) {
      if (propValue instanceof Date) {
        destination[property] = new Date(propValue.getTime());
      } else if (isFunction3(propValue.clone)) {
        destination[property] = propValue.clone();
      } else {
        var destProp = destination[property];
        if (typeof destProp === OBJECT2) {
          destination[property] = destProp || {};
        } else {
          destination[property] = {};
        }
        deepExtendOne(destination[property], propValue);
      }
    } else if (propType !== UNDEFINED2) {
      destination[property] = propValue;
    }
  }
  return destination;
}
function deepExtend(destination) {
  var arguments$1 = arguments;
  var length = arguments.length;
  for (var i = 1; i < length; i++) {
    deepExtendOne(destination, arguments$1[i]);
  }
  return destination;
}

// node_modules/@progress/kendo-charts/dist/es/common/is-object.js
function isObject(value) {
  return typeof value === "object";
}

// node_modules/@progress/kendo-charts/dist/es/common/style-value.js
function styleValue(value) {
  if (isNumber2(value)) {
    return value + "px";
  }
  return value;
}

// node_modules/@progress/kendo-charts/dist/es/common/element-styles.js
var SIZE_STYLES_REGEX = /width|height|top|left|bottom|right/i;
function isSizeField(field) {
  return SIZE_STYLES_REGEX.test(field);
}
function elementStyles2(element, styles) {
  var stylesArray = isString2(styles) ? [styles] : styles;
  if (isArray(stylesArray)) {
    var result = {};
    var style = window.getComputedStyle(element);
    for (var idx = 0; idx < stylesArray.length; idx++) {
      var field = stylesArray[idx];
      result[field] = isSizeField(field) ? parseFloat(style[field]) : style[field];
    }
    return result;
  } else if (isObject(styles)) {
    for (var field$1 in styles) {
      element.style[field$1] = styleValue(styles[field$1]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/get-spacing.js
function getSpacing(value, defaultSpacing) {
  if (defaultSpacing === void 0)
    defaultSpacing = 0;
  var spacing = { top: 0, right: 0, bottom: 0, left: 0 };
  if (typeof value === "number") {
    spacing[TOP] = spacing[RIGHT] = spacing[BOTTOM] = spacing[LEFT] = value;
  } else {
    spacing[TOP] = value[TOP] || defaultSpacing;
    spacing[RIGHT] = value[RIGHT] || defaultSpacing;
    spacing[BOTTOM] = value[BOTTOM] || defaultSpacing;
    spacing[LEFT] = value[LEFT] || defaultSpacing;
  }
  return spacing;
}

// node_modules/@progress/kendo-charts/dist/es/services/template-service.js
var current = {
  compile: function(template3) {
    return template3;
  }
};
var TemplateService = function TemplateService2() {
};
TemplateService.register = function register(userImplementation) {
  current = userImplementation;
};
TemplateService.compile = function compile(template3) {
  return current.compile(template3);
};
var template_service_default = TemplateService;

// node_modules/@progress/kendo-charts/dist/es/common/get-template.js
function getTemplate(options2) {
  if (options2 === void 0)
    options2 = {};
  var template3;
  if (options2.template) {
    options2.template = template3 = template_service_default.compile(options2.template);
  } else if (isFunction3(options2.content)) {
    template3 = options2.content;
  }
  return template3;
}

// node_modules/@progress/kendo-charts/dist/es/common/getter.js
var FIELD_REGEX = /\[(?:(\d+)|['"](.*?)['"])\]|((?:(?!\[.*?\]|\.).)+)/g;
var getterCache = {};
getterCache["undefined"] = function(obj) {
  return obj;
};
function getter(field) {
  if (getterCache[field]) {
    return getterCache[field];
  }
  var fields = [];
  field.replace(FIELD_REGEX, function(match, index, indexAccessor, field2) {
    fields.push(drawing_exports.util.defined(index) ? index : indexAccessor || field2);
  });
  getterCache[field] = function(obj) {
    var result = obj;
    for (var idx = 0; idx < fields.length && result; idx++) {
      result = result[fields[idx]];
    }
    return result;
  };
  return getterCache[field];
}

// node_modules/@progress/kendo-charts/dist/es/common/grep.js
function grep(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    if (callback(array[idx])) {
      result.push(array[idx]);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/has-classes.js
function hasClasses(element, classNames2) {
  if (element.className) {
    var names = classNames2.split(" ");
    for (var idx = 0; idx < names.length; idx++) {
      if (element.className.indexOf(names[idx]) !== -1) {
        return true;
      }
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/hash-map.js
var HashMap = function HashMap2() {
  this._map = {};
};
HashMap.prototype.get = function get(name3) {
  return this._map[this._key(name3)];
};
HashMap.prototype.set = function set(name3, value) {
  this._map[this._key(name3)] = value;
};
HashMap.prototype._key = function _key(name3) {
  return name3 instanceof Date ? name3.getTime() : name3;
};
var hash_map_default = HashMap;

// node_modules/@progress/kendo-charts/dist/es/common/in-array.js
function inArray(value, array) {
  if (array) {
    return array.indexOf(value) !== -1;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/interpolate-value.js
function interpolateValue(start, end, progress) {
  return drawing_exports.util.round(start + (end - start) * progress, COORD_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/common/instance-observer.js
var TRIGGER = "trigger";
var InstanceObserver = function InstanceObserver2(observer, handlers) {
  this.observer = observer;
  this.handlerMap = deepExtend({}, this.handlerMap, handlers);
};
InstanceObserver.prototype.trigger = function trigger(name3, args) {
  var ref2 = this;
  var observer = ref2.observer;
  var handlerMap = ref2.handlerMap;
  var isDefaultPrevented3;
  if (handlerMap[name3]) {
    isDefaultPrevented3 = this.callObserver(handlerMap[name3], args);
  } else if (observer[TRIGGER]) {
    isDefaultPrevented3 = this.callObserver(TRIGGER, name3, args);
  }
  return isDefaultPrevented3;
};
InstanceObserver.prototype.callObserver = function callObserver(fnName) {
  var args = [], len = arguments.length - 1;
  while (len-- > 0)
    args[len] = arguments[len + 1];
  return this.observer[fnName].apply(this.observer, args);
};
InstanceObserver.prototype.requiresHandlers = function requiresHandlers(names) {
  var this$1 = this;
  if (this.observer.requiresHandlers) {
    return this.observer.requiresHandlers(names);
  }
  for (var idx = 0; idx < names.length; idx++) {
    if (this$1.handlerMap[names[idx]]) {
      return true;
    }
  }
};
var instance_observer_default = InstanceObserver;

// node_modules/@progress/kendo-charts/dist/es/common/map.js
function map(array, callback) {
  var length = array.length;
  var result = [];
  for (var idx = 0; idx < length; idx++) {
    var value = callback(array[idx]);
    if (drawing_exports.util.defined(value)) {
      result.push(value);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/common/mousewheel-delta.js
var browser5 = support_default.browser || {};
function mousewheelDelta(e) {
  var delta = 0;
  if (e.wheelDelta) {
    delta = -e.wheelDelta / 120;
    if (browser5.webkit) {
      delta = delta / (2 * Math.max(window.devicePixelRatio, 0.625));
    }
  } else if (e.detail) {
    delta = e.detail / 3;
  }
  delta = delta > 0 ? Math.ceil(delta) : Math.floor(delta);
  return delta;
}

// node_modules/@progress/kendo-charts/dist/es/drawing-utils.js
var ref = drawing_exports.util;
var append2 = ref.append;
var bindEvents2 = ref.bindEvents;
var defined2 = ref.defined;
var deg2 = ref.deg;
var elementOffset2 = ref.elementOffset;
var elementSize2 = ref.elementSize;
var eventCoordinates2 = ref.eventCoordinates;
var eventElement2 = ref.eventElement;
var hashKey2 = ref.hashKey;
var last2 = ref.last;
var limitValue2 = ref.limitValue;
var objectKey2 = ref.objectKey;
var rad2 = ref.rad;
var round3 = ref.round;
var unbindEvents2 = ref.unbindEvents;
var valueOrDefault2 = ref.valueOrDefault;

// node_modules/@progress/kendo-charts/dist/es/common/font-loader.js
var FontLoader = function FontLoader2() {
};
FontLoader.fetchFonts = function fetchFonts(options2, fonts, state) {
  if (state === void 0)
    state = { depth: 0 };
  var MAX_DEPTH = 5;
  if (!options2 || state.depth > MAX_DEPTH || !document.fonts) {
    return;
  }
  Object.keys(options2).forEach(function(key) {
    var value = options2[key];
    if (key === "dataSource" || key[0] === "$" || !value) {
      return;
    }
    if (key === "font") {
      fonts.push(value);
    } else if (typeof value === "object") {
      state.depth++;
      FontLoader.fetchFonts(value, fonts, state);
      state.depth--;
    }
  });
};
FontLoader.loadFonts = function loadFonts2(fonts, callback) {
  var promises = [];
  if (fonts.length > 0 && document.fonts) {
    try {
      promises = fonts.map(function(font) {
        return document.fonts.load(font);
      });
    } catch (e) {
      logToConsole(e);
    }
    Promise.all(promises).then(callback, callback);
  } else {
    callback();
  }
};
FontLoader.preloadFonts = function preloadFonts(options2, callback) {
  var fonts = [];
  FontLoader.fetchFonts(options2, fonts);
  FontLoader.loadFonts(fonts, callback);
};
var font_loader_default = FontLoader;

// node_modules/@progress/kendo-charts/dist/es/common/set-default-options.js
function setDefaultOptions(type, options2) {
  var proto = type.prototype;
  if (proto.options) {
    proto.options = deepExtend({}, proto.options, options2);
  } else {
    proto.options = options2;
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/sparse-array-limits.js
function sparseArrayLimits(arr) {
  var min3 = MAX_VALUE;
  var max2 = MIN_VALUE;
  for (var idx = 0, length = arr.length; idx < length; idx++) {
    var value = arr[idx];
    if (value !== null && isFinite(value)) {
      min3 = Math.min(min3, value);
      max2 = Math.max(max2, value);
    }
  }
  return {
    min: min3 === MAX_VALUE ? void 0 : min3,
    max: max2 === MIN_VALUE ? void 0 : max2
  };
}

// node_modules/@progress/kendo-charts/dist/es/common/find.js
function find(array, predicate) {
  for (var i = 0; i < array.length; i++) {
    var item = array[i];
    if (predicate(item, i, array)) {
      return item;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/common/element-scale.js
var Matrix2 = geometry_exports.Matrix;
var matrixRegexp2 = /matrix\((.*)\)/;
function parseMatrix2(matrixString) {
  var match = matrixString.match(matrixRegexp2);
  if (match === null || match.length !== 2) {
    return Matrix2.unit();
  }
  var members = match[1].split(",").map(function(x) {
    return parseFloat(x);
  });
  return new (Function.prototype.bind.apply(Matrix2, [null].concat(members)))();
}
function transformMatrix2(element) {
  var transform2 = getComputedStyle(element).transform;
  if (transform2 === "none") {
    return Matrix2.unit();
  }
  return parseMatrix2(transform2);
}
function elementScale2(element) {
  if (!element) {
    return Matrix2.unit();
  }
  var matrix = transformMatrix2(element);
  var parent = element.parentElement;
  while (parent) {
    var parentMatrix = transformMatrix2(parent);
    matrix = matrix.multiplyCopy(parentMatrix);
    parent = parent.parentElement;
  }
  matrix.b = matrix.c = matrix.e = matrix.f = 0;
  return matrix;
}

// node_modules/@progress/kendo-charts/dist/es/common/auto-text-color.js
function autoTextColor(color) {
  var isDark = new color_default(color).isDark();
  if (isDark) {
    return WHITE;
  }
  return BLACK;
}
var auto_text_color_default = autoTextColor;

// node_modules/@progress/kendo-charts/dist/es/common/create-hash-set.js
var DELETED = {};
var LegacySet = function LegacySet2(values5) {
  var this$1 = this;
  this._index = {};
  this._values = values5 ? values5.slice(0) : [];
  for (var i = 0; i < this._values.length; i++) {
    this$1._index[this$1._values[i]] = i;
  }
};
var prototypeAccessors = { size: { configurable: true } };
LegacySet.prototype.values = function values() {
  return this._values.filter(function(item) {
    return item !== DELETED;
  });
};
LegacySet.prototype.has = function has(value) {
  return this._index[value] !== void 0;
};
LegacySet.prototype.add = function add(value) {
  if (!this.has(value)) {
    this._index[value] = this._values.length;
    this._values.push(value);
  }
};
LegacySet.prototype.delete = function delete$1(value) {
  var index = this._index[value];
  if (index !== void 0) {
    this._values[index] = DELETED;
    delete this._index[value];
  }
};
LegacySet.prototype.clear = function clear2() {
  this._index = {};
  this._values = [];
};
prototypeAccessors.size.get = function() {
  return this._values.length;
};
Object.defineProperties(LegacySet.prototype, prototypeAccessors);
var SetWrapper = function SetWrapper2(values5) {
  this._set = new Set(values5);
};
var prototypeAccessors$1 = { size: { configurable: true } };
SetWrapper.prototype.values = function values2() {
  return Array.from(this._set);
};
SetWrapper.prototype.has = function has2(value) {
  return this._set.has(value);
};
SetWrapper.prototype.add = function add2(value) {
  this._set.add(value);
};
SetWrapper.prototype.delete = function delete$2(value) {
  this._set.delete(value);
};
SetWrapper.prototype.clear = function clear3() {
  this._set.clear();
};
prototypeAccessors$1.size.get = function() {
  return this._set.size;
};
Object.defineProperties(SetWrapper.prototype, prototypeAccessors$1);
var supportsSet = function() {
  var supported = false;
  if (typeof Set === "function") {
    var set2 = /* @__PURE__ */ new Set([1]);
    supported = set2.has(1);
  }
  return supported;
};
function createHashSet(values5) {
  if (supportsSet()) {
    return new SetWrapper(values5);
  }
  return new LegacySet(values5);
}

// node_modules/@progress/kendo-charts/dist/es/common/default-error-handler.js
function defaultErrorHandler(error2) {
  throw error2;
}

// node_modules/@progress/kendo-charts/dist/es/common/keys.js
var keys = {
  INSERT: 45,
  DELETE: 46,
  BACKSPACE: 8,
  TAB: 9,
  ENTER: 13,
  ESC: 27,
  LEFT: 37,
  UP: 38,
  RIGHT: 39,
  DOWN: 40,
  END: 35,
  HOME: 36,
  SPACEBAR: 32,
  PAGEUP: 33,
  PAGEDOWN: 34,
  F2: 113,
  F10: 121,
  F12: 123,
  NUMPAD_PLUS: 107,
  NUMPAD_MINUS: 109,
  NUMPAD_DOT: 110
};
var keys_default = keys;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-major-unit.js
function autoMajorUnit(min3, max2) {
  var diff = round3(max2 - min3, DEFAULT_PRECISION - 1);
  if (diff === 0) {
    if (max2 === 0) {
      return 0.1;
    }
    diff = Math.abs(max2);
  }
  var scale = Math.pow(10, Math.floor(Math.log(diff) / Math.log(10)));
  var relativeValue = round3(diff / scale, DEFAULT_PRECISION);
  var scaleMultiplier = 1;
  if (relativeValue < 1.904762) {
    scaleMultiplier = 0.2;
  } else if (relativeValue < 4.761904) {
    scaleMultiplier = 0.5;
  } else if (relativeValue < 9.523809) {
    scaleMultiplier = 1;
  } else {
    scaleMultiplier = 2;
  }
  return round3(scale * scaleMultiplier, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/point.js
var Point2 = function(Class3) {
  function Point8(x, y) {
    Class3.call(this);
    this.x = x || 0;
    this.y = y || 0;
  }
  if (Class3)
    Point8.__proto__ = Class3;
  Point8.prototype = Object.create(Class3 && Class3.prototype);
  Point8.prototype.constructor = Point8;
  Point8.prototype.clone = function clone2() {
    return new Point8(this.x, this.y);
  };
  Point8.prototype.equals = function equals(point2) {
    return point2 && this.x === point2.x && this.y === point2.y;
  };
  Point8.prototype.rotate = function rotate(center, degrees) {
    var theta = rad2(degrees);
    var cosT = Math.cos(theta);
    var sinT = Math.sin(theta);
    var cx = center.x;
    var cy = center.y;
    var ref2 = this;
    var x = ref2.x;
    var y = ref2.y;
    this.x = round3(
      cx + (x - cx) * cosT + (y - cy) * sinT,
      COORD_PRECISION
    );
    this.y = round3(
      cy + (y - cy) * cosT - (x - cx) * sinT,
      COORD_PRECISION
    );
    return this;
  };
  Point8.prototype.multiply = function multiply(a) {
    this.x *= a;
    this.y *= a;
    return this;
  };
  Point8.prototype.distanceTo = function distanceTo(point2) {
    var dx = this.x - point2.x;
    var dy = this.y - point2.y;
    return Math.sqrt(dx * dx + dy * dy);
  };
  Point8.onCircle = function onCircle(center, angle, radius) {
    var radians = rad2(angle);
    return new Point8(
      center.x - radius * Math.cos(radians),
      center.y - radius * Math.sin(radians)
    );
  };
  return Point8;
}(class_default);
var point_default2 = Point2;

// node_modules/@progress/kendo-charts/dist/es/core/box.js
var Box = function(Class3) {
  function Box2(x1, y1, x2, y2) {
    Class3.call(this);
    this.x1 = x1 || 0;
    this.y1 = y1 || 0;
    this.x2 = x2 || 0;
    this.y2 = y2 || 0;
  }
  if (Class3)
    Box2.__proto__ = Class3;
  Box2.prototype = Object.create(Class3 && Class3.prototype);
  Box2.prototype.constructor = Box2;
  Box2.prototype.equals = function equals(box) {
    return this.x1 === box.x1 && this.x2 === box.x2 && this.y1 === box.y1 && this.y2 === box.y2;
  };
  Box2.prototype.width = function width() {
    return this.x2 - this.x1;
  };
  Box2.prototype.height = function height() {
    return this.y2 - this.y1;
  };
  Box2.prototype.translate = function translate2(dx, dy) {
    this.x1 += dx;
    this.x2 += dx;
    this.y1 += dy;
    this.y2 += dy;
    return this;
  };
  Box2.prototype.move = function move(x, y) {
    var height = this.height();
    var width = this.width();
    if (defined2(x)) {
      this.x1 = x;
      this.x2 = this.x1 + width;
    }
    if (defined2(y)) {
      this.y1 = y;
      this.y2 = this.y1 + height;
    }
    return this;
  };
  Box2.prototype.wrap = function wrap2(targetBox) {
    this.x1 = Math.min(this.x1, targetBox.x1);
    this.y1 = Math.min(this.y1, targetBox.y1);
    this.x2 = Math.max(this.x2, targetBox.x2);
    this.y2 = Math.max(this.y2, targetBox.y2);
    return this;
  };
  Box2.prototype.wrapPoint = function wrapPoint(point2) {
    var arrayPoint = isArray(point2);
    var x = arrayPoint ? point2[0] : point2.x;
    var y = arrayPoint ? point2[1] : point2.y;
    this.wrap(new Box2(x, y, x, y));
    return this;
  };
  Box2.prototype.snapTo = function snapTo(targetBox, axis) {
    if (axis === X || !axis) {
      this.x1 = targetBox.x1;
      this.x2 = targetBox.x2;
    }
    if (axis === Y || !axis) {
      this.y1 = targetBox.y1;
      this.y2 = targetBox.y2;
    }
    return this;
  };
  Box2.prototype.alignTo = function alignTo(targetBox, anchor) {
    var height = this.height();
    var width = this.width();
    var axis = anchor === TOP || anchor === BOTTOM ? Y : X;
    var offset = axis === Y ? height : width;
    if (anchor === CENTER) {
      var targetCenter = targetBox.center();
      var center = this.center();
      this.x1 += targetCenter.x - center.x;
      this.y1 += targetCenter.y - center.y;
    } else if (anchor === TOP || anchor === LEFT) {
      this[axis + 1] = targetBox[axis + 1] - offset;
    } else {
      this[axis + 1] = targetBox[axis + 2];
    }
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.shrink = function shrink(dw, dh) {
    this.x2 -= dw;
    this.y2 -= dh;
    return this;
  };
  Box2.prototype.expand = function expand(dw, dh) {
    this.shrink(-dw, -dh);
    return this;
  };
  Box2.prototype.pad = function pad4(padding) {
    var spacing = getSpacing(padding);
    this.x1 -= spacing.left;
    this.x2 += spacing.right;
    this.y1 -= spacing.top;
    this.y2 += spacing.bottom;
    return this;
  };
  Box2.prototype.unpad = function unpad2(padding) {
    var spacing = getSpacing(padding);
    spacing.left = -spacing.left;
    spacing.top = -spacing.top;
    spacing.right = -spacing.right;
    spacing.bottom = -spacing.bottom;
    return this.pad(spacing);
  };
  Box2.prototype.clone = function clone2() {
    return new Box2(this.x1, this.y1, this.x2, this.y2);
  };
  Box2.prototype.center = function center() {
    return new point_default2(
      this.x1 + this.width() / 2,
      this.y1 + this.height() / 2
    );
  };
  Box2.prototype.containsPoint = function containsPoint(point2) {
    return point2.x >= this.x1 && point2.x <= this.x2 && point2.y >= this.y1 && point2.y <= this.y2;
  };
  Box2.prototype.points = function points3() {
    return [
      new point_default2(this.x1, this.y1),
      new point_default2(this.x2, this.y1),
      new point_default2(this.x2, this.y2),
      new point_default2(this.x1, this.y2)
    ];
  };
  Box2.prototype.getHash = function getHash() {
    return [this.x1, this.y1, this.x2, this.y2].join(",");
  };
  Box2.prototype.overlaps = function overlaps(box) {
    return !(box.y2 < this.y1 || this.y2 < box.y1 || box.x2 < this.x1 || this.x2 < box.x1);
  };
  Box2.prototype.rotate = function rotate(rotation) {
    var width = this.width();
    var height = this.height();
    var ref2 = this.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var r1 = rotatePoint(0, 0, cx, cy, rotation);
    var r2 = rotatePoint(width, 0, cx, cy, rotation);
    var r3 = rotatePoint(width, height, cx, cy, rotation);
    var r4 = rotatePoint(0, height, cx, cy, rotation);
    width = Math.max(r1.x, r2.x, r3.x, r4.x) - Math.min(r1.x, r2.x, r3.x, r4.x);
    height = Math.max(r1.y, r2.y, r3.y, r4.y) - Math.min(r1.y, r2.y, r3.y, r4.y);
    this.x2 = this.x1 + width;
    this.y2 = this.y1 + height;
    return this;
  };
  Box2.prototype.toRect = function toRect() {
    return new geometry_exports.Rect([this.x1, this.y1], [this.width(), this.height()]);
  };
  Box2.prototype.hasSize = function hasSize() {
    return this.width() !== 0 && this.height() !== 0;
  };
  Box2.prototype.align = function align2(targetBox, axis, alignment) {
    var c1 = axis + 1;
    var c2 = axis + 2;
    var sizeFunc = axis === X ? WIDTH : HEIGHT;
    var size = this[sizeFunc]();
    if (inArray(alignment, [LEFT, TOP])) {
      this[c1] = targetBox[c1];
      this[c2] = this[c1] + size;
    } else if (inArray(alignment, [RIGHT, BOTTOM])) {
      this[c2] = targetBox[c2];
      this[c1] = this[c2] - size;
    } else if (alignment === CENTER) {
      this[c1] = targetBox[c1] + (targetBox[sizeFunc]() - size) / 2;
      this[c2] = this[c1] + size;
    }
  };
  return Box2;
}(class_default);
function rotatePoint(x, y, cx, cy, angle) {
  var theta = rad2(angle);
  return new point_default2(
    cx + (x - cx) * Math.cos(theta) + (y - cy) * Math.sin(theta),
    cy - (x - cx) * Math.sin(theta) + (y - cy) * Math.cos(theta)
  );
}
var box_default = Box;

// node_modules/@progress/kendo-charts/dist/es/core/ring.js
var Ring = function(Class3) {
  function Ring2(center, innerRadius, radius, startAngle, angle) {
    Class3.call(this);
    this.center = center;
    this.innerRadius = innerRadius;
    this.radius = radius;
    this.startAngle = startAngle;
    this.angle = angle;
  }
  if (Class3)
    Ring2.__proto__ = Class3;
  Ring2.prototype = Object.create(Class3 && Class3.prototype);
  Ring2.prototype.constructor = Ring2;
  Ring2.prototype.clone = function clone2() {
    return new Ring2(this.center, this.innerRadius, this.radius, this.startAngle, this.angle);
  };
  Ring2.prototype.middle = function middle() {
    return this.startAngle + this.angle / 2;
  };
  Ring2.prototype.setRadius = function setRadius(newRadius, innerRadius) {
    if (innerRadius) {
      this.innerRadius = newRadius;
    } else {
      this.radius = newRadius;
    }
    return this;
  };
  Ring2.prototype.point = function point2(angle, innerRadius) {
    var radianAngle = rad2(angle);
    var ax = Math.cos(radianAngle);
    var ay = Math.sin(radianAngle);
    var radius = innerRadius ? this.innerRadius : this.radius;
    var x = round3(this.center.x - ax * radius, COORD_PRECISION);
    var y = round3(this.center.y - ay * radius, COORD_PRECISION);
    return new point_default2(x, y);
  };
  Ring2.prototype.adjacentBox = function adjacentBox(distance, width, height) {
    var sector = this.clone().expand(distance);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    var hw = width / 2;
    var hh = height / 2;
    var sa = Math.sin(rad2(midAndle));
    var ca = Math.cos(rad2(midAndle));
    var x = midPoint.x - hw;
    var y = midPoint.y - hh;
    if (Math.abs(sa) < 0.9) {
      x += hw * -ca / Math.abs(ca);
    }
    if (Math.abs(ca) < 0.9) {
      y += hh * -sa / Math.abs(sa);
    }
    return new box_default(x, y, x + width, y + height);
  };
  Ring2.prototype.containsPoint = function containsPoint(p2) {
    var center = this.center;
    var innerRadius = this.innerRadius;
    var radius = this.radius;
    var startAngle = this.startAngle;
    var endAngle = this.startAngle + this.angle;
    var dx = p2.x - center.x;
    var dy = p2.y - center.y;
    var vector = new point_default2(dx, dy);
    var startPoint = this.point(startAngle);
    var startVector = new point_default2(startPoint.x - center.x, startPoint.y - center.y);
    var endPoint = this.point(endAngle);
    var endVector = new point_default2(endPoint.x - center.x, endPoint.y - center.y);
    var dist = round3(dx * dx + dy * dy, COORD_PRECISION);
    return (startVector.equals(vector) || clockwise(startVector, vector)) && !clockwise(endVector, vector) && dist >= innerRadius * innerRadius && dist <= radius * radius;
  };
  Ring2.prototype.getBBox = function getBBox() {
    var this$1 = this;
    var box = new box_default(MAX_VALUE, MAX_VALUE, MIN_VALUE, MIN_VALUE);
    var startAngle = round3(this.startAngle % 360);
    var endAngle = round3((startAngle + this.angle) % 360);
    var innerRadius = this.innerRadius;
    var allAngles = [0, 90, 180, 270, startAngle, endAngle].sort(numericComparer);
    var startAngleIndex = allAngles.indexOf(startAngle);
    var endAngleIndex = allAngles.indexOf(endAngle);
    var angles;
    if (startAngle === endAngle) {
      angles = allAngles;
    } else {
      if (startAngleIndex < endAngleIndex) {
        angles = allAngles.slice(startAngleIndex, endAngleIndex + 1);
      } else {
        angles = [].concat(
          allAngles.slice(0, endAngleIndex + 1),
          allAngles.slice(startAngleIndex, allAngles.length)
        );
      }
    }
    for (var i = 0; i < angles.length; i++) {
      var point2 = this$1.point(angles[i]);
      box.wrapPoint(point2);
      box.wrapPoint(point2, innerRadius);
    }
    if (!innerRadius) {
      box.wrapPoint(this.center);
    }
    return box;
  };
  Ring2.prototype.expand = function expand(value) {
    this.radius += value;
    return this;
  };
  return Ring2;
}(class_default);
function numericComparer(a, b) {
  return a - b;
}
var ring_default = Ring;

// node_modules/@progress/kendo-charts/dist/es/core/sector.js
var Sector = function(Ring2) {
  function Sector2(center, radius, startAngle, angle) {
    Ring2.call(this, center, 0, radius, startAngle, angle);
  }
  if (Ring2)
    Sector2.__proto__ = Ring2;
  Sector2.prototype = Object.create(Ring2 && Ring2.prototype);
  Sector2.prototype.constructor = Sector2;
  Sector2.prototype.expand = function expand(value) {
    return Ring2.prototype.expand.call(this, value);
  };
  Sector2.prototype.clone = function clone2() {
    return new Sector2(this.center, this.radius, this.startAngle, this.angle);
  };
  Sector2.prototype.setRadius = function setRadius(newRadius) {
    this.radius = newRadius;
    return this;
  };
  return Sector2;
}(ring_default);

// node_modules/@progress/kendo-charts/dist/es/core/shape-builder.js
var DIRECTION_ANGLE = 1e-3;
var ShapeBuilder = function(Class3) {
  function ShapeBuilder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    ShapeBuilder2.__proto__ = Class3;
  ShapeBuilder2.prototype = Object.create(Class3 && Class3.prototype);
  ShapeBuilder2.prototype.constructor = ShapeBuilder2;
  ShapeBuilder2.prototype.createRing = function createRing(sector, options2) {
    var startAngle = sector.startAngle + 180;
    var endAngle = sector.angle + startAngle;
    if (sector.angle > 0 && startAngle === endAngle) {
      endAngle += DIRECTION_ANGLE;
    }
    var center = new geometry_exports.Point(sector.center.x, sector.center.y);
    var radius = Math.max(sector.radius, 0);
    var innerRadius = Math.max(sector.innerRadius, 0);
    var arc = new geometry_exports.Arc(center, {
      startAngle,
      endAngle,
      radiusX: radius,
      radiusY: radius
    });
    var path = drawing_exports.Path.fromArc(arc, options2).close();
    if (innerRadius) {
      arc.radiusX = arc.radiusY = innerRadius;
      var innerEnd = arc.pointAt(endAngle);
      path.lineTo(innerEnd.x, innerEnd.y);
      path.arc(endAngle, startAngle, innerRadius, innerRadius, true);
    } else {
      path.lineTo(center.x, center.y);
    }
    return path;
  };
  return ShapeBuilder2;
}(class_default);
ShapeBuilder.current = new ShapeBuilder();
var shape_builder_default = ShapeBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/chart-element.js
var ChartElement = function(Class3) {
  function ChartElement2(options2) {
    Class3.call(this);
    this.children = [];
    this.options = deepExtend({}, this.options, this.initUserOptions(options2));
  }
  if (Class3)
    ChartElement2.__proto__ = Class3;
  ChartElement2.prototype = Object.create(Class3 && Class3.prototype);
  ChartElement2.prototype.constructor = ChartElement2;
  ChartElement2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  ChartElement2.prototype.reflow = function reflow(targetBox) {
    var children = this.children;
    var box;
    for (var i = 0; i < children.length; i++) {
      var currentChild = children[i];
      currentChild.reflow(targetBox);
      box = box ? box.wrap(currentChild.box) : currentChild.box.clone();
    }
    this.box = box || targetBox;
  };
  ChartElement2.prototype.destroy = function destroy2() {
    var children = this.children;
    if (this.animation) {
      this.animation.destroy();
    }
    for (var i = 0; i < children.length; i++) {
      children[i].destroy();
    }
  };
  ChartElement2.prototype.getRoot = function getRoot() {
    var parent = this.parent;
    return parent ? parent.getRoot() : null;
  };
  ChartElement2.prototype.getSender = function getSender() {
    var service = this.getService();
    if (service) {
      return service.sender;
    }
  };
  ChartElement2.prototype.getService = function getService() {
    var element = this;
    while (element) {
      if (element.chartService) {
        return element.chartService;
      }
      element = element.parent;
    }
  };
  ChartElement2.prototype.translateChildren = function translateChildren(dx, dy) {
    var children = this.children;
    var childrenCount = children.length;
    for (var i = 0; i < childrenCount; i++) {
      children[i].box.translate(dx, dy);
    }
  };
  ChartElement2.prototype.append = function append3() {
    var arguments$1 = arguments;
    var this$1 = this;
    for (var i = 0; i < arguments.length; i++) {
      var item = arguments$1[i];
      this$1.children.push(item);
      item.parent = this$1;
    }
  };
  ChartElement2.prototype.renderVisual = function renderVisual() {
    if (this.options.visible === false) {
      return;
    }
    this.createVisual();
    this.addVisual();
    this.renderChildren();
    this.createAnimation();
    this.renderComplete();
  };
  ChartElement2.prototype.addVisual = function addVisual() {
    if (this.visual) {
      this.visual.chartElement = this;
      if (this.parent) {
        this.parent.appendVisual(this.visual);
      }
    }
  };
  ChartElement2.prototype.renderChildren = function renderChildren() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      children[i].renderVisual();
    }
  };
  ChartElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: this.options.zIndex,
      visible: valueOrDefault2(this.options.visible, true)
    });
  };
  ChartElement2.prototype.createAnimation = function createAnimation() {
    if (this.visual && this.options.animation) {
      this.animation = drawing_exports.Animation.create(
        this.visual,
        this.options.animation
      );
    }
  };
  ChartElement2.prototype.appendVisual = function appendVisual(childVisual) {
    if (!childVisual.chartElement) {
      childVisual.chartElement = this;
    }
    if (childVisual.options.noclip) {
      this.clipRoot().visual.append(childVisual);
    } else if (defined2(childVisual.options.zIndex)) {
      this.stackRoot().stackVisual(childVisual);
    } else if (this.isStackRoot) {
      this.stackVisual(childVisual);
    } else if (this.visual) {
      this.visual.append(childVisual);
    } else {
      this.parent.appendVisual(childVisual);
    }
  };
  ChartElement2.prototype.clipRoot = function clipRoot() {
    if (this.parent) {
      return this.parent.clipRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackRoot = function stackRoot() {
    if (this.parent) {
      return this.parent.stackRoot();
    }
    return this;
  };
  ChartElement2.prototype.stackVisual = function stackVisual(childVisual) {
    var zIndex = childVisual.options.zIndex || 0;
    var visuals = this.visual.children;
    var length = visuals.length;
    var pos;
    for (pos = 0; pos < length; pos++) {
      var sibling = visuals[pos];
      var here = valueOrDefault2(sibling.options.zIndex, 0);
      if (here > zIndex) {
        break;
      }
    }
    this.visual.insert(pos, childVisual);
  };
  ChartElement2.prototype.traverse = function traverse(callback) {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      var child = children[i];
      callback(child);
      if (child.traverse) {
        child.traverse(callback);
      }
    }
  };
  ChartElement2.prototype.closest = function closest2(match) {
    var element = this;
    var matched = false;
    while (element && !matched) {
      matched = match(element);
      if (!matched) {
        element = element.parent;
      }
    }
    if (matched) {
      return element;
    }
  };
  ChartElement2.prototype.renderComplete = function renderComplete() {
  };
  ChartElement2.prototype.hasHighlight = function hasHighlight() {
    var options2 = (this.options || {}).highlight;
    return !(!this.createHighlight || options2 && options2.visible === false);
  };
  ChartElement2.prototype.toggleHighlight = function toggleHighlight(show2, opacity) {
    var this$1 = this;
    var options2 = (this.options || {}).highlight || {};
    var customVisual = options2.visual;
    var highlight = this._highlight;
    if (!highlight) {
      var highlightOptions = {
        fill: {
          color: WHITE,
          opacity: opacity || 0.2
        },
        stroke: {
          color: WHITE,
          width: 1,
          opacity: opacity || 0.2
        }
      };
      if (customVisual) {
        highlight = this._highlight = customVisual(
          Object.assign(
            this.highlightVisualArgs(),
            {
              createVisual: function() {
                return this$1.createHighlight(highlightOptions);
              },
              sender: this.getSender(),
              series: this.series,
              dataItem: this.dataItem,
              category: this.category,
              value: this.value,
              percentage: this.percentage,
              runningTotal: this.runningTotal,
              total: this.total
            }
          )
        );
        if (!highlight) {
          return;
        }
      } else {
        highlight = this._highlight = this.createHighlight(highlightOptions);
      }
      if (!defined2(highlight.options.zIndex)) {
        highlight.options.zIndex = valueOrDefault2(options2.zIndex, this.options.zIndex);
      }
      this.appendVisual(highlight);
    }
    highlight.visible(show2);
  };
  ChartElement2.prototype.createGradientOverlay = function createGradientOverlay(element, options2, gradientOptions) {
    var overlay = new drawing_exports.Path(Object.assign({
      stroke: {
        color: "none"
      },
      fill: this.createGradient(gradientOptions),
      closed: element.options.closed
    }, options2));
    overlay.segments.elements(element.segments.elements());
    return overlay;
  };
  ChartElement2.prototype.createGradient = function createGradient(options2) {
    if (this.parent) {
      return this.parent.createGradient(options2);
    }
  };
  ChartElement2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return true;
  };
  return ChartElement2;
}(class_default);
ChartElement.prototype.options = {};
var chart_element_default = ChartElement;

// node_modules/@progress/kendo-charts/dist/es/core/box-element.js
var BoxElement = function(ChartElement2) {
  function BoxElement2(options2) {
    ChartElement2.call(this, options2);
    this.options.margin = getSpacing(this.options.margin);
    this.options.padding = getSpacing(this.options.padding);
  }
  if (ChartElement2)
    BoxElement2.__proto__ = ChartElement2;
  BoxElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BoxElement2.prototype.constructor = BoxElement2;
  BoxElement2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options2 = this.options;
    var width = options2.width;
    var height = options2.height;
    var shrinkToFit = options2.shrinkToFit;
    var hasSetSize = width && height;
    var margin = options2.margin;
    var padding = options2.padding;
    var borderWidth = options2.border.width;
    var box;
    var reflowPaddingBox = function() {
      this$1.align(targetBox, X, options2.align);
      this$1.align(targetBox, Y, options2.vAlign);
      this$1.paddingBox = box.clone().unpad(margin).unpad(borderWidth);
    };
    var contentBox = targetBox.clone();
    if (hasSetSize) {
      contentBox.x2 = contentBox.x1 + width;
      contentBox.y2 = contentBox.y1 + height;
    }
    if (shrinkToFit) {
      contentBox.unpad(margin).unpad(borderWidth).unpad(padding);
    }
    ChartElement2.prototype.reflow.call(this, contentBox);
    if (hasSetSize) {
      box = this.box = new box_default(0, 0, width, height);
    } else {
      box = this.box;
    }
    if (shrinkToFit && hasSetSize) {
      reflowPaddingBox();
      contentBox = this.contentBox = this.paddingBox.clone().unpad(padding);
    } else {
      contentBox = this.contentBox = box.clone();
      box.pad(padding).pad(borderWidth).pad(margin);
      reflowPaddingBox();
    }
    this.translateChildren(
      box.x1 - contentBox.x1 + margin.left + borderWidth + padding.left,
      box.y1 - contentBox.y1 + margin.top + borderWidth + padding.top
    );
    var children = this.children;
    for (var i = 0; i < children.length; i++) {
      var item = children[i];
      item.reflow(item.box);
    }
  };
  BoxElement2.prototype.align = function align2(targetBox, axis, alignment) {
    this.box.align(targetBox, axis, alignment);
  };
  BoxElement2.prototype.hasBox = function hasBox() {
    var options2 = this.options;
    return options2.border.width || options2.background;
  };
  BoxElement2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    if (options2.visible && this.hasBox()) {
      this.visual.append(drawing_exports.Path.fromRect(
        this.paddingBox.toRect(),
        this.visualStyle()
      ));
    }
  };
  BoxElement2.prototype.visualStyle = function visualStyle() {
    var options2 = this.options;
    var border = options2.border || {};
    return {
      stroke: {
        width: border.width,
        color: border.color,
        opacity: valueOrDefault2(border.opacity, options2.opacity),
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      cursor: options2.cursor
    };
  };
  return BoxElement2;
}(chart_element_default);
setDefaultOptions(BoxElement, {
  align: LEFT,
  vAlign: TOP,
  margin: {},
  padding: {},
  border: {
    color: BLACK,
    width: 0
  },
  background: "",
  shrinkToFit: false,
  width: 0,
  height: 0,
  visible: true
});
var box_element_default = BoxElement;

// node_modules/@progress/kendo-charts/dist/es/core/shape-element.js
var ShapeElement = function(BoxElement2) {
  function ShapeElement2(options2, pointData) {
    BoxElement2.call(this, options2);
    this.pointData = pointData;
  }
  if (BoxElement2)
    ShapeElement2.__proto__ = BoxElement2;
  ShapeElement2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  ShapeElement2.prototype.constructor = ShapeElement2;
  ShapeElement2.prototype.getElement = function getElement() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.paddingBox;
    var type = options2.type;
    var rotation = options2.rotation;
    var center = box.center();
    var halfWidth = box.width() / 2;
    var halfHeight = box.height() / 2;
    if (!options2.visible || !this.hasBox()) {
      return null;
    }
    var style = this.visualStyle();
    var element;
    if (type === CIRCLE) {
      element = new drawing_exports.Circle(
        new geometry_exports.Circle([
          round3(box.x1 + halfWidth, COORD_PRECISION),
          round3(box.y1 + halfHeight, COORD_PRECISION)
        ], Math.min(halfWidth, halfHeight)),
        style
      );
    } else if (type === TRIANGLE) {
      element = drawing_exports.Path.fromPoints([
        [box.x1 + halfWidth, box.y1],
        [box.x1, box.y2],
        [box.x2, box.y2]
      ], style).close();
    } else if (type === CROSS) {
      element = new drawing_exports.MultiPath(style);
      element.moveTo(box.x1, box.y1).lineTo(box.x2, box.y2);
      element.moveTo(box.x1, box.y2).lineTo(box.x2, box.y1);
    } else {
      var rect = box.toRect();
      if (type === ROUNDED_RECT) {
        var borderRadius = valueOrDefault2(options2.borderRadius, rect.width() / 5);
        rect.setCornerRadius(borderRadius);
      }
      element = drawing_exports.Path.fromRect(rect, style);
    }
    if (rotation) {
      element.transform(
        geometry_exports.transform().rotate(-rotation, [center.x, center.y])
      );
    }
    element.options.zIndex = options2.zIndex;
    return element;
  };
  ShapeElement2.prototype.createElement = function createElement15() {
    var this$1 = this;
    var customVisual = this.options.visual;
    var pointData = this.pointData || {};
    var visual;
    if (customVisual) {
      visual = customVisual({
        value: pointData.value,
        dataItem: pointData.dataItem,
        sender: this.getSender(),
        series: pointData.series,
        category: pointData.category,
        rect: this.paddingBox.toRect(),
        options: this.visualOptions(),
        createVisual: function() {
          return this$1.getElement();
        }
      });
    } else {
      visual = this.getElement();
    }
    return visual;
  };
  ShapeElement2.prototype.visualOptions = function visualOptions() {
    var options2 = this.options;
    return {
      background: options2.background,
      border: options2.border,
      margin: options2.margin,
      padding: options2.padding,
      type: options2.type,
      size: options2.width,
      visible: options2.visible
    };
  };
  ShapeElement2.prototype.createVisual = function createVisual() {
    this.visual = this.createElement();
  };
  return ShapeElement2;
}(box_element_default);
setDefaultOptions(ShapeElement, {
  type: CIRCLE,
  align: CENTER,
  vAlign: CENTER
});
var shape_element_default = ShapeElement;

// node_modules/@progress/kendo-charts/dist/es/core/gradients.js
var LINEAR = "linear";
var RADIAL = "radial";
var GRADIENTS = {
  glass: {
    type: LINEAR,
    rotation: 0,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.25,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 1,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpBevel: {
    type: RADIAL,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.55
    }, {
      offset: 0.65,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0.25
    }]
  },
  roundedBevel: {
    type: RADIAL,
    stops: [{
      offset: 0.33,
      color: WHITE,
      opacity: 0.06
    }, {
      offset: 0.83,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.95,
      color: WHITE,
      opacity: 0
    }]
  },
  roundedGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0
    }, {
      offset: 0.5,
      color: WHITE,
      opacity: 0.3
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  sharpGlass: {
    type: RADIAL,
    supportVML: false,
    stops: [{
      offset: 0,
      color: WHITE,
      opacity: 0.2
    }, {
      offset: 0.15,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.17,
      color: WHITE,
      opacity: 0.35
    }, {
      offset: 0.85,
      color: WHITE,
      opacity: 0.05
    }, {
      offset: 0.87,
      color: WHITE,
      opacity: 0.15
    }, {
      offset: 0.99,
      color: WHITE,
      opacity: 0
    }]
  },
  bubbleShadow: {
    type: RADIAL,
    center: [0.5, 0.5],
    radius: 0.5
  }
};
var gradients_default = GRADIENTS;

// node_modules/@progress/kendo-charts/dist/es/core/utils/box-diff.js
function boxDiff(r, s) {
  if (r.x1 === s.x1 && r.y1 === s.y1 && r.x2 === s.x2 && r.y2 === s.y2) {
    return s;
  }
  var a = Math.min(r.x1, s.x1);
  var b = Math.max(r.x1, s.x1);
  var c = Math.min(r.x2, s.x2);
  var d = Math.max(r.x2, s.x2);
  var e = Math.min(r.y1, s.y1);
  var f = Math.max(r.y1, s.y1);
  var g = Math.min(r.y2, s.y2);
  var h = Math.max(r.y2, s.y2);
  var boxes = [];
  boxes[0] = new box_default(b, e, c, f);
  boxes[1] = new box_default(a, f, b, g);
  boxes[2] = new box_default(c, f, d, g);
  boxes[3] = new box_default(b, g, c, h);
  if (r.x1 === a && r.y1 === e || s.x1 === a && s.y1 === e) {
    boxes[4] = new box_default(a, e, b, f);
    boxes[5] = new box_default(c, g, d, h);
  } else {
    boxes[4] = new box_default(c, e, d, f);
    boxes[5] = new box_default(a, g, b, h);
  }
  return grep(boxes, function(box) {
    return box.height() > 0 && box.width() > 0;
  })[0];
}

// node_modules/@progress/kendo-charts/dist/es/core/root-element.js
var RootElement = function(ChartElement2) {
  function RootElement2(options2) {
    ChartElement2.call(this, options2);
    var rootOptions = this.options;
    rootOptions.width = parseInt(rootOptions.width, 10);
    rootOptions.height = parseInt(rootOptions.height, 10);
    this.gradients = {};
  }
  if (ChartElement2)
    RootElement2.__proto__ = ChartElement2;
  RootElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RootElement2.prototype.constructor = RootElement2;
  RootElement2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var currentBox = new box_default(0, 0, options2.width, options2.height);
    this.box = currentBox.unpad(options2.margin);
    for (var i = 0; i < children.length; i++) {
      children[i].reflow(currentBox);
      currentBox = boxDiff(currentBox, children[i].box) || new box_default();
    }
  };
  RootElement2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group();
    this.createBackground();
  };
  RootElement2.prototype.createBackground = function createBackground() {
    var options2 = this.options;
    var border = options2.border || {};
    var box = this.box.clone().pad(options2.margin).unpad(border.width);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      fill: {
        color: options2.background,
        opacity: options2.opacity
      },
      zIndex: -10
    });
    this.visual.append(background);
  };
  RootElement2.prototype.getRoot = function getRoot() {
    return this;
  };
  RootElement2.prototype.createGradient = function createGradient(options2) {
    var gradients = this.gradients;
    var hashCode = objectKey2(options2);
    var gradient = gradients_default[options2.gradient];
    var drawingGradient;
    if (gradients[hashCode]) {
      drawingGradient = gradients[hashCode];
    } else {
      var gradientOptions = Object.assign({}, gradient, options2);
      if (gradient.type === "linear") {
        drawingGradient = new drawing_exports.LinearGradient(gradientOptions);
      } else {
        if (options2.innerRadius) {
          gradientOptions.stops = innerRadialStops(gradientOptions);
        }
        drawingGradient = new drawing_exports.RadialGradient(gradientOptions);
        drawingGradient.supportVML = gradient.supportVML !== false;
      }
      gradients[hashCode] = drawingGradient;
    }
    return drawingGradient;
  };
  RootElement2.prototype.cleanGradients = function cleanGradients() {
    var gradients = this.gradients;
    for (var hashCode in gradients) {
      gradients[hashCode]._observers = [];
    }
  };
  RootElement2.prototype.size = function size() {
    var options2 = this.options;
    return new box_default(0, 0, options2.width, options2.height);
  };
  return RootElement2;
}(chart_element_default);
setDefaultOptions(RootElement, {
  width: DEFAULT_WIDTH,
  height: DEFAULT_HEIGHT,
  background: WHITE,
  border: {
    color: BLACK,
    width: 0
  },
  margin: getSpacing(5),
  zIndex: -2
});
function innerRadialStops(options2) {
  var stops = options2.stops;
  var usedSpace = options2.innerRadius / options2.radius * 100;
  var length = stops.length;
  var currentStops = [];
  for (var i = 0; i < length; i++) {
    var currentStop = Object.assign({}, stops[i]);
    currentStop.offset = (currentStop.offset * (100 - usedSpace) + usedSpace) / 100;
    currentStops.push(currentStop);
  }
  return currentStops;
}
var root_element_default = RootElement;

// node_modules/@progress/kendo-charts/dist/es/core/float-element.js
var FloatElement = function(ChartElement2) {
  function FloatElement2(options2) {
    ChartElement2.call(this, options2);
    this._initDirection();
  }
  if (ChartElement2)
    FloatElement2.__proto__ = ChartElement2;
  FloatElement2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FloatElement2.prototype.constructor = FloatElement2;
  FloatElement2.prototype._initDirection = function _initDirection() {
    var options2 = this.options;
    if (options2.vertical) {
      this.groupAxis = X;
      this.elementAxis = Y;
      this.groupSizeField = WIDTH;
      this.elementSizeField = HEIGHT;
      this.groupSpacing = options2.spacing;
      this.elementSpacing = options2.vSpacing;
    } else {
      this.groupAxis = Y;
      this.elementAxis = X;
      this.groupSizeField = HEIGHT;
      this.elementSizeField = WIDTH;
      this.groupSpacing = options2.vSpacing;
      this.elementSpacing = options2.spacing;
    }
  };
  FloatElement2.prototype.reflow = function reflow(targetBox) {
    this.box = targetBox.clone();
    this.reflowChildren();
  };
  FloatElement2.prototype.reflowChildren = function reflowChildren() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var elementAxis = ref2.elementAxis;
    var groupAxis = ref2.groupAxis;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var ref$1 = this.groupOptions();
    var groups = ref$1.groups;
    var groupsSize = ref$1.groupsSize;
    var maxGroupElementsSize = ref$1.maxGroupElementsSize;
    var groupsCount = groups.length;
    var groupsStart = box[groupAxis + 1] + this.alignStart(groupsSize, box[groupSizeField]());
    if (groupsCount) {
      var groupStart = groupsStart;
      for (var groupIdx = 0; groupIdx < groupsCount; groupIdx++) {
        var group = groups[groupIdx];
        var groupElements = group.groupElements;
        var elementStart = box[elementAxis + 1];
        var groupElementsCount = groupElements.length;
        for (var idx = 0; idx < groupElementsCount; idx++) {
          var element = groupElements[idx];
          var elementSize3 = this$1.elementSize(element);
          var groupElementStart = groupStart + this$1.alignStart(elementSize3[groupSizeField], group.groupSize);
          var elementBox = new box_default();
          elementBox[groupAxis + 1] = groupElementStart;
          elementBox[groupAxis + 2] = groupElementStart + elementSize3[groupSizeField];
          elementBox[elementAxis + 1] = elementStart;
          elementBox[elementAxis + 2] = elementStart + elementSize3[elementSizeField];
          element.reflow(elementBox);
          elementStart += elementSize3[elementSizeField] + this$1.elementSpacing;
        }
        groupStart += group.groupSize + this$1.groupSpacing;
      }
      box[groupAxis + 1] = groupsStart;
      box[groupAxis + 2] = groupsStart + groupsSize;
      box[elementAxis + 2] = box[elementAxis + 1] + maxGroupElementsSize;
    }
  };
  FloatElement2.prototype.alignStart = function alignStart2(size, maxSize) {
    var start = 0;
    var align2 = this.options.align;
    if (align2 === RIGHT || align2 === BOTTOM) {
      start = maxSize - size;
    } else if (align2 === CENTER) {
      start = (maxSize - size) / 2;
    }
    return start;
  };
  FloatElement2.prototype.groupOptions = function groupOptions() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var children = ref2.children;
    var elementSizeField = ref2.elementSizeField;
    var groupSizeField = ref2.groupSizeField;
    var elementSpacing = ref2.elementSpacing;
    var groupSpacing = ref2.groupSpacing;
    var maxSize = round3(box[elementSizeField]());
    var childrenCount = children.length;
    var groups = [];
    var groupSize = 0;
    var groupElementsSize = 0;
    var groupsSize = 0;
    var maxGroupElementsSize = 0;
    var groupElements = [];
    for (var idx = 0; idx < childrenCount; idx++) {
      var element = children[idx];
      if (!element.box) {
        element.reflow(box);
      }
      var elementSize3 = this$1.elementSize(element);
      if (this$1.options.wrap && round3(groupElementsSize + elementSpacing + elementSize3[elementSizeField]) > maxSize) {
        groups.push({
          groupElements,
          groupSize,
          groupElementsSize
        });
        maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
        groupsSize += groupSpacing + groupSize;
        groupSize = 0;
        groupElementsSize = 0;
        groupElements = [];
      }
      groupSize = Math.max(groupSize, elementSize3[groupSizeField]);
      if (groupElementsSize > 0) {
        groupElementsSize += elementSpacing;
      }
      groupElementsSize += elementSize3[elementSizeField];
      groupElements.push(element);
    }
    groups.push({
      groupElements,
      groupSize,
      groupElementsSize
    });
    maxGroupElementsSize = Math.max(maxGroupElementsSize, groupElementsSize);
    groupsSize += groupSize;
    return {
      groups,
      groupsSize,
      maxGroupElementsSize
    };
  };
  FloatElement2.prototype.elementSize = function elementSize3(element) {
    return {
      width: element.box.width(),
      height: element.box.height()
    };
  };
  FloatElement2.prototype.createVisual = function createVisual() {
  };
  return FloatElement2;
}(chart_element_default);
setDefaultOptions(FloatElement, {
  vertical: true,
  wrap: true,
  vSpacing: 0,
  spacing: 0
});
var float_element_default = FloatElement;

// node_modules/@progress/kendo-charts/dist/es/core/text.js
var DrawingText = drawing_exports.Text;
var Text2 = function(ChartElement2) {
  function Text4(content, options2) {
    ChartElement2.call(this, options2);
    this.content = content;
    this.reflow(new box_default());
  }
  if (ChartElement2)
    Text4.__proto__ = ChartElement2;
  Text4.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Text4.prototype.constructor = Text4;
  Text4.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var size = options2.size = drawing_exports.util.measureText(this.content, { font: options2.font });
    this.baseline = size.baseline;
    this.box = new box_default(
      targetBox.x1,
      targetBox.y1,
      targetBox.x1 + size.width,
      targetBox.y1 + size.height
    );
  };
  Text4.prototype.createVisual = function createVisual() {
    var ref2 = this.options;
    var font = ref2.font;
    var color = ref2.color;
    var opacity = ref2.opacity;
    var cursor = ref2.cursor;
    this.visual = new DrawingText(this.content, this.box.toRect().topLeft(), {
      font,
      fill: { color, opacity },
      cursor
    });
  };
  return Text4;
}(chart_element_default);
setDefaultOptions(Text2, {
  font: DEFAULT_FONT,
  color: BLACK
});
var text_default2 = Text2;

// node_modules/@progress/kendo-charts/dist/es/core/utils/rect-to-box.js
function rectToBox(rect) {
  var origin = rect.origin;
  var bottomRight = rect.bottomRight();
  return new box_default(origin.x, origin.y, bottomRight.x, bottomRight.y);
}

// node_modules/@progress/kendo-charts/dist/es/core/text-box.js
var ROWS_SPLIT_REGEX = /\n/m;
var TextBox = function(BoxElement2) {
  function TextBox2(content, options2, data) {
    BoxElement2.call(this, options2);
    this.content = content;
    this.data = data;
    this._initContainer();
    if (this.options._autoReflow !== false) {
      this.reflow(new box_default());
    }
  }
  if (BoxElement2)
    TextBox2.__proto__ = BoxElement2;
  TextBox2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  TextBox2.prototype.constructor = TextBox2;
  TextBox2.prototype._initContainer = function _initContainer() {
    var options2 = this.options;
    var rows = String(this.content).split(ROWS_SPLIT_REGEX);
    var floatElement = new float_element_default({ vertical: true, align: options2.align, wrap: false });
    var textOptions = deepExtend({}, options2, { opacity: 1, animation: null });
    this.container = floatElement;
    this.append(floatElement);
    for (var rowIdx = 0; rowIdx < rows.length; rowIdx++) {
      var text = new text_default2(rows[rowIdx].trim(), textOptions);
      floatElement.append(text);
    }
  };
  TextBox2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var visualFn = options2.visual;
    this.container.options.align = options2.align;
    if (visualFn && !this._boxReflow) {
      var visualBox = targetBox;
      if (!visualBox.hasSize()) {
        this._boxReflow = true;
        this.reflow(visualBox);
        this._boxReflow = false;
        visualBox = this.box;
      }
      var visual = this.visual = visualFn(this.visualContext(visualBox));
      if (visual) {
        visualBox = rectToBox(visual.clippedBBox() || new geometry_exports.Rect());
        visual.options.zIndex = options2.zIndex;
      }
      this.box = this.contentBox = this.paddingBox = visualBox;
    } else {
      BoxElement2.prototype.reflow.call(this, targetBox);
      if (options2.rotation) {
        var margin = getSpacing(options2.margin);
        var box = this.box.unpad(margin);
        this.targetBox = targetBox;
        this.normalBox = box.clone();
        box = this.rotate();
        box.translate(margin.left - margin.right, margin.top - margin.bottom);
        this.rotatedBox = box.clone();
        box.pad(margin);
      }
    }
  };
  TextBox2.prototype.createVisual = function createVisual() {
    var options2 = this.options;
    this.visual = new drawing_exports.Group({
      transform: this.rotationTransform(),
      zIndex: options2.zIndex,
      noclip: options2.noclip
    });
    if (this.hasBox()) {
      var box = drawing_exports.Path.fromRect(this.paddingBox.toRect(), this.visualStyle());
      this.visual.append(box);
    }
  };
  TextBox2.prototype.renderVisual = function renderVisual() {
    if (!this.options.visible) {
      return;
    }
    if (this.options.visual) {
      var visual = this.visual;
      if (visual && !defined2(visual.options.noclip)) {
        visual.options.noclip = this.options.noclip;
      }
      this.addVisual();
      this.createAnimation();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  TextBox2.prototype.visualContext = function visualContext(targetBox) {
    var this$1 = this;
    var context2 = {
      text: this.content,
      rect: targetBox.toRect(),
      sender: this.getSender(),
      options: this.options,
      createVisual: function() {
        this$1._boxReflow = true;
        this$1.reflow(targetBox);
        this$1._boxReflow = false;
        return this$1.getDefaultVisual();
      }
    };
    if (this.data) {
      Object.assign(context2, this.data);
    }
    return context2;
  };
  TextBox2.prototype.getDefaultVisual = function getDefaultVisual() {
    this.createVisual();
    this.renderChildren();
    var visual = this.visual;
    delete this.visual;
    return visual;
  };
  TextBox2.prototype.rotate = function rotate() {
    var options2 = this.options;
    this.box.rotate(options2.rotation);
    this.align(this.targetBox, X, options2.align);
    this.align(this.targetBox, Y, options2.vAlign);
    return this.box;
  };
  TextBox2.prototype.rotationTransform = function rotationTransform() {
    var rotation = this.options.rotation;
    if (!rotation) {
      return null;
    }
    var ref2 = this.normalBox.center();
    var cx = ref2.x;
    var cy = ref2.y;
    var boxCenter = this.rotatedBox.center();
    return geometry_exports.transform().translate(boxCenter.x - cx, boxCenter.y - cy).rotate(rotation, [cx, cy]);
  };
  return TextBox2;
}(box_element_default);
var text_box_default = TextBox;

// node_modules/@progress/kendo-charts/dist/es/core/title.js
var Title = function(ChartElement2) {
  function Title2(options2) {
    ChartElement2.call(this, options2);
    this._textBox = new text_box_default(this.options.text, Object.assign({}, this.options, {
      vAlign: this.options.position
    }));
    this.append(this._textBox);
  }
  if (ChartElement2)
    Title2.__proto__ = ChartElement2;
  Title2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Title2.prototype.constructor = Title2;
  Title2.prototype.reflow = function reflow(targetBox) {
    ChartElement2.prototype.reflow.call(this, targetBox);
    this.box.snapTo(targetBox, X);
  };
  Title2.buildTitle = function buildTitle(options2, defaultOptions) {
    var titleOptions = options2;
    if (typeof options2 === "string") {
      titleOptions = { text: options2 };
    }
    titleOptions = Object.assign({ visible: true }, defaultOptions, titleOptions);
    var title2;
    if (titleOptions && titleOptions.visible && titleOptions.text) {
      title2 = new Title2(titleOptions);
    }
    return title2;
  };
  Title2.orderTitles = function orderTitles(titles) {
    var items = [].concat(titles);
    var top = items.filter(function(item) {
      return item && item.options.position !== BOTTOM;
    });
    var bottom = items.filter(function(item) {
      return item && item.options.position === BOTTOM;
    });
    collapseVerticalMargins(top);
    collapseVerticalMargins(bottom);
    bottom.reverse();
    return top.concat(bottom);
  };
  return Title2;
}(chart_element_default);
function collapseVerticalMargins(items) {
  for (var i = 1; i < items.length; i++) {
    var box = items[i]._textBox;
    var prevBox = items[i - 1]._textBox;
    prevBox.options.margin = Object.assign(getSpacing(prevBox.options.margin), { bottom: 0 });
    box.options.margin = Object.assign(getSpacing(box.options.margin), { top: 0 });
  }
}
setDefaultOptions(Title, {
  color: BLACK,
  position: TOP,
  align: CENTER,
  margin: getSpacing(5),
  padding: getSpacing(5)
});
var title_default = Title;

// node_modules/@progress/kendo-charts/dist/es/core/axis-label.js
var AxisLabel = function(TextBox2) {
  function AxisLabel2(value, text, index, dataItem, options2) {
    TextBox2.call(this, text, options2);
    this.text = text;
    this.value = value;
    this.index = index;
    this.dataItem = dataItem;
    this.reflow(new box_default());
  }
  if (TextBox2)
    AxisLabel2.__proto__ = TextBox2;
  AxisLabel2.prototype = Object.create(TextBox2 && TextBox2.prototype);
  AxisLabel2.prototype.constructor = AxisLabel2;
  AxisLabel2.prototype.visualContext = function visualContext(targetBox) {
    var context2 = TextBox2.prototype.visualContext.call(this, targetBox);
    context2.value = this.value;
    context2.dataItem = this.dataItem;
    context2.format = this.options.format;
    context2.culture = this.options.culture;
    return context2;
  };
  AxisLabel2.prototype.click = function click(widget, e) {
    widget.trigger(AXIS_LABEL_CLICK, {
      element: eventElement2(e),
      value: this.value,
      text: this.text,
      index: this.index,
      dataItem: this.dataItem,
      axis: this.parent.options
    });
  };
  AxisLabel2.prototype.rotate = function rotate() {
    if (this.options.alignRotation !== CENTER) {
      var box = this.normalBox.toRect();
      var transform2 = this.rotationTransform();
      this.box = rectToBox(box.bbox(transform2.matrix()));
    } else {
      TextBox2.prototype.rotate.call(this);
    }
    return this.box;
  };
  AxisLabel2.prototype.rotationTransform = function rotationTransform() {
    var options2 = this.options;
    var rotation = options2.rotation;
    if (!rotation) {
      return null;
    }
    if (options2.alignRotation === CENTER) {
      return TextBox2.prototype.rotationTransform.call(this);
    }
    var rotationMatrix = geometry_exports.transform().rotate(rotation).matrix();
    var box = this.normalBox.toRect();
    var rect = this.targetBox.toRect();
    var rotationOrigin = options2.rotationOrigin || TOP;
    var alignAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? X : Y;
    var distanceAxis = rotationOrigin === TOP || rotationOrigin === BOTTOM ? Y : X;
    var axisAnchor = rotationOrigin === TOP || rotationOrigin === LEFT ? rect.origin : rect.bottomRight();
    var topLeft = box.topLeft().transformCopy(rotationMatrix);
    var topRight = box.topRight().transformCopy(rotationMatrix);
    var bottomRight = box.bottomRight().transformCopy(rotationMatrix);
    var bottomLeft = box.bottomLeft().transformCopy(rotationMatrix);
    var rotatedBox = geometry_exports.Rect.fromPoints(topLeft, topRight, bottomRight, bottomLeft);
    var translate2 = {};
    translate2[distanceAxis] = rect.origin[distanceAxis] - rotatedBox.origin[distanceAxis];
    var distanceLeft = Math.abs(topLeft[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var distanceRight = Math.abs(topRight[distanceAxis] + translate2[distanceAxis] - axisAnchor[distanceAxis]);
    var alignStart2, alignEnd;
    if (round3(distanceLeft, DEFAULT_PRECISION) === round3(distanceRight, DEFAULT_PRECISION)) {
      alignStart2 = topLeft;
      alignEnd = topRight;
    } else if (distanceRight < distanceLeft) {
      alignStart2 = topRight;
      alignEnd = bottomRight;
    } else {
      alignStart2 = topLeft;
      alignEnd = bottomLeft;
    }
    var alignCenter = alignStart2[alignAxis] + (alignEnd[alignAxis] - alignStart2[alignAxis]) / 2;
    translate2[alignAxis] = rect.center()[alignAxis] - alignCenter;
    return geometry_exports.transform().translate(translate2.x, translate2.y).rotate(rotation);
  };
  return AxisLabel2;
}(text_box_default);
setDefaultOptions(AxisLabel, {
  _autoReflow: false
});
var axis_label_default = AxisLabel;

// node_modules/@progress/kendo-charts/dist/es/core/note.js
var DEFAULT_ICON_SIZE = 7;
var DEFAULT_LABEL_COLOR = "#fff";
var Note = function(BoxElement2) {
  function Note2(fields, options2, chartService) {
    BoxElement2.call(this, options2);
    this.fields = fields;
    this.chartService = chartService;
    this.render();
  }
  if (BoxElement2)
    Note2.__proto__ = BoxElement2;
  Note2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Note2.prototype.constructor = Note2;
  Note2.prototype.hide = function hide2() {
    this.options.visible = false;
  };
  Note2.prototype.show = function show2() {
    this.options.visible = true;
  };
  Note2.prototype.render = function render3() {
    var this$1 = this;
    var options2 = this.options;
    if (options2.visible) {
      var label = options2.label;
      var icon = options2.icon;
      var box = new box_default();
      var childAlias = function() {
        return this$1;
      };
      var size = icon.size;
      var text = this.fields.text;
      var width, height;
      if (defined2(label) && label.visible) {
        var noteTemplate = getTemplate(label);
        if (noteTemplate) {
          text = noteTemplate(this.fields);
        } else if (label.format) {
          text = this.chartService.format.auto(label.format, text);
        }
        if (!label.color) {
          label.color = label.position === INSIDE ? DEFAULT_LABEL_COLOR : icon.background;
        }
        this.label = new text_box_default(text, deepExtend({}, label));
        this.label.aliasFor = childAlias;
        if (label.position === INSIDE && !defined2(size)) {
          if (icon.type === CIRCLE) {
            size = Math.max(this.label.box.width(), this.label.box.height());
          } else {
            width = this.label.box.width();
            height = this.label.box.height();
          }
          box.wrap(this.label.box);
        }
      }
      icon.width = width || size || DEFAULT_ICON_SIZE;
      icon.height = height || size || DEFAULT_ICON_SIZE;
      var marker = new shape_element_default(deepExtend({}, icon));
      marker.aliasFor = childAlias;
      this.marker = marker;
      this.append(marker);
      if (this.label) {
        this.append(this.label);
      }
      marker.reflow(new box_default());
      this.wrapperBox = box.wrap(marker.box);
    }
  };
  Note2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var marker = ref2.marker;
    var wrapperBox = ref2.wrapperBox;
    var center = targetBox.center();
    var length = options2.line.length;
    var position = options2.position;
    if (options2.visible) {
      var lineStart, box, contentBox;
      if (inArray(position, [LEFT, RIGHT])) {
        if (position === LEFT) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(-length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x1, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x2, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(length, targetBox.center().y - wrapperBox.center().y);
          if (options2.line.visible) {
            lineStart = [targetBox.x2, center.y];
            this.linePoints = [
              lineStart,
              [contentBox.x1, center.y]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      } else {
        if (position === BOTTOM) {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y2];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y1]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        } else {
          contentBox = wrapperBox.alignTo(targetBox, position).translate(targetBox.center().x - wrapperBox.center().x, -length);
          if (options2.line.visible) {
            lineStart = [center.x, targetBox.y1];
            this.linePoints = [
              lineStart,
              [center.x, contentBox.y2]
            ];
            box = contentBox.clone().wrapPoint(lineStart);
          }
        }
      }
      if (marker) {
        marker.reflow(contentBox);
      }
      if (label) {
        label.reflow(contentBox);
        if (marker) {
          if (options2.label.position === OUTSIDE) {
            label.box.alignTo(marker.box, position);
          }
          label.reflow(label.box);
        }
      }
      this.contentBox = contentBox;
      this.targetBox = targetBox;
      this.box = box || contentBox;
    }
  };
  Note2.prototype.createVisual = function createVisual() {
    BoxElement2.prototype.createVisual.call(this);
    this.visual.options.noclip = this.options.noclip;
    if (this.options.visible) {
      this.createLine();
    }
  };
  Note2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (options2.visible && customVisual) {
      this.visual = customVisual(Object.assign(this.fields, {
        sender: this.getSender(),
        rect: this.targetBox.toRect(),
        options: {
          background: options2.background,
          border: options2.background,
          icon: options2.icon,
          label: options2.label,
          line: options2.line,
          position: options2.position,
          visible: options2.visible
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      }));
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  Note2.prototype.createLine = function createLine() {
    var options2 = this.options.line;
    if (this.linePoints) {
      var path = drawing_exports.Path.fromPoints(this.linePoints, {
        stroke: {
          color: options2.color,
          width: options2.width,
          dashType: options2.dashType
        }
      });
      alignPathToPixel(path);
      this.visual.append(path);
    }
  };
  Note2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_CLICK, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(NOTE_HOVER, args)) {
      e.preventDefault();
    }
  };
  Note2.prototype.out = function out(widget, e) {
    var args = this.eventArgs(e);
    widget.trigger(NOTE_LEAVE, args);
  };
  Note2.prototype.eventArgs = function eventArgs(e) {
    var options2 = this.options;
    return Object.assign(this.fields, {
      element: eventElement2(e),
      text: defined2(options2.label) ? options2.label.text : "",
      visual: this.visual
    });
  };
  return Note2;
}(box_element_default);
setDefaultOptions(Note, {
  icon: {
    visible: true,
    type: CIRCLE
  },
  label: {
    position: INSIDE,
    visible: true,
    align: CENTER,
    vAlign: CENTER
  },
  line: {
    visible: true
  },
  visible: true,
  position: TOP,
  zIndex: 2
});
var note_default = Note;

// node_modules/@progress/kendo-charts/dist/es/services/intl-service.js
var defaultImplementation = {
  format: function(format2, value) {
    return value;
  },
  toString: function(value) {
    return value;
  },
  parseDate: function(value) {
    return new Date(value);
  },
  firstDay: function() {
    return 0;
  }
};
var current2 = defaultImplementation;
var IntlService2 = function IntlService3() {
};
var staticAccessors = { implementation: { configurable: true } };
IntlService2.register = function register2(userImplementation) {
  current2 = userImplementation;
};
staticAccessors.implementation.get = function() {
  return current2;
};
Object.defineProperties(IntlService2, staticAccessors);
var intl_service_default = IntlService2;

// node_modules/@progress/kendo-charts/dist/es/services/format-service.js
var FORMAT_REPLACE_REGEX = /\{(\d+)(:[^\}]+)?\}/g;
var FormatService = function FormatService2(intlService) {
  this._intlService = intlService;
};
var prototypeAccessors2 = { intl: { configurable: true } };
prototypeAccessors2.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors2.intl.set = function(value) {
  this._intlService = value;
};
FormatService.prototype.auto = function auto(formatString2) {
  var values5 = [], len = arguments.length - 1;
  while (len-- > 0)
    values5[len] = arguments[len + 1];
  var intl = this.intl;
  if (isString2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    return intl.format.apply(intl, [formatString2].concat(values5));
  }
  return intl.toString(values5[0], formatString2);
};
FormatService.prototype.localeAuto = function localeAuto(formatString2, values5, locale) {
  var intl = this.intl;
  var result;
  if (isString2(formatString2) && formatString2.match(FORMAT_REGEX)) {
    result = formatString2.replace(FORMAT_REPLACE_REGEX, function(match, index, placeholderFormat) {
      var value = values5[parseInt(index, 10)];
      return intl.toString(value, placeholderFormat ? placeholderFormat.substring(1) : "", locale);
    });
  } else {
    result = intl.toString(values5[0], formatString2, locale);
  }
  return result;
};
Object.defineProperties(FormatService.prototype, prototypeAccessors2);
var format_service_default = FormatService;

// node_modules/@progress/kendo-charts/dist/es/services/chart-service.js
var ChartService = function ChartService2(chart, context2) {
  if (context2 === void 0)
    context2 = {};
  this._intlService = context2.intlService;
  this.sender = context2.sender || chart;
  this.format = new format_service_default(context2.intlService);
  this.chart = chart;
  this.rtl = Boolean(context2.rtl);
};
var prototypeAccessors3 = { intl: { configurable: true } };
prototypeAccessors3.intl.get = function() {
  return this._intlService || intl_service_default.implementation;
};
prototypeAccessors3.intl.set = function(value) {
  this._intlService = value;
  this.format.intl = value;
};
ChartService.prototype.notify = function notify(name3, args) {
  if (this.chart) {
    this.chart.trigger(name3, args);
  }
};
ChartService.prototype.isPannable = function isPannable(axis) {
  var pannable = ((this.chart || {}).options || {}).pannable;
  return pannable && pannable.lock !== axis;
};
Object.defineProperties(ChartService.prototype, prototypeAccessors3);
var chart_service_default = ChartService;

// node_modules/@progress/kendo-charts/dist/es/services/dom-events-builder.js
var current3;
var DomEventsBuilder = function DomEventsBuilder2() {
};
DomEventsBuilder.register = function register3(userImplementation) {
  current3 = userImplementation;
};
DomEventsBuilder.create = function create(element, events2) {
  if (current3) {
    return current3.create(element, events2);
  }
};
var dom_events_builder_default = DomEventsBuilder;

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-tick.js
function createAxisTick(options2, tickOptions) {
  var tickX = options2.tickX;
  var tickY = options2.tickY;
  var position = options2.position;
  var tick = new drawing_exports.Path({
    stroke: {
      width: tickOptions.width,
      color: tickOptions.color
    }
  });
  if (options2.vertical) {
    tick.moveTo(tickX, position).lineTo(tickX + tickOptions.size, position);
  } else {
    tick.moveTo(position, tickY).lineTo(position, tickY + tickOptions.size);
  }
  alignPathToPixel(tick);
  return tick;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/create-axis-grid-line.js
function createAxisGridLine(options2, gridLine) {
  var lineStart = options2.lineStart;
  var lineEnd = options2.lineEnd;
  var position = options2.position;
  var line = new drawing_exports.Path({
    stroke: {
      width: gridLine.width,
      color: gridLine.color,
      dashType: gridLine.dashType
    }
  });
  if (options2.vertical) {
    line.moveTo(lineStart, position).lineTo(lineEnd, position);
  } else {
    line.moveTo(position, lineStart).lineTo(position, lineEnd);
  }
  alignPathToPixel(line);
  return line;
}

// node_modules/@progress/kendo-charts/dist/es/core/axis.js
var Axis = function(ChartElement2) {
  function Axis2(options2, chartService) {
    if (chartService === void 0)
      chartService = new chart_service_default();
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!this.options.visible) {
      this.options = deepExtend({}, this.options, {
        labels: {
          visible: false
        },
        line: {
          visible: false
        },
        margin: 0,
        majorTickSize: 0,
        minorTickSize: 0
      });
    }
    this.options.minorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.minorTickType !== NONE
    }, this.options.minorTicks, {
      size: this.options.minorTickSize,
      align: this.options.minorTickType
    });
    this.options.majorTicks = deepExtend({}, {
      color: this.options.line.color,
      width: this.options.line.width,
      visible: this.options.majorTickType !== NONE
    }, this.options.majorTicks, {
      size: this.options.majorTickSize,
      align: this.options.majorTickType
    });
    this.initFields();
    if (!this.options._deferLabels) {
      this.createLabels();
    }
    this.createTitle();
    this.createNotes();
  }
  if (ChartElement2)
    Axis2.__proto__ = ChartElement2;
  Axis2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Axis2.prototype.constructor = Axis2;
  Axis2.prototype.initFields = function initFields() {
  };
  Axis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.labelsCount()
    };
  };
  Axis2.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {
    var rotation = labelOptions.rotation;
    if (isObject(rotation)) {
      labelOptions.alignRotation = rotation.align;
      labelOptions.rotation = rotation.angle;
    }
  };
  Axis2.prototype.createLabels = function createLabels() {
    var this$1 = this;
    var options2 = this.options;
    var align2 = options2.vertical ? RIGHT : CENTER;
    var labelOptions = deepExtend({}, options2.labels, {
      align: align2,
      zIndex: options2.zIndex
    });
    var step = Math.max(1, labelOptions.step);
    this.clearLabels();
    if (labelOptions.visible) {
      this.normalizeLabelRotation(labelOptions);
      if (labelOptions.rotation === "auto") {
        labelOptions.rotation = 0;
        options2.autoRotateLabels = true;
      }
      var range = this.labelsRange();
      for (var idx = range.min; idx < range.max; idx += step) {
        var labelContext = { index: idx, count: range.max };
        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);
        if (label) {
          this$1.append(label);
          this$1.labels.push(label);
        }
      }
    }
  };
  Axis2.prototype.clearLabels = function clearLabels() {
    this.children = grep(this.children, function(child) {
      return !(child instanceof axis_label_default);
    });
    this.labels = [];
  };
  Axis2.prototype.clearTitle = function clearTitle() {
    var this$1 = this;
    if (this.title) {
      this.children = grep(this.children, function(child) {
        return child !== this$1.title;
      });
      this.title = void 0;
    }
  };
  Axis2.prototype.clear = function clear4() {
    this.clearLabels();
    this.clearTitle();
  };
  Axis2.prototype.lineBox = function lineBox() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var axisX = mirror ? box.x1 : box.x2;
    var axisY = mirror ? box.y2 : box.y1;
    var lineWidth = options2.line.width || 0;
    return vertical ? new box_default(axisX, box.y1, axisX, box.y2 - lineWidth) : new box_default(box.x1, axisY, box.x2 - lineWidth, axisY);
  };
  Axis2.prototype.createTitle = function createTitle() {
    var options2 = this.options;
    var titleOptions = deepExtend({
      rotation: options2.vertical ? -90 : 0,
      text: "",
      zIndex: 1,
      visualSize: true
    }, options2.title);
    if (titleOptions.visible && titleOptions.text) {
      var title2 = new text_box_default(titleOptions.text, titleOptions);
      this.append(title2);
      this.title = title2;
    }
  };
  Axis2.prototype.createNotes = function createNotes() {
    var this$1 = this;
    var options2 = this.options;
    var notes2 = options2.notes;
    var items = notes2.data || [];
    this.notes = [];
    for (var i = 0; i < items.length; i++) {
      var item = deepExtend({}, notes2, items[i]);
      item.value = this$1.parseNoteValue(item.value);
      var note = new note_default({
        value: item.value,
        text: item.label.text,
        dataItem: item
      }, item, this$1.chartService);
      if (note.options.visible) {
        if (defined2(note.options.position)) {
          if (options2.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {
            note.options.position = options2.reverse ? LEFT : RIGHT;
          } else if (!options2.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {
            note.options.position = options2.reverse ? BOTTOM : TOP;
          }
        } else {
          if (options2.vertical) {
            note.options.position = options2.reverse ? LEFT : RIGHT;
          } else {
            note.options.position = options2.reverse ? BOTTOM : TOP;
          }
        }
        this$1.append(note);
        this$1.notes.push(note);
      }
    }
  };
  Axis2.prototype.parseNoteValue = function parseNoteValue(value) {
    return value;
  };
  Axis2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    this.createPlotBands();
  };
  Axis2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this.createBackground();
    this.createLine();
  };
  Axis2.prototype.gridLinesVisual = function gridLinesVisual() {
    var gridLines = this._gridLines;
    if (!gridLines) {
      gridLines = this._gridLines = new drawing_exports.Group({
        zIndex: -2
      });
      this.appendVisual(this._gridLines);
    }
    return gridLines;
  };
  Axis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var mirror = options2.labels.mirror;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical: options2.vertical
    };
    function render3(tickPositions, tickOptions, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, tickOptions.step);
      if (tickOptions.visible) {
        for (var i = tickOptions.skip; i < count; i += step) {
          if (defined2(skipUnit) && i % skipUnit === 0) {
            continue;
          }
          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
          tickLineOptions.position = tickPositions[i];
          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
        }
      }
    }
    render3(this.getMajorTickPositions(), options2.majorTicks);
    render3(this.getMinorTickPositions(), options2.minorTicks, majorUnit / options2.minorUnit);
  };
  Axis2.prototype.createLine = function createLine() {
    var options2 = this.options;
    var line = options2.line;
    var lineBox = this.lineBox();
    if (line.width > 0 && line.visible) {
      var path = new drawing_exports.Path({
        stroke: {
          width: line.width,
          color: line.color,
          dashType: line.dashType
        }
        /* TODO
        zIndex: line.zIndex,
        */
      });
      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      if (options2._alignLines) {
        alignPathToPixel(path);
      }
      var group = this._lineGroup = new drawing_exports.Group();
      group.append(path);
      this.visual.append(group);
      this.createTicks(group);
    }
  };
  Axis2.prototype.getActualTickSize = function getActualTickSize() {
    var options2 = this.options;
    var tickSize = 0;
    if (options2.majorTicks.visible && options2.minorTicks.visible) {
      tickSize = Math.max(options2.majorTicks.size, options2.minorTicks.size);
    } else if (options2.majorTicks.visible) {
      tickSize = options2.majorTicks.size;
    } else if (options2.minorTicks.visible) {
      tickSize = options2.minorTicks.size;
    }
    return tickSize;
  };
  Axis2.prototype.createBackground = function createBackground() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var background = options2.background;
    if (background) {
      this._backgroundPath = drawing_exports.Path.fromRect(box.toRect(), {
        fill: {
          color: background
        },
        stroke: null
      });
      this.visual.append(this._backgroundPath);
    }
  };
  Axis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var options2 = this.options;
    var plotBands = options2.plotBands || [];
    var vertical = options2.vertical;
    var plotArea = this.plotArea;
    if (plotBands.length === 0) {
      return;
    }
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    var altAxis = grep(this.pane.axes, function(axis) {
      return axis.options.vertical !== this$1.options.vertical;
    })[0];
    for (var idx = 0; idx < plotBands.length; idx++) {
      var item = plotBands[idx];
      var slotX = void 0, slotY = void 0;
      var labelOptions = item.label;
      var label = void 0;
      if (vertical) {
        slotX = (altAxis || plotArea.axisX).lineBox();
        slotY = this$1.getSlot(item.from, item.to, true);
      } else {
        slotX = this$1.getSlot(item.from, item.to, true);
        slotY = (altAxis || plotArea.axisY).lineBox();
      }
      if (labelOptions) {
        labelOptions.vAlign = labelOptions.position || LEFT;
        label = this$1.createPlotBandLabel(
          labelOptions,
          item,
          new box_default(
            slotX.x1,
            slotY.y1,
            slotX.x2,
            slotY.y2
          )
        );
      }
      if (slotX.width() !== 0 && slotY.height() !== 0) {
        var bandRect = new geometry_exports.Rect(
          [slotX.x1, slotY.y1],
          [slotX.width(), slotY.height()]
        );
        var path = drawing_exports.Path.fromRect(bandRect, {
          fill: {
            color: item.color,
            opacity: item.opacity
          },
          stroke: null
        });
        group.append(path);
        if (label) {
          group.append(label);
        }
      }
    }
    this.appendVisual(group);
  };
  Axis2.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {
    if (label.visible === false) {
      return null;
    }
    var text = label.text;
    var textbox;
    if (defined2(label) && label.visible) {
      var labelTemplate = getTemplate(label);
      if (labelTemplate) {
        text = labelTemplate({ text, item });
      } else if (label.format) {
        text = this.chartService.format.auto(label.format, text);
      }
      if (!label.color) {
        label.color = this.options.labels.color;
      }
    }
    textbox = new text_box_default(text, label);
    textbox.reflow(box);
    textbox.renderVisual();
    return textbox.visual;
  };
  Axis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var minorUnit = options2.minorUnit;
    var vertical = options2.vertical;
    var axisLineVisible = altAxis.options.line.visible;
    var majorUnit = majorGridLines.visible ? options2.majorUnit : 0;
    var lineBox = altAxis.lineBox();
    var linePos = lineBox[vertical ? "y1" : "x1"];
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render3(tickPositions, gridLine, skipUnit) {
      var count = tickPositions.length;
      var step = Math.max(1, gridLine.step);
      if (gridLine.visible) {
        for (var i = gridLine.skip; i < count; i += step) {
          var pos = round3(tickPositions[i]);
          if (!inArray(pos, majorTicks)) {
            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {
              lineOptions.position = pos;
              container.append(createAxisGridLine(lineOptions, gridLine));
              majorTicks.push(pos);
            }
          }
        }
      }
    }
    render3(this.getMajorTickPositions(), majorGridLines);
    render3(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);
    return container.children;
  };
  Axis2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var title2 = ref2.title;
    var vertical = options2.vertical;
    var count = labels.length;
    var sizeFn = vertical ? WIDTH : HEIGHT;
    var titleSize = title2 ? title2.box[sizeFn]() : 0;
    var space = this.getActualTickSize() + options2.margin + titleSize;
    var rootBox = (this.getRoot() || {}).box || box;
    var boxSize = rootBox[sizeFn]();
    var maxLabelSize = 0;
    for (var i = 0; i < count; i++) {
      var labelSize = labels[i].box[sizeFn]();
      if (labelSize + space <= boxSize) {
        maxLabelSize = Math.max(maxLabelSize, labelSize);
      }
    }
    if (vertical) {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x1 + maxLabelSize + space,
        box.y2
      );
    } else {
      this.box = new box_default(
        box.x1,
        box.y1,
        box.x2,
        box.y1 + maxLabelSize + space
      );
    }
    this.arrangeTitle();
    this.arrangeLabels();
    this.arrangeNotes();
  };
  Axis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getMajorTickPositions();
  };
  Axis2.prototype.labelTickIndex = function labelTickIndex(label) {
    return label.index;
  };
  Axis2.prototype.arrangeLabels = function arrangeLabels() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var tickPositions = this.getLabelsTickPositions();
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var labelSize = vertical ? label.box.height() : label.box.width();
      var firstTickPosition = tickPositions[tickIx];
      var nextTickPosition = tickPositions[tickIx + 1];
      var positionStart = void 0, positionEnd = void 0;
      if (vertical) {
        if (labelsBetweenTicks) {
          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;
          positionStart = middle - labelSize / 2;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
        }
        positionEnd = positionStart;
      } else {
        if (labelsBetweenTicks) {
          positionStart = firstTickPosition;
          positionEnd = nextTickPosition;
        } else {
          positionStart = firstTickPosition - labelSize / 2;
          positionEnd = positionStart + labelSize;
        }
      }
      this$1.positionLabel(label, mirror, positionStart, positionEnd);
    }
  };
  Axis2.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {
    if (positionEnd === void 0)
      positionEnd = positionStart;
    var options2 = this.options;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var labelOffset = this.getActualTickSize() + options2.margin;
    var labelBox;
    if (vertical) {
      var labelX = lineBox.x2;
      if (mirror) {
        labelX += labelOffset;
        label.options.rotationOrigin = LEFT;
      } else {
        labelX -= labelOffset + label.box.width();
        label.options.rotationOrigin = RIGHT;
      }
      labelBox = label.box.move(labelX, positionStart);
    } else {
      var labelY = lineBox.y1;
      if (mirror) {
        labelY -= labelOffset + label.box.height();
        label.options.rotationOrigin = BOTTOM;
      } else {
        labelY += labelOffset;
        label.options.rotationOrigin = TOP;
      }
      labelBox = new box_default(
        positionStart,
        labelY,
        positionEnd,
        labelY + label.box.height()
      );
    }
    label.reflow(labelBox);
  };
  Axis2.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {
    if (labelBox.width() < slotWidth) {
      return 0;
    }
    if (labelBox.height() > slotWidth) {
      return -90;
    }
    return -45;
  };
  Axis2.prototype.autoRotateLabels = function autoRotateLabels() {
    var this$1 = this;
    if (!this.options.autoRotateLabels || this.options.vertical) {
      return false;
    }
    var tickPositions = this.getMajorTickPositions();
    var labels = this.labels;
    var limit = Math.min(labels.length, tickPositions.length - 1);
    var angle = 0;
    for (var idx = 0; idx < limit; idx++) {
      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);
      var labelBox = labels[idx].box;
      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);
      if (labelAngle !== 0) {
        angle = labelAngle;
      }
      if (angle === -90) {
        break;
      }
    }
    if (angle !== 0) {
      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {
        labels[idx$1].options.rotation = angle;
        labels[idx$1].reflow(new box_default());
      }
      return true;
    }
  };
  Axis2.prototype.arrangeTitle = function arrangeTitle() {
    var ref2 = this;
    var options2 = ref2.options;
    var title2 = ref2.title;
    var mirror = options2.labels.mirror;
    var vertical = options2.vertical;
    if (title2) {
      if (vertical) {
        title2.options.align = mirror ? RIGHT : LEFT;
        title2.options.vAlign = title2.options.position;
      } else {
        title2.options.align = title2.options.position;
        title2.options.vAlign = mirror ? TOP : BOTTOM;
      }
      title2.reflow(this.box);
    }
  };
  Axis2.prototype.arrangeNotes = function arrangeNotes() {
    var this$1 = this;
    for (var idx = 0; idx < this.notes.length; idx++) {
      var item = this$1.notes[idx];
      var value = item.options.value;
      var slot = void 0;
      if (defined2(value)) {
        if (this$1.shouldRenderNote(value)) {
          item.show();
        } else {
          item.hide();
        }
        slot = this$1.noteSlot(value);
      } else {
        item.hide();
      }
      item.reflow(slot || this$1.lineBox());
    }
  };
  Axis2.prototype.noteSlot = function noteSlot(value) {
    return this.getSlot(value);
  };
  Axis2.prototype.alignTo = function alignTo(secondAxis) {
    var lineBox = secondAxis.lineBox();
    var vertical = this.options.vertical;
    var pos = vertical ? Y : X;
    this.box.snapTo(lineBox, pos);
    if (vertical) {
      this.box.shrink(0, this.lineBox().height() - lineBox.height());
    } else {
      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);
    }
    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];
    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];
  };
  Axis2.prototype.axisLabelText = function axisLabelText(value, options2, context2) {
    var this$1 = this;
    var text;
    var tmpl = getTemplate(options2);
    var defaultText = function() {
      if (!options2.format) {
        return value;
      }
      return this$1.chartService.format.localeAuto(
        options2.format,
        [value],
        options2.culture
      );
    };
    if (tmpl) {
      var templateContext = Object.assign({}, context2, {
        get text() {
          return defaultText();
        },
        value,
        format: options2.format,
        culture: options2.culture
      });
      text = tmpl(templateContext);
    } else {
      text = defaultText();
    }
    return text;
  };
  Axis2.prototype.slot = function slot(from, to, limit) {
    var slot2 = this.getSlot(from, to, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  Axis2.prototype.contentBox = function contentBox() {
    var box = this.box.clone();
    var labels = this.labels;
    if (labels.length) {
      var axis = this.options.vertical ? Y : X;
      if (this.chartService.isPannable(axis)) {
        var offset = this.maxLabelOffset();
        box[axis + 1] -= offset.start;
        box[axis + 2] += offset.end;
      } else {
        if (labels[0].options.visible) {
          box.wrap(labels[0].box);
        }
        var lastLabel = labels[labels.length - 1];
        if (lastLabel.options.visible) {
          box.wrap(lastLabel.box);
        }
      }
    }
    return box;
  };
  Axis2.prototype.maxLabelOffset = function maxLabelOffset() {
    var this$1 = this;
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var labelsBetweenTicks = this.labelsBetweenTicks();
    var tickPositions = this.getLabelsTickPositions();
    var offsetField = vertical ? Y : X;
    var labels = this.labels;
    var startPosition = reverse ? 1 : 0;
    var endPosition = reverse ? 0 : 1;
    var maxStartOffset = 0;
    var maxEndOffset = 0;
    for (var idx = 0; idx < labels.length; idx++) {
      var label = labels[idx];
      var tickIx = this$1.labelTickIndex(label);
      var startTick = void 0, endTick = void 0;
      if (labelsBetweenTicks) {
        startTick = tickPositions[tickIx + startPosition];
        endTick = tickPositions[tickIx + endPosition];
      } else {
        startTick = endTick = tickPositions[tickIx];
      }
      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);
      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);
    }
    return {
      start: maxStartOffset,
      end: maxEndOffset
    };
  };
  Axis2.prototype.limitRange = function limitRange(from, to, min3, max2, offset) {
    var options2 = this.options;
    if (from < min3 && offset < 0 && (!defined2(options2.min) || options2.min <= min3) || max2 < to && offset > 0 && (!defined2(options2.max) || max2 <= options2.max)) {
      return null;
    }
    if (to < min3 && offset > 0 || max2 < from && offset < 0) {
      return {
        min: from,
        max: to
      };
    }
    var rangeSize = to - from;
    var minValue = from;
    var maxValue = to;
    if (from < min3 && offset < 0) {
      minValue = limitValue2(from, min3, max2);
      maxValue = limitValue2(from + rangeSize, min3 + rangeSize, max2);
    } else if (to > max2 && offset > 0) {
      maxValue = limitValue2(to, min3, max2);
      minValue = limitValue2(to - rangeSize, min3, max2 - rangeSize);
    }
    return {
      min: minValue,
      max: maxValue
    };
  };
  Axis2.prototype.valueRange = function valueRange3() {
    return {
      min: this.seriesMin,
      max: this.seriesMax
    };
  };
  Axis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    return (vertical ? -1 : 1) * (reverse ? -1 : 1);
  };
  Axis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = this.lineDir();
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  Axis2.prototype.pointOffset = function pointOffset(point2) {
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var relative = axisDir > 0 ? point2[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point2[axis];
    var offset = relative / lineSize;
    return offset;
  };
  Axis2.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {
    var MAX_SCALE = 0.999;
    var scale = limitValue2(rawScale, -MAX_SCALE, MAX_SCALE);
    var delta;
    if (scale > 0) {
      delta = range * Math.min(1, scale);
    } else {
      delta = range - range / (1 + scale);
    }
    return delta;
  };
  Axis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.options.justified;
  };
  Axis2.prototype.prepareUserOptions = function prepareUserOptions() {
  };
  return Axis2;
}(chart_element_default);
setDefaultOptions(Axis, {
  labels: {
    visible: true,
    rotation: 0,
    mirror: false,
    step: 1,
    skip: 0
  },
  line: {
    width: 1,
    color: BLACK,
    visible: true
  },
  title: {
    visible: true,
    position: CENTER
  },
  majorTicks: {
    align: OUTSIDE,
    size: 4,
    skip: 0,
    step: 1
  },
  minorTicks: {
    align: OUTSIDE,
    size: 3,
    skip: 0,
    step: 1
  },
  axisCrossingValue: 0,
  majorTickType: OUTSIDE,
  minorTickType: NONE,
  majorGridLines: {
    skip: 0,
    step: 1
  },
  minorGridLines: {
    visible: false,
    width: 1,
    color: BLACK,
    skip: 0,
    step: 1
  },
  // TODO: Move to line or labels options
  margin: 5,
  visible: true,
  reverse: false,
  justified: true,
  notes: {
    label: {
      text: ""
    }
  },
  _alignLines: true,
  _deferLabels: false
});
var axis_default = Axis;

// node_modules/@progress/kendo-charts/dist/es/date-utils/constants.js
var MILLISECONDS = "milliseconds";
var SECONDS = "seconds";
var MINUTES = "minutes";
var HOURS = "hours";
var DAYS = "days";
var WEEKS = "weeks";
var MONTHS = "months";
var YEARS = "years";
var TIME_PER_MILLISECOND = 1;
var TIME_PER_SECOND = 1e3;
var TIME_PER_MINUTE = 60 * TIME_PER_SECOND;
var TIME_PER_HOUR = 60 * TIME_PER_MINUTE;
var TIME_PER_DAY = 24 * TIME_PER_HOUR;
var TIME_PER_WEEK = 7 * TIME_PER_DAY;
var TIME_PER_MONTH = 31 * TIME_PER_DAY;
var TIME_PER_YEAR = 365 * TIME_PER_DAY;
var TIME_PER_UNIT = {
  "years": TIME_PER_YEAR,
  "months": TIME_PER_MONTH,
  "weeks": TIME_PER_WEEK,
  "days": TIME_PER_DAY,
  "hours": TIME_PER_HOUR,
  "minutes": TIME_PER_MINUTE,
  "seconds": TIME_PER_SECOND,
  "milliseconds": TIME_PER_MILLISECOND
};

// node_modules/@progress/kendo-charts/dist/es/date-utils/absolute-date-diff.js
function absoluteDateDiff(a, b) {
  var diff = a.getTime() - b;
  var offsetDiff = a.getTimezoneOffset() - b.getTimezoneOffset();
  return diff - offsetDiff * TIME_PER_MINUTE;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-ticks.js
function addTicks(date, ticks) {
  return new Date(date.getTime() + ticks);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-date.js
function toDate(value) {
  var result;
  if (value instanceof Date) {
    result = value;
  } else if (value) {
    result = new Date(value);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/start-of-week.js
function startOfWeek(date, weekStartDay) {
  if (weekStartDay === void 0)
    weekStartDay = 0;
  var daysToSubtract = 0;
  var day = date.getDay();
  if (!isNaN(day)) {
    while (day !== weekStartDay) {
      if (day === 0) {
        day = 6;
      } else {
        day--;
      }
      daysToSubtract++;
    }
  }
  return addTicks(date, -daysToSubtract * TIME_PER_DAY);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/add-duration.js
function adjustDST2(date, hours) {
  if (hours === 0 && date.getHours() === 23) {
    date.setHours(date.getHours() + 2);
    return true;
  }
  return false;
}
function addHours(date, hours) {
  var roundedDate = new Date(date);
  roundedDate.setMinutes(0, 0, 0);
  var tzDiff = (date.getTimezoneOffset() - roundedDate.getTimezoneOffset()) * TIME_PER_MINUTE;
  return addTicks(roundedDate, tzDiff + hours * TIME_PER_HOUR);
}
function addDuration(dateValue, value, unit, weekStartDay) {
  var result = dateValue;
  if (dateValue) {
    var date = toDate(dateValue);
    var hours = date.getHours();
    if (unit === YEARS) {
      result = new Date(date.getFullYear() + value, 0, 1);
      adjustDST2(result, 0);
    } else if (unit === MONTHS) {
      result = new Date(date.getFullYear(), date.getMonth() + value, 1);
      adjustDST2(result, hours);
    } else if (unit === WEEKS) {
      result = addDuration(startOfWeek(date, weekStartDay), value * 7, DAYS);
      adjustDST2(result, hours);
    } else if (unit === DAYS) {
      result = new Date(date.getFullYear(), date.getMonth(), date.getDate() + value);
      adjustDST2(result, hours);
    } else if (unit === HOURS) {
      result = addHours(date, value);
    } else if (unit === MINUTES) {
      result = addTicks(date, value * TIME_PER_MINUTE);
      if (result.getSeconds() > 0) {
        result.setSeconds(0);
      }
    } else if (unit === SECONDS) {
      result = addTicks(date, value * TIME_PER_SECOND);
    } else if (unit === MILLISECONDS) {
      result = addTicks(date, value);
    }
    if (unit !== MILLISECONDS && result.getMilliseconds() > 0) {
      result.setMilliseconds(0);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/floor-date.js
function floorDate(date, unit, weekStartDay) {
  return addDuration(toDate(date), 0, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/ceil-date.js
function ceilDate(dateValue, unit, weekStartDay) {
  var date = toDate(dateValue);
  if (date && floorDate(date, unit, weekStartDay).getTime() === date.getTime()) {
    return date;
  }
  return addDuration(date, 1, unit, weekStartDay);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-comparer.js
function dateComparer(a, b) {
  if (a && b) {
    return a.getTime() - b.getTime();
  }
  return -1;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-diff.js
function dateDiff(a, b) {
  return a.getTime() - b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/to-time.js
function toTime(value) {
  if (isArray(value)) {
    var result = [];
    for (var idx = 0; idx < value.length; idx++) {
      result.push(toTime(value[idx]));
    }
    return result;
  } else if (value) {
    return toDate(value).getTime();
  }
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-equals.js
function dateEquals(a, b) {
  if (a && b) {
    return toTime(a) === toTime(b);
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/date-index.js
function timeIndex(date, start, baseUnit) {
  return absoluteDateDiff(date, start) / TIME_PER_UNIT[baseUnit];
}
function dateIndex(value, start, baseUnit, baseUnitStep) {
  var date = toDate(value);
  var startDate = toDate(start);
  var index;
  if (baseUnit === MONTHS) {
    index = date.getMonth() - startDate.getMonth() + (date.getFullYear() - startDate.getFullYear()) * 12 + timeIndex(date, new Date(date.getFullYear(), date.getMonth()), DAYS) / new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
  } else if (baseUnit === YEARS) {
    index = date.getFullYear() - startDate.getFullYear() + dateIndex(date, new Date(date.getFullYear(), 0), MONTHS, 1) / 12;
  } else if (baseUnit === DAYS || baseUnit === WEEKS) {
    index = timeIndex(date, startDate, baseUnit);
  } else {
    index = dateDiff(date, start) / TIME_PER_UNIT[baseUnit];
  }
  return index / baseUnitStep;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/duration.js
function duration(a, b, unit) {
  var diff;
  if (unit === YEARS) {
    diff = b.getFullYear() - a.getFullYear();
  } else if (unit === MONTHS) {
    diff = duration(a, b, YEARS) * 12 + b.getMonth() - a.getMonth();
  } else if (unit === DAYS) {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_DAY);
  } else {
    diff = Math.floor(dateDiff(b, a) / TIME_PER_UNIT[unit]);
  }
  return diff;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-date.js
function parseDate3(intlService, date) {
  var result;
  if (isString2(date)) {
    result = intlService.parseDate(date) || toDate(date);
  } else {
    result = toDate(date);
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/parse-dates.js
function parseDates(intlService, dates) {
  if (isArray(dates)) {
    var result = [];
    for (var idx = 0; idx < dates.length; idx++) {
      result.push(parseDate3(intlService, dates[idx]));
    }
    return result;
  }
  return parseDate3(intlService, dates);
}

// node_modules/@progress/kendo-charts/dist/es/date-utils/first-day.js
function firstDay2(options2, intlService) {
  if (isNumber2(options2.weekStartDay)) {
    return options2.weekStartDay;
  }
  if (intlService && intlService.firstDay) {
    return intlService.firstDay();
  }
  return 0;
}

// node_modules/@progress/kendo-charts/dist/es/core/category-axis.js
var MIN_CATEGORY_POINTS_RANGE = 0.01;
var MIN_CATEGORY_RANGE = 0.1;
function indexOf(value, arr) {
  if (value instanceof Date) {
    var length = arr.length;
    for (var idx = 0; idx < length; idx++) {
      if (dateEquals(arr[idx], value)) {
        return idx;
      }
    }
    return -1;
  }
  return arr.indexOf(value);
}
var CategoryAxis = function(Axis2) {
  function CategoryAxis2() {
    Axis2.apply(this, arguments);
  }
  if (Axis2)
    CategoryAxis2.__proto__ = Axis2;
  CategoryAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  CategoryAxis2.prototype.constructor = CategoryAxis2;
  CategoryAxis2.prototype.initFields = function initFields() {
    this._ticks = {};
  };
  CategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    return "";
  };
  CategoryAxis2.prototype.clone = function clone2() {
    var copy = new CategoryAxis2(Object.assign({}, this.options, {
      categories: this.options.srcCategories
    }), this.chartService);
    copy.createLabels();
    return copy;
  };
  CategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var categories = options2.categories || [];
    var definedMin = defined2(options2.min);
    var definedMax = defined2(options2.max);
    options2.srcCategories = options2.categories = categories;
    if ((definedMin || definedMax) && categories.length) {
      var min3 = definedMin ? Math.floor(options2.min) : 0;
      var max2;
      if (definedMax) {
        max2 = options2.justified ? Math.floor(options2.max) + 1 : Math.ceil(options2.max);
      } else {
        max2 = categories.length;
      }
      options2.categories = options2.categories.slice(min3, max2);
    }
    return options2;
  };
  CategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    var options2 = this.options;
    var length = options2.categories.length || 1;
    var min3 = isNumber2(options2.min) ? options2.min % 1 : 0;
    var max2;
    if (isNumber2(options2.max) && options2.max % 1 !== 0 && options2.max < this.totalRange().max) {
      max2 = length - (1 - options2.max % 1);
    } else {
      max2 = length - (options2.justified ? 1 : 0);
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.totalRangeIndices = function totalRangeIndices(limit) {
    var options2 = this.options;
    var min3 = isNumber2(options2.min) ? options2.min : 0;
    var max2;
    if (isNumber2(options2.max)) {
      max2 = options2.max;
    } else if (isNumber2(options2.min)) {
      max2 = min3 + options2.categories.length;
    } else {
      max2 = this.totalRange().max || 1;
    }
    if (limit) {
      var totalRange = this.totalRange();
      min3 = limitValue2(min3, 0, totalRange.max);
      max2 = limitValue2(max2, 0, totalRange.max);
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.range = function range() {
    var options2 = this.options;
    var min3 = isNumber2(options2.min) ? options2.min : 0;
    var max2 = isNumber2(options2.max) ? options2.max : this.totalRange().max;
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.roundedRange = function roundedRange() {
    return this.range();
  };
  CategoryAxis2.prototype.totalRange = function totalRange() {
    var options2 = this.options;
    return { min: 0, max: Math.max(this._seriesMax || 0, options2.srcCategories.length) - (options2.justified ? 1 : 0) };
  };
  CategoryAxis2.prototype.scaleOptions = function scaleOptions() {
    var ref2 = this.rangeIndices();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var lineBox = this.lineBox();
    var size = this.options.vertical ? lineBox.height() : lineBox.width();
    var scale = size / (max2 - min3 || 1);
    return {
      scale: scale * (this.options.reverse ? -1 : 1),
      box: lineBox,
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    Axis2.prototype.arrangeLabels.call(this);
    this.hideOutOfRangeLabels();
  };
  CategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    var ref2 = this;
    var box = ref2.box;
    var labels = ref2.labels;
    if (labels.length > 0) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      var firstLabel = labels[0];
      var lastLabel = last2(labels);
      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {
        firstLabel.options.visible = false;
      }
      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {
        lastLabel.options.visible = false;
      }
    }
  };
  CategoryAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTicks().majorTicks;
  };
  CategoryAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTicks().minorTicks;
  };
  CategoryAxis2.prototype.getLabelsTickPositions = function getLabelsTickPositions() {
    return this.getTicks().labelTicks;
  };
  CategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this.rangeIndices();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var limit = Math.ceil(max2);
    var current4 = Math.floor(min3);
    var indices = [];
    while (current4 <= limit) {
      indices.push(current4);
      current4 += stepSize;
    }
    return indices;
  };
  CategoryAxis2.prototype.getTickPositions = function getTickPositions(stepSize) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min3 = ref$1.min;
    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];
    var indices = this.tickIndices(stepSize);
    var positions = [];
    for (var idx = 0; idx < indices.length; idx++) {
      positions.push(pos + round3(scale * (indices[idx] - min3), COORD_PRECISION));
    }
    return positions;
  };
  CategoryAxis2.prototype.getTicks = function getTicks() {
    var options2 = this.options;
    var cache2 = this._ticks;
    var range = this.rangeIndices();
    var lineBox = this.lineBox();
    var hash = lineBox.getHash() + range.min + "," + range.max + options2.reverse + options2.justified;
    if (cache2._hash !== hash) {
      var hasMinor = options2.minorTicks.visible || options2.minorGridLines.visible;
      cache2._hash = hash;
      cache2.labelTicks = this.getTickPositions(1);
      cache2.majorTicks = this.filterOutOfRangePositions(cache2.labelTicks, lineBox);
      cache2.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];
    }
    return cache2;
  };
  CategoryAxis2.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {
    if (!positions.length) {
      return positions;
    }
    var axis = this.options.vertical ? Y : X;
    var inRange = function(position) {
      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];
    };
    var end = positions.length - 1;
    var startIndex = 0;
    while (!inRange(positions[startIndex]) && startIndex <= end) {
      startIndex++;
    }
    var endIndex = end;
    while (!inRange(positions[endIndex]) && endIndex >= 0) {
      endIndex--;
    }
    return positions.slice(startIndex, endIndex + 1);
  };
  CategoryAxis2.prototype.lineInfo = function lineInfo() {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var lineBox = this.lineBox();
    var lineSize = vertical ? lineBox.height() : lineBox.width();
    var axis = vertical ? Y : X;
    var axisDir = reverse ? -1 : 1;
    var startEdge = axisDir === 1 ? 1 : 2;
    var axisOrigin = axis + startEdge.toString();
    var lineStart = lineBox[axisOrigin];
    return {
      axis,
      axisOrigin,
      axisDir,
      lineBox,
      lineSize,
      lineStart
    };
  };
  CategoryAxis2.prototype.lineDir = function lineDir() {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    return reverse ? -1 : 1;
  };
  CategoryAxis2.prototype.getSlot = function getSlot(from, to, limit) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var justified = options2.justified;
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var box = ref2.box;
    var min3 = ref2.min;
    var ref$1 = this.lineInfo();
    var valueAxis = ref$1.axis;
    var lineStart = ref$1.lineStart;
    var slotBox = box.clone();
    var singleSlot = !defined2(to);
    var start = valueOrDefault2(from, 0);
    var end = valueOrDefault2(to, start);
    end = Math.max(end - 1, start);
    end = Math.max(start, end);
    var p1 = lineStart + (start - min3) * scale;
    var p2 = lineStart + (end + 1 - min3) * scale;
    if (singleSlot && justified) {
      p2 = p1;
    }
    if (limit) {
      p1 = limitValue2(p1, box[valueAxis + 1], box[valueAxis + 2]);
      p2 = limitValue2(p2, box[valueAxis + 1], box[valueAxis + 2]);
    }
    slotBox[valueAxis + 1] = reverse ? p2 : p1;
    slotBox[valueAxis + 2] = reverse ? p1 : p2;
    return slotBox;
  };
  CategoryAxis2.prototype.limitSlot = function limitSlot(slot) {
    var vertical = this.options.vertical;
    var valueAxis = vertical ? Y : X;
    var lineBox = this.lineBox();
    var limittedSlot = slot.clone();
    limittedSlot[valueAxis + 1] = limitValue2(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    limittedSlot[valueAxis + 2] = limitValue2(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);
    return limittedSlot;
  };
  CategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var min3 = Math.floor(this.options.min || 0);
    var start = from;
    var end = to;
    if (typeof start === "string") {
      start = this.categoryIndex(start);
    } else if (isNumber2(start)) {
      start -= min3;
    }
    if (typeof end === "string") {
      end = this.categoryIndex(end);
    } else if (isNumber2(end)) {
      end -= min3;
    }
    return Axis2.prototype.slot.call(this, start, end, limit);
  };
  CategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var min3 = ref$1.min;
    var max2 = ref$1.max;
    var startValue = reverse ? max2 : min3;
    var lineStart = box[valueAxis + 1];
    var lineEnd = box[valueAxis + 2];
    var pos = point2[valueAxis];
    if (pos < lineStart || pos > lineEnd) {
      return null;
    }
    var value = startValue + (pos - lineStart) / scale;
    var diff = value % 1;
    if (justified) {
      value = Math.round(value);
    } else if (diff === 0 && value > 0) {
      value--;
    }
    return Math.floor(value);
  };
  CategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index = this.pointCategoryIndex(point2);
    if (index === null) {
      return null;
    }
    return this.options.categories[index];
  };
  CategoryAxis2.prototype.categoryIndex = function categoryIndex(value) {
    return this.totalIndex(value) - Math.floor(this.options.min || 0);
  };
  CategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    var options2 = this.options;
    return (total3 ? options2.srcCategories : options2.categories)[index];
  };
  CategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return (this.options.categories || []).length;
  };
  CategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var range = options2.categories.length;
    var scale = size / range;
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    return {
      min: offset,
      max: range + offset
    };
  };
  CategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var rangeIndices = this.totalRangeIndices();
    var range = rangeIndices.max - rangeIndices.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min3 = rangeIndices.min + minDelta;
    var max2 = rangeIndices.max - maxDelta;
    if (max2 - min3 < MIN_CATEGORY_RANGE) {
      max2 = min3 + MIN_CATEGORY_RANGE;
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this.totalRange();
    var totalMin = ref2.min;
    var totalMax = ref2.max;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax)
    };
  };
  CategoryAxis2.prototype.labelsCount = function labelsCount() {
    var labelsRange = this.labelsRange();
    return labelsRange.max - labelsRange.min;
  };
  CategoryAxis2.prototype.labelsRange = function labelsRange() {
    var options2 = this.options;
    var justified = options2.justified;
    var labelOptions = options2.labels;
    var ref2 = this.totalRangeIndices(true);
    var min3 = ref2.min;
    var max2 = ref2.max;
    var start = Math.floor(min3);
    if (!justified) {
      min3 = Math.floor(min3);
      max2 = Math.ceil(max2);
    } else {
      min3 = Math.ceil(min3);
      max2 = Math.floor(max2);
    }
    var skip;
    if (min3 > labelOptions.skip) {
      skip = labelOptions.skip + labelOptions.step * Math.ceil((min3 - labelOptions.skip) / labelOptions.step);
    } else {
      skip = labelOptions.skip;
    }
    return {
      min: skip - start,
      max: (options2.categories.length ? max2 + (justified ? 1 : 0) : 0) - start
    };
  };
  CategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var dataItem = options2.dataItems ? options2.dataItems[index] : null;
    var category = valueOrDefault2(options2.categories[index], "");
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(category, labelOptions, labelContext);
    return new axis_label_default(category, text, index, dataItem, labelOptions);
  };
  CategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.totalRangeIndices();
    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);
  };
  CategoryAxis2.prototype.noteSlot = function noteSlot(value) {
    var options2 = this.options;
    var index = value - Math.floor(options2.min || 0);
    return this.getSlot(index);
  };
  CategoryAxis2.prototype.arrangeNotes = function arrangeNotes() {
    Axis2.prototype.arrangeNotes.call(this);
    this.hideOutOfRangeNotes();
  };
  CategoryAxis2.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {
    var ref2 = this;
    var notes2 = ref2.notes;
    var box = ref2.box;
    if (notes2 && notes2.length) {
      var valueAxis = this.options.vertical ? Y : X;
      var start = box[valueAxis + 1];
      var end = box[valueAxis + 2];
      for (var idx = 0; idx < notes2.length; idx++) {
        var note = notes2[idx];
        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {
          note.hide();
        }
      }
    }
  };
  CategoryAxis2.prototype.pan = function pan(delta) {
    var range = this.totalRangeIndices(true);
    var ref2 = this.scaleOptions();
    var scale = ref2.scale;
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    var totalRange = this.totalRange();
    var min3 = range.min + offset;
    var max2 = range.max + offset;
    return this.limitRange(min3, max2, 0, totalRange.max, offset);
  };
  CategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var ref2 = this.options;
    var reverse = ref2.reverse;
    var vertical = ref2.vertical;
    var valueAxis = vertical ? Y : X;
    var range = this.totalRangeIndices(true);
    var ref$1 = this.scaleOptions();
    var scale = ref$1.scale;
    var box = ref$1.box;
    var lineStart = box[valueAxis + (reverse ? 2 : 1)];
    var diffStart = start[valueAxis] - lineStart;
    var diffEnd = end[valueAxis] - lineStart;
    var min3 = range.min + diffStart / scale;
    var max2 = range.min + diffEnd / scale;
    var rangeMin = Math.min(min3, max2);
    var rangeMax = Math.max(min3, max2);
    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {
      return {
        min: rangeMin,
        max: rangeMax
      };
    }
  };
  CategoryAxis2.prototype.valueRange = function valueRange3() {
    return this.range();
  };
  CategoryAxis2.prototype.totalIndex = function totalIndex3(value) {
    var options2 = this.options;
    var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options2.srcCategories);
    return index;
  };
  CategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var options2 = this.options;
    var min3 = 0;
    if (isNumber2(options2.min)) {
      min3 = Math.floor(options2.min);
    }
    var max2;
    if (isNumber2(options2.max)) {
      max2 = options2.justified ? Math.floor(options2.max) : Math.ceil(options2.max) - 1;
    } else {
      max2 = this.totalCount() - 1;
    }
    return {
      min: min3,
      max: max2
    };
  };
  CategoryAxis2.prototype.mapCategories = function mapCategories() {
    if (!this._categoriesMap) {
      var map2 = this._categoriesMap = new hash_map_default();
      var srcCategories = this.options.srcCategories;
      for (var idx = 0; idx < srcCategories.length; idx++) {
        map2.set(srcCategories[idx], idx);
      }
    }
  };
  CategoryAxis2.prototype.totalCount = function totalCount3() {
    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);
  };
  return CategoryAxis2;
}(axis_default);
setDefaultOptions(CategoryAxis, {
  type: "category",
  vertical: false,
  majorGridLines: {
    visible: false,
    width: 1,
    color: BLACK
  },
  labels: {
    zIndex: 1
  },
  justified: false,
  _deferLabels: true
});
var category_axis_default = CategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/constants.js
var COORDINATE_LIMIT = 3e5;
var DateLabelFormats = {
  milliseconds: "HH:mm:ss.fff",
  seconds: "HH:mm:ss",
  minutes: "HH:mm",
  hours: "HH:mm",
  days: "M/d",
  weeks: "M/d",
  months: "MMM 'yy",
  years: "yyyy"
};
var ZERO_THRESHOLD = 0.2;

// node_modules/@progress/kendo-charts/dist/es/core/date-category-axis.js
var AUTO = "auto";
var BASE_UNITS = [
  MILLISECONDS,
  SECONDS,
  MINUTES,
  HOURS,
  DAYS,
  WEEKS,
  MONTHS,
  YEARS
];
var FIT = "fit";
function categoryRange(categories) {
  var range = categories._range;
  if (!range) {
    range = categories._range = sparseArrayLimits(categories);
    range.min = toDate(range.min);
    range.max = toDate(range.max);
  }
  return range;
}
var EmptyDateRange = function EmptyDateRange2(options2) {
  this.options = options2;
};
EmptyDateRange.prototype.displayIndices = function displayIndices() {
  return {
    min: 0,
    max: 1
  };
};
EmptyDateRange.prototype.displayRange = function displayRange() {
  return {};
};
EmptyDateRange.prototype.total = function total() {
  return {};
};
EmptyDateRange.prototype.valueRange = function valueRange() {
  return {};
};
EmptyDateRange.prototype.valueIndex = function valueIndex() {
  return -1;
};
EmptyDateRange.prototype.values = function values3() {
  return [];
};
EmptyDateRange.prototype.totalIndex = function totalIndex() {
  return -1;
};
EmptyDateRange.prototype.valuesCount = function valuesCount() {
  return 0;
};
EmptyDateRange.prototype.totalCount = function totalCount() {
  return 0;
};
EmptyDateRange.prototype.dateAt = function dateAt() {
  return null;
};
var DateRange = function DateRange2(start, end, options2) {
  this.options = options2;
  options2.baseUnitStep = options2.baseUnitStep || 1;
  var roundToBaseUnit = options2.roundToBaseUnit;
  var justified = options2.justified;
  this.start = addDuration(start, 0, options2.baseUnit, options2.weekStartDay);
  var lowerEnd = this.roundToTotalStep(end);
  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options2.justifyEnd;
  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);
  var min3 = options2.min || start;
  this.valueStart = this.roundToTotalStep(min3);
  this.displayStart = roundToBaseUnit ? this.valueStart : min3;
  var max2 = options2.max;
  if (!max2) {
    this.valueEnd = lowerEnd;
    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;
  } else {
    var next = !justified && dateEquals(max2, this.roundToTotalStep(max2)) ? -1 : 0;
    this.valueEnd = this.roundToTotalStep(max2, false, next);
    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max2, !justified) : options2.max;
  }
  if (this.valueEnd < this.valueStart) {
    this.valueEnd = this.valueStart;
  }
  if (this.displayEnd <= this.displayStart) {
    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);
  }
};
DateRange.prototype.displayRange = function displayRange2() {
  return {
    min: this.displayStart,
    max: this.displayEnd
  };
};
DateRange.prototype.displayIndices = function displayIndices2() {
  if (!this._indices) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var baseUnitStep = options2.baseUnitStep;
    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);
    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);
    this._indices = { min: minIdx, max: maxIdx };
  }
  return this._indices;
};
DateRange.prototype.total = function total2() {
  return {
    min: this.start,
    max: this.end
  };
};
DateRange.prototype.totalCount = function totalCount2() {
  var last3 = this.totalIndex(this.end);
  return last3 + (this.options.justified ? 1 : 0);
};
DateRange.prototype.valueRange = function valueRange2() {
  return {
    min: this.valueStart,
    max: this.valueEnd
  };
};
DateRange.prototype.valueIndex = function valueIndex2(value) {
  var options2 = this.options;
  return Math.floor(dateIndex(value, this.valueStart, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.totalIndex = function totalIndex2(value) {
  var options2 = this.options;
  return Math.floor(dateIndex(value, this.start, options2.baseUnit, options2.baseUnitStep));
};
DateRange.prototype.dateIndex = function dateIndex$1(value) {
  var options2 = this.options;
  return dateIndex(value, this.valueStart, options2.baseUnit, options2.baseUnitStep);
};
DateRange.prototype.valuesCount = function valuesCount2() {
  var maxIdx = this.valueIndex(this.valueEnd);
  return maxIdx + 1;
};
DateRange.prototype.values = function values4() {
  var values5 = this._values;
  if (!values5) {
    var options2 = this.options;
    var range = this.valueRange();
    this._values = values5 = [];
    for (var date = range.min; date <= range.max; ) {
      values5.push(date);
      date = addDuration(date, options2.baseUnitStep, options2.baseUnit, options2.weekStartDay);
    }
  }
  return values5;
};
DateRange.prototype.dateAt = function dateAt2(index, total3) {
  var options2 = this.options;
  return addDuration(total3 ? this.start : this.valueStart, options2.baseUnitStep * index, options2.baseUnit, options2.weekStartDay);
};
DateRange.prototype.roundToTotalStep = function roundToTotalStep(value, upper, next) {
  var ref2 = this.options;
  var baseUnit = ref2.baseUnit;
  var baseUnitStep = ref2.baseUnitStep;
  var weekStartDay = ref2.weekStartDay;
  var start = this.start;
  var step = dateIndex(value, start, baseUnit, baseUnitStep);
  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);
  if (next) {
    roundedStep += next;
  }
  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);
};
function autoBaseUnit(options2, startUnit, startStep) {
  var categoryLimits = categoryRange(options2.categories);
  var span = (options2.max || categoryLimits.max) - (options2.min || categoryLimits.min);
  var autoBaseUnitSteps = options2.autoBaseUnitSteps;
  var maxDateGroups = options2.maxDateGroups;
  var autoUnit = options2.baseUnit === FIT;
  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;
  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options2.baseUnit;
  var units = span / TIME_PER_UNIT[baseUnit];
  var totalUnits = units;
  var unitSteps, step, nextStep;
  while (!step || units >= maxDateGroups) {
    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);
    do {
      nextStep = unitSteps.shift();
    } while (nextStep && startUnit === baseUnit && nextStep < startStep);
    if (nextStep) {
      step = nextStep;
      units = totalUnits / step;
    } else if (baseUnit === last2(BASE_UNITS)) {
      step = Math.ceil(totalUnits / maxDateGroups);
      break;
    } else if (autoUnit) {
      baseUnit = BASE_UNITS[autoUnitIx++] || last2(BASE_UNITS);
      totalUnits = span / TIME_PER_UNIT[baseUnit];
      unitSteps = null;
    } else {
      if (units > maxDateGroups) {
        step = Math.ceil(totalUnits / maxDateGroups);
      }
      break;
    }
  }
  options2.baseUnitStep = step;
  options2.baseUnit = baseUnit;
}
function defaultBaseUnit(options2) {
  var categories = options2.categories;
  var count = defined2(categories) ? categories.length : 0;
  var minDiff = MAX_VALUE;
  var lastCategory, unit;
  for (var categoryIx = 0; categoryIx < count; categoryIx++) {
    var category = categories[categoryIx];
    if (category && lastCategory) {
      var diff = absoluteDateDiff(category, lastCategory);
      if (diff > 0) {
        minDiff = Math.min(minDiff, diff);
        if (minDiff >= TIME_PER_YEAR) {
          unit = YEARS;
        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {
          unit = MONTHS;
        } else if (minDiff >= TIME_PER_WEEK) {
          unit = WEEKS;
        } else if (minDiff >= TIME_PER_DAY) {
          unit = DAYS;
        } else if (minDiff >= TIME_PER_HOUR) {
          unit = HOURS;
        } else if (minDiff >= TIME_PER_MINUTE) {
          unit = MINUTES;
        } else {
          unit = SECONDS;
        }
      }
    }
    lastCategory = category;
  }
  options2.baseUnit = unit || DAYS;
}
function initUnit(options2) {
  var baseUnit = (options2.baseUnit || "").toLowerCase();
  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);
  if (useDefault) {
    defaultBaseUnit(options2);
  }
  if (baseUnit === FIT || options2.baseUnitStep === AUTO) {
    autoBaseUnit(options2);
  }
  return options2;
}
var DateCategoryAxis = function(CategoryAxis2) {
  function DateCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    DateCategoryAxis2.__proto__ = CategoryAxis2;
  DateCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  DateCategoryAxis2.prototype.constructor = DateCategoryAxis2;
  DateCategoryAxis2.prototype.clone = function clone2() {
    var copy = new DateCategoryAxis2(Object.assign({}, this.options), this.chartService);
    copy.createLabels();
    return copy;
  };
  DateCategoryAxis2.prototype.categoriesHash = function categoriesHash() {
    var start = this.dataRange.total().min;
    return this.options.baseUnit + this.options.baseUnitStep + start;
  };
  DateCategoryAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    return options2;
  };
  DateCategoryAxis2.prototype.initFields = function initFields() {
    CategoryAxis2.prototype.initFields.call(this);
    var chartService = this.chartService;
    var intlService = chartService.intl;
    var options2 = this.options;
    var categories = options2.categories || [];
    if (!categories._parsed) {
      categories = parseDates(intlService, categories);
      categories._parsed = true;
    }
    options2 = deepExtend({
      roundToBaseUnit: true
    }, options2, {
      categories,
      min: parseDate3(intlService, options2.min),
      max: parseDate3(intlService, options2.max),
      weekStartDay: firstDay2(options2, intlService)
    });
    if (chartService.panning && chartService.isPannable(options2.vertical ? Y : X)) {
      options2.roundToBaseUnit = false;
    }
    options2.userSetBaseUnit = options2.userSetBaseUnit || options2.baseUnit;
    options2.userSetBaseUnitStep = options2.userSetBaseUnitStep || options2.baseUnitStep;
    this.options = options2;
    options2.srcCategories = categories;
    if (categories.length > 0) {
      var range = categoryRange(categories);
      var maxDivisions = options2.maxDivisions;
      this.dataRange = new DateRange(range.min, range.max, initUnit(options2));
      if (maxDivisions) {
        var dataRange = this.dataRange.displayRange();
        var divisionOptions = Object.assign({}, options2, {
          justified: true,
          roundToBaseUnit: false,
          baseUnit: "fit",
          min: dataRange.min,
          max: dataRange.max,
          maxDateGroups: maxDivisions
        });
        var dataRangeOptions = this.dataRange.options;
        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);
        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);
      } else {
        this.divisionRange = this.dataRange;
      }
    } else {
      options2.baseUnit = options2.baseUnit || DAYS;
      this.dataRange = this.divisionRange = new EmptyDateRange(options2);
    }
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.tickIndices = function tickIndices(stepSize) {
    var ref2 = this;
    var dataRange = ref2.dataRange;
    var divisionRange = ref2.divisionRange;
    var valuesCount3 = divisionRange.valuesCount();
    if (!this.options.maxDivisions || !valuesCount3) {
      return CategoryAxis2.prototype.tickIndices.call(this, stepSize);
    }
    var indices = [];
    var values5 = divisionRange.values();
    var offset = 0;
    if (!this.options.justified) {
      values5 = values5.concat(divisionRange.dateAt(valuesCount3));
      offset = 0.5;
    }
    for (var idx = 0; idx < values5.length; idx++) {
      indices.push(dataRange.dateIndex(values5[idx]) + offset);
      if (stepSize !== 1 && idx >= 1) {
        var last3 = indices.length - 1;
        indices.splice(idx, 0, indices[last3 - 1] + (indices[last3] - indices[last3 - 1]) * stepSize);
      }
    }
    return indices;
  };
  DateCategoryAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    var categories = this.options.categories || [];
    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;
  };
  DateCategoryAxis2.prototype.parseNoteValue = function parseNoteValue(value) {
    return parseDate3(this.chartService.intl, value);
  };
  DateCategoryAxis2.prototype.noteSlot = function noteSlot(value) {
    return this.getSlot(value);
  };
  DateCategoryAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var baseUnit = options2.baseUnit;
    var weekStartDay = options2.weekStartDay;
    var vertical = options2.vertical;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / (range.max - range.min);
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    if (range.min && range.max) {
      var from = addTicks(options2.min || range.min, offset);
      var to = addTicks(options2.max || range.max, offset);
      range = {
        min: addDuration(from, 0, baseUnit, weekStartDay),
        max: addDuration(to, 0, baseUnit, weekStartDay)
      };
    }
    return range;
  };
  DateCategoryAxis2.prototype.labelsRange = function labelsRange() {
    return {
      min: this.options.labels.skip,
      max: this.divisionRange.valuesCount()
    };
  };
  DateCategoryAxis2.prototype.pan = function pan(delta) {
    if (this.isEmpty()) {
      return null;
    }
    var options2 = this.options;
    var lineBox = this.lineBox();
    var size = options2.vertical ? lineBox.height() : lineBox.width();
    var ref2 = this.dataRange.displayRange();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var totalLimits = this.dataRange.total();
    var scale = size / (max2 - min3);
    var offset = round3(delta / scale, DEFAULT_PRECISION) * (options2.reverse ? -1 : 1);
    var from = addTicks(min3, offset);
    var to = addTicks(max2, offset);
    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);
    if (panRange) {
      panRange.min = toDate(panRange.min);
      panRange.max = toDate(panRange.max);
      panRange.baseUnit = options2.baseUnit;
      panRange.baseUnitStep = options2.baseUnitStep || 1;
      panRange.userSetBaseUnit = options2.userSetBaseUnit;
      panRange.userSetBaseUnitStep = options2.userSetBaseUnitStep;
      return panRange;
    }
  };
  DateCategoryAxis2.prototype.pointsRange = function pointsRange(start, end) {
    if (this.isEmpty()) {
      return null;
    }
    var pointsRange2 = CategoryAxis2.prototype.pointsRange.call(this, start, end);
    var datesRange = this.dataRange.displayRange();
    var indicesRange = this.dataRange.displayIndices();
    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);
    var options2 = this.options;
    var min3 = addTicks(datesRange.min, pointsRange2.min * scale);
    var max2 = addTicks(datesRange.min, pointsRange2.max * scale);
    return {
      min: min3,
      max: max2,
      baseUnit: options2.userSetBaseUnit || options2.baseUnit,
      baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
    };
  };
  DateCategoryAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    if (this.isEmpty()) {
      return {};
    }
    var options2 = this.options;
    var fit2 = options2.userSetBaseUnit === FIT;
    var totalLimits = this.dataRange.total();
    var ref2 = this.dataRange.displayRange();
    var rangeMin = ref2.min;
    var rangeMax = ref2.max;
    var position = Math.abs(this.pointOffset(cursor));
    var range = rangeMax - rangeMin;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = Math.round(position * delta);
    var maxDelta = Math.round((1 - position) * delta);
    var ref$1 = this.dataRange.options;
    var baseUnit = ref$1.baseUnit;
    var min3 = new Date(rangeMin.getTime() + minDelta);
    var max2 = new Date(rangeMax.getTime() - maxDelta);
    if (fit2) {
      var autoBaseUnitSteps = options2.autoBaseUnitSteps;
      var maxDateGroups = options2.maxDateGroups;
      var maxDiff = last2(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];
      var rangeDiff = dateDiff(rangeMax, rangeMin);
      var diff = dateDiff(max2, min3);
      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);
      var autoBaseUnitStep, ticks;
      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {
        baseUnit = BASE_UNITS[baseUnitIndex - 1];
        autoBaseUnitStep = last2(autoBaseUnitSteps[baseUnit]);
        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;
        min3 = addTicks(rangeMin, ticks);
        max2 = addTicks(rangeMax, -ticks);
      } else if (diff > maxDiff && baseUnit !== YEARS) {
        var stepIndex = 0;
        do {
          baseUnitIndex++;
          baseUnit = BASE_UNITS[baseUnitIndex];
          stepIndex = 0;
          ticks = 2 * TIME_PER_UNIT[baseUnit];
          do {
            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];
            stepIndex++;
          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);
        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);
        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;
        if (ticks > 0) {
          min3 = addTicks(rangeMin, -ticks);
          max2 = addTicks(rangeMax, ticks);
          min3 = addTicks(min3, limitValue2(max2, totalLimits.min, totalLimits.max) - max2);
          max2 = addTicks(max2, limitValue2(min3, totalLimits.min, totalLimits.max) - min3);
        }
      }
    }
    if (min3 && max2 && dateDiff(max2, min3) > 0) {
      return {
        min: min3,
        max: max2,
        baseUnit: options2.userSetBaseUnit || options2.baseUnit,
        baseUnitStep: options2.userSetBaseUnitStep || options2.baseUnitStep
      };
    }
  };
  DateCategoryAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var totalLimits = this.dataRange.total();
    var range = this.scaleRange(scale, cursor);
    if (range) {
      if (range.min < totalLimits.min) {
        range.min = totalLimits.min;
      }
      if (range.max > totalLimits.max) {
        range.max = totalLimits.max;
      }
    }
    return range;
  };
  DateCategoryAxis2.prototype.range = function range() {
    return this.dataRange.displayRange();
  };
  DateCategoryAxis2.prototype.createLabels = function createLabels() {
    CategoryAxis2.prototype.createLabels.call(this);
    this.createRangeLabels();
  };
  DateCategoryAxis2.prototype.clearLabels = function clearLabels() {
    CategoryAxis2.prototype.clearLabels.call(this);
    this.rangeLabels = [];
  };
  DateCategoryAxis2.prototype.arrangeLabels = function arrangeLabels() {
    this.arrangeRangeLabels();
    CategoryAxis2.prototype.arrangeLabels.call(this);
  };
  DateCategoryAxis2.prototype.arrangeRangeLabels = function arrangeRangeLabels() {
    var ref2 = this;
    var options2 = ref2.options;
    var rangeLabels = ref2.rangeLabels;
    if (rangeLabels.length === 0) {
      return;
    }
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var mirror = options2.rangeLabels.mirror || options2.labels.mirror;
    var firstLabel = rangeLabels[0];
    if (firstLabel) {
      var position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;
      this.positionLabel(firstLabel, mirror, position);
    }
    var lastLabel = rangeLabels[1];
    if (lastLabel) {
      var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;
      this.positionLabel(lastLabel, mirror, position$1);
    }
  };
  DateCategoryAxis2.prototype.autoRotateLabels = function autoRotateLabels() {
    CategoryAxis2.prototype.autoRotateLabels.call(this);
    this.autoRotateRangeLabels();
  };
  DateCategoryAxis2.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {
    CategoryAxis2.prototype.hideOutOfRangeLabels.call(this);
    this.hideOverlappingLabels();
  };
  DateCategoryAxis2.prototype.hideOverlappingLabels = function hideOverlappingLabels() {
    var ref2 = this;
    var rangeLabels = ref2.rangeLabels;
    var labels = ref2.labels;
    if (rangeLabels.length === 0) {
      return;
    }
    function clip(rangeLabel, label) {
      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {
        label.options.visible = false;
        return true;
      }
      return false;
    }
    var firstRangeLabel = rangeLabels[0];
    if (firstRangeLabel && firstRangeLabel.options.visible) {
      for (var i = 0; i < labels.length; i++) {
        var overlaps = clip(firstRangeLabel, labels[i]);
        if (!overlaps) {
          break;
        }
      }
    }
    var lastRangeLabel = rangeLabels[1];
    if (lastRangeLabel && lastRangeLabel.options.visible) {
      for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {
        var overlaps$1 = clip(lastRangeLabel, labels[i$1]);
        if (!overlaps$1) {
          break;
        }
      }
    }
  };
  DateCategoryAxis2.prototype.contentBox = function contentBox() {
    var box = CategoryAxis2.prototype.contentBox.call(this);
    var rangeLabels = this.rangeLabels;
    for (var i = 0; i < rangeLabels.length; i++) {
      var label = rangeLabels[i];
      if (label.options.visible) {
        box.wrap(label.box);
      }
    }
    return box;
  };
  DateCategoryAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    if (labelContext === void 0)
      labelContext = {};
    var options2 = this.options;
    var dataItem = options2.dataItems && !options2.maxDivisions ? options2.dataItems[index] : null;
    var date = this.divisionRange.dateAt(index);
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    labelContext.dataItem = dataItem;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    if (text) {
      return new axis_label_default(date, text, index, dataItem, labelOptions);
    }
  };
  DateCategoryAxis2.prototype.createRangeLabels = function createRangeLabels() {
    var this$1 = this;
    var ref2 = this.divisionRange;
    var displayStart = ref2.displayStart;
    var displayEnd = ref2.displayEnd;
    var options2 = this.options;
    var labelOptions = Object.assign({}, options2.labels, options2.rangeLabels, {
      align: CENTER,
      zIndex: options2.zIndex
    });
    if (labelOptions.visible !== true) {
      return;
    }
    this.normalizeLabelRotation(labelOptions);
    labelOptions.alignRotation = CENTER;
    if (labelOptions.rotation === "auto") {
      labelOptions.rotation = 0;
      options2.autoRotateRangeLabels = true;
    }
    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var createLabel = function(index, date, text) {
      if (text) {
        var label = new axis_label_default(date, text, index, null, labelOptions);
        this$1.append(label);
        this$1.rangeLabels.push(label);
      }
    };
    var startText = this.axisLabelText(displayStart, labelOptions, { index: 0, count: 2 });
    createLabel(0, displayStart, startText);
    var endText = this.axisLabelText(displayEnd, labelOptions, { index: 1, count: 2 });
    createLabel(1, displayEnd, endText);
  };
  DateCategoryAxis2.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {
    var this$1 = this;
    var labels = this.rangeLabels;
    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {
      return;
    }
    var rotateLabel = function(label, tickPositions2, index) {
      var width = Math.abs(tickPositions2[index + 1] - tickPositions2[index]) * 2;
      var angle = this$1.autoRotateLabelAngle(label.box, width);
      if (angle !== 0) {
        label.options.rotation = angle;
        label.reflow(new box_default());
      }
    };
    var tickPositions = this.getMajorTickPositions();
    rotateLabel(labels[0], tickPositions, 0);
    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);
  };
  DateCategoryAxis2.prototype.categoryIndex = function categoryIndex(value) {
    return this.dataRange.valueIndex(value);
  };
  DateCategoryAxis2.prototype.slot = function slot(from, to, limit) {
    var dateRange = this.dataRange;
    var start = from;
    var end = to;
    if (start instanceof Date) {
      start = dateRange.dateIndex(start);
    }
    if (end instanceof Date) {
      end = dateRange.dateIndex(end);
    }
    var slot2 = this.getSlot(start, end, limit);
    if (slot2) {
      return slot2.toRect();
    }
  };
  DateCategoryAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var start = a;
    var end = b;
    if (typeof start === OBJECT) {
      start = this.categoryIndex(start);
    }
    if (typeof end === OBJECT) {
      end = this.categoryIndex(end);
    }
    return CategoryAxis2.prototype.getSlot.call(this, start, end, limit);
  };
  DateCategoryAxis2.prototype.valueRange = function valueRange3() {
    var options2 = this.options;
    var range = categoryRange(options2.srcCategories);
    return {
      min: toDate(range.min),
      max: toDate(range.max)
    };
  };
  DateCategoryAxis2.prototype.categoryAt = function categoryAt(index, total3) {
    return this.dataRange.dateAt(index, total3);
  };
  DateCategoryAxis2.prototype.categoriesCount = function categoriesCount2() {
    return this.dataRange.valuesCount();
  };
  DateCategoryAxis2.prototype.rangeIndices = function rangeIndices() {
    return this.dataRange.displayIndices();
  };
  DateCategoryAxis2.prototype.labelsBetweenTicks = function labelsBetweenTicks() {
    return !this.divisionRange.options.justified;
  };
  DateCategoryAxis2.prototype.prepareUserOptions = function prepareUserOptions() {
    if (this.isEmpty()) {
      return;
    }
    this.options.categories = this.dataRange.values();
  };
  DateCategoryAxis2.prototype.getCategory = function getCategory(point2) {
    var index = this.pointCategoryIndex(point2);
    if (index === null) {
      return null;
    }
    return this.dataRange.dateAt(index);
  };
  DateCategoryAxis2.prototype.totalIndex = function totalIndex3(value) {
    return this.dataRange.totalIndex(value);
  };
  DateCategoryAxis2.prototype.currentRangeIndices = function currentRangeIndices() {
    var range = this.dataRange.valueRange();
    return {
      min: this.dataRange.totalIndex(range.min),
      max: this.dataRange.totalIndex(range.max)
    };
  };
  DateCategoryAxis2.prototype.totalRange = function totalRange() {
    return this.dataRange.total();
  };
  DateCategoryAxis2.prototype.totalCount = function totalCount3() {
    return this.dataRange.totalCount();
  };
  DateCategoryAxis2.prototype.isEmpty = function isEmpty() {
    return !this.options.srcCategories.length;
  };
  DateCategoryAxis2.prototype.roundedRange = function roundedRange() {
    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {
      return this.range();
    }
    var options2 = this.options;
    var datesRange = categoryRange(options2.srcCategories);
    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options2, {
      justified: false,
      roundToBaseUnit: true,
      justifyEnd: false
    }));
    return dateRange.displayRange();
  };
  return DateCategoryAxis2;
}(category_axis_default);
setDefaultOptions(DateCategoryAxis, {
  type: DATE,
  labels: {
    dateFormats: DateLabelFormats
  },
  rangeLabels: {
    visible: false
  },
  autoBaseUnitSteps: {
    milliseconds: [1, 10, 100],
    seconds: [1, 2, 5, 15, 30],
    minutes: [1, 2, 5, 15, 30],
    hours: [1, 2, 3],
    days: [1, 2, 3],
    weeks: [1, 2],
    months: [1, 2, 3, 6],
    years: [1, 2, 3, 5, 10, 25, 50]
  },
  maxDateGroups: 10
});
var date_category_axis_default = DateCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-min.js
function autoAxisMin(min3, max2, narrow) {
  if (!min3 && !max2) {
    return 0;
  }
  var axisMin;
  if (min3 >= 0 && max2 >= 0) {
    var minValue = min3 === max2 ? 0 : min3;
    var diff = (max2 - minValue) / max2;
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMin = Math.max(0, minValue - (max2 - minValue) / 2);
  } else {
    axisMin = min3;
  }
  return axisMin;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/auto-axis-max.js
function autoAxisMax(min3, max2, narrow) {
  if (!min3 && !max2) {
    return 1;
  }
  var axisMax;
  if (min3 <= 0 && max2 <= 0) {
    var maxValue = min3 === max2 ? 0 : max2;
    var diff = Math.abs((maxValue - min3) / maxValue);
    if (narrow === false || !narrow && diff > ZERO_THRESHOLD) {
      return 0;
    }
    axisMax = Math.min(0, maxValue - (min3 - maxValue) / 2);
  } else {
    axisMax = max2;
  }
  return axisMax;
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/floor.js
function floor(value, step) {
  return round3(Math.floor(value / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/ceil.js
function ceil(value, step) {
  return round3(Math.ceil(value / step) * step, DEFAULT_PRECISION);
}

// node_modules/@progress/kendo-charts/dist/es/core/utils/limit-coordinate.js
function limitCoordinate(value) {
  return Math.max(Math.min(value, COORDINATE_LIMIT), -COORDINATE_LIMIT);
}

// node_modules/@progress/kendo-charts/dist/es/core/numeric-axis.js
var MIN_VALUE_RANGE = Math.pow(10, -DEFAULT_PRECISION + 1);
var NumericAxis = function(Axis2) {
  function NumericAxis2(seriesMin, seriesMax, options2, chartService) {
    Axis2.call(this, Object.assign({}, options2, {
      seriesMin,
      seriesMax
    }), chartService);
  }
  if (Axis2)
    NumericAxis2.__proto__ = Axis2;
  NumericAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  NumericAxis2.prototype.constructor = NumericAxis2;
  NumericAxis2.prototype.initUserOptions = function initUserOptions(options2) {
    var autoOptions = autoAxisOptions(options2.seriesMin, options2.seriesMax, options2);
    this.totalOptions = totalAxisOptions(autoOptions, options2);
    return axisOptions(autoOptions, options2);
  };
  NumericAxis2.prototype.initFields = function initFields() {
    this.totalMin = this.totalOptions.min;
    this.totalMax = this.totalOptions.max;
    this.totalMajorUnit = this.totalOptions.majorUnit;
    this.seriesMin = this.options.seriesMin;
    this.seriesMax = this.options.seriesMax;
  };
  NumericAxis2.prototype.clone = function clone2() {
    return new NumericAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  NumericAxis2.prototype.startValue = function startValue() {
    return 0;
  };
  NumericAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  NumericAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    if (stepValue === 0) {
      return 1;
    }
    var options2 = this.options;
    var range = options2.max - options2.min;
    return Math.floor(round3(range / stepValue, COORD_PRECISION)) + 1;
  };
  NumericAxis2.prototype.getTickPositions = function getTickPositions(unit, skipUnit) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axisDir = ref2.axisDir;
    var axisOrigin = ref2.axisOrigin;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var range = options2.max - options2.min;
    var scale = lineSize / range;
    var step = unit * scale;
    var divisions = this.getDivisions(unit);
    var positions = [];
    var pos = lineBox[axisOrigin];
    var skipStep = 0;
    if (skipUnit) {
      skipStep = skipUnit / unit;
    }
    for (var idx = 0; idx < divisions; idx++) {
      if (idx % skipStep !== 0) {
        positions.push(round3(pos, COORD_PRECISION));
      }
      pos = pos + step * axisDir;
    }
    return positions;
  };
  NumericAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  NumericAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  NumericAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    if (limit === void 0)
      limit = false;
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var axis = ref2.axis;
    var axisDir = ref2.axisDir;
    var lineBox = ref2.lineBox;
    var lineSize = ref2.lineSize;
    var lineStart = ref2.lineStart;
    var step = axisDir * (lineSize / (options2.max - options2.min));
    var start = valueOrDefault2(a, b || 0);
    var end = valueOrDefault2(b, a || 0);
    if (limit) {
      start = limitValue2(start, options2.min, options2.max);
      end = limitValue2(end, options2.min, options2.max);
    }
    var p1 = Math.min(start, end) - options2.min;
    var p2 = Math.max(start, end) - options2.min;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  NumericAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var max2 = Number(options2.max);
    var min3 = Number(options2.min);
    var offset = this.pointOffset(point2);
    var valueOffset = offset * (max2 - min3);
    if (offset < 0 || offset > 1) {
      return null;
    }
    var value = min3 + valueOffset;
    return round3(value, DEFAULT_PRECISION);
  };
  NumericAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var max2 = options2.max;
    var min3 = options2.min;
    var ref2 = this.lineInfo();
    var lineSize = ref2.lineSize;
    var range = max2 - min3;
    var scale = lineSize / range;
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: min3 + offset,
      max: max2 + offset,
      offset
    };
  };
  NumericAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  NumericAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var value = round3(options2.min + index * options2.majorUnit, DEFAULT_PRECISION);
    var text = this.axisLabelText(value, labelOptions, labelContext);
    return new axis_label_default(value, text, index, null, labelOptions);
  };
  NumericAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return range.min <= value && value <= range.max;
  };
  NumericAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  NumericAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    if (this.isValidRange(min3, max2)) {
      return {
        min: min3,
        max: max2
      };
    }
  };
  NumericAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min3 = round3(this.options.min + minDelta, DEFAULT_PRECISION);
    var max2 = round3(this.options.max - maxDelta, DEFAULT_PRECISION);
    if (max2 - min3 < MIN_VALUE_RANGE) {
      max2 = min3 + MIN_VALUE_RANGE;
    }
    return {
      min: min3,
      max: max2
    };
  };
  NumericAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    var range = this.scaleRange(scale, cursor);
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax),
      narrowRange: false
    };
  };
  NumericAxis2.prototype.isValidRange = function isValidRange(min3, max2) {
    return max2 - min3 > MIN_VALUE_RANGE;
  };
  return NumericAxis2;
}(axis_default);
function autoAxisOptions(seriesMin, seriesMax, options2) {
  var narrowRange = options2.narrowRange;
  var autoMin = autoAxisMin(seriesMin, seriesMax, narrowRange);
  var autoMax = autoAxisMax(seriesMin, seriesMax, narrowRange);
  var majorUnit = autoMajorUnit(autoMin, autoMax);
  var autoOptions = {
    majorUnit
  };
  if (options2.roundToMajorUnit !== false) {
    if (autoMin < 0 && remainderClose(autoMin, majorUnit, 1 / 3)) {
      autoMin -= majorUnit;
    }
    if (autoMax > 0 && remainderClose(autoMax, majorUnit, 1 / 3)) {
      autoMax += majorUnit;
    }
  }
  autoOptions.min = floor(autoMin, majorUnit);
  autoOptions.max = ceil(autoMax, majorUnit);
  return autoOptions;
}
function totalAxisOptions(autoOptions, options2) {
  return {
    min: defined2(options2.min) ? Math.min(autoOptions.min, options2.min) : autoOptions.min,
    max: defined2(options2.max) ? Math.max(autoOptions.max, options2.max) : autoOptions.max,
    majorUnit: autoOptions.majorUnit
  };
}
function clearNullValues(options2, fields) {
  for (var idx = 0; idx < fields.length; idx++) {
    var field = fields[idx];
    if (options2[field] === null) {
      options2[field] = void 0;
    }
  }
}
function axisOptions(autoOptions, userOptions) {
  var options2 = userOptions;
  var userSetMin, userSetMax;
  if (userOptions) {
    clearNullValues(userOptions, ["min", "max"]);
    userSetMin = defined2(userOptions.min);
    userSetMax = defined2(userOptions.max);
    var userSetLimits = userSetMin || userSetMax;
    if (userSetLimits) {
      if (userOptions.min === userOptions.max) {
        if (userOptions.min > 0) {
          userOptions.min = 0;
        } else {
          userOptions.max = 1;
        }
      }
    }
    if (userOptions.majorUnit) {
      autoOptions.min = floor(autoOptions.min, userOptions.majorUnit);
      autoOptions.max = ceil(autoOptions.max, userOptions.majorUnit);
    } else if (userSetLimits) {
      options2 = deepExtend(autoOptions, userOptions);
      autoOptions.majorUnit = autoMajorUnit(options2.min, options2.max);
    }
  }
  autoOptions.minorUnit = (options2.majorUnit || autoOptions.majorUnit) / 5;
  var result = deepExtend(autoOptions, options2);
  if (result.min >= result.max) {
    if (userSetMin && !userSetMax) {
      result.max = result.min + result.majorUnit;
    } else if (!userSetMin && userSetMax) {
      result.min = result.max - result.majorUnit;
    }
  }
  return result;
}
function remainderClose(value, divisor, ratio) {
  var remainder = round3(Math.abs(value % divisor), DEFAULT_PRECISION);
  var threshold = divisor * (1 - ratio);
  return remainder === 0 || remainder > threshold;
}
setDefaultOptions(NumericAxis, {
  type: "numeric",
  min: 0,
  max: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    format: "#.####################"
  },
  zIndex: 1
});
var numeric_axis_default = NumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/date-value-axis.js
var MIN_VALUE_RANGE2 = 1e3;
var DateValueAxis = function(Axis2) {
  function DateValueAxis2(seriesMin, seriesMax, axisOptions2, chartService) {
    var min3 = toDate(seriesMin);
    var max2 = toDate(seriesMax);
    var intlService = chartService.intl;
    var options2 = axisOptions2 || {};
    options2 = deepExtend(options2 || {}, {
      min: parseDate3(intlService, options2.min),
      max: parseDate3(intlService, options2.max),
      axisCrossingValue: parseDates(intlService, options2.axisCrossingValues || options2.axisCrossingValue),
      weekStartDay: firstDay2(options2, intlService)
    });
    options2 = applyDefaults(min3, max2, options2);
    Axis2.call(this, options2, chartService);
    this.intlService = intlService;
    this.seriesMin = min3;
    this.seriesMax = max2;
    var weekStartDay = options2.weekStartDay || 0;
    this.totalMin = toTime(floorDate(toTime(min3) - 1, options2.baseUnit, weekStartDay));
    this.totalMax = toTime(ceilDate(toTime(max2) + 1, options2.baseUnit, weekStartDay));
  }
  if (Axis2)
    DateValueAxis2.__proto__ = Axis2;
  DateValueAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  DateValueAxis2.prototype.constructor = DateValueAxis2;
  DateValueAxis2.prototype.clone = function clone2() {
    return new DateValueAxis2(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);
  };
  DateValueAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  DateValueAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    var options2 = this.options;
    return Math.floor(
      duration(options2.min, options2.max, options2.baseUnit) / stepValue + 1
    );
  };
  DateValueAxis2.prototype.getTickPositions = function getTickPositions(step) {
    var options2 = this.options;
    var ref2 = this.lineInfo();
    var dir = ref2.axisDir;
    var lineSize = ref2.lineSize;
    var start = ref2.lineStart;
    var divisions = this.getDivisions(step);
    var timeRange = dateDiff(options2.max, options2.min);
    var scale = lineSize / timeRange;
    var weekStartDay = options2.weekStartDay || 0;
    var positions = [start];
    for (var i = 1; i < divisions; i++) {
      var date = addDuration(options2.min, i * step, options2.baseUnit, weekStartDay);
      var pos = start + dateDiff(date, options2.min) * scale * dir;
      positions.push(round3(pos, COORD_PRECISION));
    }
    return positions;
  };
  DateValueAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.getMinorTickPositions = function getMinorTickPositions() {
    return this.getTickPositions(this.options.minorUnit);
  };
  DateValueAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    return numeric_axis_default.prototype.getSlot.call(
      this,
      parseDate3(this.intlService, a),
      parseDate3(this.intlService, b),
      limit
    );
  };
  DateValueAxis2.prototype.getValue = function getValue(point2) {
    var value = numeric_axis_default.prototype.getValue.call(this, point2);
    return value !== null ? toDate(value) : null;
  };
  DateValueAxis2.prototype.labelsCount = function labelsCount() {
    return this.getDivisions(this.options.majorUnit);
  };
  DateValueAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var options2 = this.options;
    var offset = index * options2.majorUnit;
    var weekStartDay = options2.weekStartDay || 0;
    var date = options2.min;
    if (offset > 0) {
      date = addDuration(date, offset, options2.baseUnit, weekStartDay);
    }
    var unitFormat = labelOptions.dateFormats[options2.baseUnit];
    labelOptions.format = labelOptions.format || unitFormat;
    var text = this.axisLabelText(date, labelOptions, labelContext);
    return new axis_label_default(date, text, index, null, labelOptions);
  };
  DateValueAxis2.prototype.translateRange = function translateRange(delta) {
    var options2 = this.options;
    var lineBox = this.lineBox();
    var vertical = options2.vertical;
    var reverse = options2.reverse;
    var size = vertical ? lineBox.height() : lineBox.width();
    var range = this.range();
    var scale = size / dateDiff(range.max, range.min);
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    var from = addTicks(options2.min, offset);
    var to = addTicks(options2.max, offset);
    return {
      min: from,
      max: to,
      offset
    };
  };
  DateValueAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0;
  };
  DateValueAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta, true);
    var limittedRange = this.limitRange(toTime(range.min), toTime(range.max), this.totalMin, this.totalMax, range.offset);
    if (limittedRange) {
      return {
        min: toDate(limittedRange.min),
        max: toDate(limittedRange.max)
      };
    }
  };
  DateValueAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: toDate(min3),
      max: toDate(max2)
    };
  };
  DateValueAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var position = Math.abs(this.pointOffset(cursor));
    var range = this.options.max - this.options.min;
    var delta = this.scaleToDelta(scale, range);
    var minDelta = position * delta;
    var maxDelta = (1 - position) * delta;
    var min3 = toDate(toTime(this.options.min) + minDelta);
    var max2 = toDate(toTime(this.options.max) - maxDelta);
    if (max2 - min3 < MIN_VALUE_RANGE2) {
      max2 = toDate(toTime(min3) + MIN_VALUE_RANGE2);
    }
    return {
      min: min3,
      max: max2
    };
  };
  DateValueAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var min3 = toDate(limitValue2(toTime(range.min), this.totalMin, this.totalMax));
    var max2 = toDate(limitValue2(toTime(range.max), this.totalMin, this.totalMax));
    return {
      min: min3,
      max: max2
    };
  };
  return DateValueAxis2;
}(axis_default);
function timeUnits(delta) {
  var unit = HOURS;
  if (delta >= TIME_PER_YEAR) {
    unit = YEARS;
  } else if (delta >= TIME_PER_MONTH) {
    unit = MONTHS;
  } else if (delta >= TIME_PER_WEEK) {
    unit = WEEKS;
  } else if (delta >= TIME_PER_DAY) {
    unit = DAYS;
  }
  return unit;
}
function applyDefaults(seriesMin, seriesMax, options2) {
  var min3 = options2.min || seriesMin;
  var max2 = options2.max || seriesMax;
  var baseUnit = options2.baseUnit || (max2 && min3 ? timeUnits(absoluteDateDiff(max2, min3)) : HOURS);
  var baseUnitTime = TIME_PER_UNIT[baseUnit];
  var weekStartDay = options2.weekStartDay || 0;
  var autoMin = floorDate(toTime(min3) - 1, baseUnit, weekStartDay) || toDate(max2);
  var autoMax = ceilDate(toTime(max2) + 1, baseUnit, weekStartDay);
  var userMajorUnit = options2.majorUnit ? options2.majorUnit : void 0;
  var majorUnit = userMajorUnit || ceil(
    autoMajorUnit(autoMin.getTime(), autoMax.getTime()),
    baseUnitTime
  ) / baseUnitTime;
  var actualUnits = duration(autoMin, autoMax, baseUnit);
  var totalUnits = ceil(actualUnits, majorUnit);
  var unitsToAdd = totalUnits - actualUnits;
  var head = Math.floor(unitsToAdd / 2);
  var tail = unitsToAdd - head;
  if (!options2.baseUnit) {
    delete options2.baseUnit;
  }
  options2.baseUnit = options2.baseUnit || baseUnit;
  options2.min = options2.min || addDuration(autoMin, -head, baseUnit, weekStartDay);
  options2.max = options2.max || addDuration(autoMax, tail, baseUnit, weekStartDay);
  options2.minorUnit = options2.minorUnit || majorUnit / 5;
  options2.majorUnit = majorUnit;
  return options2;
}
setDefaultOptions(DateValueAxis, {
  type: DATE,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  labels: {
    dateFormats: DateLabelFormats
  }
});
var date_value_axis_default = DateValueAxis;

// node_modules/@progress/kendo-charts/dist/es/core/logarithmic-axis.js
var DEFAULT_MAJOR_UNIT = 10;
var MIN_VALUE_RANGE3 = 1e-6;
var LogarithmicAxis = function(Axis2) {
  function LogarithmicAxis2(seriesMin, seriesMax, options2, chartService) {
    var axisOptions2 = deepExtend({ majorUnit: DEFAULT_MAJOR_UNIT, min: seriesMin, max: seriesMax }, options2);
    var base = axisOptions2.majorUnit;
    var autoMax = autoAxisMax2(seriesMax, base);
    var autoMin = autoAxisMin2(seriesMin, seriesMax, axisOptions2);
    var range = initRange(autoMin, autoMax, axisOptions2, options2);
    axisOptions2.max = range.max;
    axisOptions2.min = range.min;
    axisOptions2.minorUnit = options2.minorUnit || round3(base - 1, DEFAULT_PRECISION);
    Axis2.call(this, axisOptions2, chartService);
    this.totalMin = defined2(options2.min) ? Math.min(autoMin, options2.min) : autoMin;
    this.totalMax = defined2(options2.max) ? Math.max(autoMax, options2.max) : autoMax;
    this.logMin = round3(log(range.min, base), DEFAULT_PRECISION);
    this.logMax = round3(log(range.max, base), DEFAULT_PRECISION);
    this.seriesMin = seriesMin;
    this.seriesMax = seriesMax;
    this.createLabels();
  }
  if (Axis2)
    LogarithmicAxis2.__proto__ = Axis2;
  LogarithmicAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  LogarithmicAxis2.prototype.constructor = LogarithmicAxis2;
  LogarithmicAxis2.prototype.clone = function clone2() {
    return new LogarithmicAxis2(
      this.seriesMin,
      this.seriesMax,
      Object.assign({}, this.options),
      this.chartService
    );
  };
  LogarithmicAxis2.prototype.startValue = function startValue() {
    return this.options.min;
  };
  LogarithmicAxis2.prototype.getSlot = function getSlot(a, b, limit) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var min3 = options2.min;
    var max2 = options2.max;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineBox = ref$1.lineBox;
    var lineSize = ref$1.lineSize;
    var lineStart = ref$1.lineStart;
    var step = axisDir * (lineSize / (logMax - logMin));
    var start = valueOrDefault2(a, b || 1);
    var end = valueOrDefault2(b, a || 1);
    if (start <= 0 || end <= 0) {
      return null;
    }
    if (limit) {
      start = limitValue2(start, min3, max2);
      end = limitValue2(end, min3, max2);
    }
    start = log(start, base);
    end = log(end, base);
    var p1 = Math.min(start, end) - logMin;
    var p2 = Math.max(start, end) - logMin;
    var slotBox = new box_default(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);
    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));
    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));
    return slotBox;
  };
  LogarithmicAxis2.prototype.getValue = function getValue(point2) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var base = options2.majorUnit;
    var ref$1 = this.lineInfo();
    var axis = ref$1.axis;
    var axisDir = ref$1.axisDir;
    var lineStart = ref$1.lineStart;
    var lineSize = ref$1.lineSize;
    var step = (logMax - logMin) / lineSize;
    var offset = axisDir * (point2[axis] - lineStart);
    var valueOffset = offset * step;
    if (offset < 0 || offset > lineSize) {
      return null;
    }
    var value = logMin + valueOffset;
    return round3(Math.pow(base, value), DEFAULT_PRECISION);
  };
  LogarithmicAxis2.prototype.range = function range() {
    var options2 = this.options;
    return { min: options2.min, max: options2.max };
  };
  LogarithmicAxis2.prototype.translateRange = function translateRange(delta) {
    var ref2 = this;
    var options2 = ref2.options;
    var logMin = ref2.logMin;
    var logMax = ref2.logMax;
    var reverse = options2.reverse;
    var vertical = options2.vertical;
    var base = options2.majorUnit;
    var lineBox = this.lineBox();
    var size = vertical ? lineBox.height() : lineBox.width();
    var scale = size / (logMax - logMin);
    var offset = round3(delta / scale, DEFAULT_PRECISION);
    if ((vertical || reverse) && !(vertical && reverse)) {
      offset = -offset;
    }
    return {
      min: Math.pow(base, logMin + offset),
      max: Math.pow(base, logMax + offset),
      offset
    };
  };
  LogarithmicAxis2.prototype.labelsCount = function labelsCount() {
    var floorMax = Math.floor(this.logMax);
    var count = Math.floor(floorMax - this.logMin) + 1;
    return count;
  };
  LogarithmicAxis2.prototype.getMajorTickPositions = function getMajorTickPositions() {
    var ticks = [];
    this.traverseMajorTicksPositions(function(position) {
      ticks.push(position);
    }, { step: 1, skip: 0 });
    return ticks;
  };
  LogarithmicAxis2.prototype.createTicks = function createTicks(lineGroup) {
    var options2 = this.options;
    var majorTicks = options2.majorTicks;
    var minorTicks = options2.minorTicks;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var lineBox = this.lineBox();
    var ticks = [];
    var tickLineOptions = {
      // TODO
      // _alignLines: options._alignLines,
      vertical
    };
    function render3(tickPosition, tickOptions) {
      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickLineOptions.position = tickPosition;
      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));
    }
    if (majorTicks.visible) {
      this.traverseMajorTicksPositions(render3, majorTicks);
    }
    if (minorTicks.visible) {
      this.traverseMinorTicksPositions(render3, minorTicks);
    }
    return ticks;
  };
  LogarithmicAxis2.prototype.createGridLines = function createGridLines(altAxis) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var vertical = options2.vertical;
    var lineBox = altAxis.lineBox();
    var lineOptions = {
      lineStart: lineBox[vertical ? "x1" : "y1"],
      lineEnd: lineBox[vertical ? "x2" : "y2"],
      vertical
    };
    var majorTicks = [];
    var container = this.gridLinesVisual();
    function render3(tickPosition, gridLine) {
      if (!inArray(tickPosition, majorTicks)) {
        lineOptions.position = tickPosition;
        container.append(createAxisGridLine(lineOptions, gridLine));
        majorTicks.push(tickPosition);
      }
    }
    if (majorGridLines.visible) {
      this.traverseMajorTicksPositions(render3, majorGridLines);
    }
    if (minorGridLines.visible) {
      this.traverseMinorTicksPositions(render3, minorGridLines);
    }
    return container.children;
  };
  LogarithmicAxis2.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {
    var ref2 = this.lineInfo();
    var lineStart = ref2.lineStart;
    var step = ref2.step;
    var ref$1 = this;
    var logMin = ref$1.logMin;
    var logMax = ref$1.logMax;
    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {
      var position = round3(lineStart + step * (power - logMin), DEFAULT_PRECISION);
      callback(position, tickOptions);
    }
  };
  LogarithmicAxis2.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {
    var this$1 = this;
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var ref$1 = this.lineInfo();
    var lineStart = ref$1.lineStart;
    var step = ref$1.step;
    var ref$2 = this;
    var logMin = ref$2.logMin;
    var logMax = ref$2.logMax;
    var start = Math.floor(logMin);
    for (var power = start; power < logMax; power++) {
      var minorOptions = this$1._minorIntervalOptions(power);
      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {
        var value = minorOptions.value + idx * minorOptions.minorStep;
        if (value > max2) {
          break;
        }
        if (value >= min3) {
          var position = round3(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);
          callback(position, tickOptions);
        }
      }
    }
  };
  LogarithmicAxis2.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {
    var power = Math.ceil(this.logMin + index);
    var value = Math.pow(this.options.majorUnit, power);
    var text = this.axisLabelText(value, labelOptions, labelContext);
    return new axis_label_default(value, text, index, null, labelOptions);
  };
  LogarithmicAxis2.prototype.shouldRenderNote = function shouldRenderNote(value) {
    var range = this.range();
    return range.min <= value && value <= range.max;
  };
  LogarithmicAxis2.prototype.pan = function pan(delta) {
    var range = this.translateRange(delta);
    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);
  };
  LogarithmicAxis2.prototype.pointsRange = function pointsRange(start, end) {
    var startValue = this.getValue(start);
    var endValue = this.getValue(end);
    var min3 = Math.min(startValue, endValue);
    var max2 = Math.max(startValue, endValue);
    return {
      min: min3,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.scaleRange = function scaleRange(scale, cursor) {
    var ref2 = this.options;
    var base = ref2.majorUnit;
    var logMin = log(this.options.min, base);
    var logMax = log(this.options.max, base);
    var position = Math.abs(this.pointOffset(cursor));
    var range = logMax - logMin;
    var delta = this.scaleToDelta(scale, range);
    var min3 = Math.pow(base, logMin + position * delta);
    var max2 = Math.pow(base, logMax - (1 - position) * delta);
    if (max2 - min3 < MIN_VALUE_RANGE3) {
      max2 = min3 + MIN_VALUE_RANGE3;
    }
    return {
      min: min3,
      max: max2
    };
  };
  LogarithmicAxis2.prototype.zoomRange = function zoomRange(scale, cursor) {
    var range = this.scaleRange(scale, cursor);
    var ref2 = this;
    var totalMin = ref2.totalMin;
    var totalMax = ref2.totalMax;
    return {
      min: limitValue2(range.min, totalMin, totalMax),
      max: limitValue2(range.max, totalMin, totalMax)
    };
  };
  LogarithmicAxis2.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {
    var ref2 = this.options;
    var minorUnit = ref2.minorUnit;
    var base = ref2.majorUnit;
    var value = Math.pow(base, power);
    var nextValue = Math.pow(base, power + 1);
    var difference = nextValue - value;
    var minorStep = difference / minorUnit;
    return {
      value,
      minorStep
    };
  };
  LogarithmicAxis2.prototype.lineInfo = function lineInfo() {
    var info = Axis2.prototype.lineInfo.call(this);
    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));
    return info;
  };
  return LogarithmicAxis2;
}(axis_default);
function initRange(autoMin, autoMax, axisOptions2, options2) {
  var min3 = axisOptions2.min;
  var max2 = axisOptions2.max;
  if (defined2(axisOptions2.axisCrossingValue) && axisOptions2.axisCrossingValue <= 0) {
    throwNegativeValuesError();
  }
  if (!defined2(options2.max)) {
    max2 = autoMax;
  } else if (options2.max <= 0) {
    throwNegativeValuesError();
  }
  if (!defined2(options2.min)) {
    min3 = autoMin;
  } else if (options2.min <= 0) {
    throwNegativeValuesError();
  }
  return {
    min: min3,
    max: max2
  };
}
function autoAxisMin2(min3, max2, options2) {
  var base = options2.majorUnit;
  var autoMin = min3;
  if (min3 <= 0) {
    autoMin = max2 <= 1 ? Math.pow(base, -2) : 1;
  } else if (!options2.narrowRange) {
    autoMin = Math.pow(base, Math.floor(log(min3, base)));
  }
  return autoMin;
}
function autoAxisMax2(max2, base) {
  var logMaxRemainder = round3(log(max2, base), DEFAULT_PRECISION) % 1;
  var autoMax;
  if (max2 <= 0) {
    autoMax = base;
  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {
    autoMax = Math.pow(base, log(max2, base) + 0.2);
  } else {
    autoMax = Math.pow(base, Math.ceil(log(max2, base)));
  }
  return autoMax;
}
function throwNegativeValuesError() {
  throw new Error("Non positive values cannot be used for a logarithmic axis");
}
function log(x, base) {
  return Math.log(x) / Math.log(base);
}
setDefaultOptions(LogarithmicAxis, {
  type: "log",
  majorUnit: DEFAULT_MAJOR_UNIT,
  minorUnit: 1,
  axisCrossingValue: 1,
  vertical: true,
  majorGridLines: {
    visible: true,
    width: 1,
    color: BLACK
  },
  zIndex: 1,
  _deferLabels: true
});
var logarithmic_axis_default = LogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/grid-lines-mixin.js
var GridLinesMixin = {
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var radius = Math.abs(this.box.center().y - altAxis.lineBox().y1);
    var gridLines = [];
    var skipMajor = false;
    var majorAngles, minorAngles;
    if (options2.majorGridLines.visible) {
      majorAngles = this.majorGridLineAngles(altAxis);
      skipMajor = true;
      gridLines = this.renderMajorGridLines(
        majorAngles,
        radius,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      minorAngles = this.minorGridLineAngles(altAxis, skipMajor);
      append2(gridLines, this.renderMinorGridLines(
        minorAngles,
        radius,
        options2.minorGridLines,
        altAxis,
        skipMajor
      ));
    }
    return gridLines;
  },
  renderMajorGridLines: function(angles, radius, options2) {
    return this.renderGridLines(angles, radius, options2);
  },
  renderMinorGridLines: function(angles, radius, options2, altAxis, skipMajor) {
    var radiusCallback = this.radiusCallback && this.radiusCallback(radius, altAxis, skipMajor);
    return this.renderGridLines(angles, radius, options2, radiusCallback);
  },
  renderGridLines: function(angles, radius, options2, radiusCallback) {
    var style = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var center = this.box.center();
    var circle = new geometry_exports.Circle([center.x, center.y], radius);
    var container = this.gridLinesVisual();
    for (var i = 0; i < angles.length; i++) {
      var line = new drawing_exports.Path(style);
      if (radiusCallback) {
        circle.radius = radiusCallback(angles[i]);
      }
      line.moveTo(circle.center).lineTo(circle.pointAt(angles[i] + 180));
      container.append(line);
    }
    return container.children;
  },
  gridLineAngles: function(altAxis, size, skip, step, skipAngles) {
    var this$1 = this;
    var divs = this.intervals(size, skip, step, skipAngles);
    var options2 = altAxis.options;
    var altAxisVisible = options2.visible && (options2.line || {}).visible !== false;
    return map(divs, function(d) {
      var alpha = this$1.intervalAngle(d);
      if (!altAxisVisible || alpha !== 90) {
        return alpha;
      }
    });
  }
};
var grid_lines_mixin_default = GridLinesMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-category-axis.js
var RadarCategoryAxis = function(CategoryAxis2) {
  function RadarCategoryAxis2() {
    CategoryAxis2.apply(this, arguments);
  }
  if (CategoryAxis2)
    RadarCategoryAxis2.__proto__ = CategoryAxis2;
  RadarCategoryAxis2.prototype = Object.create(CategoryAxis2 && CategoryAxis2.prototype);
  RadarCategoryAxis2.prototype.constructor = RadarCategoryAxis2;
  RadarCategoryAxis2.prototype.range = function range() {
    return { min: 0, max: this.options.categories.length };
  };
  RadarCategoryAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  RadarCategoryAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  RadarCategoryAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(skip + i * step).adjacentBox(
        0,
        labelBox.width(),
        labelBox.height()
      ));
    }
  };
  RadarCategoryAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var options2 = this.options;
    var categories = options2.categories.length;
    var divCount = categories / size || 1;
    var divAngle = 360 / divCount;
    var skip = skipOption || 0;
    var step = stepOption || 1;
    var divs = [];
    var angle = 0;
    for (var i = skip; i < divCount; i += step) {
      if (options2.reverse) {
        angle = 360 - i * divAngle;
      } else {
        angle = i * divAngle;
      }
      angle = round3(angle, COORD_PRECISION) % 360;
      if (!(skipAngles && inArray(angle, skipAngles))) {
        divs.push(angle);
      }
    }
    return divs;
  };
  RadarCategoryAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(1);
  };
  RadarCategoryAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(0.5);
  };
  RadarCategoryAxis2.prototype.intervalAngle = function intervalAngle(interval) {
    return (360 + interval + this.options.startAngle) % 360;
  };
  RadarCategoryAxis2.prototype.majorAngles = function majorAngles() {
    var this$1 = this;
    return map(this.majorIntervals(), function(interval) {
      return this$1.intervalAngle(interval);
    });
  };
  RadarCategoryAxis2.prototype.createLine = function createLine() {
    return [];
  };
  RadarCategoryAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, 1, majorGridLines.skip, majorGridLines.step);
  };
  RadarCategoryAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var ref2 = this.options;
    var minorGridLines = ref2.minorGridLines;
    var majorGridLines = ref2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(1, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, 0.5, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  RadarCategoryAxis2.prototype.radiusCallback = function radiusCallback(radius, altAxis, skipMajor) {
    if (altAxis.options.type !== ARC) {
      var minorAngle = rad2(360 / (this.options.categories.length * 2));
      var minorRadius = Math.cos(minorAngle) * radius;
      var majorAngles = this.majorAngles();
      var radiusCallback2 = function(angle) {
        if (!skipMajor && inArray(angle, majorAngles)) {
          return radius;
        }
        return minorRadius;
      };
      return radiusCallback2;
    }
  };
  RadarCategoryAxis2.prototype.createPlotBands = function createPlotBands() {
    var this$1 = this;
    var plotBands = this.options.plotBands || [];
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var slot = this$1.plotBandSlot(band);
      var singleSlot = this$1.getSlot(band.from);
      var head = band.from - Math.floor(band.from);
      slot.startAngle += head * singleSlot.angle;
      var tail = Math.ceil(band.to) - band.to;
      slot.angle -= (tail + head) * singleSlot.angle;
      var ring = shape_builder_default.current.createRing(slot, {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      });
      group.append(ring);
    }
    this.appendVisual(group);
  };
  RadarCategoryAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to - 1);
  };
  RadarCategoryAxis2.prototype.getSlot = function getSlot(from, to) {
    var options2 = this.options;
    var justified = options2.justified;
    var box = this.box;
    var divs = this.majorAngles();
    var totalDivs = divs.length;
    var slotAngle = 360 / totalDivs;
    var fromValue = from;
    if (options2.reverse && !justified) {
      fromValue = (fromValue + 1) % totalDivs;
    }
    fromValue = limitValue2(Math.floor(fromValue), 0, totalDivs - 1);
    var slotStart = divs[fromValue];
    if (justified) {
      slotStart = slotStart - slotAngle / 2;
      if (slotStart < 0) {
        slotStart += 360;
      }
    }
    var toValue = limitValue2(Math.ceil(to || fromValue), fromValue, totalDivs - 1);
    var slots = toValue - fromValue + 1;
    var angle = slotAngle * slots;
    return new ring_default(box.center(), 0, box.height() / 2, slotStart, angle);
  };
  RadarCategoryAxis2.prototype.slot = function slot(from, to) {
    var slot2 = this.getSlot(from, to);
    var startAngle = slot2.startAngle + 180;
    var endAngle = startAngle + slot2.angle;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  RadarCategoryAxis2.prototype.pointCategoryIndex = function pointCategoryIndex(point2) {
    var this$1 = this;
    var length = this.options.categories.length;
    var index = null;
    for (var i = 0; i < length; i++) {
      var slot = this$1.getSlot(i);
      if (slot.containsPoint(point2)) {
        index = i;
        break;
      }
    }
    return index;
  };
  return RadarCategoryAxis2;
}(category_axis_default);
setDefaultOptions(RadarCategoryAxis, {
  startAngle: 90,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    visible: true
  },
  justified: true
});
deepExtend(RadarCategoryAxis.prototype, grid_lines_mixin_default);
var radar_category_axis_default = RadarCategoryAxis;

// node_modules/@progress/kendo-charts/dist/es/core/polar-axis.js
var PolarAxis = function(Axis2) {
  function PolarAxis2(options2, chartService) {
    Axis2.call(this, options2, chartService);
    var instanceOptions = this.options;
    instanceOptions.minorUnit = instanceOptions.minorUnit || instanceOptions.majorUnit / 2;
  }
  if (Axis2)
    PolarAxis2.__proto__ = Axis2;
  PolarAxis2.prototype = Object.create(Axis2 && Axis2.prototype);
  PolarAxis2.prototype.constructor = PolarAxis2;
  PolarAxis2.prototype.getDivisions = function getDivisions(stepValue) {
    return numeric_axis_default.prototype.getDivisions.call(this, stepValue) - 1;
  };
  PolarAxis2.prototype.reflow = function reflow(box) {
    this.box = box;
    this.reflowLabels();
  };
  PolarAxis2.prototype.reflowLabels = function reflowLabels() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var labels = ref2.labels;
    var labelOptions = ref2.options.labels;
    var skip = labelOptions.skip || 0;
    var step = labelOptions.step || 1;
    var measureBox = new box_default();
    var divs = this.intervals(options2.majorUnit, skip, step);
    for (var i = 0; i < labels.length; i++) {
      labels[i].reflow(measureBox);
      var labelBox = labels[i].box;
      labels[i].reflow(this$1.getSlot(divs[i]).adjacentBox(0, labelBox.width(), labelBox.height()));
    }
  };
  PolarAxis2.prototype.lineBox = function lineBox() {
    return this.box;
  };
  PolarAxis2.prototype.intervals = function intervals(size, skipOption, stepOption, skipAngles) {
    if (skipAngles === void 0)
      skipAngles = false;
    var min3 = this.options.min;
    var divisions = this.getDivisions(size);
    var divs = [];
    var skip = skipOption || 0;
    var step = stepOption || 1;
    for (var i = skip; i < divisions; i += step) {
      var current4 = (360 + min3 + i * size) % 360;
      if (!(skipAngles && inArray(current4, skipAngles))) {
        divs.push(current4);
      }
    }
    return divs;
  };
  PolarAxis2.prototype.majorIntervals = function majorIntervals() {
    return this.intervals(this.options.majorUnit);
  };
  PolarAxis2.prototype.minorIntervals = function minorIntervals() {
    return this.intervals(this.options.minorUnit);
  };
  PolarAxis2.prototype.intervalAngle = function intervalAngle(i) {
    return (540 - i - this.options.startAngle) % 360;
  };
  PolarAxis2.prototype.createLine = function createLine() {
    return [];
  };
  PolarAxis2.prototype.majorGridLineAngles = function majorGridLineAngles(altAxis) {
    var majorGridLines = this.options.majorGridLines;
    return this.gridLineAngles(altAxis, this.options.majorUnit, majorGridLines.skip, majorGridLines.step);
  };
  PolarAxis2.prototype.minorGridLineAngles = function minorGridLineAngles(altAxis, skipMajor) {
    var options2 = this.options;
    var minorGridLines = options2.minorGridLines;
    var majorGridLines = options2.majorGridLines;
    var majorGridLineAngles = skipMajor ? this.intervals(options2.majorUnit, majorGridLines.skip, majorGridLines.step) : null;
    return this.gridLineAngles(altAxis, options2.minorUnit, minorGridLines.skip, minorGridLines.step, majorGridLineAngles);
  };
  PolarAxis2.prototype.plotBandSlot = function plotBandSlot(band) {
    return this.getSlot(band.from, band.to);
  };
  PolarAxis2.prototype.getSlot = function getSlot(a, b) {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var startAngle = options2.startAngle;
    var start = limitValue2(a, options2.min, options2.max);
    var end = limitValue2(b || start, start, options2.max);
    if (options2.reverse) {
      start *= -1;
      end *= -1;
    }
    start = (540 - start - startAngle) % 360;
    end = (540 - end - startAngle) % 360;
    if (end < start) {
      var tmp = start;
      start = end;
      end = tmp;
    }
    return new ring_default(box.center(), 0, box.height() / 2, start, end - start);
  };
  PolarAxis2.prototype.slot = function slot(from, to) {
    if (to === void 0)
      to = from;
    var options2 = this.options;
    var start = 360 - options2.startAngle;
    var slot2 = this.getSlot(from, to);
    var min3 = Math.min(from, to);
    var max2 = Math.max(from, to);
    var startAngle, endAngle;
    if (options2.reverse) {
      startAngle = min3;
      endAngle = max2;
    } else {
      startAngle = 360 - max2;
      endAngle = 360 - min3;
    }
    startAngle = (startAngle + start) % 360;
    endAngle = (endAngle + start) % 360;
    return new geometry_exports.Arc([slot2.center.x, slot2.center.y], {
      startAngle,
      endAngle,
      radiusX: slot2.radius,
      radiusY: slot2.radius
    });
  };
  PolarAxis2.prototype.getValue = function getValue(point2) {
    var options2 = this.options;
    var center = this.box.center();
    var dx = point2.x - center.x;
    var dy = point2.y - center.y;
    var theta = Math.round(deg2(Math.atan2(dy, dx)));
    var start = options2.startAngle;
    if (!options2.reverse) {
      theta *= -1;
      start *= -1;
    }
    return (theta + start + 360) % 360;
  };
  PolarAxis2.prototype.valueRange = function valueRange3() {
    return {
      min: 0,
      max: Math.PI * 2
    };
  };
  return PolarAxis2;
}(axis_default);
setDefaultOptions(PolarAxis, {
  type: "polar",
  startAngle: 0,
  reverse: false,
  majorUnit: 60,
  min: 0,
  max: 360,
  labels: {
    margin: getSpacing(10)
  },
  majorGridLines: {
    color: BLACK,
    visible: true,
    width: 1
  },
  minorGridLines: {
    color: "#aaa"
  }
});
deepExtend(PolarAxis.prototype, grid_lines_mixin_default, {
  createPlotBands: radar_category_axis_default.prototype.createPlotBands,
  majorAngles: radar_category_axis_default.prototype.majorAngles,
  range: numeric_axis_default.prototype.range,
  labelsCount: numeric_axis_default.prototype.labelsCount,
  createAxisLabel: numeric_axis_default.prototype.createAxisLabel
});
var polar_axis_default = PolarAxis;

// node_modules/@progress/kendo-charts/dist/es/core/mixins/radar-numeric-axis-mixin.js
var RadarNumericAxisMixin = {
  options: {
    majorGridLines: {
      visible: true
    }
  },
  createPlotBands: function() {
    var this$1 = this;
    var ref2 = this.options;
    var type = ref2.majorGridLines.type;
    var plotBands = ref2.plotBands;
    if (plotBands === void 0)
      plotBands = [];
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var group = this._plotbandGroup = new drawing_exports.Group({
      zIndex: -1
    });
    for (var i = 0; i < plotBands.length; i++) {
      var band = plotBands[i];
      var bandStyle = {
        fill: {
          color: band.color,
          opacity: band.opacity
        },
        stroke: {
          opacity: band.opacity
        }
      };
      var slot = this$1.getSlot(band.from, band.to, true);
      var ring = new ring_default(center, center.y - slot.y2, center.y - slot.y1, 0, 360);
      var shape2 = void 0;
      if (type === ARC) {
        shape2 = shape_builder_default.current.createRing(ring, bandStyle);
      } else {
        shape2 = drawing_exports.Path.fromPoints(this$1.plotBandPoints(ring, majorAngles), bandStyle).close();
      }
      group.append(shape2);
    }
    this.appendVisual(group);
  },
  plotBandPoints: function(ring, angles) {
    var innerPoints = [];
    var outerPoints = [];
    var center = [ring.center.x, ring.center.y];
    var innerCircle = new geometry_exports.Circle(center, ring.innerRadius);
    var outerCircle = new geometry_exports.Circle(center, ring.radius);
    for (var i = 0; i < angles.length; i++) {
      innerPoints.push(innerCircle.pointAt(angles[i] + 180));
      outerPoints.push(outerCircle.pointAt(angles[i] + 180));
    }
    innerPoints.reverse();
    innerPoints.push(innerPoints[0]);
    outerPoints.push(outerPoints[0]);
    return outerPoints.concat(innerPoints);
  },
  createGridLines: function(altAxis) {
    var options2 = this.options;
    var majorTicks = this.radarMajorGridLinePositions();
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var gridLines = [];
    if (options2.majorGridLines.visible) {
      gridLines = this.renderGridLines(
        center,
        majorTicks,
        majorAngles,
        options2.majorGridLines
      );
    }
    if (options2.minorGridLines.visible) {
      var minorTicks = this.radarMinorGridLinePositions();
      append2(gridLines, this.renderGridLines(
        center,
        minorTicks,
        majorAngles,
        options2.minorGridLines
      ));
    }
    return gridLines;
  },
  renderGridLines: function(center, ticks, angles, options2) {
    var style = {
      stroke: {
        width: options2.width,
        color: options2.color,
        dashType: options2.dashType
      }
    };
    var skip = options2.skip;
    if (skip === void 0)
      skip = 0;
    var step = options2.step;
    if (step === void 0)
      step = 0;
    var container = this.gridLinesVisual();
    for (var tickIx = skip; tickIx < ticks.length; tickIx += step) {
      var tickRadius = center.y - ticks[tickIx];
      if (tickRadius > 0) {
        var circle = new geometry_exports.Circle([center.x, center.y], tickRadius);
        if (options2.type === ARC) {
          container.append(new drawing_exports.Circle(circle, style));
        } else {
          var line = new drawing_exports.Path(style);
          for (var angleIx = 0; angleIx < angles.length; angleIx++) {
            line.lineTo(circle.pointAt(angles[angleIx] + 180));
          }
          line.close();
          container.append(line);
        }
      }
    }
    return container.children;
  },
  getValue: function(point2) {
    var lineBox = this.lineBox();
    var altAxis = this.plotArea.polarAxis;
    var majorAngles = altAxis.majorAngles();
    var center = altAxis.box.center();
    var radius = point2.distanceTo(center);
    var distance = radius;
    if (this.options.majorGridLines.type !== ARC && majorAngles.length > 1) {
      var dx = point2.x - center.x;
      var dy = point2.y - center.y;
      var theta = (deg2(Math.atan2(dy, dx)) + 540) % 360;
      majorAngles.sort(function(a, b) {
        return angularDistance(a, theta) - angularDistance(b, theta);
      });
      var midAngle = angularDistance(majorAngles[0], majorAngles[1]) / 2;
      var alpha = angularDistance(theta, majorAngles[0]);
      var gamma = 90 - midAngle;
      var beta = 180 - alpha - gamma;
      distance = radius * (Math.sin(rad2(beta)) / Math.sin(rad2(gamma)));
    }
    return this.axisType().prototype.getValue.call(
      this,
      new point_default2(lineBox.x1, lineBox.y2 - distance)
    );
  }
};
function angularDistance(a, b) {
  return 180 - Math.abs(Math.abs(a - b) - 180);
}
var radar_numeric_axis_mixin_default = RadarNumericAxisMixin;

// node_modules/@progress/kendo-charts/dist/es/core/radar-numeric-axis.js
var RadarNumericAxis = function(NumericAxis2) {
  function RadarNumericAxis2() {
    NumericAxis2.apply(this, arguments);
  }
  if (NumericAxis2)
    RadarNumericAxis2.__proto__ = NumericAxis2;
  RadarNumericAxis2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadarNumericAxis2.prototype.constructor = RadarNumericAxis2;
  RadarNumericAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    return this.getTickPositions(this.options.majorUnit);
  };
  RadarNumericAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var options2 = this.options;
    var minorSkipStep = 0;
    if (options2.majorGridLines.visible) {
      minorSkipStep = options2.majorUnit;
    }
    return this.getTickPositions(options2.minorUnit, minorSkipStep);
  };
  RadarNumericAxis2.prototype.axisType = function axisType() {
    return NumericAxis2;
  };
  return RadarNumericAxis2;
}(numeric_axis_default);
deepExtend(RadarNumericAxis.prototype, radar_numeric_axis_mixin_default);
var radar_numeric_axis_default = RadarNumericAxis;

// node_modules/@progress/kendo-charts/dist/es/core/radar-logarithmic-axis.js
var RadarLogarithmicAxis = function(LogarithmicAxis2) {
  function RadarLogarithmicAxis2() {
    LogarithmicAxis2.apply(this, arguments);
  }
  if (LogarithmicAxis2)
    RadarLogarithmicAxis2.__proto__ = LogarithmicAxis2;
  RadarLogarithmicAxis2.prototype = Object.create(LogarithmicAxis2 && LogarithmicAxis2.prototype);
  RadarLogarithmicAxis2.prototype.constructor = RadarLogarithmicAxis2;
  RadarLogarithmicAxis2.prototype.radarMajorGridLinePositions = function radarMajorGridLinePositions() {
    var positions = [];
    this.traverseMajorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.majorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.radarMinorGridLinePositions = function radarMinorGridLinePositions() {
    var positions = [];
    this.traverseMinorTicksPositions(function(position) {
      positions.push(position);
    }, this.options.minorGridLines);
    return positions;
  };
  RadarLogarithmicAxis2.prototype.axisType = function axisType() {
    return LogarithmicAxis2;
  };
  return RadarLogarithmicAxis2;
}(logarithmic_axis_default);
deepExtend(RadarLogarithmicAxis.prototype, radar_numeric_axis_mixin_default);
var radar_logarithmic_axis_default = RadarLogarithmicAxis;

// node_modules/@progress/kendo-charts/dist/es/core/curve-processor.js
var WEIGHT2 = 0.333;
var EXTREMUM_ALLOWED_DEVIATION2 = 0.01;
var CurveProcessor = function(Class3) {
  function CurveProcessor2(closed) {
    Class3.call(this);
    this.closed = closed;
  }
  if (Class3)
    CurveProcessor2.__proto__ = Class3;
  CurveProcessor2.prototype = Object.create(Class3 && Class3.prototype);
  CurveProcessor2.prototype.constructor = CurveProcessor2;
  CurveProcessor2.prototype.process = function process2(dataPoints) {
    var this$1 = this;
    var points3 = dataPoints.slice(0);
    var segments = [];
    var closed = this.closed;
    var length = points3.length;
    if (length > 2) {
      this.removeDuplicates(0, points3);
      length = points3.length;
    }
    if (length < 2 || length === 2 && points3[0].equals(points3[1])) {
      return segments;
    }
    var p0 = points3[0];
    var p1 = points3[1];
    var p2 = points3[2];
    segments.push(new geometry_exports.Segment(p0));
    while (p0.equals(points3[length - 1])) {
      closed = true;
      points3.pop();
      length--;
    }
    if (length === 2) {
      var tangent = this.tangent(p0, p1, X, Y);
      last2(segments).controlOut(
        this.firstControlPoint(tangent, p0, p1, X, Y)
      );
      segments.push(new geometry_exports.Segment(
        p1,
        this.secondControlPoint(tangent, p0, p1, X, Y)
      ));
      return segments;
    }
    var initialControlPoint, lastControlPoint;
    if (closed) {
      p0 = points3[length - 1];
      p1 = points3[0];
      p2 = points3[1];
      var controlPoints = this.controlPoints(p0, p1, p2);
      initialControlPoint = controlPoints[1];
      lastControlPoint = controlPoints[0];
    } else {
      var tangent$1 = this.tangent(p0, p1, X, Y);
      initialControlPoint = this.firstControlPoint(tangent$1, p0, p1, X, Y);
    }
    var cp0 = initialControlPoint;
    for (var idx = 0; idx <= length - 3; idx++) {
      this$1.removeDuplicates(idx, points3);
      length = points3.length;
      if (idx + 3 <= length) {
        p0 = points3[idx];
        p1 = points3[idx + 1];
        p2 = points3[idx + 2];
        var controlPoints$1 = this$1.controlPoints(p0, p1, p2);
        last2(segments).controlOut(cp0);
        cp0 = controlPoints$1[1];
        var cp1 = controlPoints$1[0];
        segments.push(new geometry_exports.Segment(p1, cp1));
      }
    }
    if (closed) {
      p0 = points3[length - 2];
      p1 = points3[length - 1];
      p2 = points3[0];
      var controlPoints$2 = this.controlPoints(p0, p1, p2);
      last2(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p1,
        controlPoints$2[0]
      ));
      last2(segments).controlOut(controlPoints$2[1]);
      segments.push(new geometry_exports.Segment(
        p2,
        lastControlPoint
      ));
    } else {
      var tangent$2 = this.tangent(p1, p2, X, Y);
      last2(segments).controlOut(cp0);
      segments.push(new geometry_exports.Segment(
        p2,
        this.secondControlPoint(tangent$2, p1, p2, X, Y)
      ));
    }
    return segments;
  };
  CurveProcessor2.prototype.removeDuplicates = function removeDuplicates2(idx, points3) {
    while (points3[idx + 1] && (points3[idx].equals(points3[idx + 1]) || points3[idx + 1].equals(points3[idx + 2]))) {
      points3.splice(idx + 1, 1);
    }
  };
  CurveProcessor2.prototype.invertAxis = function invertAxis2(p0, p1, p2) {
    var invertAxis3 = false;
    if (p0.x === p1.x) {
      invertAxis3 = true;
    } else if (p1.x === p2.x) {
      if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {
        invertAxis3 = true;
      }
    } else {
      var fn = this.lineFunction(p0, p1);
      var y2 = this.calculateFunction(fn, p2.x);
      if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {
        invertAxis3 = true;
      }
    }
    return invertAxis3;
  };
  CurveProcessor2.prototype.isLine = function isLine2(p0, p1, p2) {
    var fn = this.lineFunction(p0, p1);
    var y2 = this.calculateFunction(fn, p2.x);
    return p0.x === p1.x && p1.x === p2.x || round3(y2, 1) === round3(p2.y, 1);
  };
  CurveProcessor2.prototype.lineFunction = function lineFunction2(p1, p2) {
    var a = (p2.y - p1.y) / (p2.x - p1.x);
    var b = p1.y - a * p1.x;
    return [b, a];
  };
  CurveProcessor2.prototype.controlPoints = function controlPoints(p0, p1, p2) {
    var xField = X;
    var yField = Y;
    var restrict = false;
    var switchOrientation = false;
    var tangent;
    if (this.isLine(p0, p1, p2)) {
      tangent = this.tangent(p0, p1, X, Y);
    } else {
      var monotonic = {
        x: this.isMonotonicByField(p0, p1, p2, X),
        y: this.isMonotonicByField(p0, p1, p2, Y)
      };
      if (monotonic.x && monotonic.y) {
        tangent = this.tangent(p0, p2, X, Y);
        restrict = true;
      } else {
        if (this.invertAxis(p0, p1, p2)) {
          xField = Y;
          yField = X;
        }
        if (monotonic[xField]) {
          tangent = 0;
        } else {
          var sign;
          if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {
            sign = numberSign3((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));
          } else {
            sign = -numberSign3((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));
          }
          tangent = EXTREMUM_ALLOWED_DEVIATION2 * sign;
          switchOrientation = true;
        }
      }
    }
    var secondControlPoint2 = this.secondControlPoint(tangent, p0, p1, xField, yField);
    if (switchOrientation) {
      var oldXField = xField;
      xField = yField;
      yField = oldXField;
    }
    var firstControlPoint2 = this.firstControlPoint(tangent, p1, p2, xField, yField);
    if (restrict) {
      this.restrictControlPoint(p0, p1, secondControlPoint2, tangent);
      this.restrictControlPoint(p1, p2, firstControlPoint2, tangent);
    }
    return [secondControlPoint2, firstControlPoint2];
  };
  CurveProcessor2.prototype.restrictControlPoint = function restrictControlPoint2(p1, p2, cp, tangent) {
    if (p1.y < p2.y) {
      if (p2.y < cp.y) {
        cp.x = p1.x + (p2.y - p1.y) / tangent;
        cp.y = p2.y;
      } else if (cp.y < p1.y) {
        cp.x = p2.x - (p2.y - p1.y) / tangent;
        cp.y = p1.y;
      }
    } else {
      if (cp.y < p2.y) {
        cp.x = p1.x - (p1.y - p2.y) / tangent;
        cp.y = p2.y;
      } else if (p1.y < cp.y) {
        cp.x = p2.x + (p1.y - p2.y) / tangent;
        cp.y = p1.y;
      }
    }
  };
  CurveProcessor2.prototype.tangent = function tangent(p0, p1, xField, yField) {
    var x = p1[xField] - p0[xField];
    var y = p1[yField] - p0[yField];
    var tangent2;
    if (x === 0) {
      tangent2 = 0;
    } else {
      tangent2 = y / x;
    }
    return tangent2;
  };
  CurveProcessor2.prototype.isMonotonicByField = function isMonotonicByField2(p0, p1, p2, field) {
    return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];
  };
  CurveProcessor2.prototype.firstControlPoint = function firstControlPoint2(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT2;
    return this.point(t1 + distance, p0[yField] + distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.secondControlPoint = function secondControlPoint2(tangent, p0, p3, xField, yField) {
    var t1 = p0[xField];
    var t2 = p3[xField];
    var distance = (t2 - t1) * WEIGHT2;
    return this.point(t2 - distance, p3[yField] - distance * tangent, xField, yField);
  };
  CurveProcessor2.prototype.point = function point2(xValue, yValue, xField, yField) {
    var controlPoint = new geometry_exports.Point();
    controlPoint[xField] = xValue;
    controlPoint[yField] = yValue;
    return controlPoint;
  };
  CurveProcessor2.prototype.calculateFunction = function calculateFunction2(fn, x) {
    var length = fn.length;
    var result = 0;
    for (var i = 0; i < length; i++) {
      result += Math.pow(x, i) * fn[i];
    }
    return result;
  };
  return CurveProcessor2;
}(class_default);
function numberSign3(value) {
  return value <= 0 ? -1 : 1;
}
var curve_processor_default = CurveProcessor;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-axis.js
var ChartAxis = function(Class3) {
  function ChartAxis2(axis) {
    Class3.call(this);
    this._axis = axis;
    this.options = axis.options;
  }
  if (Class3)
    ChartAxis2.__proto__ = Class3;
  ChartAxis2.prototype = Object.create(Class3 && Class3.prototype);
  ChartAxis2.prototype.constructor = ChartAxis2;
  ChartAxis2.prototype.value = function value(point2) {
    var axis = this._axis;
    var value2 = axis.getCategory ? axis.getCategory(point2) : axis.getValue(point2);
    return value2;
  };
  ChartAxis2.prototype.slot = function slot(from, to, limit) {
    if (limit === void 0)
      limit = true;
    return this._axis.slot(from, to, limit);
  };
  ChartAxis2.prototype.range = function range() {
    return this._axis.range();
  };
  ChartAxis2.prototype.valueRange = function valueRange3() {
    return this._axis.valueRange();
  };
  return ChartAxis2;
}(class_default);
var chart_axis_default = ChartAxis;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/find-axis-by-name.js
function findAxisByName(name3, axes) {
  for (var idx = 0; idx < axes.length; idx++) {
    if (axes[idx].options.name === name3) {
      axes[idx].prepareUserOptions();
      return new chart_axis_default(axes[idx]);
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-pane.js
var ChartPane = function ChartPane2(pane) {
  this.visual = pane.visual;
  this.chartsVisual = pane.chartContainer.visual;
  this._pane = pane;
};
ChartPane.prototype.findAxisByName = function findAxisByName$1(name3) {
  return findAxisByName(name3, this._pane.axes);
};
var chart_pane_default = ChartPane;

// node_modules/@progress/kendo-charts/dist/es/chart/api-elements/chart-plotarea.js
var ChartPlotArea = function(Class3) {
  function ChartPlotArea2(plotArea) {
    Class3.call(this);
    this._plotArea = plotArea;
    this.visual = plotArea.visual;
    this.backgroundVisual = plotArea._bgVisual;
  }
  if (Class3)
    ChartPlotArea2.__proto__ = Class3;
  ChartPlotArea2.prototype = Object.create(Class3 && Class3.prototype);
  ChartPlotArea2.prototype.constructor = ChartPlotArea2;
  return ChartPlotArea2;
}(class_default);
var chart_plotarea_default = ChartPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/count-numbers.js
function countNumbers(values5) {
  var length = values5.length;
  var count = 0;
  for (var i = 0; i < length; i++) {
    var num = values5[i];
    if (isNumber2(num)) {
      count++;
    }
  }
  return count;
}

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/aggregates.js
var Aggregates = {
  min: function(values5) {
    var length = values5.length;
    var min3 = MAX_VALUE;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        min3 = Math.min(min3, value);
      }
    }
    return min3 === MAX_VALUE ? values5[0] : min3;
  },
  max: function(values5) {
    var length = values5.length;
    var max2 = MIN_VALUE;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        max2 = Math.max(max2, value);
      }
    }
    return max2 === MIN_VALUE ? values5[0] : max2;
  },
  sum: function(values5) {
    var length = values5.length;
    var sum = 0;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (isNumber2(value)) {
        sum += value;
      }
    }
    return sum;
  },
  sumOrNull: function(values5) {
    var result = null;
    if (countNumbers(values5)) {
      result = Aggregates.sum(values5);
    }
    return result;
  },
  count: function(values5) {
    var length = values5.length;
    var count = 0;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (value !== null && defined2(value)) {
        count++;
      }
    }
    return count;
  },
  avg: function(values5) {
    var count = countNumbers(values5);
    var result = values5[0];
    if (count > 0) {
      result = Aggregates.sum(values5) / count;
    }
    return result;
  },
  first: function(values5) {
    var length = values5.length;
    for (var i = 0; i < length; i++) {
      var value = values5[i];
      if (value !== null && defined2(value)) {
        return value;
      }
    }
    return values5[0];
  }
};
var aggregates_default = Aggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-field.js
function getField(field, row) {
  if (row === null) {
    return row;
  }
  var get2 = getter(field, true);
  return get2(row);
}

// node_modules/@progress/kendo-charts/dist/es/chart/series-binder.js
var SeriesBinder = function(Class3) {
  function SeriesBinder2() {
    Class3.call(this);
    this._valueFields = {};
    this._otherFields = {};
    this._nullValue = {};
    this._undefinedValue = {};
  }
  if (Class3)
    SeriesBinder2.__proto__ = Class3;
  SeriesBinder2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesBinder2.prototype.constructor = SeriesBinder2;
  SeriesBinder2.prototype.register = function register4(seriesTypes, valueFields, otherFields) {
    var this$1 = this;
    if (valueFields === void 0)
      valueFields = [VALUE];
    if (otherFields === void 0)
      otherFields = {};
    for (var i = 0; i < seriesTypes.length; i++) {
      var type = seriesTypes[i];
      this$1._valueFields[type] = valueFields;
      this$1._otherFields[type] = otherFields;
      this$1._nullValue[type] = this$1._makeValue(valueFields, null);
      this$1._undefinedValue[type] = this$1._makeValue(valueFields, void 0);
    }
  };
  SeriesBinder2.prototype.canonicalFields = function canonicalFields(series) {
    return this.valueFields(series).concat(this.otherFields(series));
  };
  SeriesBinder2.prototype.valueFields = function valueFields(series) {
    return this._valueFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.otherFields = function otherFields(series) {
    return this._otherFields[series.type] || [VALUE];
  };
  SeriesBinder2.prototype.bindPoint = function bindPoint(series, pointIx, item) {
    var data = series.data;
    var pointData = defined2(item) ? item : data[pointIx];
    var result = { valueFields: { value: pointData } };
    var valueFields = this.valueFields(series);
    var otherFields = this._otherFields[series.type];
    var fields, value;
    if (pointData === null) {
      value = this._nullValue[series.type];
    } else if (!defined2(pointData)) {
      value = this._undefinedValue[series.type];
    } else if (Array.isArray(pointData)) {
      var fieldData = pointData.slice(valueFields.length);
      value = this._bindFromArray(pointData, valueFields);
      fields = this._bindFromArray(fieldData, otherFields);
    } else if (typeof pointData === "object") {
      var srcValueFields = this.sourceFields(series, valueFields);
      var srcPointFields = this.sourceFields(series, otherFields);
      value = this._bindFromObject(pointData, valueFields, srcValueFields);
      fields = this._bindFromObject(pointData, otherFields, srcPointFields);
    }
    if (defined2(value)) {
      if (valueFields.length === 1) {
        result.valueFields.value = value[valueFields[0]];
      } else {
        result.valueFields = value;
      }
    }
    result.fields = fields || {};
    return result;
  };
  SeriesBinder2.prototype._makeValue = function _makeValue(fields, initialValue) {
    var value = {};
    var length = fields.length;
    for (var i = 0; i < length; i++) {
      var fieldName = fields[i];
      value[fieldName] = initialValue;
    }
    return value;
  };
  SeriesBinder2.prototype._bindFromArray = function _bindFromArray(array, fields) {
    var value = {};
    if (fields) {
      var length = Math.min(fields.length, array.length);
      for (var i = 0; i < length; i++) {
        value[fields[i]] = array[i];
      }
    }
    return value;
  };
  SeriesBinder2.prototype._bindFromObject = function _bindFromObject(object4, fields, srcFields) {
    if (srcFields === void 0)
      srcFields = fields;
    var value = {};
    if (fields) {
      var length = fields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = fields[i];
        var srcFieldName = srcFields[i];
        if (srcFieldName !== null) {
          value[fieldName] = getField(srcFieldName, object4);
        }
      }
    }
    return value;
  };
  SeriesBinder2.prototype.sourceFields = function sourceFields(series, canonicalFields) {
    var sourceFields2 = [];
    if (canonicalFields) {
      var length = canonicalFields.length;
      for (var i = 0; i < length; i++) {
        var fieldName = canonicalFields[i];
        var sourceFieldName = fieldName === VALUE ? "field" : fieldName + "Field";
        sourceFields2.push(series[sourceFieldName] !== null ? series[sourceFieldName] || fieldName : null);
      }
    }
    return sourceFields2;
  };
  return SeriesBinder2;
}(class_default);
SeriesBinder.current = new SeriesBinder();
var series_binder_default = SeriesBinder;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-range-calculator.js
var STD_ERR = "stderr";
var STD_DEV = "stddev";
var percentRegex = /percent(?:\w*)\((\d+)\)/;
var standardDeviationRegex = new RegExp("^" + STD_DEV + "(?:\\((\\d+(?:\\.\\d+)?)\\))?$");
var ErrorRangeCalculator = function(Class3) {
  function ErrorRangeCalculator2(errorValue, series, field) {
    Class3.call(this);
    this.initGlobalRanges(errorValue, series, field);
  }
  if (Class3)
    ErrorRangeCalculator2.__proto__ = Class3;
  ErrorRangeCalculator2.prototype = Object.create(Class3 && Class3.prototype);
  ErrorRangeCalculator2.prototype.constructor = ErrorRangeCalculator2;
  ErrorRangeCalculator2.prototype.initGlobalRanges = function initGlobalRanges(errorValue, series, field) {
    var data = series.data;
    var deviationMatch = standardDeviationRegex.exec(errorValue);
    if (deviationMatch) {
      this.valueGetter = this.createValueGetter(series, field);
      var average = this.getAverage(data);
      var deviation = this.getStandardDeviation(data, average, false);
      var multiple = deviationMatch[1] ? parseFloat(deviationMatch[1]) : 1;
      var errorRange = { low: average.value - deviation * multiple, high: average.value + deviation * multiple };
      this.globalRange = function() {
        return errorRange;
      };
    } else if (errorValue.indexOf && errorValue.indexOf(STD_ERR) >= 0) {
      this.valueGetter = this.createValueGetter(series, field);
      var standardError = this.getStandardError(data, this.getAverage(data));
      this.globalRange = function(value) {
        return { low: value - standardError, high: value + standardError };
      };
    }
  };
  ErrorRangeCalculator2.prototype.createValueGetter = function createValueGetter(series, field) {
    var data = series.data;
    var binder = series_binder_default.current;
    var valueFields = binder.valueFields(series);
    var item = defined2(data[0]) ? data[0] : {};
    var valueGetter;
    if (isArray(item)) {
      var index = field ? valueFields.indexOf(field) : 0;
      valueGetter = getter("[" + index + "]");
    } else if (isNumber2(item)) {
      valueGetter = getter();
    } else if (typeof item === OBJECT) {
      var srcValueFields = binder.sourceFields(series, valueFields);
      valueGetter = getter(srcValueFields[valueFields.indexOf(field)]);
    }
    return valueGetter;
  };
  ErrorRangeCalculator2.prototype.getErrorRange = function getErrorRange(pointValue, errorValue) {
    var low, high, value;
    if (!defined2(errorValue)) {
      return null;
    }
    if (this.globalRange) {
      return this.globalRange(pointValue);
    }
    if (isArray(errorValue)) {
      low = pointValue - errorValue[0];
      high = pointValue + errorValue[1];
    } else if (isNumber2(value = parseFloat(errorValue))) {
      low = pointValue - value;
      high = pointValue + value;
    } else if (value = percentRegex.exec(errorValue)) {
      var percentValue = pointValue * (parseFloat(value[1]) / 100);
      low = pointValue - Math.abs(percentValue);
      high = pointValue + Math.abs(percentValue);
    } else {
      throw new Error("Invalid ErrorBar value: " + errorValue);
    }
    return { low, high };
  };
  ErrorRangeCalculator2.prototype.getStandardError = function getStandardError(data, average) {
    return this.getStandardDeviation(data, average, true) / Math.sqrt(average.count);
  };
  ErrorRangeCalculator2.prototype.getStandardDeviation = function getStandardDeviation(data, average, isSample) {
    var this$1 = this;
    var length = data.length;
    var total3 = isSample ? average.count - 1 : average.count;
    var squareDifferenceSum = 0;
    for (var idx = 0; idx < length; idx++) {
      var value = this$1.valueGetter(data[idx]);
      if (isNumber2(value)) {
        squareDifferenceSum += Math.pow(value - average.value, 2);
      }
    }
    return Math.sqrt(squareDifferenceSum / total3);
  };
  ErrorRangeCalculator2.prototype.getAverage = function getAverage(data) {
    var this$1 = this;
    var length = data.length;
    var sum = 0;
    var count = 0;
    for (var idx = 0; idx < length; idx++) {
      var value = this$1.valueGetter(data[idx]);
      if (isNumber2(value)) {
        sum += value;
        count++;
      }
    }
    return {
      value: sum / count,
      count
    };
  };
  return ErrorRangeCalculator2;
}(class_default);
var error_range_calculator_default = ErrorRangeCalculator;

// node_modules/@progress/kendo-charts/dist/es/chart/constants.js
var browser6 = support_default.browser || {};
var INITIAL_ANIMATION_DURATION = 600;
var FADEIN = "fadeIn";
var BORDER_BRIGHTNESS = 0.8;
var TOOLTIP_OFFSET = 5;
var START_SCALE = browser6.msie ? 1e-3 : 0;
var ERROR_LOW_FIELD = "errorLow";
var ERROR_HIGH_FIELD = "errorHigh";
var X_ERROR_LOW_FIELD = "xErrorLow";
var X_ERROR_HIGH_FIELD = "xErrorHigh";
var Y_ERROR_LOW_FIELD = "yErrorLow";
var Y_ERROR_HIGH_FIELD = "yErrorHigh";
var LINE_MARKER_SIZE = 8;
var ZERO2 = "zero";
var INTERPOLATE = "interpolate";
var GAP = "gap";
var ABOVE = "above";
var BELOW = "below";
var SMOOTH = "smooth";
var STEP = "step";
var AREA = "area";
var BAR = "bar";
var BOX_PLOT = "boxPlot";
var BUBBLE = "bubble";
var BULLET = "bullet";
var CANDLESTICK = "candlestick";
var COLUMN = "column";
var DONUT = "donut";
var FUNNEL = "funnel";
var HEATMAP = "heatmap";
var HORIZONTAL_WATERFALL = "horizontalWaterfall";
var LINE = "line";
var OHLC = "ohlc";
var PIE = "pie";
var POLAR_AREA = "polarArea";
var POLAR_LINE = "polarLine";
var POLAR_SCATTER = "polarScatter";
var RADAR_AREA = "radarArea";
var RADAR_COLUMN = "radarColumn";
var RADAR_LINE = "radarLine";
var RANGE_AREA = "rangeArea";
var RANGE_BAR = "rangeBar";
var RANGE_COLUMN = "rangeColumn";
var SCATTER = "scatter";
var SCATTER_LINE = "scatterLine";
var VERTICAL_AREA = "verticalArea";
var VERTICAL_BOX_PLOT = "verticalBoxPlot";
var VERTICAL_BULLET = "verticalBullet";
var VERTICAL_LINE = "verticalLine";
var VERTICAL_RANGE_AREA = "verticalRangeArea";
var WATERFALL = "waterfall";
var EQUALLY_SPACED_SERIES = [
  BAR,
  COLUMN,
  OHLC,
  CANDLESTICK,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  BULLET,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL
];
var LEGEND_ITEM_CLICK = "legendItemClick";
var LEGEND_ITEM_HOVER = "legendItemHover";
var LEGEND_ITEM_LEAVE = "legendItemLeave";
var SERIES_CLICK = "seriesClick";
var SERIES_HOVER = "seriesHover";
var SERIES_OVER = "seriesOver";
var SERIES_LEAVE = "seriesLeave";
var PLOT_AREA_CLICK = "plotAreaClick";
var PLOT_AREA_HOVER = "plotAreaHover";
var PLOT_AREA_LEAVE = "plotAreaLeave";
var DRAG = "drag";
var DRAG_END = "dragEnd";
var DRAG_START = "dragStart";
var ZOOM_START = "zoomStart";
var ZOOM = "zoom";
var ZOOM_END = "zoomEnd";
var SELECT_START = "selectStart";
var SELECT = "select";
var SELECT_END = "selectEnd";
var RENDER = "render";
var SHOW_TOOLTIP = "showTooltip";
var HIDE_TOOLTIP = "hideTooltip";
var PANE_RENDER = "paneRender";
var LOGARITHMIC = "log";
var CATEGORY = "category";
var INSIDE_END = "insideEnd";
var INSIDE_BASE = "insideBase";
var OUTSIDE_END = "outsideEnd";
var MOUSEWHEEL = "DOMMouseScroll mousewheel";
var MOUSEWHEEL_DELAY = 150;
var MOUSEWHEEL_ZOOM_RATE = 0.3;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/error-bar-base.js
var DEFAULT_ERROR_BAR_WIDTH = 4;
var ErrorBarBase = function(ChartElement2) {
  function ErrorBarBase2(low, high, isVertical, chart, series, options2) {
    ChartElement2.call(this, options2);
    this.low = low;
    this.high = high;
    this.isVertical = isVertical;
    this.chart = chart;
    this.series = series;
  }
  if (ChartElement2)
    ErrorBarBase2.__proto__ = ChartElement2;
  ErrorBarBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ErrorBarBase2.prototype.constructor = ErrorBarBase2;
  ErrorBarBase2.prototype.reflow = function reflow(targetBox) {
    var endCaps = this.options.endCaps;
    var isVertical = this.isVertical;
    var axis = this.getAxis();
    var valueBox = axis.getSlot(this.low, this.high);
    var centerBox = targetBox.center();
    var capsWidth = this.getCapsWidth(targetBox, isVertical);
    var capValue = isVertical ? centerBox.x : centerBox.y;
    var capStart = capValue - capsWidth;
    var capEnd = capValue + capsWidth;
    var linePoints;
    if (isVertical) {
      linePoints = [
        new point_default2(centerBox.x, valueBox.y1),
        new point_default2(centerBox.x, valueBox.y2)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default2(capStart, valueBox.y1),
          new point_default2(capEnd, valueBox.y1),
          new point_default2(capStart, valueBox.y2),
          new point_default2(capEnd, valueBox.y2)
        );
      }
      this.box = new box_default(capStart, valueBox.y1, capEnd, valueBox.y2);
    } else {
      linePoints = [
        new point_default2(valueBox.x1, centerBox.y),
        new point_default2(valueBox.x2, centerBox.y)
      ];
      if (endCaps) {
        linePoints.push(
          new point_default2(valueBox.x1, capStart),
          new point_default2(valueBox.x1, capEnd),
          new point_default2(valueBox.x2, capStart),
          new point_default2(valueBox.x2, capEnd)
        );
      }
      this.box = new box_default(valueBox.x1, capStart, valueBox.x2, capEnd);
    }
    this.linePoints = linePoints;
  };
  ErrorBarBase2.prototype.getCapsWidth = function getCapsWidth(box, isVertical) {
    var boxSize = isVertical ? box.width() : box.height();
    var capsWidth = Math.min(Math.floor(boxSize / 2), DEFAULT_ERROR_BAR_WIDTH) || DEFAULT_ERROR_BAR_WIDTH;
    return capsWidth;
  };
  ErrorBarBase2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options2 = this.options;
    var visual = options2.visual;
    if (visual) {
      this.visual = visual({
        low: this.low,
        high: this.high,
        rect: this.box.toRect(),
        sender: this.getSender(),
        options: {
          endCaps: options2.endCaps,
          color: options2.color,
          line: options2.line
        },
        createVisual: function() {
          this$1.createDefaultVisual();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
    } else {
      this.createDefaultVisual();
    }
  };
  ErrorBarBase2.prototype.createDefaultVisual = function createDefaultVisual() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var linePoints = ref2.linePoints;
    var lineOptions = {
      stroke: {
        color: options2.color,
        width: options2.line.width,
        dashType: options2.line.dashType
      }
    };
    ChartElement2.prototype.createVisual.call(this);
    for (var idx = 0; idx < linePoints.length; idx += 2) {
      var line = new drawing_exports.Path(lineOptions).moveTo(linePoints[idx].x, linePoints[idx].y).lineTo(linePoints[idx + 1].x, linePoints[idx + 1].y);
      alignPathToPixel(line);
      this$1.visual.append(line);
    }
  };
  return ErrorBarBase2;
}(chart_element_default);
setDefaultOptions(ErrorBarBase, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  endCaps: true,
  line: {
    width: 2
  },
  zIndex: 1
});
var error_bar_base_default = ErrorBarBase;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/categorical-error-bar.js
var CategoricalErrorBar = function(ErrorBarBase2) {
  function CategoricalErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    CategoricalErrorBar2.__proto__ = ErrorBarBase2;
  CategoricalErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  CategoricalErrorBar2.prototype.constructor = CategoricalErrorBar2;
  CategoricalErrorBar2.prototype.getAxis = function getAxis() {
    var axis = this.chart.seriesValueAxis(this.series);
    return axis;
  };
  return CategoricalErrorBar2;
}(error_bar_base_default);
var categorical_error_bar_default = CategoricalErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/eval-options.js
var MAX_EXPAND_DEPTH = 5;
function evalOptions(options2, context2, state, dryRun) {
  if (state === void 0)
    state = {};
  if (dryRun === void 0)
    dryRun = false;
  var defaults = state.defaults = state.defaults || {};
  var depth = state.depth = state.depth || 0;
  var needsEval = false;
  state.excluded = state.excluded || [];
  if (depth > MAX_EXPAND_DEPTH) {
    return null;
  }
  for (var property in options2) {
    if (!inArray(property, state.excluded) && options2.hasOwnProperty(property)) {
      var propValue = options2[property];
      if (isFunction3(propValue)) {
        needsEval = true;
        if (!dryRun) {
          options2[property] = valueOrDefault2(propValue(context2), defaults[property]);
        }
      } else if (isObject(propValue)) {
        if (!dryRun) {
          state.defaults = defaults[property];
        }
        state.depth++;
        needsEval = evalOptions(propValue, context2, state, dryRun) || needsEval;
        state.depth--;
      }
    }
  }
  return needsEval;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/categories-count.js
function categoriesCount(series) {
  var seriesCount = series.length;
  var categories = 0;
  for (var i = 0; i < seriesCount; i++) {
    categories = Math.max(categories, series[i].data.length);
  }
  return categories;
}

// node_modules/@progress/kendo-charts/dist/es/chart/categorical-chart.js
var CategoricalChart = function(ChartElement2) {
  function CategoricalChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.categoryAxis = plotArea.seriesCategoryAxis(options2.series[0]);
    this.valueAxisRanges = {};
    this.points = [];
    this.categoryPoints = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
    this.render();
  }
  if (ChartElement2)
    CategoricalChart2.__proto__ = ChartElement2;
  CategoricalChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  CategoricalChart2.prototype.constructor = CategoricalChart2;
  CategoricalChart2.prototype.render = function render3() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  CategoricalChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        vertical: !this.options.invertAxes
      }, series);
    }
    return options2;
  };
  CategoricalChart2.prototype.plotValue = function plotValue(point2) {
    if (!point2) {
      return 0;
    }
    if (this.options.isStacked100 && isNumber2(point2.value)) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      var otherValues = [];
      var categorySum = 0;
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (other) {
          var stack2 = point2.series.stack;
          var otherStack = other.series.stack;
          if (stack2 && otherStack && stack2.group !== otherStack.group) {
            continue;
          }
          if (isNumber2(other.value)) {
            categorySum += Math.abs(other.value);
            otherValues.push(Math.abs(other.value));
          }
        }
      }
      if (categorySum > 0) {
        return point2.value / categorySum;
      }
    }
    return point2.value;
  };
  CategoricalChart2.prototype.plotRange = function plotRange(point2, startValue) {
    var this$1 = this;
    if (startValue === void 0)
      startValue = 0;
    var categoryPoints = this.categoryPoints[point2.categoryIx];
    if (this.options.isStacked) {
      var plotValue = this.plotValue(point2);
      var positive = plotValue >= 0;
      var prevValue = startValue;
      var isStackedBar = false;
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (point2 === other) {
          break;
        }
        var stack2 = point2.series.stack;
        var otherStack = other.series.stack;
        if (stack2 && otherStack) {
          if (typeof stack2 === STRING && stack2 !== otherStack) {
            continue;
          }
          if (stack2.group && stack2.group !== otherStack.group) {
            continue;
          }
        }
        var otherValue = this$1.plotValue(other);
        if (otherValue >= 0 && positive || otherValue < 0 && !positive) {
          prevValue += otherValue;
          plotValue += otherValue;
          isStackedBar = true;
          if (this$1.options.isStacked100) {
            plotValue = Math.min(plotValue, 1);
          }
        }
      }
      if (isStackedBar) {
        prevValue -= startValue;
      }
      return [prevValue, plotValue];
    }
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, convertableToNumber(point2.value) ? point2.value : axisCrossingValue];
  };
  CategoricalChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var this$1 = this;
    var min3 = MAX_VALUE;
    var max2 = MIN_VALUE;
    for (var i = 0; i < this.categoryPoints.length; i++) {
      var categoryPoints = this$1.categoryPoints[i];
      if (!categoryPoints) {
        continue;
      }
      for (var pIx = 0; pIx < categoryPoints.length; pIx++) {
        var point2 = categoryPoints[pIx];
        if (point2) {
          if (point2.series.stack === stackName || point2.series.axis === axisName) {
            var to = this$1.plotRange(point2, 0)[1];
            if (defined2(to) && isFinite(to)) {
              max2 = Math.max(max2, to);
              min3 = Math.min(min3, to);
            }
          }
        }
      }
    }
    return { min: min3, max: max2 };
  };
  CategoricalChart2.prototype.updateStackRange = function updateStackRange() {
    var this$1 = this;
    var ref2 = this.options;
    var isStacked = ref2.isStacked;
    var chartSeries = ref2.series;
    var limitsCache = {};
    if (isStacked) {
      for (var i = 0; i < chartSeries.length; i++) {
        var series = chartSeries[i];
        var axisName = series.axis;
        var key = axisName + series.stack;
        var limits = limitsCache[key];
        if (!limits) {
          limits = this$1.stackLimits(axisName, series.stack);
          var errorTotals = this$1.errorTotals;
          if (errorTotals) {
            if (errorTotals.negative.length) {
              limits.min = Math.min(limits.min, sparseArrayLimits(errorTotals.negative).min);
            }
            if (errorTotals.positive.length) {
              limits.max = Math.max(limits.max, sparseArrayLimits(errorTotals.positive).max);
            }
          }
          if (limits.min !== MAX_VALUE || limits.max !== MIN_VALUE) {
            limitsCache[key] = limits;
          } else {
            limits = null;
          }
        }
        if (limits) {
          this$1.valueAxisRanges[axisName] = limits;
        }
      }
    }
  };
  CategoricalChart2.prototype.addErrorBar = function addErrorBar(point2, data, categoryIx) {
    var value = point2.value;
    var series = point2.series;
    var seriesIx = point2.seriesIx;
    var errorBars = point2.options.errorBars;
    var lowValue = data.fields[ERROR_LOW_FIELD];
    var highValue = data.fields[ERROR_HIGH_FIELD];
    var errorRange;
    if (isNumber2(lowValue) && isNumber2(highValue)) {
      errorRange = { low: lowValue, high: highValue };
    } else if (errorBars && defined2(errorBars.value)) {
      this.seriesErrorRanges = this.seriesErrorRanges || [];
      this.seriesErrorRanges[seriesIx] = this.seriesErrorRanges[seriesIx] || new error_range_calculator_default(errorBars.value, series, VALUE);
      errorRange = this.seriesErrorRanges[seriesIx].getErrorRange(value, errorBars.value);
    }
    if (errorRange) {
      point2.low = errorRange.low;
      point2.high = errorRange.high;
      this.addPointErrorBar(point2, categoryIx);
    }
  };
  CategoricalChart2.prototype.addPointErrorBar = function addPointErrorBar(point2, categoryIx) {
    var isVertical = !this.options.invertAxes;
    var options2 = point2.options.errorBars;
    var series = point2.series;
    var low = point2.low;
    var high = point2.high;
    if (this.options.isStacked) {
      var stackedErrorRange = this.stackedErrorRange(point2, categoryIx);
      low = stackedErrorRange.low;
      high = stackedErrorRange.high;
    } else {
      var fields = { categoryIx, series };
      this.updateRange({ value: low }, fields);
      this.updateRange({ value: high }, fields);
    }
    var errorBar = new categorical_error_bar_default(low, high, isVertical, this, series, options2);
    point2.errorBars = [errorBar];
    point2.append(errorBar);
  };
  CategoricalChart2.prototype.stackedErrorRange = function stackedErrorRange(point2, categoryIx) {
    var plotValue = this.plotRange(point2, 0)[1] - point2.value;
    var low = point2.low + plotValue;
    var high = point2.high + plotValue;
    this.errorTotals = this.errorTotals || { positive: [], negative: [] };
    if (low < 0) {
      this.errorTotals.negative[categoryIx] = Math.min(this.errorTotals.negative[categoryIx] || 0, low);
    }
    if (high > 0) {
      this.errorTotals.positive[categoryIx] = Math.max(this.errorTotals.positive[categoryIx] || 0, high);
    }
    return { low, high };
  };
  CategoricalChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var categoryPoints = this.categoryPoints[categoryIx];
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    var seriesPoints = this.seriesPoints[seriesIx];
    if (!seriesPoints) {
      this.seriesPoints[seriesIx] = seriesPoints = [];
    }
    var point2 = this.createPoint(data, fields);
    if (point2) {
      Object.assign(point2, fields);
      point2.owner = this;
      point2.noteText = data.fields.noteText;
      if (!defined2(point2.dataItem)) {
        point2.dataItem = series.data[categoryIx];
      }
      this.addErrorBar(point2, data, categoryIx);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
    categoryPoints.push(point2);
    this.updateRange(data.valueFields, fields);
  };
  CategoricalChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, category, categoryIx, series, seriesIx) {
    var state = { defaults: series._defaults, excluded: ["data", "aggregate", "_events", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint"] };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, pointOptions);
      evalOptions(pointOptions, {
        value,
        category,
        index: categoryIx,
        series,
        dataItem: series.data[categoryIx]
      }, state);
    }
    return pointOptions;
  };
  CategoricalChart2.prototype.updateRange = function updateRange(data, fields) {
    var axisName = fields.series.axis;
    var value = data.value;
    var axisRange = this.valueAxisRanges[axisName];
    if (isFinite(value) && value !== null) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, value);
      axisRange.max = Math.max(axisRange.max, value);
    }
  };
  CategoricalChart2.prototype.seriesValueAxis = function seriesValueAxis(series) {
    var plotArea = this.plotArea;
    var axisName = series.axis;
    var axis = axisName ? plotArea.namedValueAxes[axisName] : plotArea.valueAxis;
    if (!axis) {
      throw new Error("Unable to locate value axis with name " + axisName);
    }
    return axis;
  };
  CategoricalChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var categorySlots = this.categorySlots = [];
    var chartPoints = this.points;
    var categoryAxis = this.categoryAxis;
    var pointIx = 0;
    this.traverseDataPoints(function(data, fields) {
      var categoryIx = fields.categoryIx;
      var currentSeries = fields.series;
      var valueAxis = this$1.seriesValueAxis(currentSeries);
      var point2 = chartPoints[pointIx++];
      var categorySlot = categorySlots[categoryIx];
      if (!categorySlot) {
        categorySlots[categoryIx] = categorySlot = this$1.categorySlot(categoryAxis, categoryIx, valueAxis);
      }
      if (point2) {
        var plotRange = this$1.plotRange(point2, valueAxis.startValue());
        var valueSlot = this$1.valueSlot(valueAxis, plotRange);
        if (valueSlot) {
          var pointSlot = this$1.pointSlot(categorySlot, valueSlot);
          point2.aboveAxis = this$1.aboveAxis(point2, valueAxis);
          point2.stackValue = plotRange[1];
          if (this$1.options.isStacked100) {
            point2.percentage = this$1.plotValue(point2);
          }
          this$1.reflowPoint(point2, pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.reflowCategories(categorySlots);
    if (!this.options.clip && this.options.limitPoints && this.points.length) {
      this.limitPoints();
    }
    this.box = targetBox;
  };
  CategoricalChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    return valueAxis.getSlot(plotRange[0], plotRange[1], !this.options.clip);
  };
  CategoricalChart2.prototype.limitPoints = function limitPoints() {
    var this$1 = this;
    var categoryPoints = this.categoryPoints;
    var points3 = categoryPoints[0].concat(last2(categoryPoints));
    for (var idx = 0; idx < points3.length; idx++) {
      if (points3[idx]) {
        this$1.limitPoint(points3[idx]);
      }
    }
  };
  CategoricalChart2.prototype.limitPoint = function limitPoint(point2) {
    var limittedSlot = this.categoryAxis.limitSlot(point2.box);
    if (!limittedSlot.equals(point2.box)) {
      point2.reflow(limittedSlot);
    }
  };
  CategoricalChart2.prototype.aboveAxis = function aboveAxis(point2, valueAxis) {
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    var value = point2.value;
    return valueAxis.options.reverse ? value < axisCrossingValue : value >= axisCrossingValue;
  };
  CategoricalChart2.prototype.categoryAxisCrossingValue = function categoryAxisCrossingValue(valueAxis) {
    var categoryAxis = this.categoryAxis;
    var options2 = valueAxis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    return crossingValues[categoryAxis.axisIndex || 0] || 0;
  };
  CategoricalChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.reflow(pointSlot);
  };
  CategoricalChart2.prototype.reflowCategories = function reflowCategories() {
  };
  CategoricalChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var options2 = this.options;
    var invertAxes = options2.invertAxes;
    var slotX = invertAxes ? valueSlot : categorySlot;
    var slotY = invertAxes ? categorySlot : valueSlot;
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  CategoricalChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  CategoricalChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var count = categoriesCount(series);
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      this$1._outOfRangeCallback(series[seriesIx], "_outOfRangeMinPoint", seriesIx, callback);
    }
    for (var categoryIx = 0; categoryIx < count; categoryIx++) {
      for (var seriesIx$1 = 0; seriesIx$1 < seriesCount; seriesIx$1++) {
        var currentSeries = series[seriesIx$1];
        var currentCategory = this$1.categoryAxis.categoryAt(categoryIx);
        var pointData = this$1._bindPoint(currentSeries, seriesIx$1, categoryIx);
        callback(pointData, {
          category: currentCategory,
          categoryIx,
          categoriesCount: count,
          series: currentSeries,
          seriesIx: seriesIx$1
        });
      }
    }
    for (var seriesIx$2 = 0; seriesIx$2 < seriesCount; seriesIx$2++) {
      this$1._outOfRangeCallback(series[seriesIx$2], "_outOfRangeMaxPoint", seriesIx$2, callback);
    }
  };
  CategoricalChart2.prototype._outOfRangeCallback = function _outOfRangeCallback(series, field, seriesIx, callback) {
    var outOfRangePoint = series[field];
    if (outOfRangePoint) {
      var categoryIx = outOfRangePoint.categoryIx;
      var pointData = this._bindPoint(series, seriesIx, categoryIx, outOfRangePoint.item);
      callback(pointData, {
        category: outOfRangePoint.category,
        categoryIx,
        series,
        seriesIx,
        dataItem: outOfRangePoint.item
      });
    }
  };
  CategoricalChart2.prototype._bindPoint = function _bindPoint(series, seriesIx, categoryIx, item) {
    if (!this._bindCache) {
      this._bindCache = [];
    }
    var bindCache = this._bindCache[seriesIx];
    if (!bindCache) {
      bindCache = this._bindCache[seriesIx] = [];
    }
    var data = bindCache[categoryIx];
    if (!data) {
      data = bindCache[categoryIx] = series_binder_default.current.bindPoint(series, categoryIx, item);
    }
    return data;
  };
  CategoricalChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value);
  };
  CategoricalChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.value;
  };
  return CategoricalChart2;
}(chart_element_default);
setDefaultOptions(CategoricalChart, {
  series: [],
  invertAxes: false,
  isStacked: false,
  clip: true,
  limitPoints: true
});
var categorical_chart_default = CategoricalChart;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/point-events-mixin.js
var PointEventsMixin = {
  click: function(chart, e) {
    return chart.trigger(
      SERIES_CLICK,
      this.eventArgs(e)
    );
  },
  hover: function(chart, e) {
    return chart.trigger(
      SERIES_HOVER,
      this.eventArgs(e)
    );
  },
  over: function(chart, e) {
    return chart.trigger(
      SERIES_OVER,
      this.eventArgs(e)
    );
  },
  out: function(chart, e) {
    return chart.trigger(
      SERIES_LEAVE,
      this.eventArgs(e)
    );
  },
  eventArgs: function(e) {
    return {
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      category: this.category,
      series: this.series,
      dataItem: this.dataItem,
      runningTotal: this.runningTotal,
      total: this.total,
      element: eventElement2(e),
      originalEvent: e,
      point: this
    };
  }
};
var point_events_mixin_default = PointEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/note-mixin.js
var NoteMixin = {
  createNote: function() {
    var options2 = this.options.notes;
    var text = this.noteText || options2.label.text;
    if (options2.visible !== false && defined2(text) && text !== null) {
      this.note = new note_default({
        value: this.value,
        text,
        dataItem: this.dataItem,
        category: this.category,
        series: this.series
      }, this.options.notes, this.owner.chartService);
      this.append(this.note);
    }
  }
};
var note_mixin_default = NoteMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-point.js
var LinePoint = function(ChartElement2) {
  function LinePoint2(value, options2) {
    ChartElement2.call(this);
    this.value = value;
    this.options = options2;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.tooltipTracking = true;
  }
  if (ChartElement2)
    LinePoint2.__proto__ = ChartElement2;
  LinePoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LinePoint2.prototype.constructor = LinePoint2;
  LinePoint2.prototype.render = function render3() {
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    if (markers.visible && markers.size) {
      this.marker = this.createMarker();
      this.append(this.marker);
    }
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var pointData = this.pointData();
      var labelText = this.value;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else if (labels.format) {
        labelText = this.formatValue(labels.format);
      }
      this.label = new text_box_default(
        labelText,
        deepExtend({
          align: CENTER,
          vAlign: CENTER,
          margin: {
            left: 5,
            right: 5
          },
          zIndex: valueOrDefault2(labels.zIndex, this.series.zIndex)
        }, labels),
        pointData
      );
      this.append(this.label);
    }
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  LinePoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options.markers;
    var background = options2.background;
    var border = deepExtend({ color: this.color }, options2.border);
    if (!defined2(border.color)) {
      border.color = new color_default(background).brightness(BORDER_BRIGHTNESS).toHex();
    }
    return border;
  };
  LinePoint2.prototype.createVisual = function createVisual() {
  };
  LinePoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options.markers;
    var marker = new shape_element_default({
      type: options2.type,
      width: options2.size,
      height: options2.size,
      rotation: options2.rotation,
      background: options2.background,
      border: this.markerBorder(),
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    return marker;
  };
  LinePoint2.prototype.markerBox = function markerBox() {
    if (!this.marker) {
      this.marker = this.createMarker();
      this.marker.reflow(this._childBox);
    }
    return this.marker.box;
  };
  LinePoint2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var aboveAxis = ref2.aboveAxis;
    var vertical = options2.vertical;
    this.render();
    this.box = targetBox;
    var childBox = targetBox.clone();
    if (vertical) {
      if (aboveAxis) {
        childBox.y1 -= childBox.height();
      } else {
        childBox.y2 += childBox.height();
      }
    } else {
      if (aboveAxis) {
        childBox.x1 += childBox.width();
      } else {
        childBox.x2 -= childBox.width();
      }
    }
    this._childBox = childBox;
    if (this.marker) {
      this.marker.reflow(childBox);
    }
    this.reflowLabel(childBox);
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(childBox);
      }
    }
    if (this.note) {
      var noteTargetBox = this.markerBox();
      if (!(options2.markers.visible && options2.markers.size)) {
        var center = noteTargetBox.center();
        noteTargetBox = new box_default(center.x, center.y, center.x, center.y);
      }
      this.note.reflow(noteTargetBox);
    }
  };
  LinePoint2.prototype.reflowLabel = function reflowLabel(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var label = ref2.label;
    var anchor = options2.labels.position;
    if (label) {
      anchor = anchor === ABOVE ? TOP : anchor;
      anchor = anchor === BELOW ? BOTTOM : anchor;
      label.reflow(box);
      label.box.alignTo(this.markerBox(), anchor);
      label.reflow(label.box);
    }
  };
  LinePoint2.prototype.createHighlight = function createHighlight() {
    var markers = this.options.highlight.markers;
    var defaultColor = this.markerBorder().color;
    var options2 = this.options.markers;
    var size = options2.size + (options2.border.width || 0) + (markers.border.width || 0);
    var shadow = new shape_element_default({
      type: options2.type,
      width: size,
      height: size,
      rotation: options2.rotation,
      background: markers.color || defaultColor,
      border: {
        color: markers.border.color,
        width: markers.border.width,
        opacity: valueOrDefault2(markers.border.opacity, 1)
      },
      opacity: valueOrDefault2(markers.opacity, 1)
    });
    shadow.reflow(this._childBox);
    return shadow.getElement();
  };
  LinePoint2.prototype.highlightVisual = function highlightVisual() {
    return (this.marker || {}).visual;
  };
  LinePoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var marker = this.marker;
    var visual, rect;
    if (marker) {
      rect = marker.paddingBox.toRect();
      visual = marker.visual;
    } else {
      var size = this.options.markers.size;
      var halfSize = size / 2;
      var center = this.box.center();
      rect = new geometry_exports.Rect([center.x - halfSize, center.y - halfSize], [size, size]);
    }
    return {
      options: this.options,
      rect,
      visual
    };
  };
  LinePoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var markerBox = this.markerBox();
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(markerBox);
    if (showTooltip) {
      var x = markerBox.x2 + TOOLTIP_OFFSET;
      var horizontalAlign = LEFT;
      var y, verticalAlign;
      if (this.aboveAxis) {
        y = markerBox.y1;
        verticalAlign = BOTTOM;
      } else {
        y = markerBox.y2;
        verticalAlign = TOP;
      }
      return {
        point: new point_default2(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  LinePoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  LinePoint2.prototype.overlapsBox = function overlapsBox(box) {
    var markerBox = this.markerBox();
    return markerBox.overlaps(box);
  };
  LinePoint2.prototype.unclipElements = function unclipElements() {
    if (this.label) {
      this.label.options.noclip = true;
    }
    if (this.note) {
      this.note.options.noclip = true;
    }
  };
  LinePoint2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      series: this.series
    };
  };
  return LinePoint2;
}(chart_element_default);
LinePoint.prototype.defaults = {
  vertical: true,
  markers: {
    visible: true,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    position: ABOVE,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    }
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: "#fff",
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  errorBars: {
    line: {
      width: 1
    }
  }
};
deepExtend(LinePoint.prototype, point_events_mixin_default);
deepExtend(LinePoint.prototype, note_mixin_default);
var line_point_default = LinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-segment.js
var LineSegment = function(ChartElement2) {
  function LineSegment2(linePoints, series, seriesIx) {
    ChartElement2.call(this);
    this.linePoints = linePoints;
    this.series = series;
    this.seriesIx = seriesIx;
  }
  if (ChartElement2)
    LineSegment2.__proto__ = ChartElement2;
  LineSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LineSegment2.prototype.constructor = LineSegment2;
  LineSegment2.prototype.points = function points3() {
    return this.toGeometryPoints(this.linePoints);
  };
  LineSegment2.prototype.toGeometryPoints = function toGeometryPoints(points3) {
    var result = [];
    for (var i = 0, length = points3.length; i < length; i++) {
      if (points3[i] && points3[i].visible !== false) {
        result.push(points3[i]._childBox.toRect().center());
      }
    }
    return result;
  };
  LineSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var customVisual = this.series.visual;
    if (customVisual) {
      this.visual = customVisual({
        points: this.toGeometryPoints(this.linePoints),
        series: this.series,
        sender: this.getSender(),
        createVisual: function() {
          this$1.segmentVisual();
          return this$1.visual;
        }
      });
      if (this.visual && !defined2(this.visual.options.zIndex)) {
        this.visual.options.zIndex = this.series.zIndex;
      }
    } else {
      this.segmentVisual();
    }
  };
  LineSegment2.prototype.segmentVisual = function segmentVisual() {
    var ref2 = this;
    var options2 = ref2.options;
    var series = ref2.series;
    var color = series.color;
    var defaults = series._defaults;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    var line = drawing_exports.Path.fromPoints(this.points(), {
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    if (options2.closed) {
      line.close();
    }
    this.visual = line;
  };
  LineSegment2.prototype.aliasFor = function aliasFor(e, coords) {
    return this.parent.getNearestPoint(coords.x, coords.y, this.seriesIx);
  };
  return LineSegment2;
}(chart_element_default);
setDefaultOptions(LineSegment, {
  closed: false
});
var line_segment_default = LineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-mixin.js
var StepLineMixin = {
  calculateStepPoints: function(points3) {
    var categoryAxis = this.parent.plotArea.seriesCategoryAxis(this.series);
    var ref2 = categoryAxis.options;
    var justified = ref2.justified;
    var vertical = ref2.vertical;
    var reverse = ref2.reverse;
    var stepAxis = vertical ? X : Y;
    var axis = vertical ? Y : X;
    var stepDir = reverse ? 2 : 1;
    var dir = stepDir;
    var previousPoint = toGeometryPoint(points3[0], stepAxis, stepDir, axis, dir);
    var result = [previousPoint];
    for (var idx = 1; idx < points3.length; idx++) {
      var point2 = toGeometryPoint(points3[idx], stepAxis, stepDir, axis, dir);
      if (previousPoint[stepAxis] !== point2[stepAxis]) {
        var stepPoint = new geometry_exports.Point();
        stepPoint[stepAxis] = previousPoint[stepAxis];
        stepPoint[axis] = point2[axis];
        result.push(stepPoint, point2);
      }
      previousPoint = point2;
    }
    if (!justified) {
      result.push(toGeometryPoint(last2(points3), stepAxis, stepDir, axis, reverse ? 1 : 2));
    } else if (previousPoint !== last2(result)) {
      result.push(previousPoint);
    }
    return result;
  }
};
function toGeometryPoint(lintPoint, stepAxis, stepDir, axis, dir) {
  var box = lintPoint.box;
  var result = new geometry_exports.Point();
  result[stepAxis] = box[stepAxis + stepDir];
  result[axis] = box[axis + dir];
  return result;
}
var step_line_mixin_default = StepLineMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/step-line-segment.js
var StepLineSegment = function(LineSegment2) {
  function StepLineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    StepLineSegment2.__proto__ = LineSegment2;
  StepLineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  StepLineSegment2.prototype.constructor = StepLineSegment2;
  StepLineSegment2.prototype.points = function points3() {
    return this.calculateStepPoints(this.linePoints);
  };
  return StepLineSegment2;
}(line_segment_default);
deepExtend(StepLineSegment.prototype, step_line_mixin_default);
var step_line_segment_default = StepLineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/spline-segment.js
var SplineSegment = function(LineSegment2) {
  function SplineSegment2() {
    LineSegment2.apply(this, arguments);
  }
  if (LineSegment2)
    SplineSegment2.__proto__ = LineSegment2;
  SplineSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  SplineSegment2.prototype.constructor = SplineSegment2;
  SplineSegment2.prototype.segmentVisual = function segmentVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var color = series.color;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    var curveProcessor = new curve_processor_default(this.options.closed);
    var segments = curveProcessor.process(this.points());
    var curve = new drawing_exports.Path({
      stroke: {
        color,
        width: series.width,
        opacity: series.opacity,
        dashType: series.dashType
      },
      zIndex: series.zIndex
    });
    curve.segments.push.apply(curve.segments, segments);
    this.visual = curve;
  };
  return SplineSegment2;
}(line_segment_default);
var spline_segment_default = SplineSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/line-chart-mixin.js
var LineChartMixin = {
  renderSegments: function() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesPoints = ref2.seriesPoints;
    var series = options2.series;
    var seriesCount = seriesPoints.length;
    var lastSegment;
    this._segments = [];
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var sortedPoints = this$1.sortPoints(seriesPoints[seriesIx]);
      var pointCount = sortedPoints.length;
      var linePoints = [];
      for (var pointIx = 0; pointIx < pointCount; pointIx++) {
        var point2 = sortedPoints[pointIx];
        if (point2) {
          linePoints.push(point2);
        } else if (this$1.seriesMissingValues(currentSeries) !== INTERPOLATE) {
          if (linePoints.length > 1) {
            lastSegment = this$1.createSegment(
              linePoints,
              currentSeries,
              seriesIx,
              lastSegment
            );
            this$1._addSegment(lastSegment);
          }
          linePoints = [];
        }
      }
      if (linePoints.length > 1) {
        lastSegment = this$1.createSegment(
          linePoints,
          currentSeries,
          seriesIx,
          lastSegment
        );
        this$1._addSegment(lastSegment);
      }
    }
    this.children.unshift.apply(this.children, this._segments);
  },
  _addSegment: function(segment) {
    this._segments.push(segment);
    segment.parent = this;
  },
  sortPoints: function(points3) {
    return points3;
  },
  seriesMissingValues: function(series) {
    var missingValues = series.missingValues;
    var assumeZero = !missingValues && this.options.isStacked;
    return assumeZero ? ZERO2 : missingValues || INTERPOLATE;
  },
  getNearestPoint: function(x, y, seriesIx) {
    var target = new point_default2(x, y);
    var allPoints = this.seriesPoints[seriesIx];
    var nearestPointDistance = MAX_VALUE;
    var nearestPoint;
    for (var i = 0; i < allPoints.length; i++) {
      var point2 = allPoints[i];
      if (point2 && defined2(point2.value) && point2.value !== null && point2.visible !== false) {
        var pointBox = point2.box;
        var pointDistance = pointBox.center().distanceTo(target);
        if (pointDistance < nearestPointDistance) {
          nearestPoint = point2;
          nearestPointDistance = pointDistance;
        }
      }
    }
    return nearestPoint;
  }
};
var line_chart_mixin_default = LineChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/clip-animation.js
var ClipAnimation = function(superclass) {
  function ClipAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ClipAnimation2.__proto__ = superclass;
  ClipAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ClipAnimation2.prototype.constructor = ClipAnimation2;
  ClipAnimation2.prototype.setup = function setup() {
    this._setEnd(this.options.box.x1);
  };
  ClipAnimation2.prototype.step = function step(pos) {
    var box = this.options.box;
    this._setEnd(interpolateValue(box.x1, box.x2, pos));
  };
  ClipAnimation2.prototype._setEnd = function _setEnd(x) {
    var element = this.element;
    var segments = element.segments;
    var topRight = segments[1].anchor();
    var bottomRight = segments[2].anchor();
    element.suspend();
    topRight.setX(x);
    element.resume();
    bottomRight.setX(x);
  };
  return ClipAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ClipAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register("clip", ClipAnimation);
var clip_animation_default = ClipAnimation;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/any-has-z-index.js
function anyHasZIndex(elements) {
  for (var idx = 0; idx < elements.length; idx++) {
    if (defined2(elements[idx].zIndex)) {
      return true;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/clip-animation-mixin.js
var ClipAnimationMixin = {
  createAnimation: function() {
    var root = this.getRoot();
    if (root && (root.options || {}).transitions !== false) {
      var box = root.size();
      var clipPath = drawing_exports.Path.fromRect(box.toRect());
      this.visual.clip(clipPath);
      this.animation = new clip_animation_default(clipPath, {
        box
      });
      if (anyHasZIndex(this.options.series)) {
        this._setChildrenAnimation(clipPath);
      }
    }
  },
  _setChildrenAnimation: function(clipPath) {
    var points3 = this.animationPoints();
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      if (point2 && point2.visual && defined2(point2.visual.options.zIndex)) {
        point2.visual.clip(clipPath);
      }
    }
  }
};
var clip_animation_mixin_default = ClipAnimationMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/line-chart/line-chart.js
var LineChart = function(CategoricalChart2) {
  function LineChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    LineChart2.__proto__ = CategoricalChart2;
  LineChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  LineChart2.prototype.constructor = LineChart2;
  LineChart2.prototype.render = function render3() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
    this.renderSegments();
  };
  LineChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  LineChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var missingValues = this.seriesMissingValues(series);
    var value = data.valueFields.value;
    if (!defined2(value) || value === null) {
      if (missingValues === ZERO2) {
        value = 0;
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(
      pointOptions,
      value,
      category,
      categoryIx,
      series,
      seriesIx
    );
    var color = data.fields.color || series.color;
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new line_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  LineChart2.prototype.plotRange = function plotRange(point2) {
    var this$1 = this;
    var plotValue = this.plotValue(point2);
    if (this.options.isStacked) {
      var categoryIx = point2.categoryIx;
      var categoryPoints = this.categoryPoints[categoryIx];
      for (var i = 0; i < categoryPoints.length; i++) {
        var other = categoryPoints[i];
        if (point2 === other) {
          break;
        }
        plotValue += this$1.plotValue(other);
        if (this$1.options.isStacked100) {
          plotValue = Math.min(plotValue, 1);
        }
      }
    }
    return [plotValue, plotValue];
  };
  LineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === STEP) {
      pointType = step_line_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  LineChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result.concat(this._segments);
  };
  LineChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return LineChart2;
}(categorical_chart_default);
deepExtend(LineChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var line_chart_default = LineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-segment.js
var AreaSegment = function(LineSegment2) {
  function AreaSegment2(linePoints, currentSeries, seriesIx, prevSegment, stackPoints) {
    LineSegment2.call(this, linePoints, currentSeries, seriesIx);
    this.prevSegment = prevSegment;
    this.stackPoints = stackPoints;
  }
  if (LineSegment2)
    AreaSegment2.__proto__ = LineSegment2;
  AreaSegment2.prototype = Object.create(LineSegment2 && LineSegment2.prototype);
  AreaSegment2.prototype.constructor = AreaSegment2;
  AreaSegment2.prototype.createVisual = function createVisual() {
    var series = this.series;
    var defaults = series._defaults;
    var lineOptions = series.line || {};
    var color = series.color;
    if (isFunction3(color) && defaults) {
      color = defaults.color;
    }
    this.visual = new drawing_exports.Group({
      zIndex: series.zIndex
    });
    this.createFill({
      fill: {
        color,
        opacity: series.opacity
      },
      stroke: null
    });
    if (lineOptions.width > 0 && lineOptions.visible !== false) {
      this.createStroke({
        stroke: deepExtend({
          color,
          opacity: series.opacity,
          lineCap: "butt"
        }, lineOptions)
      });
    }
  };
  AreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      segments = this._strokeSegments = this.createStrokeSegments();
    }
    return segments;
  };
  AreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.points());
  };
  AreaSegment2.prototype.stackSegments = function stackSegments() {
    if (this.prevSegment) {
      return this.prevSegment.createStackSegments(this.stackPoints);
    }
    return this.createStackSegments(this.stackPoints);
  };
  AreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.toGeometryPoints(stackPoints)).reverse();
  };
  AreaSegment2.prototype.segmentsFromPoints = function segmentsFromPoints(points3) {
    return points3.map(function(point2) {
      return new geometry_exports.Segment(point2);
    });
  };
  AreaSegment2.prototype.createStroke = function createStroke(style) {
    var stroke = new drawing_exports.Path(style);
    stroke.segments.push.apply(stroke.segments, this.strokeSegments());
    this.visual.append(stroke);
  };
  AreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return this.prevSegment || this.stackPoints && this.stackPoints.length;
  };
  AreaSegment2.prototype.createFill = function createFill(style) {
    var strokeSegments = this.strokeSegments();
    var fillSegments = strokeSegments.slice(0);
    var hasStackSegments = this.hasStackSegment();
    if (hasStackSegments) {
      var stackSegments = this.stackSegments();
      append2(fillSegments, stackSegments);
    }
    var fill = new drawing_exports.Path(style);
    fill.segments.push.apply(fill.segments, fillSegments);
    if (!hasStackSegments && strokeSegments.length > 1) {
      this.fillToAxes(fill);
    }
    this.visual.append(fill);
  };
  AreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var chart = this.parent;
    var invertAxes = chart.options.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.series);
    var crossingValue = chart.categoryAxisCrossingValue(valueAxis);
    var endSlot = valueAxis.getSlot(crossingValue, crossingValue, true);
    var segments = this.strokeSegments();
    var firstPoint = segments[0].anchor();
    var lastPoint = last2(segments).anchor();
    var end = invertAxes ? endSlot.x1 : endSlot.y1;
    if (invertAxes) {
      fillPath.lineTo(end, lastPoint.y).lineTo(end, firstPoint.y);
    } else {
      fillPath.lineTo(lastPoint.x, end).lineTo(firstPoint.x, end);
    }
  };
  return AreaSegment2;
}(line_segment_default);
var area_segment_default = AreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/step-area-segment.js
var StepAreaSegment = function(AreaSegment2) {
  function StepAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    StepAreaSegment2.__proto__ = AreaSegment2;
  StepAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  StepAreaSegment2.prototype.constructor = StepAreaSegment2;
  StepAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.linePoints));
  };
  StepAreaSegment2.prototype.createStackSegments = function createStackSegments(stackPoints) {
    return this.segmentsFromPoints(this.calculateStepPoints(stackPoints)).reverse();
  };
  return StepAreaSegment2;
}(area_segment_default);
deepExtend(StepAreaSegment.prototype, step_line_mixin_default);
var step_area_segment_default = StepAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/spline-area-segment.js
var SplineAreaSegment = function(AreaSegment2) {
  function SplineAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    SplineAreaSegment2.__proto__ = AreaSegment2;
  SplineAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  SplineAreaSegment2.prototype.constructor = SplineAreaSegment2;
  SplineAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    var curveProcessor = new curve_processor_default(this.options.closed);
    var linePoints = this.points();
    return curveProcessor.process(linePoints);
  };
  SplineAreaSegment2.prototype.createStackSegments = function createStackSegments() {
    var strokeSegments = this.strokeSegments();
    var stackSegments = [];
    for (var idx = strokeSegments.length - 1; idx >= 0; idx--) {
      var segment = strokeSegments[idx];
      stackSegments.push(new geometry_exports.Segment(
        segment.anchor(),
        segment.controlOut(),
        segment.controlIn()
      ));
    }
    return stackSegments;
  };
  return SplineAreaSegment2;
}(area_segment_default);
var spline_area_segment_default = SplineAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/area-chart/area-chart.js
var AreaChart = function(LineChart2) {
  function AreaChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    AreaChart2.__proto__ = LineChart2;
  AreaChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  AreaChart2.prototype.constructor = AreaChart2;
  AreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    if (isStacked && seriesIx > 0 && prevSegment) {
      var missingValues = this.seriesMissingValues(currentSeries);
      if (missingValues !== "gap") {
        stackPoints = prevSegment.linePoints;
        previousSegment = prevSegment;
      } else {
        stackPoints = this._gapStackPoints(linePoints, seriesIx, style);
      }
    }
    var pointType;
    if (style === STEP) {
      pointType = step_area_segment_default;
    } else if (style === SMOOTH) {
      pointType = spline_area_segment_default;
    } else {
      pointType = area_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
  };
  AreaChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    LineChart2.prototype.reflow.call(this, targetBox);
    var stackPoints = this._stackPoints;
    if (stackPoints) {
      for (var idx = 0; idx < stackPoints.length; idx++) {
        var stackPoint = stackPoints[idx];
        var pointSlot = this$1.categoryAxis.getSlot(stackPoint.categoryIx);
        stackPoint.reflow(pointSlot);
      }
    }
  };
  AreaChart2.prototype._gapStackPoints = function _gapStackPoints(linePoints, seriesIx, style) {
    var this$1 = this;
    var seriesPoints = this.seriesPoints;
    var startIdx = linePoints[0].categoryIx;
    var length = linePoints.length;
    if (startIdx < 0) {
      startIdx = 0;
      length--;
    }
    var endIdx = startIdx + length;
    var pointOffset = this.seriesOptions[0]._outOfRangeMinPoint ? 1 : 0;
    var stackPoints = [];
    this._stackPoints = this._stackPoints || [];
    for (var categoryIx = startIdx; categoryIx < endIdx; categoryIx++) {
      var pointIx = categoryIx + pointOffset;
      var currentSeriesIx = seriesIx;
      var point2 = void 0;
      do {
        currentSeriesIx--;
        point2 = seriesPoints[currentSeriesIx][pointIx];
      } while (currentSeriesIx > 0 && !point2);
      if (point2) {
        if (style !== STEP && categoryIx > startIdx && !seriesPoints[currentSeriesIx][pointIx - 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx - 1, currentSeriesIx));
        }
        stackPoints.push(point2);
        if (style !== STEP && categoryIx + 1 < endIdx && !seriesPoints[currentSeriesIx][pointIx + 1]) {
          stackPoints.push(this$1._previousSegmentPoint(categoryIx, pointIx, pointIx + 1, currentSeriesIx));
        }
      } else {
        var gapStackPoint = this$1._createGapStackPoint(categoryIx);
        this$1._stackPoints.push(gapStackPoint);
        stackPoints.push(gapStackPoint);
      }
    }
    return stackPoints;
  };
  AreaChart2.prototype._previousSegmentPoint = function _previousSegmentPoint(categoryIx, pointIx, segmentIx, seriesIdx) {
    var seriesPoints = this.seriesPoints;
    var index = seriesIdx;
    var point2;
    while (index > 0 && !point2) {
      index--;
      point2 = seriesPoints[index][segmentIx];
    }
    if (!point2) {
      point2 = this._createGapStackPoint(categoryIx);
      this._stackPoints.push(point2);
    } else {
      point2 = seriesPoints[index][pointIx];
    }
    return point2;
  };
  AreaChart2.prototype._createGapStackPoint = function _createGapStackPoint(categoryIx) {
    var options2 = this.pointOptions({}, 0);
    var point2 = new line_point_default(0, options2);
    point2.categoryIx = categoryIx;
    point2.series = {};
    return point2;
  };
  AreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  AreaChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return AreaChart2;
}(line_chart_default);
var area_chart_default = AreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/axis-group-range-tracker.js
var AxisGroupRangeTracker = function(Class3) {
  function AxisGroupRangeTracker2() {
    Class3.call(this);
    this.axisRanges = {};
  }
  if (Class3)
    AxisGroupRangeTracker2.__proto__ = Class3;
  AxisGroupRangeTracker2.prototype = Object.create(Class3 && Class3.prototype);
  AxisGroupRangeTracker2.prototype.constructor = AxisGroupRangeTracker2;
  AxisGroupRangeTracker2.prototype.update = function update(chartAxisRanges) {
    var axisRanges2 = this.axisRanges;
    for (var axisName in chartAxisRanges) {
      var chartRange = chartAxisRanges[axisName];
      var range = axisRanges2[axisName];
      axisRanges2[axisName] = range = range || { min: MAX_VALUE, max: MIN_VALUE };
      range.min = Math.min(range.min, chartRange.min);
      range.max = Math.max(range.max, chartRange.max);
    }
  };
  AxisGroupRangeTracker2.prototype.reset = function reset(axisName) {
    this.axisRanges[axisName] = void 0;
  };
  AxisGroupRangeTracker2.prototype.query = function query(axisName) {
    return this.axisRanges[axisName];
  };
  return AxisGroupRangeTracker2;
}(class_default);
var axis_group_range_tracker_default = AxisGroupRangeTracker;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-label.js
var BarLabel = function(ChartElement2) {
  function BarLabel2(content, options2, pointData) {
    ChartElement2.call(this, options2);
    this.textBox = new text_box_default(content, this.options, pointData);
    this.append(this.textBox);
  }
  if (ChartElement2)
    BarLabel2.__proto__ = ChartElement2;
  BarLabel2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  BarLabel2.prototype.constructor = BarLabel2;
  BarLabel2.prototype.createVisual = function createVisual() {
    this.textBox.options.noclip = this.options.noclip;
  };
  BarLabel2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var vertical = options2.vertical;
    var aboveAxis = options2.aboveAxis;
    var text = this.children[0];
    var textOptions = text.options;
    var box = text.box;
    var padding = text.options.padding;
    var labelBox = targetBox;
    textOptions.align = vertical ? CENTER : LEFT;
    textOptions.vAlign = vertical ? TOP : CENTER;
    if (options2.position === INSIDE_END) {
      if (vertical) {
        textOptions.vAlign = TOP;
        if (!aboveAxis && box.height() < targetBox.height()) {
          textOptions.vAlign = BOTTOM;
        }
      } else {
        textOptions.align = aboveAxis ? RIGHT : LEFT;
      }
    } else if (options2.position === CENTER) {
      textOptions.vAlign = CENTER;
      textOptions.align = CENTER;
    } else if (options2.position === INSIDE_BASE) {
      if (vertical) {
        textOptions.vAlign = aboveAxis ? BOTTOM : TOP;
      } else {
        textOptions.align = aboveAxis ? LEFT : RIGHT;
      }
    } else if (options2.position === OUTSIDE_END) {
      if (vertical) {
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y1 - box.height(),
            targetBox.x2,
            targetBox.y1
          );
        } else {
          labelBox = new box_default(
            targetBox.x1,
            targetBox.y2,
            targetBox.x2,
            targetBox.y2 + box.height()
          );
        }
      } else {
        textOptions.align = CENTER;
        if (aboveAxis) {
          labelBox = new box_default(
            targetBox.x2,
            targetBox.y1,
            targetBox.x2 + box.width(),
            targetBox.y2
          );
        } else {
          labelBox = new box_default(
            targetBox.x1 - box.width(),
            targetBox.y1,
            targetBox.x1,
            targetBox.y2
          );
        }
      }
    }
    if (!options2.rotation) {
      if (vertical) {
        padding.left = padding.right = (labelBox.width() - text.contentBox.width()) / 2;
      } else {
        padding.top = padding.bottom = (labelBox.height() - text.contentBox.height()) / 2;
      }
    }
    text.reflow(labelBox);
  };
  BarLabel2.prototype.alignToClipBox = function alignToClipBox(clipBox) {
    var vertical = this.options.vertical;
    var field = vertical ? Y : X;
    var start = field + "1";
    var end = field + "2";
    var text = this.children[0];
    var parentBox = this.parent.box;
    if (parentBox[start] < clipBox[start] || clipBox[end] < parentBox[end]) {
      var targetBox = text.paddingBox.clone();
      targetBox[start] = Math.max(parentBox[start], clipBox[start]);
      targetBox[end] = Math.min(parentBox[end], clipBox[end]);
      this.reflow(targetBox);
    }
  };
  return BarLabel2;
}(chart_element_default);
setDefaultOptions(BarLabel, {
  position: OUTSIDE_END,
  margin: getSpacing(3),
  padding: getSpacing(4),
  color: BLACK,
  background: "",
  border: {
    width: 1,
    color: ""
  },
  aboveAxis: true,
  vertical: false,
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  },
  zIndex: 2
});
var bar_label_default = BarLabel;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-gradient-overlay.js
function hasGradientOverlay(options2) {
  var overlay = options2.overlay;
  return overlay && overlay.gradient && overlay.gradient !== "none";
}

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar.js
var BAR_ALIGN_MIN_WIDTH = 6;
var Bar = function(ChartElement2) {
  function Bar2(value, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.value = value;
  }
  if (ChartElement2)
    Bar2.__proto__ = ChartElement2;
  Bar2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bar2.prototype.constructor = Bar2;
  Bar2.prototype.render = function render3() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createLabel();
    this.createNote();
    if (this.errorBar) {
      this.append(this.errorBar);
    }
  };
  Bar2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      this.label = new bar_label_default(
        labelText,
        deepExtend(
          {
            vertical: options2.vertical
          },
          labels
        ),
        pointData
      );
      this.append(this.label);
    }
  };
  Bar2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bar2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    if (this.errorBars) {
      for (var i = 0; i < this.errorBars.length; i++) {
        this$1.errorBars[i].reflow(targetBox);
      }
    }
  };
  Bar2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var box = ref2.box;
    var options2 = ref2.options;
    var customVisual = options2.visual;
    if (this.visible !== false) {
      ChartElement2.prototype.createVisual.call(this);
      if (customVisual) {
        var visual = this.rectVisual = customVisual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          sender: this.getSender(),
          series: this.series,
          percentage: this.percentage,
          stackValue: this.stackValue,
          runningTotal: this.runningTotal,
          total: this.total,
          rect: box.toRect(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createRect(group);
            return group;
          },
          options: options2
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else if (box.width() > 0 && box.height() > 0) {
        this.createRect(this.visual);
      }
    }
  };
  Bar2.prototype.createRect = function createRect(visual) {
    var options2 = this.options;
    var border = options2.border;
    var strokeOpacity = defined2(border.opacity) ? border.opacity : options2.opacity;
    var rect = this.box.toRect();
    rect.size.width = Math.round(rect.size.width);
    var path = this.rectVisual = drawing_exports.Path.fromRect(rect, {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: {
        color: this.getBorderColor(),
        width: border.width,
        opacity: strokeOpacity,
        dashType: border.dashType
      }
    });
    var width = this.box.width();
    var height = this.box.height();
    var size = options2.vertical ? width : height;
    if (size > BAR_ALIGN_MIN_WIDTH) {
      alignPathToPixel(path);
      if (width < 1 || height < 1) {
        path.options.stroke.lineJoin = "round";
      }
    }
    visual.append(path);
    if (hasGradientOverlay(options2)) {
      var overlay = this.createGradientOverlay(path, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay));
      visual.append(overlay);
    }
  };
  Bar2.prototype.createHighlight = function createHighlight(style) {
    var highlight = drawing_exports.Path.fromRect(this.box.toRect(), style);
    return alignPathToPixel(highlight);
  };
  Bar2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  Bar2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  Bar2.prototype.getBorderColor = function getBorderColor() {
    var color = this.color;
    var border = this.options.border;
    var brightness = border._brightness || BORDER_BRIGHTNESS;
    var borderColor = border.color;
    if (!defined2(borderColor)) {
      borderColor = new color_default(color).brightness(brightness).toHex();
    }
    return borderColor;
  };
  Bar2.prototype.tooltipAnchor = function tooltipAnchor() {
    var ref2 = this;
    var options2 = ref2.options;
    var box = ref2.box;
    var aboveAxis = ref2.aboveAxis;
    var clipBox = this.owner.pane.clipBox() || box;
    var horizontalAlign = LEFT;
    var verticalAlign = TOP;
    var x, y;
    if (options2.vertical) {
      x = Math.min(box.x2, clipBox.x2) + TOOLTIP_OFFSET;
      if (aboveAxis) {
        y = Math.max(box.y1, clipBox.y1);
      } else {
        y = Math.min(box.y2, clipBox.y2);
        verticalAlign = BOTTOM;
      }
    } else {
      var x1 = Math.max(box.x1, clipBox.x1);
      var x2 = Math.min(box.x2, clipBox.x2);
      if (options2.isStacked) {
        verticalAlign = BOTTOM;
        if (aboveAxis) {
          horizontalAlign = RIGHT;
          x = x2;
        } else {
          x = x1;
        }
        y = Math.max(box.y1, clipBox.y1) - TOOLTIP_OFFSET;
      } else {
        if (aboveAxis) {
          x = x2 + TOOLTIP_OFFSET;
        } else {
          x = x1 - TOOLTIP_OFFSET;
          horizontalAlign = RIGHT;
        }
        y = Math.max(box.y1, clipBox.y1);
      }
    }
    return {
      point: new point_default2(x, y),
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  Bar2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  Bar2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      percentage: this.percentage,
      stackValue: this.stackValue,
      runningTotal: this.runningTotal,
      total: this.total,
      series: this.series
    };
  };
  return Bar2;
}(chart_element_default);
deepExtend(Bar.prototype, point_events_mixin_default);
deepExtend(Bar.prototype, note_mixin_default);
Bar.prototype.defaults = {
  border: {
    width: 1
  },
  vertical: true,
  overlay: {
    gradient: "glass"
  },
  labels: {
    visible: false,
    format: "{0}"
  },
  opacity: 1,
  notes: {
    label: {}
  }
};
var bar_default = Bar;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/utils.js
function forEach2(elements, callback) {
  elements.forEach(callback);
}
function forEachReverse2(elements, callback) {
  var length = elements.length;
  for (var idx = length - 1; idx >= 0; idx--) {
    callback(elements[idx], idx - length - 1);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/layout/cluster-layout.js
var ClusterLayout = function(ChartElement2) {
  function ClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse2 : forEach2;
  }
  if (ChartElement2)
    ClusterLayout2.__proto__ = ChartElement2;
  ClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ClusterLayout2.prototype.constructor = ClusterLayout2;
  ClusterLayout2.prototype.reflow = function reflow(box) {
    var ref2 = this.options;
    var vertical = ref2.vertical;
    var gap = ref2.gap;
    var spacing = ref2.spacing;
    var children = this.children;
    var count = children.length;
    var axis = vertical ? Y : X;
    var slots = count + gap + spacing * (count - 1);
    var slotSize = (vertical ? box.height() : box.width()) / slots;
    var position = box[axis + 1] + slotSize * (gap / 2);
    this.forEach(children, function(child, idx) {
      var childBox = (child.box || box).clone();
      childBox[axis + 1] = position;
      childBox[axis + 2] = position + slotSize;
      child.reflow(childBox);
      if (idx < count - 1) {
        position += slotSize * spacing;
      }
      position += slotSize;
    });
  };
  return ClusterLayout2;
}(chart_element_default);
setDefaultOptions(ClusterLayout, {
  vertical: false,
  gap: 0,
  spacing: 0
});
var cluster_layout_default = ClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/stack-wrap.js
var StackWrap = function(ChartElement2) {
  function StackWrap2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    StackWrap2.__proto__ = ChartElement2;
  StackWrap2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  StackWrap2.prototype.constructor = StackWrap2;
  StackWrap2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var positionAxis = this.options.vertical ? X : Y;
    var children = this.children;
    var childrenCount = children.length;
    var box = this.box = new box_default();
    for (var i = 0; i < childrenCount; i++) {
      var currentChild = children[i];
      if (currentChild.visible !== false) {
        var childBox = currentChild.box.clone();
        childBox.snapTo(targetBox, positionAxis);
        if (i === 0) {
          box = this$1.box = childBox.clone();
        }
        currentChild.reflow(childBox);
        box.wrap(childBox);
      }
    }
  };
  return StackWrap2;
}(chart_element_default);
setDefaultOptions(StackWrap, {
  vertical: true
});
var stack_wrap_default = StackWrap;

// node_modules/@progress/kendo-charts/dist/es/chart/bar-chart/bar-chart.js
var BarChart = function(CategoricalChart2) {
  function BarChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    BarChart2.__proto__ = CategoricalChart2;
  BarChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BarChart2.prototype.constructor = BarChart2;
  BarChart2.prototype.render = function render3() {
    CategoricalChart2.prototype.render.call(this);
    this.updateStackRange();
  };
  BarChart2.prototype.pointType = function pointType() {
    return bar_default;
  };
  BarChart2.prototype.clusterType = function clusterType() {
    return cluster_layout_default;
  };
  BarChart2.prototype.stackType = function stackType() {
    return stack_wrap_default;
  };
  BarChart2.prototype.stackLimits = function stackLimits(axisName, stackName) {
    var limits = CategoricalChart2.prototype.stackLimits.call(this, axisName, stackName);
    return limits;
  };
  BarChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var isStacked = options2.isStacked;
    var value = this.pointValue(data);
    var pointOptions = this.pointOptions(series, seriesIx);
    var labelOptions = pointOptions.labels;
    if (isStacked) {
      if (labelOptions.position === OUTSIDE_END) {
        labelOptions.position = INSIDE_END;
      }
    }
    pointOptions.isStacked = isStacked;
    var color = data.fields.color || series.color;
    if (value < 0 && pointOptions.negativeColor) {
      color = pointOptions.negativeColor;
    }
    pointOptions = this.evalPointOptions(
      pointOptions,
      value,
      category,
      categoryIx,
      series,
      seriesIx
    );
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var pointType = this.pointType();
    var point2 = new pointType(value, pointOptions);
    point2.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      var clusterType = this.clusterType();
      cluster = new clusterType({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (isStacked) {
      var stackWrap = this.getStackWrap(series, cluster);
      stackWrap.append(point2);
    } else {
      cluster.append(point2);
    }
    return point2;
  };
  BarChart2.prototype.getStackWrap = function getStackWrap(series, cluster) {
    var stack2 = series.stack;
    var stackGroup = stack2 ? stack2.group || stack2 : stack2;
    var wraps = cluster.children;
    var stackWrap;
    if (typeof stackGroup === STRING) {
      for (var i = 0; i < wraps.length; i++) {
        if (wraps[i]._stackGroup === stackGroup) {
          stackWrap = wraps[i];
          break;
        }
      }
    } else {
      stackWrap = wraps[0];
    }
    if (!stackWrap) {
      var stackType = this.stackType();
      stackWrap = new stackType({
        vertical: !this.options.invertAxes
      });
      stackWrap._stackGroup = stackGroup;
      cluster.append(stackWrap);
    }
    return stackWrap;
  };
  BarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx, valueAxis) {
    var options2 = this.options;
    var categorySlot2 = categoryAxis.getSlot(categoryIx);
    var startValue = valueAxis.startValue();
    if (options2.isStacked) {
      var zeroSlot = valueAxis.getSlot(startValue, startValue, true);
      var stackAxis = options2.invertAxes ? X : Y;
      categorySlot2[stackAxis + 1] = categorySlot2[stackAxis + 2] = zeroSlot[stackAxis + 1];
    }
    return categorySlot2;
  };
  BarChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BarChart2.prototype.createAnimation = function createAnimation() {
    this._setAnimationOptions();
    CategoricalChart2.prototype.createAnimation.call(this);
    if (anyHasZIndex(this.options.series)) {
      this._setChildrenAnimation();
    }
  };
  BarChart2.prototype._setChildrenAnimation = function _setChildrenAnimation() {
    var this$1 = this;
    var points3 = this.points;
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      var pointVisual = point2.visual;
      if (pointVisual && defined2(pointVisual.options.zIndex)) {
        point2.options.animation = this$1.options.animation;
        point2.createAnimation();
      }
    }
  };
  BarChart2.prototype._setAnimationOptions = function _setAnimationOptions() {
    var options2 = this.options;
    var animation = options2.animation || {};
    var origin;
    if (options2.isStacked) {
      var valueAxis = this.seriesValueAxis(options2.series[0]);
      origin = valueAxis.getSlot(valueAxis.startValue());
    } else {
      origin = this.categoryAxis.getSlot(0);
    }
    animation.origin = new geometry_exports.Point(origin.x1, origin.y1);
    animation.vertical = !options2.invertAxes;
  };
  return BarChart2;
}(categorical_chart_default);
setDefaultOptions(BarChart, {
  animation: {
    type: BAR
  }
});
var bar_chart_default = BarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick.js
var Candlestick = function(ChartElement2) {
  function Candlestick2(value, options2) {
    ChartElement2.call(this, options2);
    this.value = value;
  }
  if (ChartElement2)
    Candlestick2.__proto__ = ChartElement2;
  Candlestick2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Candlestick2.prototype.constructor = Candlestick2;
  Candlestick2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var ocSlot = valueAxis.getSlot(value.open, value.close);
    var lhSlot = valueAxis.getSlot(value.low, value.high);
    ocSlot.x1 = lhSlot.x1 = box.x1;
    ocSlot.x2 = lhSlot.x2 = box.x2;
    this.realBody = ocSlot;
    var mid = lhSlot.center().x;
    var points3 = [];
    points3.push([[mid, lhSlot.y1], [mid, ocSlot.y1]]);
    points3.push([[mid, ocSlot.y2], [mid, lhSlot.y2]]);
    this.lines = points3;
    this.box = lhSlot.clone().wrap(ocSlot);
    if (!this._rendered) {
      this._rendered = true;
      this.createNote();
    }
    this.reflowNote();
  };
  Candlestick2.prototype.reflowNote = function reflowNote() {
    if (this.note) {
      this.note.reflow(this.box);
    }
  };
  Candlestick2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    this._mainVisual = this.mainVisual(this.options);
    this.visual.append(
      this._mainVisual
    );
    this.createOverlay();
  };
  Candlestick2.prototype.mainVisual = function mainVisual(options2) {
    var group = new drawing_exports.Group();
    this.createBody(group, options2);
    this.createLines(group, options2);
    return group;
  };
  Candlestick2.prototype.createBody = function createBody(container, options2) {
    var body = drawing_exports.Path.fromRect(this.realBody.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: this.getBorderColor(),
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault2(options2.border.opacity, options2.opacity)
      });
    }
    alignPathToPixel(body);
    container.append(body);
    if (hasGradientOverlay(options2)) {
      container.append(this.createGradientOverlay(body, { baseColor: this.color }, deepExtend({
        end: !options2.vertical ? [0, 1] : void 0
      }, options2.overlay)));
    }
  };
  Candlestick2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.lines, options2.line);
  };
  Candlestick2.prototype.drawLines = function drawLines(container, options2, lines, lineOptions) {
    if (!lines) {
      return;
    }
    var lineStyle = {
      stroke: {
        color: lineOptions.color || this.color,
        opacity: valueOrDefault2(lineOptions.opacity, options2.opacity),
        width: lineOptions.width,
        dashType: lineOptions.dashType,
        lineCap: "butt"
      }
    };
    for (var i = 0; i < lines.length; i++) {
      var line = drawing_exports.Path.fromPoints(lines[i], lineStyle);
      alignPathToPixel(line);
      container.append(line);
    }
  };
  Candlestick2.prototype.getBorderColor = function getBorderColor() {
    var border = this.options.border;
    var borderColor = border.color;
    if (!defined2(borderColor)) {
      borderColor = new color_default(this.color).brightness(border._brightness).toHex();
    }
    return borderColor;
  };
  Candlestick2.prototype.createOverlay = function createOverlay() {
    var overlay = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null
    });
    this.visual.append(overlay);
  };
  Candlestick2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var normalColor = this.color;
    this.color = highlight.color || this.color;
    var overlay = this.mainVisual(
      deepExtend({}, this.options, {
        line: {
          color: this.getBorderColor()
        }
      }, highlight)
    );
    this.color = normalColor;
    return overlay;
  };
  Candlestick2.prototype.highlightVisual = function highlightVisual() {
    return this._mainVisual;
  };
  Candlestick2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this._mainVisual
    };
  };
  Candlestick2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    var clipBox = this.owner.pane.clipBox() || box;
    return {
      point: new point_default2(box.x2 + TOOLTIP_OFFSET, Math.max(box.y1, clipBox.y1) + TOOLTIP_OFFSET),
      align: {
        horizontal: LEFT,
        vertical: TOP
      }
    };
  };
  Candlestick2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Candlestick2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  return Candlestick2;
}(chart_element_default);
setDefaultOptions(Candlestick, {
  vertical: true,
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{4:d}</th></tr><tr><td>Open:</td><td>{0:C}</td></tr><tr><td>High:</td><td>{1:C}</td></tr><tr><td>Low:</td><td>{2:C}</td></tr><tr><td>Close:</td><td>{3:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  }
});
deepExtend(Candlestick.prototype, point_events_mixin_default);
deepExtend(Candlestick.prototype, note_mixin_default);
var candlestick_default = Candlestick;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/are-numbers.js
function areNumbers(values5) {
  return countNumbers(values5) === values5.length;
}

// node_modules/@progress/kendo-charts/dist/es/chart/candlestick-chart/candlestick-chart.js
var CandlestickChart = function(CategoricalChart2) {
  function CandlestickChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    CandlestickChart2.__proto__ = CategoricalChart2;
  CandlestickChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  CandlestickChart2.prototype.constructor = CandlestickChart2;
  CandlestickChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  CandlestickChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value = data.valueFields;
    var valueParts = this.splitValue(value);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point2 = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
      point2.noteText = data.fields.noteText;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  CandlestickChart2.prototype.pointType = function pointType() {
    return candlestick_default;
  };
  CandlestickChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var pointType = this.pointType();
    var value = data.valueFields;
    var pointOptions = deepExtend({}, series);
    var color = data.fields.color || series.color;
    pointOptions = this.evalPointOptions(
      pointOptions,
      value,
      category,
      categoryIx,
      series,
      seriesIx
    );
    if (series.type === CANDLESTICK) {
      if (value.open > value.close) {
        color = data.fields.downColor || series.downColor || series.color;
      }
    }
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.vertical = !this.options.invertAxes;
    var point2 = new pointType(value, pointOptions);
    point2.color = color;
    return point2;
  };
  CandlestickChart2.prototype.splitValue = function splitValue(value) {
    return [value.low, value.open, value.close, value.high];
  };
  CandlestickChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var parts = this.splitValue(value);
    var axisRange = this.valueAxisRanges[axisName];
    axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
    axisRange = this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  CandlestickChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(
      format2,
      value.open,
      value.high,
      value.low,
      value.close,
      point2.category
    );
  };
  CandlestickChart2.prototype.animationPoints = function animationPoints() {
    return this.points;
  };
  return CandlestickChart2;
}(categorical_chart_default);
deepExtend(CandlestickChart.prototype, clip_animation_mixin_default);
var candlestick_chart_default = CandlestickChart;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot.js
var BoxPlot = function(Candlestick2) {
  function BoxPlot2(value, options2) {
    Candlestick2.call(this, value, options2);
    this.createNote();
  }
  if (Candlestick2)
    BoxPlot2.__proto__ = Candlestick2;
  BoxPlot2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  BoxPlot2.prototype.constructor = BoxPlot2;
  BoxPlot2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var whiskerSlot, boxSlot;
    this.boxSlot = boxSlot = valueAxis.getSlot(value.q1, value.q3);
    this.realBody = boxSlot;
    this.reflowBoxSlot(box);
    this.whiskerSlot = whiskerSlot = valueAxis.getSlot(value.lower, value.upper);
    this.reflowWhiskerSlot(box);
    var medianSlot = valueAxis.getSlot(value.median);
    if (value.mean) {
      var meanSlot = valueAxis.getSlot(value.mean);
      this.meanPoints = this.calcMeanPoints(box, meanSlot);
    }
    this.whiskerPoints = this.calcWhiskerPoints(boxSlot, whiskerSlot);
    this.medianPoints = this.calcMedianPoints(box, medianSlot);
    this.box = whiskerSlot.clone().wrap(boxSlot);
    this.reflowNote();
  };
  BoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.x1 = box.x1;
    this.boxSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.x1 = box.x1;
    this.whiskerSlot.x2 = box.x2;
  };
  BoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[box.x1, meanSlot.y1], [box.x2, meanSlot.y1]]
    ];
  };
  BoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().x;
    return [[
      [mid - 5, whiskerSlot.y1],
      [mid + 5, whiskerSlot.y1],
      [mid, whiskerSlot.y1],
      [mid, boxSlot.y1]
    ], [
      [mid - 5, whiskerSlot.y2],
      [mid + 5, whiskerSlot.y2],
      [mid, whiskerSlot.y2],
      [mid, boxSlot.y2]
    ]];
  };
  BoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[box.x1, medianSlot.y1], [box.x2, medianSlot.y1]]
    ];
  };
  BoxPlot2.prototype.renderOutliers = function renderOutliers(options2) {
    var this$1 = this;
    var value = this.value;
    var outliers = value.outliers || [];
    var outerFence = Math.abs(value.q3 - value.q1) * 3;
    var elements = [];
    var markers = options2.markers || {};
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i];
      if (outlierValue < value.q3 + outerFence && outlierValue > value.q1 - outerFence) {
        markers = options2.outliers;
      } else {
        markers = options2.extremes;
      }
      var markersBorder = deepExtend({}, markers.border);
      if (!defined2(markersBorder.color)) {
        if (defined2(this$1.color)) {
          markersBorder.color = this$1.color;
        } else {
          markersBorder.color = new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex();
        }
      }
      var shape2 = new shape_element_default({
        type: markers.type,
        width: markers.size,
        height: markers.size,
        rotation: markers.rotation,
        background: markers.background,
        border: markersBorder,
        opacity: markers.opacity
      });
      shape2.value = outlierValue;
      elements.push(shape2);
    }
    this.reflowOutliers(elements);
    return elements;
  };
  BoxPlot2.prototype.reflowOutliers = function reflowOutliers(outliers) {
    var this$1 = this;
    var valueAxis = this.owner.seriesValueAxis(this.options);
    var center = this.box.center();
    for (var i = 0; i < outliers.length; i++) {
      var outlierValue = outliers[i].value;
      var markerBox = valueAxis.getSlot(outlierValue);
      if (this$1.options.vertical) {
        markerBox.move(center.x);
      } else {
        markerBox.move(void 0, center.y);
      }
      this$1.box = this$1.box.wrap(markerBox);
      outliers[i].reflow(markerBox);
    }
  };
  BoxPlot2.prototype.mainVisual = function mainVisual(options2) {
    var group = Candlestick2.prototype.mainVisual.call(this, options2);
    var outliers = this.renderOutliers(options2);
    for (var i = 0; i < outliers.length; i++) {
      var element = outliers[i].getElement();
      if (element) {
        group.append(element);
      }
    }
    return group;
  };
  BoxPlot2.prototype.createLines = function createLines(container, options2) {
    this.drawLines(container, options2, this.whiskerPoints, options2.whiskers);
    this.drawLines(container, options2, this.medianPoints, options2.median);
    this.drawLines(container, options2, this.meanPoints, options2.mean);
  };
  BoxPlot2.prototype.getBorderColor = function getBorderColor() {
    if ((this.options.border || {}).color) {
      return this.options.border.color;
    }
    if (this.color) {
      return this.color;
    }
    return Candlestick2.prototype.getBorderColor.call(this);
  };
  return BoxPlot2;
}(candlestick_default);
setDefaultOptions(BoxPlot, {
  border: {
    _brightness: 0.8
  },
  line: {
    width: 2
  },
  median: {
    color: "#f6f6f6"
  },
  mean: {
    width: 2,
    dashType: "dash",
    color: "#f6f6f6"
  },
  overlay: {
    gradient: "glass"
  },
  tooltip: {
    format: "<table><tr><th colspan='2'>{6:d}</th></tr><tr><td>Lower:</td><td>{0:C}</td></tr><tr><td>Q1:</td><td>{1:C}</td></tr><tr><td>Median:</td><td>{2:C}</td></tr><tr><td>Mean:</td><td>{5:C}</td></tr><tr><td>Q3:</td><td>{3:C}</td></tr><tr><td>Upper:</td><td>{4:C}</td></tr></table>"
  },
  highlight: {
    opacity: 1,
    border: {
      width: 1,
      opacity: 1
    },
    line: {
      width: 1,
      opacity: 1
    }
  },
  notes: {
    visible: true,
    label: {}
  },
  outliers: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CROSS,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  },
  extremes: {
    visible: true,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    background: WHITE,
    border: {
      width: 2,
      opacity: 1
    },
    opacity: 0
  }
});
deepExtend(BoxPlot.prototype, point_events_mixin_default);
var box_plot_default = BoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/vertical-box-plot.js
var VerticalBoxPlot = function(BoxPlot2) {
  function VerticalBoxPlot2() {
    BoxPlot2.apply(this, arguments);
  }
  if (BoxPlot2)
    VerticalBoxPlot2.__proto__ = BoxPlot2;
  VerticalBoxPlot2.prototype = Object.create(BoxPlot2 && BoxPlot2.prototype);
  VerticalBoxPlot2.prototype.constructor = VerticalBoxPlot2;
  VerticalBoxPlot2.prototype.reflowBoxSlot = function reflowBoxSlot(box) {
    this.boxSlot.y1 = box.y1;
    this.boxSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.reflowWhiskerSlot = function reflowWhiskerSlot(box) {
    this.whiskerSlot.y1 = box.y1;
    this.whiskerSlot.y2 = box.y2;
  };
  VerticalBoxPlot2.prototype.calcMeanPoints = function calcMeanPoints(box, meanSlot) {
    return [
      [[meanSlot.x1, box.y1], [meanSlot.x1, box.y2]]
    ];
  };
  VerticalBoxPlot2.prototype.calcWhiskerPoints = function calcWhiskerPoints(boxSlot, whiskerSlot) {
    var mid = whiskerSlot.center().y;
    return [[
      [whiskerSlot.x1, mid - 5],
      [whiskerSlot.x1, mid + 5],
      [whiskerSlot.x1, mid],
      [boxSlot.x1, mid]
    ], [
      [whiskerSlot.x2, mid - 5],
      [whiskerSlot.x2, mid + 5],
      [whiskerSlot.x2, mid],
      [boxSlot.x2, mid]
    ]];
  };
  VerticalBoxPlot2.prototype.calcMedianPoints = function calcMedianPoints(box, medianSlot) {
    return [
      [[medianSlot.x1, box.y1], [medianSlot.x1, box.y2]]
    ];
  };
  return VerticalBoxPlot2;
}(box_plot_default);
var vertical_box_plot_default = VerticalBoxPlot;

// node_modules/@progress/kendo-charts/dist/es/chart/box-plot-chart/box-plot-chart.js
var BoxPlotChart = function(CandlestickChart2) {
  function BoxPlotChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    BoxPlotChart2.__proto__ = CandlestickChart2;
  BoxPlotChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  BoxPlotChart2.prototype.constructor = BoxPlotChart2;
  BoxPlotChart2.prototype.addValue = function addValue(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var value = data.valueFields;
    var valueParts = this.splitValue(value);
    var hasValue3 = areNumbers(valueParts);
    var dataItem = series.data[categoryIx];
    var categoryPoints = this.categoryPoints[categoryIx];
    var point2;
    if (!categoryPoints) {
      this.categoryPoints[categoryIx] = categoryPoints = [];
    }
    if (hasValue3) {
      point2 = this.createPoint(data, fields);
    }
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    if (point2) {
      this.updateRange(value, fields);
      cluster.append(point2);
      point2.categoryIx = categoryIx;
      point2.category = category;
      point2.series = series;
      point2.seriesIx = seriesIx;
      point2.owner = this;
      point2.dataItem = dataItem;
    }
    this.points.push(point2);
    categoryPoints.push(point2);
  };
  BoxPlotChart2.prototype.pointType = function pointType() {
    if (this.options.invertAxes) {
      return vertical_box_plot_default;
    }
    return box_plot_default;
  };
  BoxPlotChart2.prototype.splitValue = function splitValue(value) {
    return [
      value.lower,
      value.q1,
      value.median,
      value.q3,
      value.upper
    ];
  };
  BoxPlotChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    var parts = this.splitValue(value).concat(this.filterOutliers(value.outliers));
    if (defined2(value.mean)) {
      parts = parts.concat(value.mean);
    }
    axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
    axisRange = this.valueAxisRanges[axisName] = {
      min: Math.min.apply(Math, parts.concat([axisRange.min])),
      max: Math.max.apply(Math, parts.concat([axisRange.max]))
    };
  };
  BoxPlotChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(
      format2,
      value.lower,
      value.q1,
      value.median,
      value.q3,
      value.upper,
      value.mean,
      point2.category
    );
  };
  BoxPlotChart2.prototype.filterOutliers = function filterOutliers(items) {
    var length = (items || []).length;
    var result = [];
    for (var i = 0; i < length; i++) {
      var item = items[i];
      if (defined2(item) && item !== null) {
        result.push(item);
      }
    }
    return result;
  };
  BoxPlotChart2.prototype.supportsPointInactiveOpacity = function supportsPointInactiveOpacity() {
    return false;
  };
  return BoxPlotChart2;
}(candlestick_chart_default);
var box_plot_chart_default = BoxPlotChart;

// node_modules/@progress/kendo-charts/dist/es/chart/error-bars/scatter-error-bar.js
var ScatterErrorBar = function(ErrorBarBase2) {
  function ScatterErrorBar2() {
    ErrorBarBase2.apply(this, arguments);
  }
  if (ErrorBarBase2)
    ScatterErrorBar2.__proto__ = ErrorBarBase2;
  ScatterErrorBar2.prototype = Object.create(ErrorBarBase2 && ErrorBarBase2.prototype);
  ScatterErrorBar2.prototype.constructor = ScatterErrorBar2;
  ScatterErrorBar2.prototype.getAxis = function getAxis() {
    var axes = this.chart.seriesAxes(this.series);
    var axis = this.isVertical ? axes.y : axes.x;
    return axis;
  };
  return ScatterErrorBar2;
}(error_bar_base_default);
var scatter_error_bar_default = ScatterErrorBar;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/has-value.js
function hasValue(value) {
  return defined2(value) && value !== null;
}

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-chart.js
var ScatterChart = function(ChartElement2) {
  function ScatterChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    ScatterChart2.__proto__ = ChartElement2;
  ScatterChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ScatterChart2.prototype.constructor = ScatterChart2;
  ScatterChart2.prototype._initFields = function _initFields() {
    this.xAxisRanges = {};
    this.yAxisRanges = {};
    this.points = [];
    this.seriesPoints = [];
    this.seriesOptions = [];
    this._evalSeries = [];
  };
  ScatterChart2.prototype.render = function render3() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  ScatterChart2.prototype.addErrorBar = function addErrorBar(point2, field, fields) {
    var value = point2.value[field];
    var valueErrorField = field + "Value";
    var lowField = field + "ErrorLow";
    var highField = field + "ErrorHigh";
    var seriesIx = fields.seriesIx;
    var series = fields.series;
    var errorBars = point2.options.errorBars;
    var lowValue = fields[lowField];
    var highValue = fields[highField];
    if (isNumber2(value)) {
      var errorRange;
      if (isNumber2(lowValue) && isNumber2(highValue)) {
        errorRange = { low: lowValue, high: highValue };
      }
      if (errorBars && defined2(errorBars[valueErrorField])) {
        this.seriesErrorRanges = this.seriesErrorRanges || { x: [], y: [] };
        this.seriesErrorRanges[field][seriesIx] = this.seriesErrorRanges[field][seriesIx] || new error_range_calculator_default(errorBars[valueErrorField], series, field);
        errorRange = this.seriesErrorRanges[field][seriesIx].getErrorRange(value, errorBars[valueErrorField]);
      }
      if (errorRange) {
        this.addPointErrorBar(errorRange, point2, field);
      }
    }
  };
  ScatterChart2.prototype.addPointErrorBar = function addPointErrorBar(errorRange, point2, field) {
    var low = errorRange.low;
    var high = errorRange.high;
    var series = point2.series;
    var options2 = point2.options.errorBars;
    var isVertical = field === Y;
    var item = {};
    point2[field + "Low"] = low;
    point2[field + "High"] = high;
    point2.errorBars = point2.errorBars || [];
    var errorBar = new scatter_error_bar_default(low, high, isVertical, this, series, options2);
    point2.errorBars.push(errorBar);
    point2.append(errorBar);
    item[field] = low;
    this.updateRange(item, series);
    item[field] = high;
    this.updateRange(item, series);
  };
  ScatterChart2.prototype.addValue = function addValue(value, fields) {
    var x = value.x;
    var y = value.y;
    var seriesIx = fields.seriesIx;
    var series = this.options.series[seriesIx];
    var missingValues = this.seriesMissingValues(series);
    var seriesPoints = this.seriesPoints[seriesIx];
    var pointValue = value;
    if (!(hasValue(x) && hasValue(y))) {
      pointValue = this.createMissingValue(pointValue, missingValues);
    }
    var point2;
    if (pointValue) {
      point2 = this.createPoint(pointValue, fields);
      if (point2) {
        Object.assign(point2, fields);
        this.addErrorBar(point2, X, fields);
        this.addErrorBar(point2, Y, fields);
      }
      this.updateRange(pointValue, fields.series);
    }
    this.points.push(point2);
    seriesPoints.push(point2);
  };
  ScatterChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues;
  };
  ScatterChart2.prototype.createMissingValue = function createMissingValue() {
  };
  ScatterChart2.prototype.updateRange = function updateRange(value, series) {
    var intlService = this.chartService.intl;
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var x = value.x;
    var y = value.y;
    var xAxisRange = this.xAxisRanges[xAxisName];
    var yAxisRange = this.yAxisRanges[yAxisName];
    if (hasValue(x)) {
      xAxisRange = this.xAxisRanges[xAxisName] = xAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString2(x)) {
        x = parseDate3(intlService, x);
      }
      xAxisRange.min = Math.min(xAxisRange.min, x);
      xAxisRange.max = Math.max(xAxisRange.max, x);
    }
    if (hasValue(y)) {
      yAxisRange = this.yAxisRanges[yAxisName] = yAxisRange || { min: MAX_VALUE, max: MIN_VALUE };
      if (isString2(y)) {
        y = parseDate3(intlService, y);
      }
      yAxisRange.min = Math.min(yAxisRange.min, y);
      yAxisRange.max = Math.max(yAxisRange.max, y);
    }
  };
  ScatterChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = { defaults: series._defaults, excluded: ["data", "tooltip", "content", "template", "visual", "toggle", "_outOfRangeMinPoint", "_outOfRangeMaxPoint"] };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value,
        series,
        dataItem: fields.dataItem
      }, state);
    }
    return pointOptions;
  };
  ScatterChart2.prototype.pointType = function pointType() {
    return line_point_default;
  };
  ScatterChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  ScatterChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new line_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  ScatterChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return {
      x: xAxis,
      y: yAxis
    };
  };
  ScatterChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value, fields) {
      var point2 = chartPoints[pointIx++];
      var seriesAxes = this$1.seriesAxes(fields.series);
      var slotX = seriesAxes.x.getSlot(value.x, value.x, limit);
      var slotY = seriesAxes.y.getSlot(value.y, value.y, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  ScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  ScatterChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var seriesPoints = ref2.seriesPoints;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var currentSeriesPoints = seriesPoints[seriesIx];
      if (!currentSeriesPoints) {
        seriesPoints[seriesIx] = [];
      }
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var value = ref$1.valueFields;
        var fields = ref$1.fields;
        callback(value, deepExtend({
          pointIx,
          series: currentSeries,
          seriesIx,
          dataItem: currentSeries.data[pointIx],
          owner: this$1
        }, fields));
      }
    }
  };
  ScatterChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y);
  };
  ScatterChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result;
  };
  return ScatterChart2;
}(chart_element_default);
setDefaultOptions(ScatterChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}"
  },
  labels: {
    format: "{0}, {1}"
  },
  clip: true
});
deepExtend(ScatterChart.prototype, clip_animation_mixin_default, {
  _bindPoint: categorical_chart_default.prototype._bindPoint
});
var scatter_chart_default = ScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble.js
var Bubble = function(LinePoint2) {
  function Bubble2(value, options2) {
    LinePoint2.call(this, value, options2);
    this.category = value.category;
  }
  if (LinePoint2)
    Bubble2.__proto__ = LinePoint2;
  Bubble2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  Bubble2.prototype.constructor = Bubble2;
  Bubble2.prototype.createHighlight = function createHighlight() {
    var highlight = this.options.highlight;
    var border = highlight.border;
    var markers = this.options.markers;
    var center = this.box.center();
    var radius = (markers.size + markers.border.width + border.width) / 2;
    var highlightGroup = new drawing_exports.Group();
    var shadow = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y + radius / 5 + border.width / 2], radius + border.width / 2), {
      stroke: {
        color: "none"
      },
      fill: this.createGradient({
        gradient: "bubbleShadow",
        color: markers.background,
        stops: [{
          offset: 0,
          color: markers.background,
          opacity: 0.3
        }, {
          offset: 1,
          color: markers.background,
          opacity: 0
        }]
      })
    });
    var overlay = new drawing_exports.Circle(new geometry_exports.Circle([center.x, center.y], radius), {
      stroke: {
        color: border.color || new color_default(markers.background).brightness(BORDER_BRIGHTNESS).toHex(),
        width: border.width,
        opacity: border.opacity
      },
      fill: {
        color: markers.background,
        opacity: highlight.opacity
      }
    });
    highlightGroup.append(shadow, overlay);
    return highlightGroup;
  };
  return Bubble2;
}(line_point_default);
Bubble.prototype.defaults = deepExtend({}, Bubble.prototype.defaults, {
  labels: {
    position: CENTER
  },
  highlight: {
    opacity: 1,
    border: {
      color: "#fff",
      width: 2,
      opacity: 1
    }
  }
});
Bubble.prototype.defaults.highlight.zIndex = void 0;
var bubble_default = Bubble;

// node_modules/@progress/kendo-charts/dist/es/chart/bubble-chart/bubble-chart.js
var BubbleChart = function(ScatterChart2) {
  function BubbleChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    BubbleChart2.__proto__ = ScatterChart2;
  BubbleChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  BubbleChart2.prototype.constructor = BubbleChart2;
  BubbleChart2.prototype._initFields = function _initFields() {
    this._maxSize = MIN_VALUE;
    ScatterChart2.prototype._initFields.call(this);
  };
  BubbleChart2.prototype.addValue = function addValue(value, fields) {
    if (value.size !== null && (value.size > 0 || value.size < 0 && fields.series.negativeValues.visible)) {
      this._maxSize = Math.max(this._maxSize, Math.abs(value.size));
      ScatterChart2.prototype.addValue.call(this, value, fields);
    } else {
      this.points.push(null);
      this.seriesPoints[fields.seriesIx].push(null);
    }
  };
  BubbleChart2.prototype.reflow = function reflow(box) {
    this.updateBubblesSize(box);
    ScatterChart2.prototype.reflow.call(this, box);
  };
  BubbleChart2.prototype.pointType = function pointType() {
    return bubble_default;
  };
  BubbleChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointsCount = series.data.length;
    var delay = fields.pointIx * (INITIAL_ANIMATION_DURATION / pointsCount);
    var animationOptions = {
      delay,
      duration: INITIAL_ANIMATION_DURATION - delay,
      type: BUBBLE
    };
    var color = fields.color || series.color;
    if (value.size < 0 && series.negativeValues.visible) {
      color = valueOrDefault2(
        series.negativeValues.color,
        color
      );
    }
    var pointOptions = deepExtend({
      labels: {
        animation: {
          delay,
          duration: INITIAL_ANIMATION_DURATION - delay
        }
      }
    }, this.pointOptions(series, fields.seriesIx), {
      markers: {
        type: CIRCLE,
        border: series.border,
        opacity: series.opacity,
        animation: animationOptions
      }
    });
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    pointOptions.markers.background = color;
    var point2 = new bubble_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  BubbleChart2.prototype.updateBubblesSize = function updateBubblesSize(box) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    var boxSize = Math.min(box.width(), box.height());
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesPoints = this$1.seriesPoints[seriesIx];
      var minSize = currentSeries.minSize || Math.max(boxSize * 0.02, 10);
      var maxSize = currentSeries.maxSize || boxSize * 0.2;
      var minR = minSize / 2;
      var maxR = maxSize / 2;
      var minArea = Math.PI * minR * minR;
      var maxArea = Math.PI * maxR * maxR;
      var areaRange = maxArea - minArea;
      var areaRatio = areaRange / this$1._maxSize;
      for (var pointIx = 0; pointIx < seriesPoints.length; pointIx++) {
        var point2 = seriesPoints[pointIx];
        if (point2) {
          var area = Math.abs(point2.value.size) * areaRatio;
          var radius = Math.sqrt((minArea + area) / Math.PI);
          var baseZIndex = valueOrDefault2(point2.options.zIndex, 0);
          var zIndex = baseZIndex + (1 - radius / maxR);
          deepExtend(point2.options, {
            zIndex,
            markers: {
              size: radius * 2,
              zIndex
            },
            labels: {
              zIndex: zIndex + 1
            }
          });
        }
      }
    }
  };
  BubbleChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y, value.size, point2.category);
  };
  BubbleChart2.prototype.createAnimation = function createAnimation() {
  };
  BubbleChart2.prototype.createVisual = function createVisual() {
  };
  return BubbleChart2;
}(scatter_chart_default);
setDefaultOptions(BubbleChart, {
  tooltip: {
    format: "{3}"
  },
  labels: {
    format: "{3}"
  }
});
var bubble_chart_default = BubbleChart;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/target.js
var Target = function(ShapeElement2) {
  function Target2() {
    ShapeElement2.apply(this, arguments);
  }
  if (ShapeElement2)
    Target2.__proto__ = ShapeElement2;
  Target2.prototype = Object.create(ShapeElement2 && ShapeElement2.prototype);
  Target2.prototype.constructor = Target2;
  return Target2;
}(shape_element_default);
deepExtend(Target.prototype, point_events_mixin_default);
var target_default = Target;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet.js
var Bullet = function(ChartElement2) {
  function Bullet2(value, options2) {
    ChartElement2.call(this, options2);
    this.aboveAxis = this.options.aboveAxis;
    this.color = options2.color || WHITE;
    this.value = value;
  }
  if (ChartElement2)
    Bullet2.__proto__ = ChartElement2;
  Bullet2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Bullet2.prototype.constructor = Bullet2;
  Bullet2.prototype.render = function render3() {
    var options2 = this.options;
    if (!this._rendered) {
      this._rendered = true;
      if (defined2(this.value.target)) {
        this.target = new target_default({
          type: options2.target.shape,
          background: options2.target.color || this.color,
          opacity: options2.opacity,
          zIndex: options2.zIndex,
          border: options2.target.border,
          vAlign: TOP,
          align: RIGHT
        });
        this.target.value = this.value;
        this.target.dataItem = this.dataItem;
        this.target.series = this.series;
        this.append(this.target);
      }
      this.createLabel();
      this.createNote();
    }
  };
  Bullet2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      this.label = new bar_label_default(labelText, labels, pointData);
      this.append(this.label);
    }
  };
  Bullet2.prototype.reflow = function reflow(box) {
    this.render();
    var ref2 = this;
    var options2 = ref2.options;
    var target = ref2.target;
    var chart = ref2.owner;
    var invertAxes = options2.invertAxes;
    var valueAxis = chart.seriesValueAxis(this.options);
    var categorySlot = chart.categorySlot(chart.categoryAxis, options2.categoryIx, valueAxis);
    var targetValueSlot = valueAxis.getSlot(this.value.target);
    var targetSlotX = invertAxes ? targetValueSlot : categorySlot;
    var targetSlotY = invertAxes ? categorySlot : targetValueSlot;
    if (target) {
      var targetSlot = new box_default(
        targetSlotX.x1,
        targetSlotY.y1,
        targetSlotX.x2,
        targetSlotY.y2
      );
      target.options.height = invertAxes ? targetSlot.height() : options2.target.line.width;
      target.options.width = invertAxes ? options2.target.line.width : targetSlot.width();
      target.reflow(targetSlot);
    }
    var label = this.label;
    if (label) {
      label.options.aboveAxis = this.aboveAxis;
      label.reflow(box);
    }
    if (this.note) {
      this.note.reflow(box);
    }
    this.box = box;
  };
  Bullet2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    var body = drawing_exports.Path.fromRect(this.box.toRect(), {
      fill: {
        color: this.color,
        opacity: options2.opacity
      },
      stroke: null
    });
    if (options2.border.width > 0) {
      body.options.set("stroke", {
        color: options2.border.color || this.color,
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: valueOrDefault2(options2.border.opacity, options2.opacity)
      });
    }
    this.bodyVisual = body;
    alignPathToPixel(body);
    this.visual.append(body);
  };
  Bullet2.prototype.createAnimation = function createAnimation() {
    if (this.bodyVisual) {
      this.animation = drawing_exports.Animation.create(
        this.bodyVisual,
        this.options.animation
      );
    }
  };
  Bullet2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromRect(this.box.toRect(), style);
  };
  Bullet2.prototype.highlightVisual = function highlightVisual() {
    return this.bodyVisual;
  };
  Bullet2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      rect: this.box.toRect(),
      visual: this.bodyVisual,
      options: this.options
    };
  };
  Bullet2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  Bullet2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series
    };
  };
  Bullet2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  return Bullet2;
}(chart_element_default);
Bullet.prototype.tooltipAnchor = bar_default.prototype.tooltipAnchor;
setDefaultOptions(Bullet, {
  border: {
    width: 1
  },
  vertical: false,
  opacity: 1,
  target: {
    shape: "",
    border: {
      width: 0,
      color: "green"
    },
    line: {
      width: 2
    }
  },
  labels: {
    visible: false
  },
  tooltip: {
    format: "Current: {0}<br />Target: {1}"
  },
  notes: {
    label: {}
  }
});
deepExtend(Bullet.prototype, point_events_mixin_default);
deepExtend(Bullet.prototype, note_mixin_default);
var bullet_default = Bullet;

// node_modules/@progress/kendo-charts/dist/es/chart/bullet-chart/bullet-chart.js
var BulletChart = function(CategoricalChart2) {
  function BulletChart2(plotArea, options2) {
    wrapData(options2);
    CategoricalChart2.call(this, plotArea, options2);
  }
  if (CategoricalChart2)
    BulletChart2.__proto__ = CategoricalChart2;
  BulletChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  BulletChart2.prototype.constructor = BulletChart2;
  BulletChart2.prototype.reflowCategories = function reflowCategories(categorySlots) {
    var children = this.children;
    var childrenLength = children.length;
    for (var i = 0; i < childrenLength; i++) {
      children[i].reflow(categorySlots[i]);
    }
  };
  BulletChart2.prototype.plotRange = function plotRange(point2) {
    var series = point2.series;
    var valueAxis = this.seriesValueAxis(series);
    var axisCrossingValue = this.categoryAxisCrossingValue(valueAxis);
    return [axisCrossingValue, point2.value.current || axisCrossingValue];
  };
  BulletChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var value = data.valueFields;
    var bulletOptions = deepExtend({
      vertical: !options2.invertAxes,
      overlay: series.overlay,
      categoryIx,
      invertAxes: options2.invertAxes
    }, series);
    var color = data.fields.color || series.color;
    bulletOptions = this.evalPointOptions(
      bulletOptions,
      value,
      category,
      categoryIx,
      series,
      seriesIx
    );
    if (isFunction3(series.color)) {
      color = bulletOptions.color;
    }
    var bullet = new bullet_default(value, bulletOptions);
    bullet.color = color;
    var cluster = children[categoryIx];
    if (!cluster) {
      cluster = new cluster_layout_default({
        vertical: options2.invertAxes,
        gap: options2.gap,
        spacing: options2.spacing,
        rtl: !options2.invertAxes && (this.chartService || {}).rtl
      });
      this.append(cluster);
    }
    cluster.append(bullet);
    return bullet;
  };
  BulletChart2.prototype.updateRange = function updateRange(value, fields) {
    var current4 = value.current;
    var target = value.target;
    var axisName = fields.series.axis;
    var axisRange = this.valueAxisRanges[axisName];
    if (defined2(current4) && !isNaN(current4) && defined2(target && !isNaN(target))) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, current4, target);
      axisRange.max = Math.max(axisRange.max, current4, target);
    }
  };
  BulletChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value.current, point2.value.target);
  };
  BulletChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields.current;
  };
  BulletChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value = point2.value.current;
    return value > 0;
  };
  BulletChart2.prototype.createAnimation = function createAnimation() {
    var this$1 = this;
    var points3 = this.points;
    this._setAnimationOptions();
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      point2.options.animation = this$1.options.animation;
      point2.createAnimation();
    }
  };
  return BulletChart2;
}(categorical_chart_default);
BulletChart.prototype._setAnimationOptions = bar_chart_default.prototype._setAnimationOptions;
setDefaultOptions(BulletChart, {
  animation: {
    type: BAR
  }
});
function wrapData(options2) {
  var series = options2.series;
  for (var i = 0; i < series.length; i++) {
    var seriesItem = series[i];
    var data = seriesItem.data;
    if (data && !isArray(data[0]) && !isObject(data[0])) {
      seriesItem.data = [data];
    }
  }
}
var bullet_chart_default = BulletChart;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/base-tooltip.js
var BaseTooltip = function(Class3) {
  function BaseTooltip2(chartService, options2) {
    Class3.call(this);
    this.chartService = chartService;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    BaseTooltip2.__proto__ = Class3;
  BaseTooltip2.prototype = Object.create(Class3 && Class3.prototype);
  BaseTooltip2.prototype.constructor = BaseTooltip2;
  BaseTooltip2.prototype.getStyle = function getStyle(options2, point2) {
    var background = options2.background;
    var border = options2.border.color;
    if (point2) {
      var pointColor = point2.color || point2.options.color;
      background = valueOrDefault2(background, pointColor);
      border = valueOrDefault2(border, pointColor);
    }
    var padding = getSpacing(options2.padding || {}, "auto");
    return {
      backgroundColor: background,
      borderColor: border,
      font: options2.font,
      color: options2.color,
      opacity: options2.opacity,
      borderWidth: styleValue(options2.border.width),
      paddingTop: styleValue(padding.top),
      paddingBottom: styleValue(padding.bottom),
      paddingLeft: styleValue(padding.left),
      paddingRight: styleValue(padding.right)
    };
  };
  BaseTooltip2.prototype.show = function show2(options2, tooltipOptions, point2) {
    options2.format = tooltipOptions.format;
    var style = this.getStyle(tooltipOptions, point2);
    options2.style = style;
    var background = new color_default(style.backgroundColor);
    if (!defined2(tooltipOptions.color) && !background.isDark()) {
      options2.className = "k-chart-tooltip-inverse";
    }
    this.chartService.notify(SHOW_TOOLTIP, options2);
    this.visible = true;
  };
  BaseTooltip2.prototype.hide = function hide2() {
    if (this.chartService) {
      this.chartService.notify(HIDE_TOOLTIP);
    }
    this.visible = false;
  };
  BaseTooltip2.prototype.destroy = function destroy2() {
    delete this.chartService;
  };
  return BaseTooltip2;
}(class_default);
setDefaultOptions(BaseTooltip, {
  border: {
    width: 1
  },
  opacity: 1
});
var base_tooltip_default = BaseTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair-tooltip.js
var CrosshairTooltip = function(BaseTooltip2) {
  function CrosshairTooltip2(chartService, crosshair, options2) {
    BaseTooltip2.call(this, chartService, options2);
    this.crosshair = crosshair;
    this.formatService = chartService.format;
    this.initAxisName();
  }
  if (BaseTooltip2)
    CrosshairTooltip2.__proto__ = BaseTooltip2;
  CrosshairTooltip2.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  CrosshairTooltip2.prototype.constructor = CrosshairTooltip2;
  CrosshairTooltip2.prototype.initAxisName = function initAxisName() {
    var axis = this.crosshair.axis;
    var plotArea = axis.plotArea;
    var name3;
    if (plotArea.categoryAxis) {
      name3 = axis.getCategory ? "categoryAxis" : "valueAxis";
    } else {
      name3 = axis.options.vertical ? "yAxis" : "xAxis";
    }
    this.axisName = name3;
  };
  CrosshairTooltip2.prototype.showAt = function showAt(point2) {
    var ref2 = this;
    var axis = ref2.crosshair.axis;
    var options2 = ref2.options;
    var value = axis[options2.stickyMode ? "getCategory" : "getValue"](point2);
    var formattedValue = value;
    if (options2.format) {
      formattedValue = this.formatService.auto(options2.format, value);
    } else if (axis.options.type === DATE) {
      formattedValue = this.formatService.auto(axis.options.labels.dateFormats[axis.options.baseUnit], value);
    }
    this.show({
      point: point2,
      anchor: this.getAnchor(),
      crosshair: this.crosshair,
      value: formattedValue,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    }, this.options);
  };
  CrosshairTooltip2.prototype.hide = function hide2() {
    this.chartService.notify(HIDE_TOOLTIP, {
      crosshair: this.crosshair,
      axisName: this.axisName,
      axisIndex: this.crosshair.axis.axisIndex
    });
  };
  CrosshairTooltip2.prototype.getAnchor = function getAnchor() {
    var ref2 = this;
    var crosshair = ref2.crosshair;
    var ref_options = ref2.options;
    var position = ref_options.position;
    var padding = ref_options.padding;
    var vertical = !crosshair.axis.options.vertical;
    var lineBox = crosshair.line.bbox();
    var horizontalAlign, verticalAlign, point2;
    if (vertical) {
      horizontalAlign = CENTER;
      if (position === BOTTOM) {
        verticalAlign = TOP;
        point2 = lineBox.bottomLeft().translate(0, padding);
      } else {
        verticalAlign = BOTTOM;
        point2 = lineBox.topLeft().translate(0, -padding);
      }
    } else {
      verticalAlign = CENTER;
      if (position === LEFT) {
        horizontalAlign = RIGHT;
        point2 = lineBox.topLeft().translate(-padding, 0);
      } else {
        horizontalAlign = LEFT;
        point2 = lineBox.topRight().translate(padding, 0);
      }
    }
    return {
      point: point2,
      align: {
        horizontal: horizontalAlign,
        vertical: verticalAlign
      }
    };
  };
  return CrosshairTooltip2;
}(base_tooltip_default);
setDefaultOptions(CrosshairTooltip, {
  padding: 10
});
var crosshair_tooltip_default = CrosshairTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/crosshair/crosshair.js
var Crosshair = function(ChartElement2) {
  function Crosshair2(chartService, axis, options2) {
    ChartElement2.call(this, options2);
    this.axis = axis;
    this.stickyMode = axis instanceof category_axis_default;
    var tooltipOptions = this.options.tooltip;
    if (tooltipOptions.visible) {
      this.tooltip = new crosshair_tooltip_default(
        chartService,
        this,
        deepExtend({}, tooltipOptions, { stickyMode: this.stickyMode })
      );
    }
  }
  if (ChartElement2)
    Crosshair2.__proto__ = ChartElement2;
  Crosshair2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Crosshair2.prototype.constructor = Crosshair2;
  Crosshair2.prototype.showAt = function showAt(point2) {
    this.point = point2;
    this.moveLine();
    this.line.visible(true);
    if (this.tooltip) {
      this.tooltip.showAt(point2);
    }
  };
  Crosshair2.prototype.hide = function hide2() {
    this.line.visible(false);
    if (this.tooltip) {
      this.tooltip.hide();
    }
  };
  Crosshair2.prototype.moveLine = function moveLine() {
    var ref2 = this;
    var axis = ref2.axis;
    var point2 = ref2.point;
    var vertical = axis.options.vertical;
    var box = this.getBox();
    var dim = vertical ? Y : X;
    var lineStart = new geometry_exports.Point(box.x1, box.y1);
    var lineEnd;
    if (vertical) {
      lineEnd = new geometry_exports.Point(box.x2, box.y1);
    } else {
      lineEnd = new geometry_exports.Point(box.x1, box.y2);
    }
    if (point2) {
      if (this.stickyMode) {
        var slot = axis.getSlot(axis.pointCategoryIndex(point2));
        lineStart[dim] = lineEnd[dim] = slot.center()[dim];
      } else {
        lineStart[dim] = lineEnd[dim] = point2[dim];
      }
    }
    this.box = box;
    this.line.moveTo(lineStart).lineTo(lineEnd);
  };
  Crosshair2.prototype.getBox = function getBox() {
    var axis = this.axis;
    var axes = axis.pane.axes;
    var length = axes.length;
    var vertical = axis.options.vertical;
    var box = axis.lineBox().clone();
    var dim = vertical ? X : Y;
    var axisLineBox;
    for (var i = 0; i < length; i++) {
      var currentAxis = axes[i];
      if (currentAxis.options.vertical !== vertical) {
        if (!axisLineBox) {
          axisLineBox = currentAxis.lineBox().clone();
        } else {
          axisLineBox.wrap(currentAxis.lineBox());
        }
      }
    }
    box[dim + 1] = axisLineBox[dim + 1];
    box[dim + 2] = axisLineBox[dim + 2];
    return box;
  };
  Crosshair2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options;
    this.line = new drawing_exports.Path({
      stroke: {
        color: options2.color,
        width: options2.width,
        opacity: options2.opacity,
        dashType: options2.dashType
      },
      visible: false
    });
    this.moveLine();
    this.visual.append(this.line);
  };
  Crosshair2.prototype.destroy = function destroy2() {
    if (this.tooltip) {
      this.tooltip.destroy();
    }
    ChartElement2.prototype.destroy.call(this);
  };
  return Crosshair2;
}(chart_element_default);
setDefaultOptions(Crosshair, {
  color: BLACK,
  width: 2,
  zIndex: -1,
  tooltip: {
    visible: false
  }
});
var crosshair_default = Crosshair;

// node_modules/@progress/kendo-charts/dist/es/chart/chart-container.js
var ChartContainer = function(ChartElement2) {
  function ChartContainer2(options2, pane) {
    ChartElement2.call(this, options2);
    this.pane = pane;
  }
  if (ChartElement2)
    ChartContainer2.__proto__ = ChartElement2;
  ChartContainer2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  ChartContainer2.prototype.constructor = ChartContainer2;
  ChartContainer2.prototype.shouldClip = function shouldClip() {
    var children = this.children;
    var length = children.length;
    for (var i = 0; i < length; i++) {
      if (children[i].options.clip === true) {
        return true;
      }
    }
    return false;
  };
  ChartContainer2.prototype._clipBox = function _clipBox() {
    return this.pane.chartsBox();
  };
  ChartContainer2.prototype.createVisual = function createVisual() {
    this.visual = new drawing_exports.Group({
      zIndex: 0
    });
    if (this.shouldClip()) {
      var clipBox = this.clipBox = this._clipBox();
      var clipRect = clipBox.toRect();
      var clipPath = drawing_exports.Path.fromRect(clipRect);
      alignPathToPixel(clipPath);
      this.visual.clip(clipPath);
      this.unclipLabels();
    }
  };
  ChartContainer2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  ChartContainer2.prototype.unclipLabels = function unclipLabels() {
    var ref2 = this;
    var charts = ref2.children;
    var clipBox = ref2.clipBox;
    for (var i = 0; i < charts.length; i++) {
      var points3 = charts[i].points || {};
      var length = points3.length;
      for (var j = 0; j < length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && point2.overlapsBox && point2.overlapsBox(clipBox)) {
          if (point2.unclipElements) {
            point2.unclipElements();
          } else {
            var label = point2.label;
            var note = point2.note;
            if (label && label.options.visible) {
              if (label.alignToClipBox) {
                label.alignToClipBox(clipBox);
              }
              label.options.noclip = true;
            }
            if (note && note.options.visible) {
              note.options.noclip = true;
            }
          }
        }
      }
    }
  };
  ChartContainer2.prototype.destroy = function destroy2() {
    ChartElement2.prototype.destroy.call(this);
    delete this.parent;
  };
  return ChartContainer2;
}(chart_element_default);
ChartContainer.prototype.isStackRoot = true;
var chart_container_default = ChartContainer;

// node_modules/@progress/kendo-charts/dist/es/chart/pane.js
var Pane = function(BoxElement2) {
  function Pane3(options2) {
    BoxElement2.call(this, options2);
    this.id = paneID();
    this.createTitle();
    this.content = new chart_element_default();
    this.chartContainer = new chart_container_default({}, this);
    this.append(this.content);
    this.axes = [];
    this.charts = [];
  }
  if (BoxElement2)
    Pane3.__proto__ = BoxElement2;
  Pane3.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  Pane3.prototype.constructor = Pane3;
  Pane3.prototype.createTitle = function createTitle() {
    var titleOptions = this.options.title;
    if (isObject(titleOptions)) {
      titleOptions = deepExtend({}, titleOptions, {
        align: titleOptions.position,
        position: TOP
      });
    }
    this.title = title_default.buildTitle(titleOptions, Pane3.prototype.options.title);
    if (this.title) {
      this.append(this.title);
    }
  };
  Pane3.prototype.appendAxis = function appendAxis(axis) {
    this.content.append(axis);
    this.axes.push(axis);
    axis.pane = this;
  };
  Pane3.prototype.appendAxisAt = function appendAxisAt(axis, pos) {
    this.content.append(axis);
    this.axes.splice(pos, 0, axis);
    axis.pane = this;
  };
  Pane3.prototype.appendChart = function appendChart(chart) {
    if (this.chartContainer.parent !== this.content) {
      this.content.append(this.chartContainer);
    }
    this.charts.push(chart);
    this.chartContainer.append(chart);
    chart.pane = this;
  };
  Pane3.prototype.empty = function empty() {
    var this$1 = this;
    var plotArea = this.parent;
    if (plotArea) {
      for (var i = 0; i < this.axes.length; i++) {
        plotArea.removeAxis(this$1.axes[i]);
      }
      for (var i$1 = 0; i$1 < this.charts.length; i$1++) {
        plotArea.removeChart(this$1.charts[i$1]);
      }
    }
    this.axes = [];
    this.charts = [];
    this.content.destroy();
    this.content.children = [];
    this.chartContainer.children = [];
  };
  Pane3.prototype.reflow = function reflow(targetBox) {
    var content;
    if (last2(this.children) === this.content) {
      content = this.children.pop();
    }
    BoxElement2.prototype.reflow.call(this, targetBox);
    if (content) {
      this.children.push(content);
    }
    if (this.title) {
      this.contentBox.y1 += this.title.box.height();
    }
  };
  Pane3.prototype.visualStyle = function visualStyle() {
    var style = BoxElement2.prototype.visualStyle.call(this);
    style.zIndex = -10;
    return style;
  };
  Pane3.prototype.renderComplete = function renderComplete() {
    if (this.options.visible) {
      this.createGridLines();
    }
  };
  Pane3.prototype.stackRoot = function stackRoot() {
    return this;
  };
  Pane3.prototype.clipRoot = function clipRoot() {
    return this;
  };
  Pane3.prototype.createGridLines = function createGridLines() {
    var axes = this.axes;
    var allAxes = axes.concat(this.parent.axes);
    var vGridLines = [];
    var hGridLines = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var vertical = axis.options.vertical;
      var gridLines = vertical ? vGridLines : hGridLines;
      for (var j = 0; j < allAxes.length; j++) {
        if (gridLines.length === 0) {
          var altAxis = allAxes[j];
          if (vertical !== altAxis.options.vertical) {
            append2(gridLines, axis.createGridLines(altAxis));
          }
        }
      }
    }
  };
  Pane3.prototype.refresh = function refresh() {
    this.visual.clear();
    this.content.parent = null;
    this.content.createGradient = this.createGradient.bind(this);
    this.content.renderVisual();
    this.content.parent = this;
    if (this.title) {
      this.visual.append(this.title.visual);
    }
    this.visual.append(this.content.visual);
    this.renderComplete();
    this.notifyRender();
  };
  Pane3.prototype.chartsBox = function chartsBox() {
    var axes = this.axes;
    var length = axes.length;
    var chartsBox2 = new box_default();
    for (var idx = 0; idx < length; idx++) {
      var axis = axes[idx];
      var axisValueField = axis.options.vertical ? Y : X;
      var lineBox = axis.lineBox();
      chartsBox2[axisValueField + 1] = lineBox[axisValueField + 1];
      chartsBox2[axisValueField + 2] = lineBox[axisValueField + 2];
    }
    if (chartsBox2.x2 === 0) {
      var allAxes = this.parent.axes;
      var length$1 = allAxes.length;
      for (var idx$1 = 0; idx$1 < length$1; idx$1++) {
        var axis$1 = allAxes[idx$1];
        if (!axis$1.options.vertical) {
          var lineBox$1 = axis$1.lineBox();
          chartsBox2.x1 = lineBox$1.x1;
          chartsBox2.x2 = lineBox$1.x2;
        }
      }
    }
    return chartsBox2;
  };
  Pane3.prototype.clipBox = function clipBox() {
    return this.chartContainer.clipBox;
  };
  Pane3.prototype.notifyRender = function notifyRender() {
    var service = this.getService();
    if (service) {
      service.notify(PANE_RENDER, {
        pane: new chart_pane_default(this),
        index: this.paneIndex,
        name: this.options.name
      });
    }
  };
  return Pane3;
}(box_element_default);
var ID = 1;
function paneID() {
  return "pane" + ID++;
}
Pane.prototype.isStackRoot = true;
setDefaultOptions(Pane, {
  zIndex: -1,
  shrinkToFit: true,
  title: {
    align: LEFT
  },
  visible: true
});
var pane_default = Pane;

// node_modules/@progress/kendo-charts/dist/es/chart/utils/append-if-not-null.js
function appendIfNotNull(array, element) {
  if (element !== null) {
    array.push(element);
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/segment-visible.js
function segmentVisible(series, fields, index) {
  var visible = fields.visible;
  if (defined2(visible)) {
    return visible;
  }
  var pointVisibility = series.pointVisibility;
  if (pointVisibility) {
    return pointVisibility[index];
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/bind-segments.js
function bindSegments(series) {
  var data = series.data;
  var points3 = [];
  var sum = 0;
  var count = 0;
  for (var idx = 0; idx < data.length; idx++) {
    var pointData = series_binder_default.current.bindPoint(series, idx);
    var value = pointData.valueFields.value;
    if (isString2(value)) {
      value = parseFloat(value);
    }
    if (isNumber2(value)) {
      pointData.visible = segmentVisible(series, pointData.fields, idx) !== false;
      pointData.value = Math.abs(value);
      points3.push(pointData);
      if (pointData.visible) {
        sum += pointData.value;
      }
      if (value !== 0) {
        count++;
      }
    } else {
      points3.push(null);
    }
  }
  return {
    total: sum,
    points: points3,
    count
  };
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/equals-ignore-case.js
function equalsIgnoreCase(a, b) {
  if (a && b) {
    return a.toLowerCase() === b.toLowerCase();
  }
  return a === b;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/filter-series-by-type.js
function filterSeriesByType(series, types) {
  var result = [];
  var seriesTypes = [].concat(types);
  for (var idx = 0; idx < series.length; idx++) {
    var currentSeries = series[idx];
    if (inArray(currentSeries.type, seriesTypes)) {
      result.push(currentSeries);
    }
  }
  return result;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/get-date-field.js
function getDateField(field, row, intlService) {
  if (row === null) {
    return row;
  }
  var key = "_date_" + field;
  var value = row[key];
  if (!value) {
    value = parseDate3(intlService, getter(field, true)(row));
    row[key] = value;
  }
  return value;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/is-date-axis.js
function isDateAxis(axisOptions2, sampleCategory) {
  var type = axisOptions2.type;
  var dateCategory = sampleCategory instanceof Date;
  return !type && dateCategory || equalsIgnoreCase(type, DATE);
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/single-item-or-array.js
function singleItemOrArray(array) {
  return array.length === 1 ? array[0] : array;
}

// node_modules/@progress/kendo-charts/dist/es/chart/utils/create-out-of-range-points.js
var AREA_REGEX = /area/i;
function seriesMissingValues(series) {
  if (series.missingValues) {
    return series.missingValues;
  }
  return AREA_REGEX.test(series.type) || series.stack ? ZERO2 : INTERPOLATE;
}
function hasValue2(series, item) {
  var fields = series_binder_default.current.bindPoint(series, null, item);
  var valueFields = fields.valueFields;
  for (var field in valueFields) {
    if (convertableToNumber(valueFields[field])) {
      return true;
    }
  }
}
function findNext(ref2) {
  var start = ref2.start;
  var dir = ref2.dir;
  var min3 = ref2.min;
  var max2 = ref2.max;
  var getter2 = ref2.getter;
  var hasItem = ref2.hasItem;
  var series = ref2.series;
  var pointHasValue, outPoint;
  var idx = start;
  do {
    idx += dir;
    if (hasItem(idx)) {
      outPoint = getter2(idx);
      pointHasValue = hasValue2(series, outPoint.item);
    }
  } while (min3 <= idx && idx <= max2 && !pointHasValue);
  if (pointHasValue) {
    return outPoint;
  }
}
function createOutOfRangePoints(series, range, count, getter2, hasItem) {
  var min3 = range.min;
  var max2 = range.max;
  var hasMinPoint = min3 > 0 && min3 < count;
  var hasMaxPoint = max2 + 1 < count;
  if (hasMinPoint || hasMaxPoint) {
    var missingValues = seriesMissingValues(series);
    var minPoint, maxPoint;
    if (missingValues !== INTERPOLATE) {
      if (hasMinPoint) {
        minPoint = getter2(min3 - 1);
      }
      if (hasMaxPoint) {
        maxPoint = getter2(max2 + 1);
      }
    } else {
      var outPoint, pointHasValue;
      if (hasMinPoint) {
        outPoint = getter2(min3 - 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          minPoint = findNext({
            start: min3,
            dir: -1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          minPoint = outPoint;
        }
      }
      if (hasMaxPoint) {
        outPoint = getter2(max2 + 1);
        pointHasValue = hasValue2(series, outPoint.item);
        if (!pointHasValue) {
          maxPoint = findNext({
            start: max2,
            dir: 1,
            min: 0,
            max: count - 1,
            getter: getter2,
            hasItem,
            series
          });
        } else {
          maxPoint = outPoint;
        }
      }
    }
    if (minPoint) {
      series._outOfRangeMinPoint = minPoint;
    }
    if (maxPoint) {
      series._outOfRangeMaxPoint = maxPoint;
    }
  }
}

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-base.js
var PlotAreaBase = function(ChartElement2) {
  function PlotAreaBase2(series, options2, chartService) {
    ChartElement2.call(this, options2);
    this.initFields(series, options2);
    this.series = series;
    this.initSeries();
    this.charts = [];
    this.options.legend = this.options.legend || {};
    this.options.legend.items = [];
    this.axes = [];
    this.crosshairs = [];
    this.chartService = chartService;
    this.originalOptions = options2;
    this.createPanes();
    this.render();
    this.createCrosshairs();
  }
  if (ChartElement2)
    PlotAreaBase2.__proto__ = ChartElement2;
  PlotAreaBase2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PlotAreaBase2.prototype.constructor = PlotAreaBase2;
  PlotAreaBase2.prototype.initFields = function initFields() {
  };
  PlotAreaBase2.prototype.initSeries = function initSeries() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      series[i].index = i;
    }
  };
  PlotAreaBase2.prototype.createPanes = function createPanes() {
    var this$1 = this;
    var titleOptions = this.options.title || {};
    var paneDefaults = this.options.paneDefaults;
    var paneOptions = this.options.panes || [];
    var panesLength = Math.max(paneOptions.length, 1);
    var panes = [];
    var defaults = deepExtend({
      title: {
        color: titleOptions.color
      }
    }, paneDefaults);
    for (var i = 0; i < panesLength; i++) {
      var options2 = deepExtend({}, defaults, paneOptions[i]);
      if (isString2(options2.title)) {
        options2.title = deepExtend({ text: options2.title }, defaults.title);
      }
      var currentPane = new pane_default(options2);
      currentPane.paneIndex = i;
      panes.push(currentPane);
      this$1.append(currentPane);
    }
    this.panes = panes;
  };
  PlotAreaBase2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return axis.options.crosshair;
  };
  PlotAreaBase2.prototype.createCrosshairs = function createCrosshairs(panes) {
    var this$1 = this;
    if (panes === void 0)
      panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      for (var j = 0; j < pane.axes.length; j++) {
        var axis = pane.axes[j];
        var options2 = this$1.crosshairOptions(axis);
        if (options2 && options2.visible) {
          var currentCrosshair = new crosshair_default(this$1.chartService, axis, options2);
          this$1.crosshairs.push(currentCrosshair);
          pane.content.append(currentCrosshair);
        }
      }
    }
  };
  PlotAreaBase2.prototype.removeCrosshairs = function removeCrosshairs(pane) {
    var crosshairs = this.crosshairs;
    var axes = pane.axes;
    for (var i = crosshairs.length - 1; i >= 0; i--) {
      for (var j = 0; j < axes.length; j++) {
        if (crosshairs[i].axis === axes[j]) {
          crosshairs.splice(i, 1);
          break;
        }
      }
    }
  };
  PlotAreaBase2.prototype.hideCrosshairs = function hideCrosshairs() {
    var crosshairs = this.crosshairs;
    for (var idx = 0; idx < crosshairs.length; idx++) {
      crosshairs[idx].hide();
    }
  };
  PlotAreaBase2.prototype.findPane = function findPane(name3) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].options.name === name3) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane || panes[0];
  };
  PlotAreaBase2.prototype.findPointPane = function findPointPane(point2) {
    var panes = this.panes;
    var matchingPane;
    for (var i = 0; i < panes.length; i++) {
      if (panes[i].box.containsPoint(point2)) {
        matchingPane = panes[i];
        break;
      }
    }
    return matchingPane;
  };
  PlotAreaBase2.prototype.appendAxis = function appendAxis(axis) {
    var pane = this.findPane(axis.options.pane);
    pane.appendAxis(axis);
    this.axes.push(axis);
    axis.plotArea = this;
  };
  PlotAreaBase2.prototype.removeAxis = function removeAxis(axisToRemove) {
    var this$1 = this;
    var filteredAxes = [];
    for (var i = 0; i < this.axes.length; i++) {
      var axis = this$1.axes[i];
      if (axisToRemove !== axis) {
        filteredAxes.push(axis);
      } else {
        axis.destroy();
      }
    }
    this.axes = filteredAxes;
  };
  PlotAreaBase2.prototype.appendChart = function appendChart(chart, pane) {
    this.charts.push(chart);
    if (pane) {
      pane.appendChart(chart);
    } else {
      this.append(chart);
    }
  };
  PlotAreaBase2.prototype.removeChart = function removeChart(chartToRemove) {
    var this$1 = this;
    var filteredCharts = [];
    for (var i = 0; i < this.charts.length; i++) {
      var chart = this$1.charts[i];
      if (chart !== chartToRemove) {
        filteredCharts.push(chart);
      } else {
        chart.destroy();
      }
    }
    this.charts = filteredCharts;
  };
  PlotAreaBase2.prototype.addToLegend = function addToLegend(series) {
    var count = series.length;
    var legend2 = this.options.legend;
    var labels = legend2.labels || {};
    var inactiveItems = legend2.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    var data = [];
    for (var i = 0; i < count; i++) {
      var currentSeries = series[i];
      var seriesVisible = currentSeries.visible !== false;
      if (currentSeries.visibleInLegend === false) {
        continue;
      }
      var text = currentSeries.name;
      var labelTemplate = seriesVisible ? getTemplate(labels) : getTemplate(inactiveItemsLabels) || getTemplate(labels);
      if (labelTemplate) {
        text = labelTemplate({
          text: hasValue(text) ? text : "",
          series: currentSeries
        });
      }
      var defaults = currentSeries._defaults;
      var color = currentSeries.color;
      if (isFunction3(color) && defaults) {
        color = defaults.color;
      }
      var itemLabelOptions = void 0, markerColor = void 0;
      if (seriesVisible) {
        itemLabelOptions = {};
        markerColor = color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = inactiveItems.markers.color;
      }
      if (hasValue(text) && text !== "") {
        data.push({
          text,
          labels: itemLabelOptions,
          markerColor,
          series: currentSeries,
          active: seriesVisible
        });
      }
    }
    append2(legend2.items, data);
  };
  PlotAreaBase2.prototype.groupAxes = function groupAxes(panes) {
    var xAxes = [];
    var yAxes = [];
    for (var paneIx = 0; paneIx < panes.length; paneIx++) {
      var paneAxes = panes[paneIx].axes;
      for (var axisIx = 0; axisIx < paneAxes.length; axisIx++) {
        var axis = paneAxes[axisIx];
        if (axis.options.vertical) {
          yAxes.push(axis);
        } else {
          xAxes.push(axis);
        }
      }
    }
    return { x: xAxes, y: yAxes, any: xAxes.concat(yAxes) };
  };
  PlotAreaBase2.prototype.groupSeriesByPane = function groupSeriesByPane() {
    var this$1 = this;
    var series = this.series;
    var seriesByPane = {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var pane = this$1.seriesPaneName(currentSeries);
      if (seriesByPane[pane]) {
        seriesByPane[pane].push(currentSeries);
      } else {
        seriesByPane[pane] = [currentSeries];
      }
    }
    return seriesByPane;
  };
  PlotAreaBase2.prototype.filterVisibleSeries = function filterVisibleSeries(series) {
    var result = [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (currentSeries.visible !== false) {
        result.push(currentSeries);
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options.plotArea;
    var panes = this.panes;
    var margin = getSpacing(options2.margin);
    this.box = targetBox.clone().unpad(margin);
    this.reflowPanes();
    this.detachLabels();
    this.reflowAxes(panes);
    this.reflowCharts(panes);
  };
  PlotAreaBase2.prototype.redraw = function redraw(panes) {
    var this$1 = this;
    var panesArray = [].concat(panes);
    this.initSeries();
    var root = this.getRoot();
    if (root) {
      root.cleanGradients();
    }
    for (var i = 0; i < panesArray.length; i++) {
      this$1.removeCrosshairs(panesArray[i]);
      panesArray[i].empty();
    }
    this.render(panesArray);
    this.detachLabels();
    this.reflowAxes(this.panes);
    this.reflowCharts(panesArray);
    this.createCrosshairs(panesArray);
    for (var i$1 = 0; i$1 < panesArray.length; i$1++) {
      panesArray[i$1].refresh();
    }
  };
  PlotAreaBase2.prototype.axisCrossingValues = function axisCrossingValues(axis, crossingAxes) {
    var options2 = axis.options;
    var crossingValues = [].concat(
      options2.axisCrossingValues || options2.axisCrossingValue
    );
    var valuesToAdd = crossingAxes.length - crossingValues.length;
    var defaultValue = crossingValues[0] || 0;
    for (var i = 0; i < valuesToAdd; i++) {
      crossingValues.push(defaultValue);
    }
    return crossingValues;
  };
  PlotAreaBase2.prototype.alignAxisTo = function alignAxisTo(axis, targetAxis, crossingValue, targetCrossingValue) {
    var slot = axis.getSlot(crossingValue, crossingValue, true);
    var slotEdge = axis.options.reverse ? 2 : 1;
    var targetSlot = targetAxis.getSlot(targetCrossingValue, targetCrossingValue, true);
    var targetEdge = targetAxis.options.reverse ? 2 : 1;
    var axisBox = axis.box.translate(
      targetSlot[X + targetEdge] - slot[X + slotEdge],
      targetSlot[Y + targetEdge] - slot[Y + slotEdge]
    );
    if (axis.pane !== targetAxis.pane) {
      axisBox.translate(0, axis.pane.box.y1 - targetAxis.pane.box.y1);
    }
    axis.reflow(axisBox);
  };
  PlotAreaBase2.prototype.alignAxes = function alignAxes(xAxes, yAxes) {
    var this$1 = this;
    var xAnchor = xAxes[0];
    var yAnchor = yAxes[0];
    var xAnchorCrossings = this.axisCrossingValues(xAnchor, yAxes);
    var yAnchorCrossings = this.axisCrossingValues(yAnchor, xAxes);
    var leftAnchors = {};
    var rightAnchors = {};
    var topAnchors = {};
    var bottomAnchors = {};
    for (var i = 0; i < yAxes.length; i++) {
      var axis = yAxes[i];
      var pane = axis.pane;
      var paneId = pane.id;
      var visible = axis.options.visible !== false;
      var anchor = paneAnchor(xAxes, pane) || xAnchor;
      var anchorCrossings = xAnchorCrossings;
      if (anchor !== xAnchor) {
        anchorCrossings = this$1.axisCrossingValues(anchor, yAxes);
      }
      this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
      if (axis.options._overlap) {
        continue;
      }
      if (round3(axis.lineBox().x1) === round3(anchor.lineBox().x1)) {
        if (leftAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(leftAnchors[paneId].box, LEFT).translate(-axis.options.margin, 0)
          );
        }
        if (visible) {
          leftAnchors[paneId] = axis;
        }
      }
      if (round3(axis.lineBox().x2) === round3(anchor.lineBox().x2)) {
        if (!axis._mirrored) {
          axis.options.labels.mirror = !axis.options.labels.mirror;
          axis._mirrored = true;
        }
        this$1.alignAxisTo(axis, anchor, yAnchorCrossings[i], anchorCrossings[i]);
        if (rightAnchors[paneId]) {
          axis.reflow(
            axis.box.alignTo(rightAnchors[paneId].box, RIGHT).translate(axis.options.margin, 0)
          );
        }
        if (visible) {
          rightAnchors[paneId] = axis;
        }
      }
      if (i !== 0 && yAnchor.pane === axis.pane) {
        axis.alignTo(yAnchor);
        axis.reflow(axis.box);
      }
    }
    for (var i$1 = 0; i$1 < xAxes.length; i$1++) {
      var axis$1 = xAxes[i$1];
      var pane$1 = axis$1.pane;
      var paneId$1 = pane$1.id;
      var visible$1 = axis$1.options.visible !== false;
      var anchor$1 = paneAnchor(yAxes, pane$1) || yAnchor;
      var anchorCrossings$1 = yAnchorCrossings;
      if (anchor$1 !== yAnchor) {
        anchorCrossings$1 = this$1.axisCrossingValues(anchor$1, xAxes);
      }
      this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
      if (axis$1.options._overlap) {
        continue;
      }
      if (round3(axis$1.lineBox().y1) === round3(anchor$1.lineBox().y1)) {
        if (!axis$1._mirrored) {
          axis$1.options.labels.mirror = !axis$1.options.labels.mirror;
          axis$1._mirrored = true;
        }
        this$1.alignAxisTo(axis$1, anchor$1, xAnchorCrossings[i$1], anchorCrossings$1[i$1]);
        if (topAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(topAnchors[paneId$1].box, TOP).translate(0, -axis$1.options.margin)
          );
        }
        if (visible$1) {
          topAnchors[paneId$1] = axis$1;
        }
      }
      if (round3(axis$1.lineBox().y2, COORD_PRECISION) === round3(anchor$1.lineBox().y2, COORD_PRECISION)) {
        if (bottomAnchors[paneId$1]) {
          axis$1.reflow(
            axis$1.box.alignTo(bottomAnchors[paneId$1].box, BOTTOM).translate(0, axis$1.options.margin)
          );
        }
        if (visible$1) {
          bottomAnchors[paneId$1] = axis$1;
        }
      }
      if (i$1 !== 0) {
        axis$1.alignTo(xAnchor);
        axis$1.reflow(axis$1.box);
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisWidth = function shrinkAxisWidth(panes) {
    var axes = this.groupAxes(panes).any;
    var axisBox = axisGroupBox(axes);
    var overflowX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.axes.length > 0) {
        overflowX = Math.max(
          overflowX,
          axisBox.width() - currentPane.contentBox.width()
        );
      }
    }
    if (overflowX !== 0) {
      for (var i$1 = 0; i$1 < axes.length; i$1++) {
        var currentAxis = axes[i$1];
        if (!currentAxis.options.vertical) {
          currentAxis.reflow(currentAxis.box.shrink(overflowX, 0));
        }
      }
    }
  };
  PlotAreaBase2.prototype.shrinkAxisHeight = function shrinkAxisHeight(panes) {
    var shrinked;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var axes = currentPane.axes;
      var overflowY = Math.max(0, axisGroupBox(axes).height() - currentPane.contentBox.height());
      if (overflowY !== 0) {
        for (var j = 0; j < axes.length; j++) {
          var currentAxis = axes[j];
          if (currentAxis.options.vertical) {
            currentAxis.reflow(
              currentAxis.box.shrink(0, overflowY)
            );
          }
        }
        shrinked = true;
      }
    }
    return shrinked;
  };
  PlotAreaBase2.prototype.fitAxes = function fitAxes(panes) {
    var axes = this.groupAxes(panes).any;
    var offsetX = 0;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      var paneAxes = currentPane.axes;
      var paneBox = currentPane.contentBox;
      if (paneAxes.length > 0) {
        var axisBox = axisGroupBox(paneAxes);
        var offsetY = Math.max(paneBox.y1 - axisBox.y1, paneBox.y2 - axisBox.y2);
        offsetX = Math.max(offsetX, paneBox.x1 - axisBox.x1);
        for (var j = 0; j < paneAxes.length; j++) {
          var currentAxis = paneAxes[j];
          currentAxis.reflow(
            currentAxis.box.translate(0, offsetY)
          );
        }
      }
    }
    for (var i$1 = 0; i$1 < axes.length; i$1++) {
      var currentAxis$1 = axes[i$1];
      currentAxis$1.reflow(
        currentAxis$1.box.translate(offsetX, 0)
      );
    }
  };
  PlotAreaBase2.prototype.reflowAxes = function reflowAxes(panes) {
    var this$1 = this;
    var axes = this.groupAxes(panes);
    for (var i = 0; i < panes.length; i++) {
      this$1.reflowPaneAxes(panes[i]);
    }
    if (axes.x.length > 0 && axes.y.length > 0) {
      this.alignAxes(axes.x, axes.y);
      this.shrinkAxisWidth(panes);
      this.autoRotateAxisLabels(axes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisWidth(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.shrinkAxisHeight(panes);
      this.alignAxes(axes.x, axes.y);
      if (this.shrinkAxisHeight(panes)) {
        this.alignAxes(axes.x, axes.y);
      }
      this.fitAxes(panes);
    }
  };
  PlotAreaBase2.prototype.autoRotateAxisLabels = function autoRotateAxisLabels(groupedAxes) {
    var this$1 = this;
    var ref2 = this;
    var panes = ref2.panes;
    var axes = allPaneAxes(panes);
    var rotated;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      if (axis.autoRotateLabels()) {
        rotated = true;
      }
    }
    if (rotated) {
      for (var idx$1 = 0; idx$1 < panes.length; idx$1++) {
        this$1.reflowPaneAxes(panes[idx$1]);
      }
      if (groupedAxes.x.length > 0 && groupedAxes.y.length > 0) {
        this.alignAxes(groupedAxes.x, groupedAxes.y);
        this.shrinkAxisWidth(panes);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPaneAxes = function reflowPaneAxes(pane) {
    var axes = pane.axes;
    var length = axes.length;
    if (length > 0) {
      for (var i = 0; i < length; i++) {
        axes[i].reflow(pane.contentBox);
      }
    }
  };
  PlotAreaBase2.prototype.reflowCharts = function reflowCharts(panes) {
    var charts = this.charts;
    var count = charts.length;
    var box = this.box;
    for (var i = 0; i < count; i++) {
      var chartPane = charts[i].pane;
      if (!chartPane || inArray(chartPane, panes)) {
        charts[i].reflow(box);
      }
    }
  };
  PlotAreaBase2.prototype.reflowPanes = function reflowPanes() {
    var ref2 = this;
    var box = ref2.box;
    var panes = ref2.panes;
    var panesLength = panes.length;
    var remainingHeight = box.height();
    var remainingPanes = panesLength;
    var autoHeightPanes = 0;
    var top = box.y1;
    for (var i = 0; i < panesLength; i++) {
      var currentPane = panes[i];
      var height = currentPane.options.height;
      currentPane.options.width = box.width();
      if (!currentPane.options.height) {
        autoHeightPanes++;
      } else {
        if (height.indexOf && height.indexOf("%")) {
          var percents = parseInt(height, 10) / 100;
          currentPane.options.height = percents * box.height();
        }
        currentPane.reflow(box.clone());
        remainingHeight -= currentPane.options.height;
      }
    }
    for (var i$1 = 0; i$1 < panesLength; i$1++) {
      var currentPane$1 = panes[i$1];
      if (!currentPane$1.options.height) {
        currentPane$1.options.height = remainingHeight / autoHeightPanes;
      }
    }
    for (var i$2 = 0; i$2 < panesLength; i$2++) {
      var currentPane$2 = panes[i$2];
      var paneBox = box.clone().move(box.x1, top);
      currentPane$2.reflow(paneBox);
      remainingPanes--;
      top += currentPane$2.options.height;
    }
  };
  PlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    var axes = this.axes;
    var axesCount = axes.length;
    var box;
    for (var i = 0; i < axesCount; i++) {
      var axisA = axes[i];
      for (var j = 0; j < axesCount; j++) {
        var axisB = axes[j];
        if (axisA.options.vertical !== axisB.options.vertical) {
          var lineBox = axisA.lineBox().clone().wrap(axisB.lineBox());
          if (!box) {
            box = lineBox;
          } else {
            box = box.wrap(lineBox);
          }
        }
      }
    }
    return box || this.box;
  };
  PlotAreaBase2.prototype.chartsBoxes = function chartsBoxes() {
    var panes = this.panes;
    var boxes = [];
    for (var idx = 0; idx < panes.length; idx++) {
      boxes.push(panes[idx].chartsBox());
    }
    return boxes;
  };
  PlotAreaBase2.prototype.addBackgroundPaths = function addBackgroundPaths(multipath) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      multipath.paths.push(drawing_exports.Path.fromRect(boxes[idx].toRect()));
    }
  };
  PlotAreaBase2.prototype.backgroundContainsPoint = function backgroundContainsPoint(point2) {
    var boxes = this.chartsBoxes();
    for (var idx = 0; idx < boxes.length; idx++) {
      if (boxes[idx].containsPoint(point2)) {
        return true;
      }
    }
  };
  PlotAreaBase2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var options2 = this.options.plotArea;
    var opacity = options2.opacity;
    var background = options2.background;
    var border = options2.border;
    if (border === void 0)
      border = {};
    if (isTransparent2(background)) {
      background = WHITE;
      opacity = 0;
    }
    var bg = this._bgVisual = new drawing_exports.MultiPath({
      fill: {
        color: background,
        opacity
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      },
      zIndex: -1
    });
    this.addBackgroundPaths(bg);
    this.appendVisual(bg);
  };
  PlotAreaBase2.prototype.pointsByCategoryIndex = function pointsByCategoryIndex(categoryIndex) {
    var charts = this.charts;
    var result = [];
    if (categoryIndex !== null) {
      for (var i = 0; i < charts.length; i++) {
        var chart = charts[i];
        if (chart.pane.options.name === "_navigator") {
          continue;
        }
        var points3 = charts[i].categoryPoints[categoryIndex];
        if (points3 && points3.length) {
          for (var j = 0; j < points3.length; j++) {
            var point2 = points3[j];
            if (point2 && defined2(point2.value) && point2.value !== null) {
              result.push(point2);
            }
          }
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.pointsBySeriesIndex = function pointsBySeriesIndex(seriesIndex) {
    return this.filterPoints(function(point2) {
      return point2.series.index === seriesIndex;
    });
  };
  PlotAreaBase2.prototype.pointsBySeriesName = function pointsBySeriesName(name3) {
    return this.filterPoints(function(point2) {
      return point2.series.name === name3;
    });
  };
  PlotAreaBase2.prototype.filterPoints = function filterPoints(callback) {
    var charts = this.charts;
    var result = [];
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points3 = chart.points;
      for (var j = 0; j < points3.length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && callback(point2)) {
          result.push(point2);
        }
      }
    }
    return result;
  };
  PlotAreaBase2.prototype.findPoint = function findPoint(callback) {
    var charts = this.charts;
    for (var i = 0; i < charts.length; i++) {
      var chart = charts[i];
      var points3 = chart.points;
      for (var j = 0; j < points3.length; j++) {
        var point2 = points3[j];
        if (point2 && point2.visible !== false && callback(point2)) {
          return point2;
        }
      }
    }
  };
  PlotAreaBase2.prototype.paneByPoint = function paneByPoint(point2) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      if (pane.box.containsPoint(point2)) {
        return pane;
      }
    }
  };
  PlotAreaBase2.prototype.detachLabels = function detachLabels() {
    var axes = this.groupAxes(this.panes);
    var xAxes = axes.x;
    var yAxes = axes.y;
    this.detachAxisGroupLabels(yAxes, xAxes);
    this.detachAxisGroupLabels(xAxes, yAxes);
  };
  PlotAreaBase2.prototype.detachAxisGroupLabels = function detachAxisGroupLabels(axes, crossingAxes) {
    var this$1 = this;
    var labelAxisCount = 0;
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var pane = axis.pane;
      var anchor = paneAnchor(crossingAxes, pane) || crossingAxes[0];
      var axisIndex = i + labelAxisCount;
      var labelAxis = this$1.createLabelAxis(axis, axisIndex, anchor);
      if (labelAxis) {
        labelAxisCount++;
        var pos = pane.axes.indexOf(axis) + labelAxisCount;
        pane.appendAxisAt(labelAxis, pos);
      }
    }
  };
  PlotAreaBase2.prototype.createLabelAxis = function createLabelAxis(axis, axisIndex, anchor) {
    var labelOptions = axis.options.labels;
    var position = labelOptions.position;
    var onAxis = position !== END && position !== START;
    var visible = labelOptions.visible;
    if (onAxis || visible === false) {
      return null;
    }
    var allAxes = this.groupAxes(this.panes);
    var crossingAxes = anchor.options.vertical ? allAxes.x : allAxes.y;
    var anchorCrossings = this.axisCrossingValues(anchor, crossingAxes);
    var end = position === END;
    var range = anchor.range();
    var edge = end ? range.max : range.min;
    var crossingValue = limitValue2(anchorCrossings[axisIndex], range.min, range.max);
    if (crossingValue - edge === 0) {
      return null;
    }
    anchorCrossings.splice(axisIndex + 1, 0, edge);
    anchor.options.axisCrossingValues = anchorCrossings;
    var labelAxis = axis.clone();
    axis.clear();
    labelAxis.options.name = void 0;
    labelAxis.options.line.visible = false;
    labelAxis.options.crosshair = void 0;
    labelAxis.options.notes = void 0;
    labelAxis.options.plotBands = void 0;
    return labelAxis;
  };
  return PlotAreaBase2;
}(chart_element_default);
function isSingleAxis(axis) {
  return !axis.pane.axes.some(
    function(a) {
      return a.options.vertical === axis.options.vertical && a !== axis && a.options.visible !== false;
    }
  );
}
function axisGroupBox(axes) {
  var length = axes.length;
  var box;
  for (var i = 0; i < length; i++) {
    var axis = axes[i];
    var visible = axis.options.visible !== false;
    if (visible || isSingleAxis(axis)) {
      var axisBox = visible ? axis.contentBox() : axis.lineBox();
      if (!box) {
        box = axisBox.clone();
      } else {
        box.wrap(axisBox);
      }
    }
  }
  return box || new box_default();
}
function paneAnchor(axes, pane) {
  for (var i = 0; i < axes.length; i++) {
    var anchor = axes[i];
    if (anchor && anchor.pane === pane) {
      return anchor;
    }
  }
}
function isTransparent2(color) {
  return color === "" || color === null || color === "none" || color === "transparent" || !defined2(color);
}
var allPaneAxes = function(panes) {
  return panes.reduce(function(acc, pane) {
    return acc.concat(pane.axes);
  }, []);
};
setDefaultOptions(PlotAreaBase, {
  series: [],
  plotArea: {
    margin: {}
  },
  background: "",
  border: {
    color: BLACK,
    width: 0
  },
  paneDefaults: {
    title: {}
  },
  legend: {
    inactiveItems: {
      labels: {
        color: "#919191"
      },
      markers: {
        color: "#919191"
      }
    }
  }
});
var plotarea_base_default = PlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/plotarea-events-mixin.js
var PlotAreaEventsMixin = {
  hover: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_HOVER);
  },
  click: function(chart, e) {
    this._dispatchEvent(chart, e, PLOT_AREA_CLICK);
  }
};
var plotarea_events_mixin_default = PlotAreaEventsMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/series-aggregator.js
var SeriesAggregator = function(Class3) {
  function SeriesAggregator2(series, binder, defaultAggregates) {
    Class3.call(this);
    var canonicalFields = binder.canonicalFields(series);
    var valueFields = binder.valueFields(series);
    var sourceFields = binder.sourceFields(series, canonicalFields);
    var seriesFields = this._seriesFields = [];
    var defaults = defaultAggregates.query(series.type);
    var rootAggregate = series.aggregate || defaults;
    this._series = series;
    this._binder = binder;
    for (var i = 0; i < canonicalFields.length; i++) {
      var field = canonicalFields[i];
      var fieldAggregate = void 0;
      if (isObject(rootAggregate)) {
        fieldAggregate = rootAggregate[field];
      } else if (i === 0 || inArray(field, valueFields)) {
        fieldAggregate = rootAggregate;
      } else {
        break;
      }
      if (fieldAggregate) {
        seriesFields.push({
          canonicalName: field,
          name: sourceFields[i],
          transform: isFunction3(fieldAggregate) ? fieldAggregate : aggregates_default[fieldAggregate]
        });
      }
    }
  }
  if (Class3)
    SeriesAggregator2.__proto__ = Class3;
  SeriesAggregator2.prototype = Object.create(Class3 && Class3.prototype);
  SeriesAggregator2.prototype.constructor = SeriesAggregator2;
  SeriesAggregator2.prototype.aggregatePoints = function aggregatePoints(srcPoints, group) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2._series;
    var seriesFields = ref2._seriesFields;
    var data = this._bindPoints(srcPoints || []);
    var firstDataItem = data.dataItems[0];
    var result = {};
    if (firstDataItem && !isNumber2(firstDataItem) && !isArray(firstDataItem)) {
      var fn = function() {
      };
      fn.prototype = firstDataItem;
      result = new fn();
    }
    for (var i = 0; i < seriesFields.length; i++) {
      var field = seriesFields[i];
      var srcValues = this$1._bindField(data.values, field.canonicalName);
      var value = field.transform(srcValues, series, data.dataItems, group);
      if (value !== null && isObject(value) && !defined2(value.length) && !(value instanceof Date)) {
        result = value;
        break;
      } else {
        if (defined2(value)) {
          setValue(field.name, result, value);
        }
      }
    }
    return result;
  };
  SeriesAggregator2.prototype._bindPoints = function _bindPoints(points3) {
    var ref2 = this;
    var binder = ref2._binder;
    var series = ref2._series;
    var values5 = [];
    var dataItems = [];
    for (var i = 0; i < points3.length; i++) {
      var pointIx = points3[i];
      values5.push(binder.bindPoint(series, pointIx));
      dataItems.push(series.data[pointIx]);
    }
    return {
      values: values5,
      dataItems
    };
  };
  SeriesAggregator2.prototype._bindField = function _bindField(data, field) {
    var values5 = [];
    var count = data.length;
    for (var i = 0; i < count; i++) {
      var item = data[i];
      var valueFields = item.valueFields;
      var value = void 0;
      if (defined2(valueFields[field])) {
        value = valueFields[field];
      } else {
        value = item.fields[field];
      }
      values5.push(value);
    }
    return values5;
  };
  return SeriesAggregator2;
}(class_default);
function setValue(fieldName, target, value) {
  var parentObj = target;
  var field = fieldName;
  if (fieldName.indexOf(".") > -1) {
    var parts = fieldName.split(".");
    while (parts.length > 1) {
      field = parts.shift();
      if (!defined2(parentObj[field])) {
        parentObj[field] = {};
      }
      parentObj = parentObj[field];
    }
    field = parts.shift();
  }
  parentObj[field] = value;
}
var series_aggregator_default = SeriesAggregator;

// node_modules/@progress/kendo-charts/dist/es/chart/aggregates/default-aggregates.js
var DefaultAggregates = function(Class3) {
  function DefaultAggregates2() {
    Class3.call(this);
    this._defaults = {};
  }
  if (Class3)
    DefaultAggregates2.__proto__ = Class3;
  DefaultAggregates2.prototype = Object.create(Class3 && Class3.prototype);
  DefaultAggregates2.prototype.constructor = DefaultAggregates2;
  DefaultAggregates2.prototype.register = function register4(seriesTypes, aggregates) {
    var this$1 = this;
    for (var i = 0; i < seriesTypes.length; i++) {
      this$1._defaults[seriesTypes[i]] = aggregates;
    }
  };
  DefaultAggregates2.prototype.query = function query(seriesType) {
    return this._defaults[seriesType];
  };
  return DefaultAggregates2;
}(class_default);
DefaultAggregates.current = new DefaultAggregates();
var default_aggregates_default = DefaultAggregates;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar.js
var RangeBar = function(Bar2) {
  function RangeBar2() {
    Bar2.apply(this, arguments);
  }
  if (Bar2)
    RangeBar2.__proto__ = Bar2;
  RangeBar2.prototype = Object.create(Bar2 && Bar2.prototype);
  RangeBar2.prototype.constructor = RangeBar2;
  RangeBar2.prototype.createLabel = function createLabel() {
    var labels = this.options.labels;
    var fromOptions = deepExtend({}, labels, labels.from);
    var toOptions = deepExtend({}, labels, labels.to);
    if (fromOptions.visible) {
      this.labelFrom = this._createLabel(fromOptions);
      this.append(this.labelFrom);
    }
    if (toOptions.visible) {
      this.labelTo = this._createLabel(toOptions);
      this.append(this.labelTo);
    }
  };
  RangeBar2.prototype._createLabel = function _createLabel(options2) {
    var labelTemplate = getTemplate(options2);
    var pointData = this.pointData();
    var labelText;
    if (labelTemplate) {
      labelText = labelTemplate(pointData);
    } else {
      labelText = this.formatValue(options2.format);
    }
    return new bar_label_default(
      labelText,
      deepExtend(
        {
          vertical: this.options.vertical
        },
        options2
      ),
      pointData
    );
  };
  RangeBar2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var ref2 = this;
    var labelFrom = ref2.labelFrom;
    var labelTo = ref2.labelTo;
    var value = ref2.value;
    this.box = targetBox;
    if (labelFrom) {
      labelFrom.options.aboveAxis = value.from > value.to;
      labelFrom.reflow(targetBox);
    }
    if (labelTo) {
      labelTo.options.aboveAxis = value.to > value.from;
      labelTo.reflow(targetBox);
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
  };
  return RangeBar2;
}(bar_default);
RangeBar.prototype.defaults = deepExtend({}, RangeBar.prototype.defaults, {
  labels: {
    format: "{0} - {1}"
  },
  tooltip: {
    format: "{1}"
  }
});
var range_bar_default = RangeBar;

// node_modules/@progress/kendo-charts/dist/es/chart/range-bar-chart/range-bar-chart.js
var RangeBarChart = function(BarChart2) {
  function RangeBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RangeBarChart2.__proto__ = BarChart2;
  RangeBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RangeBarChart2.prototype.constructor = RangeBarChart2;
  RangeBarChart2.prototype.pointType = function pointType() {
    return range_bar_default;
  };
  RangeBarChart2.prototype.pointValue = function pointValue(data) {
    return data.valueFields;
  };
  RangeBarChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    if (point2.value.from === null && point2.value.to === null) {
      return "";
    }
    return this.chartService.format.auto(format2, point2.value.from, point2.value.to);
  };
  RangeBarChart2.prototype.plotRange = function plotRange(point2) {
    if (!point2) {
      return 0;
    }
    return [point2.value.from, point2.value.to];
  };
  RangeBarChart2.prototype.updateRange = function updateRange(value, fields) {
    var axisName = fields.series.axis;
    var from = value.from;
    var to = value.to;
    var axisRange = this.valueAxisRanges[axisName];
    if (value !== null && isNumber2(from) && isNumber2(to)) {
      axisRange = this.valueAxisRanges[axisName] = axisRange || { min: MAX_VALUE, max: MIN_VALUE };
      axisRange.min = Math.min(axisRange.min, from);
      axisRange.max = Math.max(axisRange.max, from);
      axisRange.min = Math.min(axisRange.min, to);
      axisRange.max = Math.max(axisRange.max, to);
    }
  };
  RangeBarChart2.prototype.aboveAxis = function aboveAxis(point2) {
    var value = point2.value;
    return value.from < value.to;
  };
  return RangeBarChart2;
}(bar_chart_default);
RangeBarChart.prototype.plotLimits = categorical_chart_default.prototype.plotLimits;
var range_bar_chart_default = RangeBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-line-point.js
var RangeLinePoint = function(LinePoint2) {
  function RangeLinePoint2() {
    LinePoint2.apply(this, arguments);
  }
  if (LinePoint2)
    RangeLinePoint2.__proto__ = LinePoint2;
  RangeLinePoint2.prototype = Object.create(LinePoint2 && LinePoint2.prototype);
  RangeLinePoint2.prototype.constructor = RangeLinePoint2;
  RangeLinePoint2.prototype.aliasFor = function aliasFor() {
    return this.parent;
  };
  return RangeLinePoint2;
}(line_point_default);
var range_line_point_default = RangeLinePoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-point.js
var AUTO2 = "auto";
var DEFAULT_FROM_FORMAT = "{0}";
var DEFAULT_TO_FORMAT = "{1}";
var RangeAreaPoint = function(ChartElement2) {
  function RangeAreaPoint2(value, options2) {
    ChartElement2.call(this);
    this.value = value;
    this.options = options2;
    this.aboveAxis = valueOrDefault2(this.options.aboveAxis, true);
    this.tooltipTracking = true;
    this.initLabelsFormat();
  }
  if (ChartElement2)
    RangeAreaPoint2.__proto__ = ChartElement2;
  RangeAreaPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RangeAreaPoint2.prototype.constructor = RangeAreaPoint2;
  RangeAreaPoint2.prototype.render = function render3() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    var ref2 = this.options;
    var markers = ref2.markers;
    var labels = ref2.labels;
    var value = this.value;
    var fromPoint = this.fromPoint = new range_line_point_default(value, deepExtend({}, this.options, {
      labels: labels.from,
      markers: markers.from
    }));
    var toPoint = this.toPoint = new range_line_point_default(value, deepExtend({}, this.options, {
      labels: labels.to,
      markers: markers.to
    }));
    this.copyFields(fromPoint);
    this.copyFields(toPoint);
    this.append(fromPoint);
    this.append(toPoint);
  };
  RangeAreaPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var fromBox = targetBox.from;
    var toBox = targetBox.to;
    this.positionLabels(fromBox, toBox);
    this.fromPoint.reflow(fromBox);
    this.toPoint.reflow(toBox);
    this.box = this.fromPoint.markerBox().clone().wrap(this.toPoint.markerBox());
  };
  RangeAreaPoint2.prototype.createHighlight = function createHighlight() {
    var group = new drawing_exports.Group();
    group.append(this.fromPoint.createHighlight());
    group.append(this.toPoint.createHighlight());
    return group;
  };
  RangeAreaPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.visual;
  };
  RangeAreaPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      from: this.fromPoint.highlightVisualArgs(),
      to: this.toPoint.highlightVisualArgs()
    };
  };
  RangeAreaPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var clipBox = this.owner.pane.clipBox();
    var showTooltip = !clipBox || clipBox.overlaps(this.box);
    if (showTooltip) {
      var box = this.box;
      var center = box.center();
      var horizontalAlign = LEFT;
      var x, y, verticalAlign;
      if (this.options.vertical) {
        x = center.x;
        y = box.y1 - TOOLTIP_OFFSET;
        verticalAlign = BOTTOM;
      } else {
        x = box.x2 + TOOLTIP_OFFSET;
        y = center.y;
        verticalAlign = CENTER;
      }
      return {
        point: new point_default2(x, y),
        align: {
          horizontal: horizontalAlign,
          vertical: verticalAlign
        }
      };
    }
  };
  RangeAreaPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  RangeAreaPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  RangeAreaPoint2.prototype.unclipElements = function unclipElements() {
    this.fromPoint.unclipElements();
    this.toPoint.unclipElements();
  };
  RangeAreaPoint2.prototype.initLabelsFormat = function initLabelsFormat() {
    var labels = this.options.labels;
    if (!labels.format) {
      if (!labels.from || !labels.from.format) {
        labels.from = Object.assign({}, labels.from, {
          format: DEFAULT_FROM_FORMAT
        });
      }
      if (!labels.to || !labels.to.format) {
        labels.to = Object.assign({}, labels.to, {
          format: DEFAULT_TO_FORMAT
        });
      }
    }
  };
  RangeAreaPoint2.prototype.positionLabels = function positionLabels(fromBox, toBox) {
    var ref2 = this.options;
    var labels = ref2.labels;
    var vertical = ref2.vertical;
    if (labels.position === AUTO2) {
      var fromLabelPosition, toLabelPosition;
      if (vertical) {
        if (toBox.y1 <= fromBox.y1) {
          toLabelPosition = ABOVE;
          fromLabelPosition = BELOW;
        } else {
          toLabelPosition = BELOW;
          fromLabelPosition = ABOVE;
        }
      } else {
        if (toBox.x1 <= fromBox.x1) {
          toLabelPosition = LEFT;
          fromLabelPosition = RIGHT;
        } else {
          toLabelPosition = RIGHT;
          fromLabelPosition = LEFT;
        }
      }
      if (!labels.from || !labels.from.position) {
        this.fromPoint.options.labels.position = fromLabelPosition;
      }
      if (!labels.to || !labels.to.position) {
        this.toPoint.options.labels.position = toLabelPosition;
      }
    }
  };
  RangeAreaPoint2.prototype.copyFields = function copyFields(point2) {
    point2.dataItem = this.dataItem;
    point2.category = this.category;
    point2.series = this.series;
    point2.color = this.color;
    point2.owner = this.owner;
  };
  return RangeAreaPoint2;
}(chart_element_default);
deepExtend(RangeAreaPoint.prototype, point_events_mixin_default);
deepExtend(RangeAreaPoint.prototype, note_mixin_default);
RangeAreaPoint.prototype.defaults = {
  markers: {
    visible: false,
    background: WHITE,
    size: LINE_MARKER_SIZE,
    type: CIRCLE,
    border: {
      width: 2
    },
    opacity: 1
  },
  labels: {
    visible: false,
    margin: getSpacing(3),
    padding: getSpacing(4),
    animation: {
      type: FADEIN,
      delay: INITIAL_ANIMATION_DURATION
    },
    position: AUTO2
  },
  notes: {
    label: {}
  },
  highlight: {
    markers: {
      border: {
        color: WHITE,
        width: 2
      }
    },
    zIndex: HIGHLIGHT_ZINDEX
  },
  tooltip: {
    format: "{0} - {1}"
  }
};
var range_area_point_default = RangeAreaPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-segment.js
var RangeAreaSegment = function(AreaSegment2) {
  function RangeAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RangeAreaSegment2.__proto__ = AreaSegment2;
  RangeAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RangeAreaSegment2.prototype.constructor = RangeAreaSegment2;
  RangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.toGeometryPoints(this.toPoints()));
  };
  RangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.toGeometryPoints(this.fromPoints().reverse()));
    }
    return fromSegments;
  };
  RangeAreaSegment2.prototype.createStroke = function createStroke(style) {
    var toPath = new drawing_exports.Path(style);
    var fromPath = new drawing_exports.Path(style);
    toPath.segments.push.apply(toPath.segments, this.strokeSegments());
    fromPath.segments.push.apply(fromPath.segments, this.stackSegments());
    this.visual.append(toPath);
    this.visual.append(fromPath);
  };
  RangeAreaSegment2.prototype.hasStackSegment = function hasStackSegment() {
    return true;
  };
  RangeAreaSegment2.prototype.fromPoints = function fromPoints() {
    return this.linePoints.map(function(point2) {
      return point2.fromPoint;
    });
  };
  RangeAreaSegment2.prototype.toPoints = function toPoints() {
    return this.linePoints.map(function(point2) {
      return point2.toPoint;
    });
  };
  return RangeAreaSegment2;
}(area_segment_default);
var range_area_segment_default = RangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/spline-range-area-segment.js
var SplineRangeAreaSegment = function(RangeAreaSegment2) {
  function SplineRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    SplineRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  SplineRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  SplineRangeAreaSegment2.prototype.constructor = SplineRangeAreaSegment2;
  SplineRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.createCurveSegments(this.toPoints());
  };
  SplineRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.createCurveSegments(this.fromPoints().reverse());
    }
    return fromSegments;
  };
  SplineRangeAreaSegment2.prototype.createCurveSegments = function createCurveSegments(points3) {
    var curveProcessor = new curve_processor_default();
    return curveProcessor.process(this.toGeometryPoints(points3));
  };
  return SplineRangeAreaSegment2;
}(range_area_segment_default);
var spline_range_area_segment_default = SplineRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/step-range-area-segment.js
var StepRangeAreaSegment = function(RangeAreaSegment2) {
  function StepRangeAreaSegment2() {
    RangeAreaSegment2.apply(this, arguments);
  }
  if (RangeAreaSegment2)
    StepRangeAreaSegment2.__proto__ = RangeAreaSegment2;
  StepRangeAreaSegment2.prototype = Object.create(RangeAreaSegment2 && RangeAreaSegment2.prototype);
  StepRangeAreaSegment2.prototype.constructor = StepRangeAreaSegment2;
  StepRangeAreaSegment2.prototype.createStrokeSegments = function createStrokeSegments() {
    return this.segmentsFromPoints(this.calculateStepPoints(this.toPoints()));
  };
  StepRangeAreaSegment2.prototype.stackSegments = function stackSegments() {
    var fromSegments = this.fromSegments;
    if (!this.fromSegments) {
      fromSegments = this.fromSegments = this.segmentsFromPoints(this.calculateStepPoints(this.fromPoints()));
      fromSegments.reverse();
    }
    return fromSegments;
  };
  return StepRangeAreaSegment2;
}(range_area_segment_default);
deepExtend(StepRangeAreaSegment.prototype, step_line_mixin_default);
var step_range_area_segment_default = StepRangeAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/range-area-chart/range-area-chart.js
var RangeAreaChart = function(CategoricalChart2) {
  function RangeAreaChart2() {
    CategoricalChart2.apply(this, arguments);
  }
  if (CategoricalChart2)
    RangeAreaChart2.__proto__ = CategoricalChart2;
  RangeAreaChart2.prototype = Object.create(CategoricalChart2 && CategoricalChart2.prototype);
  RangeAreaChart2.prototype.constructor = RangeAreaChart2;
  RangeAreaChart2.prototype.render = function render3() {
    CategoricalChart2.prototype.render.call(this);
    this.renderSegments();
  };
  RangeAreaChart2.prototype.pointType = function pointType() {
    return range_area_point_default;
  };
  RangeAreaChart2.prototype.createPoint = function createPoint(data, fields) {
    var categoryIx = fields.categoryIx;
    var category = fields.category;
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var value = data.valueFields;
    if (!hasValue(value.from) && !hasValue(value.to)) {
      if (this.seriesMissingValues(series) === ZERO2) {
        value = {
          from: 0,
          to: 0
        };
      } else {
        return null;
      }
    }
    var pointOptions = this.pointOptions(series, seriesIx);
    pointOptions = this.evalPointOptions(
      pointOptions,
      value,
      category,
      categoryIx,
      series,
      seriesIx
    );
    var color = data.fields.color || series.color;
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    }
    var point2 = new range_area_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  RangeAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segmentType2;
    if (style === "smooth") {
      segmentType2 = spline_range_area_segment_default;
    } else if (style === "step") {
      segmentType2 = step_range_area_segment_default;
    } else {
      segmentType2 = range_area_segment_default;
    }
    return new segmentType2(linePoints, currentSeries, seriesIx);
  };
  RangeAreaChart2.prototype.plotRange = function plotRange(point2, startValue) {
    if (!point2) {
      return [startValue, startValue];
    }
    return [point2.value.from, point2.value.to];
  };
  RangeAreaChart2.prototype.valueSlot = function valueSlot(valueAxis, plotRange) {
    var fromSlot = valueAxis.getSlot(plotRange[0], plotRange[0], !this.options.clip);
    var toSlot = valueAxis.getSlot(plotRange[1], plotRange[1], !this.options.clip);
    if (fromSlot && toSlot) {
      return {
        from: fromSlot,
        to: toSlot
      };
    }
  };
  RangeAreaChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var from = valueSlot.from;
    var to = valueSlot.to;
    var fromSlot, toSlot;
    if (this.options.invertAxes) {
      fromSlot = new box_default(from.x1, categorySlot.y1, from.x2, categorySlot.y2);
      toSlot = new box_default(to.x1, categorySlot.y1, to.x2, categorySlot.y2);
    } else {
      fromSlot = new box_default(categorySlot.x1, from.y1, categorySlot.x2, from.y2);
      toSlot = new box_default(categorySlot.x1, to.y1, categorySlot.x2, to.y2);
    }
    return {
      from: fromSlot,
      to: toSlot
    };
  };
  RangeAreaChart2.prototype.addValue = function addValue(data, fields) {
    var valueFields = data.valueFields;
    if (!isNumber2(valueFields.from)) {
      valueFields.from = valueFields.to;
    }
    if (!isNumber2(valueFields.to)) {
      valueFields.to = valueFields.from;
    }
    CategoricalChart2.prototype.addValue.call(this, data, fields);
  };
  RangeAreaChart2.prototype.updateRange = function updateRange(value, fields) {
    if (value !== null && isNumber2(value.from) && isNumber2(value.to)) {
      var axisName = fields.series.axis;
      var axisRange = this.valueAxisRanges[axisName] = this.valueAxisRanges[axisName] || { min: MAX_VALUE, max: MIN_VALUE };
      var from = value.from;
      var to = value.to;
      axisRange.min = Math.min(axisRange.min, from, to);
      axisRange.max = Math.max(axisRange.max, from, to);
    }
  };
  RangeAreaChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.from, value.to);
  };
  RangeAreaChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      var point2 = points3[idx];
      if (point2) {
        result.push((point2.fromPoint || {}).marker);
        result.push((point2.toPoint || {}).marker);
      }
    }
    return result.concat(this._segments);
  };
  return RangeAreaChart2;
}(categorical_chart_default);
deepExtend(RangeAreaChart.prototype, line_chart_mixin_default, clip_animation_mixin_default);
var range_area_chart_default = RangeAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-point.js
var OHLCPoint = function(Candlestick2) {
  function OHLCPoint2() {
    Candlestick2.apply(this, arguments);
  }
  if (Candlestick2)
    OHLCPoint2.__proto__ = Candlestick2;
  OHLCPoint2.prototype = Object.create(Candlestick2 && Candlestick2.prototype);
  OHLCPoint2.prototype.constructor = OHLCPoint2;
  OHLCPoint2.prototype.reflow = function reflow(box) {
    var ref2 = this;
    var options2 = ref2.options;
    var value = ref2.value;
    var chart = ref2.owner;
    var valueAxis = chart.seriesValueAxis(options2);
    var oPoints = [];
    var cPoints = [];
    var lhPoints = [];
    var lhSlot = valueAxis.getSlot(value.low, value.high);
    var oSlot = valueAxis.getSlot(value.open, value.open);
    var cSlot = valueAxis.getSlot(value.close, value.close);
    oSlot.x1 = cSlot.x1 = lhSlot.x1 = box.x1;
    oSlot.x2 = cSlot.x2 = lhSlot.x2 = box.x2;
    var mid = lhSlot.center().x;
    oPoints.push([oSlot.x1, oSlot.y1]);
    oPoints.push([mid, oSlot.y1]);
    cPoints.push([mid, cSlot.y1]);
    cPoints.push([cSlot.x2, cSlot.y1]);
    lhPoints.push([mid, lhSlot.y1]);
    lhPoints.push([mid, lhSlot.y2]);
    this.lines = [
      oPoints,
      cPoints,
      lhPoints
    ];
    this.box = lhSlot.clone().wrap(oSlot.clone().wrap(cSlot));
    this.reflowNote();
  };
  OHLCPoint2.prototype.createBody = function createBody() {
  };
  return OHLCPoint2;
}(candlestick_default);
var ohlc_point_default = OHLCPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/ohlc-chart/ohlc-chart.js
var OHLCChart = function(CandlestickChart2) {
  function OHLCChart2() {
    CandlestickChart2.apply(this, arguments);
  }
  if (CandlestickChart2)
    OHLCChart2.__proto__ = CandlestickChart2;
  OHLCChart2.prototype = Object.create(CandlestickChart2 && CandlestickChart2.prototype);
  OHLCChart2.prototype.constructor = OHLCChart2;
  OHLCChart2.prototype.pointType = function pointType() {
    return ohlc_point_default;
  };
  return OHLCChart2;
}(candlestick_chart_default);
var ohlc_chart_default = OHLCChart;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-segment.js
var WaterfallSegment = function(ChartElement2) {
  function WaterfallSegment2(from, to, series) {
    ChartElement2.call(this);
    this.from = from;
    this.to = to;
    this.series = series;
  }
  if (ChartElement2)
    WaterfallSegment2.__proto__ = ChartElement2;
  WaterfallSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  WaterfallSegment2.prototype.constructor = WaterfallSegment2;
  WaterfallSegment2.prototype.linePoints = function linePoints() {
    var from = this.from;
    var ref2 = this;
    var fromBox = ref2.from.box;
    var toBox = ref2.to.box;
    var points3 = [];
    if (from.isVertical) {
      var y = from.aboveAxis ? fromBox.y1 : fromBox.y2;
      points3.push(
        [fromBox.x1, y],
        [toBox.x2, y]
      );
    } else {
      var x = from.aboveAxis ? fromBox.x2 : fromBox.x1;
      points3.push(
        [x, fromBox.y1],
        [x, toBox.y2]
      );
    }
    return points3;
  };
  WaterfallSegment2.prototype.createVisual = function createVisual() {
    ChartElement2.prototype.createVisual.call(this);
    var line = this.series.line || {};
    var path = drawing_exports.Path.fromPoints(this.linePoints(), {
      stroke: {
        color: line.color,
        width: line.width,
        opacity: line.opacity,
        dashType: line.dashType
      }
    });
    alignPathToPixel(path);
    this.visual.append(path);
  };
  return WaterfallSegment2;
}(chart_element_default);
setDefaultOptions(WaterfallSegment, {
  animation: {
    type: FADEIN,
    delay: INITIAL_ANIMATION_DURATION
  }
});
var waterfall_segment_default = WaterfallSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/waterfall-chart/waterfall-chart.js
var WaterfallChart = function(BarChart2) {
  function WaterfallChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    WaterfallChart2.__proto__ = BarChart2;
  WaterfallChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  WaterfallChart2.prototype.constructor = WaterfallChart2;
  WaterfallChart2.prototype.render = function render3() {
    BarChart2.prototype.render.call(this);
    this.createSegments();
  };
  WaterfallChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var series = this.options.series;
    var totalCategories = categoriesCount(series);
    var isVertical = !this.options.invertAxes;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var total3 = 0;
      var runningTotal = 0;
      for (var categoryIx = 0; categoryIx < totalCategories; categoryIx++) {
        var data = series_binder_default.current.bindPoint(currentSeries, categoryIx);
        var value = data.valueFields.value;
        var summary = data.fields.summary;
        var from = total3;
        var to = void 0;
        if (summary) {
          if (summary.toLowerCase() === "total") {
            data.valueFields.value = total3;
            from = 0;
            to = total3;
          } else {
            data.valueFields.value = runningTotal;
            to = from - runningTotal;
            runningTotal = 0;
          }
        } else if (isNumber2(value)) {
          runningTotal += value;
          total3 += value;
          to = total3;
        }
        callback(data, {
          category: this$1.categoryAxis.categoryAt(categoryIx),
          categoryIx,
          series: currentSeries,
          seriesIx,
          total: total3,
          runningTotal,
          from,
          to,
          isVertical
        });
      }
    }
  };
  WaterfallChart2.prototype.updateRange = function updateRange(value, fields) {
    BarChart2.prototype.updateRange.call(this, { value: fields.to }, fields);
  };
  WaterfallChart2.prototype.aboveAxis = function aboveAxis(point2) {
    return point2.value >= 0;
  };
  WaterfallChart2.prototype.plotRange = function plotRange(point2) {
    return [point2.from, point2.to];
  };
  WaterfallChart2.prototype.createSegments = function createSegments() {
    var this$1 = this;
    var series = this.options.series;
    var seriesPoints = this.seriesPoints;
    var segments = this.segments = [];
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var points3 = seriesPoints[seriesIx];
      if (points3) {
        var prevPoint = void 0;
        for (var pointIx = 0; pointIx < points3.length; pointIx++) {
          var point2 = points3[pointIx];
          if (point2 && prevPoint) {
            var segment = new waterfall_segment_default(prevPoint, point2, currentSeries);
            segments.push(segment);
            this$1.append(segment);
          }
          prevPoint = point2;
        }
      }
    }
  };
  return WaterfallChart2;
}(bar_chart_default);
var waterfall_chart_default = WaterfallChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/categorical-plotarea.js
var AREA_SERIES = [AREA, VERTICAL_AREA, RANGE_AREA, VERTICAL_RANGE_AREA];
var OUT_OF_RANGE_SERIES = [LINE, VERTICAL_LINE].concat(AREA_SERIES);
var CategoricalPlotArea = function(PlotAreaBase2) {
  function CategoricalPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    CategoricalPlotArea2.__proto__ = PlotAreaBase2;
  CategoricalPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  CategoricalPlotArea2.prototype.constructor = CategoricalPlotArea2;
  CategoricalPlotArea2.prototype.initFields = function initFields(series) {
    var this$1 = this;
    this.namedCategoryAxes = {};
    this.namedValueAxes = {};
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
    if (series.length > 0) {
      this.invertAxes = inArray(
        series[0].type,
        [
          BAR,
          BULLET,
          VERTICAL_LINE,
          VERTICAL_AREA,
          VERTICAL_RANGE_AREA,
          RANGE_BAR,
          HORIZONTAL_WATERFALL,
          VERTICAL_BOX_PLOT
        ]
      );
      for (var i = 0; i < series.length; i++) {
        var stack2 = series[i].stack;
        if (stack2 && stack2.type === "100%") {
          this$1.stack100 = true;
          break;
        }
      }
    }
  };
  CategoricalPlotArea2.prototype.render = function render3(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.createCategoryAxes(panes);
    this.aggregateCategories(panes);
    this.createCategoryAxesLabels(panes);
    this.createCharts(panes);
    this.createValueAxes(panes);
  };
  CategoricalPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis instanceof category_axis_default) {
      delete this.namedCategoryAxes[axisName];
    } else {
      this.valueAxisRangeTracker.reset(axisName);
      delete this.namedValueAxes[axisName];
    }
    if (axis === this.categoryAxis) {
      delete this.categoryAxis;
    }
    if (axis === this.valueAxis) {
      delete this.valueAxis;
    }
  };
  CategoricalPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var visibleSeries = this$1.filterVisibleSeries(paneSeries);
      if (!visibleSeries) {
        continue;
      }
      var groups = this$1.groupSeriesByCategoryAxis(visibleSeries);
      for (var groupIx = 0; groupIx < groups.length; groupIx++) {
        this$1.createChartGroup(groups[groupIx], pane);
      }
    }
  };
  CategoricalPlotArea2.prototype.createChartGroup = function createChartGroup(series, pane) {
    this.createAreaChart(
      filterSeriesByType(series, [AREA, VERTICAL_AREA]),
      pane
    );
    this.createRangeAreaChart(
      filterSeriesByType(series, [RANGE_AREA, VERTICAL_RANGE_AREA]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [COLUMN, BAR]),
      pane
    );
    this.createRangeBarChart(
      filterSeriesByType(series, [RANGE_COLUMN, RANGE_BAR]),
      pane
    );
    this.createBulletChart(
      filterSeriesByType(series, [BULLET, VERTICAL_BULLET]),
      pane
    );
    this.createCandlestickChart(
      filterSeriesByType(series, CANDLESTICK),
      pane
    );
    this.createBoxPlotChart(
      filterSeriesByType(series, [BOX_PLOT, VERTICAL_BOX_PLOT]),
      pane
    );
    this.createOHLCChart(
      filterSeriesByType(series, OHLC),
      pane
    );
    this.createWaterfallChart(
      filterSeriesByType(series, [WATERFALL, HORIZONTAL_WATERFALL]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [LINE, VERTICAL_LINE]),
      pane
    );
  };
  CategoricalPlotArea2.prototype.aggregateCategories = function aggregateCategories(panes) {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    var processedSeries = [];
    this._currentPointsCache = {};
    this._seriesPointsCache = this._seriesPointsCache || {};
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var categoryAxis = this$1.seriesCategoryAxis(currentSeries);
      var axisPane = this$1.findPane(categoryAxis.options.pane);
      var dateAxis = equalsIgnoreCase(categoryAxis.options.type, DATE);
      if ((dateAxis || currentSeries.categoryField) && inArray(axisPane, panes)) {
        currentSeries = this$1.aggregateSeries(currentSeries, categoryAxis);
      } else {
        currentSeries = this$1.filterSeries(currentSeries, categoryAxis);
      }
      processedSeries.push(currentSeries);
    }
    this._seriesPointsCache = this._currentPointsCache;
    this._currentPointsCache = null;
    this.srcSeries = series;
    this.series = processedSeries;
  };
  CategoricalPlotArea2.prototype.filterSeries = function filterSeries(series, categoryAxis) {
    var dataLength = (series.data || {}).length;
    categoryAxis._seriesMax = Math.max(categoryAxis._seriesMax || 0, dataLength);
    if (!(isNumber2(categoryAxis.options.min) || isNumber2(categoryAxis.options.max))) {
      return series;
    }
    var range = categoryAxis.currentRangeIndices();
    var outOfRangePoints = inArray(series.type, OUT_OF_RANGE_SERIES);
    var currentSeries = deepExtend({}, series);
    currentSeries.data = (currentSeries.data || []).slice(range.min, range.max + 1);
    if (outOfRangePoints) {
      createOutOfRangePoints(currentSeries, range, dataLength, function(idx) {
        return {
          item: series.data[idx],
          category: categoryAxis.categoryAt(idx, true),
          categoryIx: idx - range.min
        };
      }, function(idx) {
        return defined2(series.data[idx]);
      });
    }
    return currentSeries;
  };
  CategoricalPlotArea2.prototype.clearSeriesPointsCache = function clearSeriesPointsCache() {
    this._seriesPointsCache = {};
  };
  CategoricalPlotArea2.prototype.seriesSourcePoints = function seriesSourcePoints(series, categoryAxis) {
    var this$1 = this;
    var key = series.index + ";" + categoryAxis.categoriesHash();
    if (this._seriesPointsCache[key]) {
      this._currentPointsCache[key] = this._seriesPointsCache[key];
      return this._seriesPointsCache[key];
    }
    var axisOptions2 = categoryAxis.options;
    var srcCategories = axisOptions2.srcCategories;
    var dateAxis = equalsIgnoreCase(axisOptions2.type, DATE);
    var srcData = series.data;
    var getFn = dateAxis ? getDateField : getField;
    var result = [];
    if (!dateAxis) {
      categoryAxis.mapCategories();
    }
    for (var idx = 0; idx < srcData.length; idx++) {
      var category = void 0;
      if (series.categoryField) {
        category = getFn(series.categoryField, srcData[idx], this$1.chartService.intl);
      } else {
        category = srcCategories[idx];
      }
      if (defined2(category) && category !== null) {
        var categoryIx = categoryAxis.totalIndex(category);
        result[categoryIx] = result[categoryIx] || { items: [], category };
        result[categoryIx].items.push(idx);
      }
    }
    this._currentPointsCache[key] = result;
    return result;
  };
  CategoricalPlotArea2.prototype.aggregateSeries = function aggregateSeries(series, categoryAxis) {
    var srcData = series.data;
    if (!srcData.length) {
      return series;
    }
    var srcPoints = this.seriesSourcePoints(series, categoryAxis);
    var result = deepExtend({}, series);
    var aggregator = new series_aggregator_default(deepExtend({}, series), series_binder_default.current, default_aggregates_default.current);
    var data = result.data = [];
    var dataItems = categoryAxis.options.dataItems || [];
    var range = categoryAxis.currentRangeIndices();
    var categoryItem = function(idx2) {
      var categoryIdx = idx2 - range.min;
      var point3 = srcPoints[idx2];
      if (!point3) {
        point3 = srcPoints[idx2] = {};
      }
      point3.categoryIx = categoryIdx;
      if (!point3.item) {
        var category = categoryAxis.categoryAt(idx2, true);
        point3.category = category;
        point3.item = aggregator.aggregatePoints(point3.items, category);
      }
      return point3;
    };
    for (var idx = range.min; idx <= range.max; idx++) {
      var point2 = categoryItem(idx);
      data[point2.categoryIx] = point2.item;
      if (point2.items && point2.items.length) {
        dataItems[point2.categoryIx] = point2.item;
      }
    }
    if (inArray(result.type, OUT_OF_RANGE_SERIES)) {
      createOutOfRangePoints(result, range, categoryAxis.totalCount(), categoryItem, function(idx2) {
        return srcPoints[idx2];
      });
    }
    categoryAxis.options.dataItems = dataItems;
    return result;
  };
  CategoricalPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    var series = chart.options.series;
    var categoryAxis = this.seriesCategoryAxis(series[0]);
    var categories = categoryAxis.options.categories;
    var categoriesToAdd = Math.max(0, categoriesCount(series) - categories.length);
    if (categoriesToAdd > 0) {
      categories = categoryAxis.options.categories = categoryAxis.options.categories.slice(0);
      while (categoriesToAdd--) {
        categories.push("");
      }
    }
    this.valueAxisRangeTracker.update(chart.valueAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  CategoricalPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var axisName = series.axis;
    var axisOptions2 = [].concat(options2.valueAxis);
    var axis = grep(axisOptions2, function(a) {
      return a.name === axisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = (panes[0] || {}).name || "default";
    var paneName = (axis || {}).pane || defaultPaneName;
    return paneName;
  };
  CategoricalPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis(series) {
    var axisName = series.categoryAxis;
    var axis = axisName ? this.namedCategoryAxes[axisName] : this.categoryAxis;
    if (!axis) {
      throw new Error("Unable to locate category axis with name " + axisName);
    }
    return axis;
  };
  CategoricalPlotArea2.prototype.stackableChartOptions = function stackableChartOptions(firstSeries, pane) {
    var stack2 = firstSeries.stack;
    var isStacked100 = stack2 && stack2.type === "100%";
    var clip = pane.options.clip;
    return {
      isStacked: stack2,
      isStacked100,
      clip
    };
  };
  CategoricalPlotArea2.prototype.groupSeriesByCategoryAxis = function groupSeriesByCategoryAxis(series) {
    var categoryAxes = [];
    var unique = {};
    for (var idx = 0; idx < series.length; idx++) {
      var name3 = series[idx].categoryAxis || "$$default$$";
      if (!unique.hasOwnProperty(name3)) {
        unique[name3] = true;
        categoryAxes.push(name3);
      }
    }
    var groups = [];
    for (var axisIx = 0; axisIx < categoryAxes.length; axisIx++) {
      var axis = categoryAxes[axisIx];
      var axisSeries = groupSeries(series, axis, axisIx);
      if (axisSeries.length === 0) {
        continue;
      }
      groups.push(axisSeries);
    }
    return groups;
  };
  CategoricalPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var barChart = new bar_chart_default(this, Object.assign({
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(barChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeBarChart = function createRangeBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var rangeColumnChart = new range_bar_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(rangeColumnChart, pane);
  };
  CategoricalPlotArea2.prototype.createBulletChart = function createBulletChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var bulletChart = new bullet_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(bulletChart, pane);
  };
  CategoricalPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var lineChart = new line_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(lineChart, pane);
  };
  CategoricalPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var areaChart = new area_chart_default(this, Object.assign({
      invertAxes: this.invertAxes,
      series
    }, this.stackableChartOptions(firstSeries, pane)));
    this.appendChart(areaChart, pane);
  };
  CategoricalPlotArea2.prototype.createRangeAreaChart = function createRangeAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var rangeAreaChart = new range_area_chart_default(this, {
      invertAxes: this.invertAxes,
      series,
      clip: pane.options.clip
    });
    this.appendChart(rangeAreaChart, pane);
  };
  CategoricalPlotArea2.prototype.createOHLCChart = function createOHLCChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new ohlc_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createCandlestickChart = function createCandlestickChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new candlestick_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createBoxPlotChart = function createBoxPlotChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var chart = new box_plot_chart_default(this, {
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      series,
      spacing: firstSeries.spacing,
      clip: pane.options.clip
    });
    this.appendChart(chart, pane);
  };
  CategoricalPlotArea2.prototype.createWaterfallChart = function createWaterfallChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var waterfallChart = new waterfall_chart_default(this, {
      series,
      invertAxes: this.invertAxes,
      gap: firstSeries.gap,
      spacing: firstSeries.spacing
    });
    this.appendChart(waterfallChart, pane);
  };
  CategoricalPlotArea2.prototype.axisRequiresRounding = function axisRequiresRounding(categoryAxisName, categoryAxisIndex) {
    var this$1 = this;
    var centeredSeries = filterSeriesByType(this.series, EQUALLY_SPACED_SERIES);
    for (var seriesIx = 0; seriesIx < this.series.length; seriesIx++) {
      var currentSeries = this$1.series[seriesIx];
      if (inArray(currentSeries.type, AREA_SERIES)) {
        var line = currentSeries.line;
        if (line && line.style === STEP) {
          centeredSeries.push(currentSeries);
        }
      }
    }
    for (var seriesIx$1 = 0; seriesIx$1 < centeredSeries.length; seriesIx$1++) {
      var seriesAxis = centeredSeries[seriesIx$1].categoryAxis || "";
      if (seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.aggregatedAxis = function aggregatedAxis(categoryAxisName, categoryAxisIndex) {
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var seriesAxis = series[seriesIx].categoryAxis || "";
      if ((seriesAxis === categoryAxisName || !seriesAxis && categoryAxisIndex === 0) && series[seriesIx].categoryField) {
        return true;
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      if (axes[i] instanceof category_axis_default) {
        axes[i].createLabels();
      }
    }
  };
  CategoricalPlotArea2.prototype.createCategoryAxes = function createCategoryAxes(panes) {
    var this$1 = this;
    var invertAxes = this.invertAxes;
    var definitions = [].concat(this.options.categoryAxis);
    var axes = [];
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name3 = axisOptions2.name;
        var categories = axisOptions2.categories;
        if (categories === void 0)
          categories = [];
        axisOptions2 = deepExtend({
          vertical: invertAxes,
          reverse: !invertAxes && this$1.chartService.rtl,
          axisCrossingValue: invertAxes ? MAX_VALUE : 0
        }, axisOptions2);
        if (!defined2(axisOptions2.justified)) {
          axisOptions2.justified = this$1.isJustified();
        }
        if (this$1.axisRequiresRounding(name3, i)) {
          axisOptions2.justified = false;
        }
        var categoryAxis = void 0;
        if (isDateAxis(axisOptions2, categories[0])) {
          categoryAxis = new date_category_axis_default(axisOptions2, this$1.chartService);
        } else {
          categoryAxis = new category_axis_default(axisOptions2, this$1.chartService);
        }
        definitions[i].categories = categoryAxis.options.srcCategories;
        if (name3) {
          if (this$1.namedCategoryAxes[name3]) {
            throw new Error("Category axis with name " + name3 + " is already defined");
          }
          this$1.namedCategoryAxes[name3] = categoryAxis;
        }
        categoryAxis.axisIndex = i;
        axes.push(categoryAxis);
        this$1.appendAxis(categoryAxis);
      }
    }
    var primaryAxis = this.categoryAxis || axes[0];
    this.categoryAxis = primaryAxis;
    if (invertAxes) {
      this.axisY = primaryAxis;
    } else {
      this.axisX = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype.isJustified = function isJustified() {
    var series = this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      if (!inArray(currentSeries.type, AREA_SERIES)) {
        return false;
      }
    }
    return true;
  };
  CategoricalPlotArea2.prototype.createValueAxes = function createValueAxes(panes) {
    var this$1 = this;
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var definitions = [].concat(this.options.valueAxis);
    var invertAxes = this.invertAxes;
    var baseOptions = { vertical: !invertAxes, reverse: invertAxes && this.chartService.rtl };
    var axes = [];
    if (this.stack100) {
      baseOptions.roundToMajorUnit = false;
      baseOptions.labels = { format: "P0" };
    }
    for (var i = 0; i < definitions.length; i++) {
      var axisOptions2 = definitions[i];
      var axisPane = this$1.findPane(axisOptions2.pane);
      if (inArray(axisPane, panes)) {
        var name3 = axisOptions2.name;
        var defaultAxisRange = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC) ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
        var range = tracker.query(name3) || defaultRange || defaultAxisRange;
        if (i === 0 && range && defaultRange) {
          range.min = Math.min(range.min, defaultRange.min);
          range.max = Math.max(range.max, defaultRange.max);
        }
        var axisType = void 0;
        if (equalsIgnoreCase(axisOptions2.type, LOGARITHMIC)) {
          axisType = logarithmic_axis_default;
        } else {
          axisType = numeric_axis_default;
        }
        var valueAxis = new axisType(
          range.min,
          range.max,
          deepExtend({}, baseOptions, axisOptions2),
          this$1.chartService
        );
        if (name3) {
          if (this$1.namedValueAxes[name3]) {
            throw new Error("Value axis with name " + name3 + " is already defined");
          }
          this$1.namedValueAxes[name3] = valueAxis;
        }
        valueAxis.axisIndex = i;
        axes.push(valueAxis);
        this$1.appendAxis(valueAxis);
      }
    }
    var primaryAxis = this.valueAxis || axes[0];
    this.valueAxis = primaryAxis;
    if (invertAxes) {
      this.axisX = primaryAxis;
    } else {
      this.axisY = primaryAxis;
    }
  };
  CategoricalPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var pane = this.pointPane(point2);
    var categories = [];
    var values5 = [];
    if (!pane) {
      return;
    }
    var allAxes = pane.axes;
    for (var i = 0; i < allAxes.length; i++) {
      var axis = allAxes[i];
      if (axis.getValue) {
        appendIfNotNull(values5, axis.getValue(point2));
      } else {
        appendIfNotNull(categories, axis.getCategory(point2));
      }
    }
    if (categories.length === 0) {
      appendIfNotNull(categories, this.categoryAxis.getCategory(point2));
    }
    if (categories.length > 0 && values5.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        category: singleItemOrArray(categories),
        value: singleItemOrArray(values5)
      });
    }
  };
  CategoricalPlotArea2.prototype.pointPane = function pointPane(point2) {
    var panes = this.panes;
    for (var i = 0; i < panes.length; i++) {
      var currentPane = panes[i];
      if (currentPane.contentBox.containsPoint(point2)) {
        return currentPane;
      }
    }
  };
  CategoricalPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    updateAxisOptions(this.options, axis, options2);
    updateAxisOptions(this.originalOptions, axis, options2);
  };
  return CategoricalPlotArea2;
}(plotarea_base_default);
function updateAxisOptions(targetOptions, axis, options2) {
  var axesOptions = axis instanceof category_axis_default ? [].concat(targetOptions.categoryAxis) : [].concat(targetOptions.valueAxis);
  deepExtend(axesOptions[axis.axisIndex], options2);
}
function groupSeries(series, axis, axisIx) {
  return grep(series, function(s) {
    return axisIx === 0 && !s.categoryAxis || s.categoryAxis === axis;
  });
}
setDefaultOptions(CategoricalPlotArea, {
  categoryAxis: {},
  valueAxis: {}
});
deepExtend(CategoricalPlotArea.prototype, plotarea_events_mixin_default);
var categorical_plotarea_default = CategoricalPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/highlight.js
var Highlight = function(Class3) {
  function Highlight2() {
    Class3.call(this);
    this._points = [];
  }
  if (Class3)
    Highlight2.__proto__ = Class3;
  Highlight2.prototype = Object.create(Class3 && Class3.prototype);
  Highlight2.prototype.constructor = Highlight2;
  Highlight2.prototype.destroy = function destroy2() {
    this._points = [];
  };
  Highlight2.prototype.show = function show2(points3, opacity) {
    var this$1 = this;
    var arrayPoints = [].concat(points3);
    this.hide();
    for (var i = 0; i < arrayPoints.length; i++) {
      var point2 = arrayPoints[i];
      if (point2 && point2.toggleHighlight && point2.hasHighlight()) {
        this$1.togglePointHighlight(point2, true, opacity);
        this$1._points.push(point2);
      }
    }
  };
  Highlight2.prototype.togglePointHighlight = function togglePointHighlight(point2, show2, opacity) {
    var toggleHandler = (point2.options.highlight || {}).toggle;
    if (toggleHandler) {
      var eventArgs = {
        category: point2.category,
        series: point2.series,
        dataItem: point2.dataItem,
        value: point2.value,
        stackValue: point2.stackValue,
        preventDefault: preventDefault2,
        visual: point2.highlightVisual(),
        show: show2
      };
      toggleHandler(eventArgs);
      if (!eventArgs._defaultPrevented) {
        point2.toggleHighlight(show2, opacity);
      }
    } else {
      point2.toggleHighlight(show2, opacity);
    }
  };
  Highlight2.prototype.hide = function hide2() {
    var this$1 = this;
    var points3 = this._points;
    while (points3.length) {
      this$1.togglePointHighlight(points3.pop(), false);
    }
  };
  Highlight2.prototype.isHighlighted = function isHighlighted(element) {
    var points3 = this._points;
    for (var i = 0; i < points3.length; i++) {
      var point2 = points3[i];
      if (element === point2) {
        return true;
      }
    }
    return false;
  };
  return Highlight2;
}(class_default);
function preventDefault2() {
  this._defaultPrevented = true;
}
var highlight_default = Highlight;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/accept-key.js
function acceptKey(e, mouseKey) {
  var key = (mouseKey || "").toLowerCase();
  var event = e.event;
  var accept = key === "none" && !(event.ctrlKey || event.shiftKey || event.altKey) || event[key + "Key"];
  return accept;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/to-chart-axis-ranges.js
function toChartAxisRanges(axisRanges2) {
  var ranges = {};
  for (var idx = 0; idx < axisRanges2.length; idx++) {
    var axisRange = axisRanges2[idx];
    if (axisRange.axis.options.name) {
      ranges[axisRange.axis.options.name] = {
        min: axisRange.range.min,
        max: axisRange.range.max
      };
    }
  }
  return ranges;
}

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/pannable.js
var Pannable = function(Class3) {
  function Pannable2(plotArea, options2) {
    Class3.call(this);
    this.plotArea = plotArea;
    this.options = deepExtend({}, this.options, options2);
  }
  if (Class3)
    Pannable2.__proto__ = Class3;
  Pannable2.prototype = Object.create(Class3 && Class3.prototype);
  Pannable2.prototype.constructor = Pannable2;
  Pannable2.prototype.start = function start(e) {
    this._active = acceptKey(e, this.options.key);
    return this._active;
  };
  Pannable2.prototype.move = function move(e) {
    if (this._active) {
      var axisRanges2 = this.axisRanges = this._panAxes(e, X).concat(this._panAxes(e, Y));
      if (axisRanges2.length) {
        this.axisRanges = axisRanges2;
        return toChartAxisRanges(axisRanges2);
      }
    }
  };
  Pannable2.prototype.end = function end() {
    var active = this._active;
    this._active = false;
    return active;
  };
  Pannable2.prototype.pan = function pan() {
    var ref2 = this;
    var plotArea = ref2.plotArea;
    var axisRanges2 = ref2.axisRanges;
    if (axisRanges2.length) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var range = axisRanges2[idx];
        plotArea.updateAxisOptions(range.axis, range.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  Pannable2.prototype.destroy = function destroy2() {
    delete this.plotArea;
  };
  Pannable2.prototype._panAxes = function _panAxes(e, position) {
    var plotArea = this.plotArea;
    var delta = -e[position].delta;
    var lock = (this.options.lock || "").toLowerCase();
    var updatedAxes = [];
    if (delta !== 0 && (lock || "").toLowerCase() !== position) {
      var axes = plotArea.axes;
      for (var idx = 0; idx < axes.length; idx++) {
        var axis = axes[idx];
        if (position === X && !axis.options.vertical || position === Y && axis.options.vertical) {
          var range = axis.pan(delta);
          if (range) {
            range.limitRange = true;
            updatedAxes.push({
              axis,
              range
            });
          }
        }
      }
    }
    return updatedAxes;
  };
  return Pannable2;
}(class_default);
Pannable.prototype.options = {
  key: "none",
  lock: "none"
};
var pannable_default = Pannable;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/zoom-selection.js
var ZoomSelection = function(Class3) {
  function ZoomSelection2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({}, this.options, options2);
    this.createElement();
  }
  if (Class3)
    ZoomSelection2.__proto__ = Class3;
  ZoomSelection2.prototype = Object.create(Class3 && Class3.prototype);
  ZoomSelection2.prototype.constructor = ZoomSelection2;
  ZoomSelection2.prototype.createElement = function createElement15() {
    var marquee = this._marquee = document.createElement("div");
    marquee.className = "k-marquee";
    var marqueeColor = document.createElement("div");
    marqueeColor.className = "k-marquee-color";
    marquee.appendChild(marqueeColor);
  };
  ZoomSelection2.prototype.removeElement = function removeElement() {
    if (this._marquee.parentNode) {
      this._marquee.parentNode.removeChild(this._marquee);
    }
  };
  ZoomSelection2.prototype.setStyles = function setStyles(styles) {
    elementStyles2(this._marquee, styles);
  };
  ZoomSelection2.prototype.start = function start(e) {
    if (acceptKey(e, this.options.key)) {
      var chart = this.chart;
      var point2 = chart._eventCoordinates(e);
      var zoomPane = this._zoomPane = chart._plotArea.paneByPoint(point2);
      var clipBox = zoomPane ? zoomPane.chartsBox().clone() : null;
      if (zoomPane && clipBox) {
        var offset = this._elementOffset();
        clipBox.translate(offset.left, offset.top);
        this._zoomPaneClipBox = clipBox;
        document.body.appendChild(this._marquee);
        this.setStyles({
          left: e.pageX + 1,
          top: e.pageY + 1,
          width: 0,
          height: 0
        });
        return true;
      }
    }
    return false;
  };
  ZoomSelection2.prototype._elementOffset = function _elementOffset() {
    var chartElement = this.chart.element;
    var ref2 = elementStyles2(chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref2.paddingLeft;
    var paddingTop = ref2.paddingTop;
    var offset = elementOffset2(chartElement);
    return {
      left: paddingLeft + offset.left,
      top: paddingTop + offset.top
    };
  };
  ZoomSelection2.prototype.move = function move(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      this.setStyles(this._selectionPosition(e));
    }
  };
  ZoomSelection2.prototype.end = function end(e) {
    var zoomPane = this._zoomPane;
    if (zoomPane) {
      var elementOffset3 = this._elementOffset();
      var selectionPosition = this._selectionPosition(e);
      selectionPosition.left -= elementOffset3.left;
      selectionPosition.top -= elementOffset3.top;
      var start = { x: selectionPosition.left, y: selectionPosition.top };
      var end2 = { x: selectionPosition.left + selectionPosition.width, y: selectionPosition.top + selectionPosition.height };
      this._updateAxisRanges(start, end2);
      this.removeElement();
      delete this._zoomPane;
      return toChartAxisRanges(this.axisRanges);
    }
  };
  ZoomSelection2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    if (axisRanges2 && axisRanges2.length) {
      var plotArea = this.chart._plotArea;
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  ZoomSelection2.prototype.destroy = function destroy2() {
    this.removeElement();
    delete this._marquee;
    delete this.chart;
  };
  ZoomSelection2.prototype._updateAxisRanges = function _updateAxisRanges(start, end) {
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this._zoomPane.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && defined2(axis.axisIndex)) {
        var range = axis.pointsRange(start, end);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
  };
  ZoomSelection2.prototype._selectionPosition = function _selectionPosition(e) {
    var clipBox = this._zoomPaneClipBox;
    var startLocation = {
      x: e.x.startLocation,
      y: e.y.startLocation
    };
    var pageX = e.x.location;
    var pageY = e.y.location;
    var lock = (this.options.lock || "").toLowerCase();
    var left = Math.min(startLocation.x, pageX);
    var top = Math.min(startLocation.y, pageY);
    var width = Math.abs(startLocation.x - pageX);
    var height = Math.abs(startLocation.y - pageY);
    if (lock === X) {
      left = clipBox.x1;
      width = clipBox.width();
    }
    if (lock === Y) {
      top = clipBox.y1;
      height = clipBox.height();
    }
    if (pageX > clipBox.x2) {
      width = clipBox.x2 - startLocation.x;
    }
    if (pageX < clipBox.x1) {
      width = startLocation.x - clipBox.x1;
    }
    if (pageY > clipBox.y2) {
      height = clipBox.y2 - startLocation.y;
    }
    if (pageY < clipBox.y1) {
      height = startLocation.y - clipBox.y1;
    }
    return {
      left: Math.max(left, clipBox.x1),
      top: Math.max(top, clipBox.y1),
      width,
      height
    };
  };
  return ZoomSelection2;
}(class_default);
ZoomSelection.prototype.options = {
  key: "shift",
  lock: "none"
};
var zoom_selection_default = ZoomSelection;

// node_modules/@progress/kendo-charts/dist/es/chart/pan-and-zoom/mousewheel-zoom.js
var MIN_RATE = 0.01;
var MAX_RATE = 0.9;
var DEFAULT_RATE = 0.3;
var MousewheelZoom = function(Class3) {
  function MousewheelZoom2(chart, options2) {
    Class3.call(this);
    this.chart = chart;
    this.options = deepExtend({
      rate: DEFAULT_RATE
    }, this.options, options2);
  }
  if (Class3)
    MousewheelZoom2.__proto__ = Class3;
  MousewheelZoom2.prototype = Object.create(Class3 && Class3.prototype);
  MousewheelZoom2.prototype.constructor = MousewheelZoom2;
  MousewheelZoom2.prototype.updateRanges = function updateRanges(delta, coords) {
    var this$1 = this;
    var lock = (this.options.lock || "").toLowerCase();
    var axisRanges2 = [];
    var axes = this.chart._plotArea.axes;
    for (var idx = 0; idx < axes.length; idx++) {
      var axis = axes[idx];
      var vertical = axis.options.vertical;
      if (!(lock === X && !vertical) && !(lock === Y && vertical) && axis.zoomRange) {
        var rate = limitValue2(this$1.options.rate, MIN_RATE, MAX_RATE);
        var range = axis.zoomRange(-delta * rate, coords);
        if (range) {
          axisRanges2.push({
            axis,
            range
          });
        }
      }
    }
    this.axisRanges = axisRanges2;
    return toChartAxisRanges(axisRanges2);
  };
  MousewheelZoom2.prototype.zoom = function zoom() {
    var axisRanges2 = this.axisRanges;
    var plotArea = this.chart._plotArea;
    if (axisRanges2 && axisRanges2.length && plotArea.updateAxisOptions) {
      for (var idx = 0; idx < axisRanges2.length; idx++) {
        var axisRange = axisRanges2[idx];
        plotArea.updateAxisOptions(axisRange.axis, axisRange.range);
      }
      plotArea.redraw(plotArea.panes);
    }
  };
  MousewheelZoom2.prototype.destroy = function destroy2() {
    delete this.chart;
  };
  return MousewheelZoom2;
}(class_default);
var mousewheel_zoom_default = MousewheelZoom;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-layout.js
var LegendLayout = function(ChartElement2) {
  function LegendLayout2(options2, chartService) {
    ChartElement2.call(this, options2);
    this.chartService = chartService;
  }
  if (ChartElement2)
    LegendLayout2.__proto__ = ChartElement2;
  LegendLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  LegendLayout2.prototype.constructor = LegendLayout2;
  LegendLayout2.prototype.render = function render3() {
    var ref2 = this;
    var children = ref2.children;
    var options2 = ref2.options;
    var vertical = options2.vertical;
    this.visual = new drawing_exports.Layout(null, {
      spacing: vertical ? 0 : options2.spacing,
      lineSpacing: vertical ? options2.spacing : 0,
      orientation: vertical ? "vertical" : "horizontal",
      reverse: options2.rtl,
      alignItems: vertical ? "start" : "center"
    });
    for (var idx = 0; idx < children.length; idx++) {
      var legendItem = children[idx];
      legendItem.reflow(new box_default());
      legendItem.renderVisual();
    }
  };
  LegendLayout2.prototype.reflow = function reflow(box) {
    this.visual.rect(box.toRect());
    this.visual.reflow();
    var bbox = this.visual.clippedBBox();
    if (bbox) {
      this.box = rectToBox(bbox);
    } else {
      this.box = new box_default();
    }
  };
  LegendLayout2.prototype.renderVisual = function renderVisual() {
    this.addVisual();
  };
  LegendLayout2.prototype.createVisual = function createVisual() {
  };
  return LegendLayout2;
}(chart_element_default);
var legend_layout_default = LegendLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend-item.js
var LegendItem = function(BoxElement2) {
  function LegendItem2(options2) {
    BoxElement2.call(this, options2);
    this.createContainer();
    if (!options2.rtl) {
      this.createMarker();
      this.createLabel();
    } else {
      this.createLabel();
      this.createMarker();
    }
  }
  if (BoxElement2)
    LegendItem2.__proto__ = BoxElement2;
  LegendItem2.prototype = Object.create(BoxElement2 && BoxElement2.prototype);
  LegendItem2.prototype.constructor = LegendItem2;
  LegendItem2.prototype.createContainer = function createContainer() {
    this.container = new float_element_default({ vertical: false, wrap: false, align: CENTER, spacing: this.options.spacing });
    this.append(this.container);
  };
  LegendItem2.prototype.createMarker = function createMarker() {
    this.container.append(new shape_element_default(this.markerOptions()));
  };
  LegendItem2.prototype.markerOptions = function markerOptions() {
    var options2 = this.options;
    var markerColor = options2.markerColor;
    return deepExtend({}, options2.markers, {
      background: markerColor,
      border: {
        color: markerColor
      }
    });
  };
  LegendItem2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labelOptions = deepExtend({}, options2.labels);
    this.container.append(new text_box_default(options2.text, labelOptions));
  };
  LegendItem2.prototype.renderComplete = function renderComplete() {
    BoxElement2.prototype.renderComplete.call(this);
    var cursor = this.options.cursor || {};
    var eventSink = this._itemOverlay = drawing_exports.Path.fromRect(this.container.box.toRect(), {
      fill: {
        color: WHITE,
        opacity: 0
      },
      stroke: null,
      cursor: cursor.style || cursor
    });
    this.appendVisual(eventSink);
  };
  LegendItem2.prototype.click = function click(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_CLICK, args) && e && e.type === "contextmenu") {
      e.preventDefault();
    }
  };
  LegendItem2.prototype.over = function over(widget, e) {
    var args = this.eventArgs(e);
    if (!widget.trigger(LEGEND_ITEM_HOVER, args)) {
      widget._legendItemHover(args.seriesIndex, args.pointIndex);
    }
    return true;
  };
  LegendItem2.prototype.out = function out(widget, e) {
    widget._unsetActivePoint();
    widget.trigger(LEGEND_ITEM_LEAVE, this.eventArgs(e));
  };
  LegendItem2.prototype.eventArgs = function eventArgs(e) {
    var options2 = this.options;
    return {
      element: eventElement2(e),
      text: options2.text,
      series: options2.series,
      seriesIndex: options2.series.index,
      pointIndex: options2.pointIndex
    };
  };
  LegendItem2.prototype.renderVisual = function renderVisual() {
    var this$1 = this;
    var options2 = this.options;
    var customVisual = options2.visual;
    if (customVisual) {
      this.visual = customVisual({
        active: options2.active,
        series: options2.series,
        sender: this.getSender(),
        pointIndex: options2.pointIndex,
        options: {
          markers: this.markerOptions(),
          labels: options2.labels
        },
        createVisual: function() {
          this$1.createVisual();
          this$1.renderChildren();
          this$1.renderComplete();
          var defaultVisual = this$1.visual;
          delete this$1.visual;
          return defaultVisual;
        }
      });
      this.addVisual();
    } else {
      BoxElement2.prototype.renderVisual.call(this);
    }
  };
  return LegendItem2;
}(box_element_default);
var legend_item_default = LegendItem;

// node_modules/@progress/kendo-charts/dist/es/chart/legend/legend.js
var HORIZONTAL = "horizontal";
var POINTER = "pointer";
var CUSTOM = "custom";
var Legend = function(ChartElement2) {
  function Legend2(options2, chartService) {
    if (chartService === void 0)
      chartService = {};
    ChartElement2.call(this, options2);
    this.chartService = chartService;
    if (!inArray(this.options.position, [TOP, RIGHT, BOTTOM, LEFT, CUSTOM])) {
      this.options.position = RIGHT;
    }
    this.createContainers();
    this.createLegendTitle(options2.title);
    this.createItems();
  }
  if (ChartElement2)
    Legend2.__proto__ = ChartElement2;
  Legend2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  Legend2.prototype.constructor = Legend2;
  Legend2.prototype.createContainers = function createContainers() {
    var options2 = this.options;
    var position = options2.position;
    var userAlign = options2.align;
    var align2 = position;
    var vAlign2 = CENTER;
    if (position === CUSTOM) {
      align2 = LEFT;
    } else if (inArray(position, [TOP, BOTTOM])) {
      if (userAlign === "start") {
        align2 = LEFT;
      } else if (userAlign === "end") {
        align2 = RIGHT;
      } else {
        align2 = CENTER;
      }
      vAlign2 = position;
    } else if (userAlign) {
      if (userAlign === "start") {
        vAlign2 = TOP;
      } else if (userAlign === "end") {
        vAlign2 = BOTTOM;
      }
    }
    this.container = new box_element_default({
      margin: options2.margin,
      padding: options2.padding,
      background: options2.background,
      border: options2.border,
      vAlign: vAlign2,
      align: align2,
      zIndex: options2.zIndex,
      shrinkToFit: true
    });
    if (this.hasTitle()) {
      this.itemsContainer = new box_element_default({
        vAlign: vAlign2,
        align: align2,
        zIndex: options2.zIndex,
        shrinkToFit: true
      });
    } else {
      this.itemsContainer = this.container;
    }
    this.append(this.container);
  };
  Legend2.prototype.createItems = function createItems() {
    var chartService = this.getService();
    var options2 = this.options;
    var vertical = this.isVertical();
    var innerElement = new legend_layout_default({
      vertical,
      spacing: options2.spacing,
      rtl: chartService.rtl
    }, chartService);
    var items = options2.items;
    if (options2.reverse) {
      items = items.slice(0).reverse();
    }
    var count = items.length;
    for (var i = 0; i < count; i++) {
      var item = items[i];
      innerElement.append(new legend_item_default(deepExtend({}, {
        markers: options2.markers,
        labels: options2.labels,
        rtl: chartService.rtl
      }, options2.item, item)));
    }
    innerElement.render();
    this.itemsContainer.append(innerElement);
  };
  Legend2.prototype.isVertical = function isVertical() {
    var ref2 = this.options;
    var orientation = ref2.orientation;
    var position = ref2.position;
    var vertical = position === CUSTOM && orientation !== HORIZONTAL || (defined2(orientation) ? orientation !== HORIZONTAL : inArray(position, [LEFT, RIGHT]));
    return vertical;
  };
  Legend2.prototype.hasItems = function hasItems() {
    return this.container.children[0].children.length > 0;
  };
  Legend2.prototype.reflow = function reflow(targetBox) {
    var options2 = this.options;
    var legendBox = targetBox.clone();
    if (!this.hasItems()) {
      this.box = legendBox;
      return;
    }
    if (options2.position === CUSTOM) {
      this.containerCustomReflow(legendBox);
      this.box = legendBox;
    } else {
      this.containerReflow(legendBox);
    }
    if (this.hasTitle()) {
      this.title.reflow(new box_default(this.container.box.x1, this.title.box.y1, this.container.box.x2, this.title.box.y2));
    }
  };
  Legend2.prototype.containerReflow = function containerReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var position = options2.position;
    var width = options2.width;
    var height = options2.height;
    var pos = position === TOP || position === BOTTOM ? X : Y;
    var vertical = this.isVertical();
    var alignTarget = targetBox.clone();
    var containerBox = targetBox.clone();
    if (position === LEFT || position === RIGHT) {
      containerBox.y1 = alignTarget.y1 = 0;
    }
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
      containerBox.align(alignTarget, Y, container.options.vAlign);
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
      containerBox.align(alignTarget, X, container.options.align);
    }
    container.reflow(containerBox);
    containerBox = container.box;
    var box = containerBox.clone();
    if (options2.offsetX || options2.offsetY) {
      containerBox.translate(options2.offsetX, options2.offsetY);
      container.reflow(containerBox);
    }
    box[pos + 1] = targetBox[pos + 1];
    box[pos + 2] = targetBox[pos + 2];
    this.box = box;
  };
  Legend2.prototype.containerCustomReflow = function containerCustomReflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var container = ref2.container;
    var offsetX = options2.offsetX;
    var offsetY = options2.offsetY;
    var width = options2.width;
    var height = options2.height;
    var vertical = this.isVertical();
    var containerBox = targetBox.clone();
    if (vertical && height) {
      containerBox.y2 = containerBox.y1 + height;
    } else if (!vertical && width) {
      containerBox.x2 = containerBox.x1 + width;
    }
    container.reflow(containerBox);
    containerBox = container.box;
    container.reflow(new box_default(
      offsetX,
      offsetY,
      offsetX + containerBox.width(),
      offsetY + containerBox.height()
    ));
  };
  Legend2.prototype.renderVisual = function renderVisual() {
    if (this.hasItems()) {
      ChartElement2.prototype.renderVisual.call(this);
    }
  };
  Legend2.prototype.createLegendTitle = function createLegendTitle(title2) {
    var titleOptions = deepExtend({}, {
      color: BLACK,
      position: TOP,
      align: CENTER
    }, title2);
    var text = titleOptions.text;
    if (!title2 || title2.visible === false) {
      return;
    }
    if (defined2(titleOptions) && titleOptions.visible) {
      var labelTemplate = getTemplate(titleOptions);
      if (labelTemplate) {
        text = labelTemplate({ text });
      } else if (titleOptions.format) {
        text = this.chartService.format.auto(titleOptions.format, text);
      }
    }
    this.title = new text_box_default(text, titleOptions);
    this.createTitleLayout();
    this.appendTitleLayoutContent();
  };
  Legend2.prototype.createTitleLayout = function createTitleLayout() {
    this.layout = new float_element_default({
      vertical: true,
      wrap: false
    });
    this.container.append(this.layout);
  };
  Legend2.prototype.hasTitle = function hasTitle() {
    return Boolean(this.options.title && this.options.title.visible !== false);
  };
  Legend2.prototype.appendTitleLayoutContent = function appendTitleLayoutContent() {
    var options2 = this.options;
    if (options2.title.position === BOTTOM) {
      this.layout.append(this.itemsContainer);
      this.layout.append(this.title);
    } else {
      this.layout.append(this.title);
      this.layout.append(this.itemsContainer);
    }
  };
  return Legend2;
}(chart_element_default);
setDefaultOptions(Legend, {
  position: RIGHT,
  items: [],
  offsetX: 0,
  offsetY: 0,
  margin: getSpacing(5),
  padding: getSpacing(5),
  border: {
    color: BLACK,
    width: 0
  },
  item: {
    cursor: POINTER,
    spacing: 6
  },
  spacing: 6,
  background: "",
  zIndex: 1,
  markers: {
    border: {
      width: 0
    },
    width: 15,
    height: 3,
    type: "rect",
    align: LEFT,
    vAlign: CENTER
  }
});
var legend_default = Legend;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/plotarea-factory.js
var PlotAreaFactory = function(Class3) {
  function PlotAreaFactory2() {
    Class3.call(this);
    this._registry = [];
  }
  if (Class3)
    PlotAreaFactory2.__proto__ = Class3;
  PlotAreaFactory2.prototype = Object.create(Class3 && Class3.prototype);
  PlotAreaFactory2.prototype.constructor = PlotAreaFactory2;
  PlotAreaFactory2.prototype.register = function register4(type, seriesTypes) {
    this._registry.push({
      type,
      seriesTypes
    });
  };
  PlotAreaFactory2.prototype.create = function create2(srcSeries, options2, chartService) {
    var registry = this._registry;
    var match = registry[0];
    var series;
    for (var idx = 0; idx < registry.length; idx++) {
      var entry = registry[idx];
      series = filterSeriesByType(srcSeries, entry.seriesTypes);
      if (series.length > 0) {
        match = entry;
        break;
      }
    }
    return new match.type(series, options2, chartService);
  };
  return PlotAreaFactory2;
}(class_default);
PlotAreaFactory.current = new PlotAreaFactory();
var plotarea_factory_default = PlotAreaFactory;

// node_modules/@progress/kendo-charts/dist/es/chart/selection.js
var ZOOM_ACCELERATION = 3;
var SELECTOR_HEIGHT_ADJUST = 0.1;
function createDiv(className) {
  var element = document.createElement("div");
  if (className) {
    element.className = className;
  }
  return element;
}
function closestHandle(element) {
  var current4 = element;
  while (current4 && !hasClasses(current4, "k-handle")) {
    current4 = current4.parentNode;
  }
  return current4;
}
var Selection = function(Class3) {
  function Selection2(chart, categoryAxis, options2, observer) {
    Class3.call(this);
    var chartElement = chart.element;
    this.options = deepExtend({}, this.options, options2);
    this.chart = chart;
    this.observer = observer;
    this.chartElement = chartElement;
    this.categoryAxis = categoryAxis;
    this._dateAxis = this.categoryAxis instanceof date_category_axis_default;
    this.initOptions();
    this.visible = this.options.visible && chartElement.offsetHeight;
    if (this.visible) {
      this.createElements();
      this.set(this._index(this.options.from), this._index(this.options.to));
      this.bindEvents();
    }
  }
  if (Class3)
    Selection2.__proto__ = Class3;
  Selection2.prototype = Object.create(Class3 && Class3.prototype);
  Selection2.prototype.constructor = Selection2;
  Selection2.prototype.onPane = function onPane(pane) {
    return this.categoryAxis.pane === pane;
  };
  Selection2.prototype.createElements = function createElements() {
    var options2 = this.options;
    var wrapper = this.wrapper = createDiv("k-selector");
    elementStyles2(wrapper, {
      top: options2.offset.top,
      left: options2.offset.left,
      width: options2.width,
      height: options2.height,
      direction: "ltr"
    });
    var selection = this.selection = createDiv("k-selection");
    this.leftMask = createDiv("k-mask");
    this.rightMask = createDiv("k-mask");
    wrapper.appendChild(this.leftMask);
    wrapper.appendChild(this.rightMask);
    wrapper.appendChild(selection);
    selection.appendChild(createDiv("k-selection-bg"));
    var leftHandle = this.leftHandle = createDiv("k-handle k-left-handle");
    var rightHandle = this.rightHandle = createDiv("k-handle k-right-handle");
    leftHandle.appendChild(createDiv());
    rightHandle.appendChild(createDiv());
    selection.appendChild(leftHandle);
    selection.appendChild(rightHandle);
    this.chartElement.appendChild(wrapper);
    var selectionStyles = elementStyles2(selection, ["borderLeftWidth", "borderRightWidth", "height"]);
    var leftHandleHeight = elementStyles2(leftHandle, "height").height;
    var rightHandleHeight = elementStyles2(rightHandle, "height").height;
    options2.selection = {
      border: {
        left: selectionStyles.borderLeftWidth,
        right: selectionStyles.borderRightWidth
      }
    };
    elementStyles2(leftHandle, {
      top: (selectionStyles.height - leftHandleHeight) / 2
    });
    elementStyles2(rightHandle, {
      top: (selectionStyles.height - rightHandleHeight) / 2
    });
    wrapper.style.cssText = wrapper.style.cssText;
  };
  Selection2.prototype.bindEvents = function bindEvents$1() {
    var obj;
    if (this.options.mousewheel !== false) {
      this._mousewheelHandler = this._mousewheel.bind(this);
      bindEvents2(this.wrapper, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
    }
    this._domEvents = dom_events_builder_default.create(this.wrapper, {
      stopPropagation: true,
      // applicable for the jQuery UserEvents
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      press: this._press.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
  };
  Selection2.prototype.initOptions = function initOptions() {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var box = categoryAxis.pane.chartsBox();
    var intlService = this.chart.chartService.intl;
    if (this._dateAxis) {
      deepExtend(options2, {
        min: parseDate3(intlService, options2.min),
        max: parseDate3(intlService, options2.max),
        from: parseDate3(intlService, options2.from),
        to: parseDate3(intlService, options2.to)
      });
    }
    var ref$1 = elementStyles2(this.chartElement, ["paddingLeft", "paddingTop"]);
    var paddingLeft = ref$1.paddingLeft;
    var paddingTop = ref$1.paddingTop;
    this.options = deepExtend({}, {
      width: box.width(),
      height: box.height() + SELECTOR_HEIGHT_ADJUST,
      //workaround for sub-pixel hover on the paths in chrome
      padding: {
        left: paddingLeft,
        top: paddingTop
      },
      offset: {
        left: box.x1 + paddingLeft,
        top: box.y1 + paddingTop
      },
      from: options2.min,
      to: options2.max
    }, options2);
  };
  Selection2.prototype.destroy = function destroy2() {
    var obj;
    if (this._domEvents) {
      this._domEvents.destroy();
      delete this._domEvents;
    }
    clearTimeout(this._mwTimeout);
    this._state = null;
    if (this.wrapper) {
      if (this._mousewheelHandler) {
        unbindEvents2(this.wrapper, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));
        this._mousewheelHandler = null;
      }
      this.chartElement.removeChild(this.wrapper);
      this.wrapper = null;
    }
  };
  Selection2.prototype._rangeEventArgs = function _rangeEventArgs(range) {
    return {
      axis: this.categoryAxis.options,
      from: this._value(range.from),
      to: this._value(range.to)
    };
  };
  Selection2.prototype._start = function _start(e) {
    var options2 = this.options;
    var target = eventElement2(e);
    if (this._state || !target) {
      return;
    }
    this.chart._unsetActivePoint();
    this._state = {
      moveTarget: closestHandle(target) || target,
      startLocation: e.x ? e.x.location : 0,
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs({
      from: this._index(options2.from),
      to: this._index(options2.to)
    });
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    }
  };
  Selection2.prototype._press = function _press(e) {
    var handle;
    if (this._state) {
      handle = this._state.moveTarget;
    } else {
      handle = closestHandle(eventElement2(e));
    }
    if (handle) {
      addClass(handle, "k-handle-active");
    }
  };
  Selection2.prototype._move = function _move(e) {
    if (!this._state) {
      return;
    }
    var ref2 = this;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var target = state.moveTarget;
    var reverse = categoryAxis.options.reverse;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var delta = state.startLocation - e.x.location;
    var oldRange = { from: range.from, to: range.to };
    var span = range.to - range.from;
    var scale = elementStyles2(this.wrapper, "width").width / (categoryAxis.categoriesCount() - 1);
    var offset = Math.round(delta / scale) * (reverse ? -1 : 1);
    if (!target) {
      return;
    }
    var leftHandle = hasClasses(target, "k-left-handle");
    var rightHandle = hasClasses(target, "k-right-handle");
    if (hasClasses(target, "k-selection k-selection-bg")) {
      range.from = Math.min(
        Math.max(min3, from - offset),
        max2 - span
      );
      range.to = Math.min(
        range.from + span,
        max2
      );
    } else if (leftHandle && !reverse || rightHandle && reverse) {
      range.from = Math.min(
        Math.max(min3, from - offset),
        max2 - 1
      );
      range.to = Math.max(range.from + 1, range.to);
    } else if (leftHandle && reverse || rightHandle && !reverse) {
      range.to = Math.min(
        Math.max(min3 + 1, to - offset),
        max2
      );
      range.from = Math.min(range.to - 1, range.from);
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.move(range.from, range.to);
      this.trigger(SELECT, this._rangeEventArgs(range));
    }
  };
  Selection2.prototype._end = function _end() {
    if (this._state) {
      var moveTarget = this._state.moveTarget;
      if (moveTarget) {
        removeClass(moveTarget, "k-handle-active");
      }
      var range = this._state.range;
      this.set(range.from, range.to);
      this.trigger(SELECT_END, this._rangeEventArgs(range));
      delete this._state;
    }
  };
  Selection2.prototype._tap = function _tap(e) {
    var ref2 = this;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var coords = this.chart._eventCoordinates(e);
    var categoryIx = categoryAxis.pointCategoryIndex(new point_default2(coords.x, categoryAxis.box.y1));
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var span = to - from;
    var mid = from + span / 2;
    var range = {};
    var rightClick = e.event.which === 3;
    var offset = Math.round(mid - categoryIx);
    if (this._state || rightClick) {
      return;
    }
    this.chart._unsetActivePoint();
    if (!categoryAxis.options.justified) {
      offset--;
    }
    range.from = Math.min(
      Math.max(min3, from - offset),
      max2 - span
    );
    range.to = Math.min(range.from + span, max2);
    this._start(e);
    if (this._state) {
      this._state.range = range;
      this.trigger(SELECT, this._rangeEventArgs(range));
      this._end();
    }
  };
  Selection2.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    this._start({ target: this.selection });
    if (this._state) {
      var range = this._state.range;
      e.preventDefault();
      e.stopPropagation();
      if (Math.abs(delta) > 1) {
        delta *= ZOOM_ACCELERATION;
      }
      if (this.options.mousewheel.reverse) {
        delta *= -1;
      }
      if (this.expand(delta)) {
        this.trigger(SELECT, {
          axis: this.categoryAxis.options,
          delta,
          originalEvent: e,
          from: this._value(range.from),
          to: this._value(range.to)
        });
      }
      if (this._mwTimeout) {
        clearTimeout(this._mwTimeout);
      }
      this._mwTimeout = setTimeout(function() {
        this$1._end();
      }, MOUSEWHEEL_DELAY);
    }
  };
  Selection2.prototype._gesturestart = function _gesturestart(e) {
    var options2 = this.options;
    this._state = {
      range: {
        from: this._index(options2.from),
        to: this._index(options2.to)
      }
    };
    var args = this._rangeEventArgs(this._state.range);
    if (this.trigger(SELECT_START, args)) {
      this._state = null;
    } else {
      e.preventDefault();
    }
  };
  Selection2.prototype._gestureend = function _gestureend() {
    if (this._state) {
      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));
      delete this._state;
    }
  };
  Selection2.prototype._gesturechange = function _gesturechange(e) {
    var ref2 = this;
    var chart = ref2.chart;
    var state = ref2._state;
    var options2 = ref2.options;
    var categoryAxis = ref2.categoryAxis;
    var range = state.range;
    var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;
    var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;
    var left = Math.min(p0, p1);
    var right = Math.max(p0, p1);
    e.preventDefault();
    range.from = categoryAxis.pointCategoryIndex(new point_default2(left)) || options2.min;
    range.to = categoryAxis.pointCategoryIndex(new point_default2(right)) || options2.max;
    this.move(range.from, range.to);
    this.trigger(SELECT, this._rangeEventArgs(range));
  };
  Selection2.prototype._index = function _index(value) {
    var index = value;
    if (value instanceof Date) {
      index = this.categoryAxis.categoryIndex(value);
    }
    return index;
  };
  Selection2.prototype._value = function _value(index) {
    var value = index;
    if (this._dateAxis) {
      value = this.categoryAxis.categoryAt(index);
      if (value > this.options.max) {
        value = this.options.max;
      }
    }
    return value;
  };
  Selection2.prototype._slot = function _slot(value) {
    var categoryAxis = this.categoryAxis;
    var index = this._index(value);
    return categoryAxis.getSlot(index, index, true);
  };
  Selection2.prototype.move = function move(from, to) {
    var options2 = this.options;
    var reverse = this.categoryAxis.options.reverse;
    var offset = options2.offset;
    var padding = options2.padding;
    var border = options2.selection.border;
    var left = reverse ? to : from;
    var right = reverse ? from : to;
    var edge = "x" + (reverse ? 2 : 1);
    var box = this._slot(left);
    var leftMaskWidth = round3(box[edge] - offset.left + padding.left);
    elementStyles2(this.leftMask, {
      width: leftMaskWidth
    });
    elementStyles2(this.selection, {
      left: leftMaskWidth
    });
    box = this._slot(right);
    var rightMaskWidth = round3(options2.width - (box[edge] - offset.left + padding.left));
    elementStyles2(this.rightMask, {
      width: rightMaskWidth
    });
    var distance = options2.width - rightMaskWidth;
    if (distance !== options2.width) {
      distance += border.right;
    }
    elementStyles2(this.rightMask, {
      left: distance
    });
    elementStyles2(this.selection, {
      width: Math.max(options2.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)
    });
  };
  Selection2.prototype.set = function set2(from, to) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var fromValue = limitValue2(this._index(from), min3, max2);
    var toValue = limitValue2(this._index(to), fromValue + 1, max2);
    if (options2.visible) {
      this.move(fromValue, toValue);
    }
    options2.from = this._value(fromValue);
    options2.to = this._value(toValue);
  };
  Selection2.prototype.expand = function expand(delta) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var zDir = options2.mousewheel.zoom;
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    if (this._state) {
      range = this._state.range;
    }
    if (zDir !== RIGHT) {
      range.from = limitValue2(
        limitValue2(from - delta, 0, to - 1),
        min3,
        max2
      );
    }
    if (zDir !== LEFT) {
      range.to = limitValue2(
        limitValue2(to + delta, range.from + 1, max2),
        min3,
        max2
      );
    }
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.zoom = function zoom(delta, coords) {
    var options2 = this.options;
    var min3 = this._index(options2.min);
    var max2 = this._index(options2.max);
    var from = this._index(options2.from);
    var to = this._index(options2.to);
    var range = { from, to };
    var oldRange = deepExtend({}, range);
    var ref2 = this.categoryAxis.options;
    var reverse = ref2.reverse;
    var origin = X + (reverse ? "2" : "1");
    var lineBox = this.categoryAxis.lineBox();
    var relative = Math.abs(lineBox[origin] - coords[X]);
    var size = lineBox.width();
    var position = round3(relative / size, 2);
    var minDelta = round3(position * delta);
    var maxDelta = round3((1 - position) * delta);
    if (this._state) {
      range = this._state.range;
    }
    range.from = limitValue2(
      limitValue2(from - minDelta, 0, to - 1),
      min3,
      max2
    );
    range.to = limitValue2(
      limitValue2(to + maxDelta, range.from + 1, max2),
      min3,
      max2
    );
    if (range.from !== oldRange.from || range.to !== oldRange.to) {
      this.set(range.from, range.to);
      return true;
    }
  };
  Selection2.prototype.trigger = function trigger2(name3, args) {
    return (this.observer || this.chart).trigger(name3, args);
  };
  return Selection2;
}(class_default);
setDefaultOptions(Selection, {
  visible: true,
  mousewheel: {
    zoom: "both"
  },
  min: MIN_VALUE,
  max: MAX_VALUE
});
var selection_default = Selection;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/tooltip.js
var Tooltip = function(BaseTooltip2) {
  function Tooltip3() {
    BaseTooltip2.apply(this, arguments);
  }
  if (BaseTooltip2)
    Tooltip3.__proto__ = BaseTooltip2;
  Tooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  Tooltip3.prototype.show = function show2(point2) {
    if (!point2 || !point2.tooltipAnchor || this._current && this._current === point2) {
      return;
    }
    var options2 = deepExtend({}, this.options, point2.options.tooltip);
    var anchor = point2.tooltipAnchor();
    if (anchor) {
      this._current = point2;
      BaseTooltip2.prototype.show.call(this, {
        point: point2,
        anchor
      }, options2, point2);
    } else {
      this.hide();
    }
  };
  Tooltip3.prototype.hide = function hide2() {
    delete this._current;
    BaseTooltip2.prototype.hide.call(this);
  };
  return Tooltip3;
}(base_tooltip_default);
var tooltip_default = Tooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/tooltip/shared-tooltip.js
var SharedTooltip = function(BaseTooltip2) {
  function SharedTooltip3(plotArea, options2) {
    BaseTooltip2.call(this, plotArea.chartService, options2);
    this.plotArea = plotArea;
    this.formatService = plotArea.chartService.format;
  }
  if (BaseTooltip2)
    SharedTooltip3.__proto__ = BaseTooltip2;
  SharedTooltip3.prototype = Object.create(BaseTooltip2 && BaseTooltip2.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype.showAt = function showAt(points3, coords) {
    var tooltipPoints = grep(points3, function(point3) {
      var tooltip = point3.series.tooltip;
      var excluded = tooltip && tooltip.visible === false;
      return !excluded;
    });
    if (tooltipPoints.length > 0) {
      var point2 = tooltipPoints[0];
      var slot = this.plotArea.categoryAxis.getSlot(point2.categoryIx);
      var anchor = coords ? this._slotAnchor(coords, slot) : this._defaultAnchor(point2, slot);
      this.show({
        anchor,
        shared: true,
        points: points3,
        category: point2.category,
        categoryText: this.formatService.auto(this.options.categoryFormat, point2.category),
        series: this.plotArea.series
      }, this.options);
    }
  };
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(point2, slot) {
    var axis = this.plotArea.categoryAxis;
    var align2 = {
      horizontal: "left",
      vertical: "center"
    };
    if (!axis.options.vertical) {
      point2.x = slot.center().x;
    }
    return {
      point: point2,
      align: align2
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    var box = point2.owner.pane.chartsBox();
    var vertical = this.plotArea.categoryAxis.options.vertical;
    var center = box.center();
    var slotCenter = slot.center();
    var align2 = {
      horizontal: "center",
      vertical: "center"
    };
    var centerPoint;
    if (vertical) {
      centerPoint = new point_default2(center.x, slotCenter.y);
    } else {
      centerPoint = new point_default2(slotCenter.x, center.y);
    }
    return {
      point: centerPoint,
      align: align2
    };
  };
  return SharedTooltip3;
}(base_tooltip_default);
setDefaultOptions(SharedTooltip, {
  categoryFormat: "{0:d}"
});
var shared_tooltip_default = SharedTooltip;

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bar-chart-animation.js
var BarChartAnimation = function(superclass) {
  function BarChartAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarChartAnimation2.__proto__ = superclass;
  BarChartAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarChartAnimation2.prototype.constructor = BarChartAnimation2;
  BarChartAnimation2.prototype.setup = function setup() {
    var ref2 = this;
    var element = ref2.element;
    var options2 = ref2.options;
    var bbox = element.bbox();
    if (bbox) {
      this.origin = options2.origin;
      var axis = options2.vertical ? Y : X;
      var fromScale = this.fromScale = new geometry_exports.Point(1, 1);
      fromScale[axis] = START_SCALE;
      element.transform(
        geometry_exports.transform().scale(fromScale.x, fromScale.y)
      );
    } else {
      this.abort();
    }
  };
  BarChartAnimation2.prototype.step = function step(pos) {
    var scaleX = interpolateValue(this.fromScale.x, 1, pos);
    var scaleY = interpolateValue(this.fromScale.y, 1, pos);
    this.element.transform(
      geometry_exports.transform().scale(scaleX, scaleY, this.origin)
    );
  };
  BarChartAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    this.element.transform(null);
  };
  return BarChartAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarChartAnimation, {
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(BAR, BarChartAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/bubble-animation.js
var BubbleAnimation = function(superclass) {
  function BubbleAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BubbleAnimation2.__proto__ = superclass;
  BubbleAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BubbleAnimation2.prototype.constructor = BubbleAnimation2;
  BubbleAnimation2.prototype.setup = function setup() {
    var center = this.center = this.element.bbox().center();
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, center)
    );
  };
  BubbleAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.center)
    );
  };
  return BubbleAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BubbleAnimation, {
  easing: "easeOutElastic"
});
drawing_exports.AnimationFactory.current.register(BUBBLE, BubbleAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/fade-in-animation.js
var FadeInAnimation = function(superclass) {
  function FadeInAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeInAnimation2.__proto__ = superclass;
  FadeInAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeInAnimation2.prototype.constructor = FadeInAnimation2;
  FadeInAnimation2.prototype.setup = function setup() {
    this.fadeTo = this.element.opacity();
    this.element.opacity(0);
  };
  FadeInAnimation2.prototype.step = function step(pos) {
    this.element.opacity(pos * this.fadeTo);
  };
  return FadeInAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(FadeInAnimation, {
  duration: 200,
  easing: "linear"
});
drawing_exports.AnimationFactory.current.register(FADEIN, FadeInAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/animations/pie-animation.js
var PieAnimation = function(superclass) {
  function PieAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    PieAnimation2.__proto__ = superclass;
  PieAnimation2.prototype = Object.create(superclass && superclass.prototype);
  PieAnimation2.prototype.constructor = PieAnimation2;
  PieAnimation2.prototype.setup = function setup() {
    this.element.transform(
      geometry_exports.transform().scale(START_SCALE, START_SCALE, this.options.center)
    );
  };
  PieAnimation2.prototype.step = function step(pos) {
    this.element.transform(
      geometry_exports.transform().scale(pos, pos, this.options.center)
    );
  };
  return PieAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(PieAnimation, {
  easing: "easeOutElastic",
  duration: INITIAL_ANIMATION_DURATION
});
drawing_exports.AnimationFactory.current.register(PIE, PieAnimation);

// node_modules/@progress/kendo-charts/dist/es/chart/scatter-charts/scatter-line-chart.js
var ScatterLineChart = function(ScatterChart2) {
  function ScatterLineChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    ScatterLineChart2.__proto__ = ScatterChart2;
  ScatterLineChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  ScatterLineChart2.prototype.constructor = ScatterLineChart2;
  ScatterLineChart2.prototype.render = function render3() {
    ScatterChart2.prototype.render.call(this);
    this.renderSegments();
  };
  ScatterLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    return new pointType(linePoints, currentSeries, seriesIx);
  };
  ScatterLineChart2.prototype.animationPoints = function animationPoints() {
    var points3 = ScatterChart2.prototype.animationPoints.call(this);
    return points3.concat(this._segments);
  };
  ScatterLineChart2.prototype.createMissingValue = function createMissingValue(value, missingValues) {
    if (missingValues === ZERO2) {
      var missingValue = {
        x: value.x,
        y: value.y
      };
      if (!hasValue(missingValue.x)) {
        missingValue.x = 0;
      }
      if (!hasValue(missingValue.y)) {
        missingValue.y = 0;
      }
      return missingValue;
    }
  };
  return ScatterLineChart2;
}(scatter_chart_default);
deepExtend(ScatterLineChart.prototype, line_chart_mixin_default);
var scatter_line_chart_default = ScatterLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/xy-plotarea.js
var XYPlotArea = function(PlotAreaBase2) {
  function XYPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    XYPlotArea2.__proto__ = PlotAreaBase2;
  XYPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  XYPlotArea2.prototype.constructor = XYPlotArea2;
  XYPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
    this.xAxisRangeTracker = new axis_group_range_tracker_default();
    this.yAxisRangeTracker = new axis_group_range_tracker_default();
  };
  XYPlotArea2.prototype.render = function render3(panes) {
    var this$1 = this;
    if (panes === void 0)
      panes = this.panes;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createScatterChart(
        filterSeriesByType(filteredSeries, SCATTER),
        pane
      );
      this$1.createScatterLineChart(
        filterSeriesByType(filteredSeries, SCATTER_LINE),
        pane
      );
      this$1.createBubbleChart(
        filterSeriesByType(filteredSeries, BUBBLE),
        pane
      );
    }
    this.createAxes(panes);
  };
  XYPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.xAxisRangeTracker.update(chart.xAxisRanges);
    this.yAxisRangeTracker.update(chart.yAxisRanges);
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
  };
  XYPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      this.yAxisRangeTracker.reset(axisName);
      delete this.namedYAxes[axisName];
    } else {
      this.xAxisRangeTracker.reset(axisName);
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  XYPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  XYPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createScatterLineChart = function createScatterLineChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new scatter_line_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createBubbleChart = function createBubbleChart(series, pane) {
    if (series.length > 0) {
      this.appendChart(
        new bubble_chart_default(this, { series, clip: pane.options.clip }),
        pane
      );
    }
  };
  XYPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var tracker = vertical ? this.yAxisRangeTracker : this.xAxisRangeTracker;
    var axisOptions2 = deepExtend({ reverse: !vertical && this.chartService.rtl }, options2, { vertical });
    var isLog = equalsIgnoreCase(axisOptions2.type, LOGARITHMIC);
    var defaultRange = tracker.query();
    var defaultAxisRange = isLog ? { min: 0.1, max: 1 } : { min: 0, max: 1 };
    var range = tracker.query(axisName) || defaultRange || defaultAxisRange;
    var typeSamples = [axisOptions2.min, axisOptions2.max];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    if (axisIndex === 0 && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_value_axis_default;
    } else if (isLog) {
      axisType = logarithmic_axis_default;
    } else {
      axisType = numeric_axis_default;
    }
    var axis = new axisType(range.min, range.max, axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    return axis;
  };
  XYPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  XYPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      var currentValue = axis.getValue(point2);
      if (currentValue !== null) {
        values5.push(currentValue);
      }
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  XYPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions2(this.options, index, vertical, options2);
    updateAxisOptions2(this.originalOptions, index, vertical, options2);
  };
  return XYPlotArea2;
}(plotarea_base_default);
function updateAxisOptions2(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(XYPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(XYPlotArea.prototype, plotarea_events_mixin_default);
var xy_plotarea_default = XYPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-segment.js
var PieSegment = function(ChartElement2) {
  function PieSegment2(value, sector, options2) {
    ChartElement2.call(this, options2);
    this.value = value;
    this.sector = sector;
  }
  if (ChartElement2)
    PieSegment2.__proto__ = ChartElement2;
  PieSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieSegment2.prototype.constructor = PieSegment2;
  PieSegment2.prototype.render = function render3() {
    var labels = this.options.labels;
    var chartService = this.owner.chartService;
    var labelText = this.value;
    if (this._rendered || this.visible === false) {
      return;
    }
    this._rendered = true;
    var labelTemplate = getTemplate(labels);
    var pointData = this.pointData();
    if (labelTemplate) {
      labelText = labelTemplate(pointData);
    } else if (labels.format) {
      labelText = chartService.format.auto(labels.format, labelText);
    }
    if (labels.visible && (labelText || labelText === 0)) {
      if (labels.position === CENTER || labels.position === INSIDE_END) {
        if (!labels.color) {
          labels.color = auto_text_color_default(this.options.color);
        }
        if (!labels.background) {
          labels.background = this.options.color;
        }
      } else {
        var themeLabels = chartService.theme.seriesDefaults.labels;
        labels.color = labels.color || themeLabels.color;
        labels.background = labels.background || themeLabels.background;
      }
      this.label = new text_box_default(labelText, deepExtend({}, labels, {
        align: CENTER,
        vAlign: "",
        animation: {
          type: FADEIN,
          delay: this.animationDelay
        }
      }), pointData);
      this.append(this.label);
    }
  };
  PieSegment2.prototype.reflow = function reflow(targetBox) {
    this.render();
    this.box = targetBox;
    this.reflowLabel();
  };
  PieSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var labelsDistance = labelsOptions.distance;
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      var labelWidth = label.box.width();
      var lp;
      if (labelsOptions.position === CENTER) {
        sector.radius = Math.abs((sector.radius - labelHeight) / 2) + labelHeight;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else if (labelsOptions.position === INSIDE_END) {
        sector.radius = sector.radius - labelHeight / 2;
        lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        var x1;
        lp = sector.clone().expand(labelsDistance).point(angle);
        if (lp.x >= sector.center.x) {
          x1 = lp.x + labelWidth;
          label.orientation = RIGHT;
        } else {
          x1 = lp.x - labelWidth;
          label.orientation = LEFT;
        }
        label.reflow(new box_default(x1, lp.y - labelHeight, lp.x, lp.y));
      }
    }
  };
  PieSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    ChartElement2.prototype.createVisual.call(this);
    if (this.value) {
      if (options2.visual) {
        var startAngle = (sector.startAngle + 180) % 360;
        var visual = options2.visual({
          category: this.category,
          dataItem: this.dataItem,
          value: this.value,
          series: this.series,
          percentage: this.percentage,
          center: new geometry_exports.Point(sector.center.x, sector.center.y),
          radius: sector.radius,
          innerRadius: sector.innerRadius,
          startAngle,
          endAngle: startAngle + sector.angle,
          options: options2,
          sender: this.getSender(),
          createVisual: function() {
            var group = new drawing_exports.Group();
            this$1.createSegmentVisual(group);
            return group;
          }
        });
        if (visual) {
          this.visual.append(visual);
        }
      } else {
        this.createSegmentVisual(this.visual);
      }
    }
  };
  PieSegment2.prototype.createSegmentVisual = function createSegmentVisual(group) {
    var ref2 = this;
    var sector = ref2.sector;
    var options2 = ref2.options;
    var borderOptions = options2.border || {};
    var border = borderOptions.width > 0 ? {
      stroke: {
        color: borderOptions.color,
        width: borderOptions.width,
        opacity: borderOptions.opacity,
        dashType: borderOptions.dashType
      }
    } : {};
    var color = options2.color;
    var fill = {
      color,
      opacity: options2.opacity
    };
    var visual = this.createSegment(sector, deepExtend({
      fill,
      stroke: {
        opacity: options2.opacity
      },
      zIndex: options2.zIndex
    }, border));
    group.append(visual);
    if (hasGradientOverlay(options2)) {
      group.append(this.createGradientOverlay(visual, {
        baseColor: color,
        fallbackFill: fill
      }, deepExtend({
        center: [sector.center.x, sector.center.y],
        innerRadius: sector.innerRadius,
        radius: sector.radius,
        userSpace: true
      }, options2.overlay)));
    }
  };
  PieSegment2.prototype.createSegment = function createSegment(sector, options2) {
    if (options2.singleSegment) {
      return new drawing_exports.Circle(new geometry_exports.Circle(new geometry_exports.Point(sector.center.x, sector.center.y), sector.radius), options2);
    }
    return shape_builder_default.current.createRing(sector, options2);
  };
  PieSegment2.prototype.createAnimation = function createAnimation() {
    var ref2 = this;
    var options2 = ref2.options;
    var center = ref2.sector.center;
    deepExtend(options2, {
      animation: {
        center: [center.x, center.y],
        delay: this.animationDelay
      }
    });
    ChartElement2.prototype.createAnimation.call(this);
  };
  PieSegment2.prototype.createHighlight = function createHighlight(options2) {
    var highlight = this.options.highlight || {};
    var border = highlight.border || {};
    return this.createSegment(this.sector, deepExtend({}, options2, {
      fill: {
        color: highlight.color,
        opacity: highlight.opacity
      },
      stroke: {
        opacity: border.opacity,
        width: border.width,
        color: border.color
      }
    }));
  };
  PieSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  PieSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var sector = this.sector;
    return {
      options: this.options,
      radius: sector.radius,
      innerRadius: sector.innerRadius,
      center: new geometry_exports.Point(sector.center.x, sector.center.y),
      startAngle: sector.startAngle,
      endAngle: sector.angle + sector.startAngle,
      visual: this.visual
    };
  };
  PieSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var sector = this.sector.clone().expand(TOOLTIP_OFFSET);
    var midAndle = sector.middle();
    var midPoint = sector.point(midAndle);
    return {
      point: midPoint,
      align: tooltipAlignment(midAndle + 180)
    };
  };
  PieSegment2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  PieSegment2.prototype.pointData = function pointData() {
    return {
      dataItem: this.dataItem,
      category: this.category,
      value: this.value,
      series: this.series,
      percentage: this.percentage
    };
  };
  return PieSegment2;
}(chart_element_default);
var RAD_30 = round3(rad2(30), DEFAULT_PRECISION);
var RAD_60 = round3(rad2(60), DEFAULT_PRECISION);
function tooltipAlignment(angle) {
  var radians = rad2(angle);
  var sine = round3(Math.sin(radians), DEFAULT_PRECISION);
  var cosine = round3(Math.cos(radians), DEFAULT_PRECISION);
  var horizontal;
  if (Math.abs(sine) > RAD_60) {
    horizontal = CENTER;
  } else if (cosine < 0) {
    horizontal = RIGHT;
  } else {
    horizontal = LEFT;
  }
  var vertical;
  if (Math.abs(sine) < RAD_30) {
    vertical = CENTER;
  } else if (sine < 0) {
    vertical = BOTTOM;
  } else {
    vertical = TOP;
  }
  return {
    horizontal,
    vertical
  };
}
setDefaultOptions(PieSegment, {
  color: WHITE,
  overlay: {
    gradient: "roundedBevel"
  },
  border: {
    width: 0.5
  },
  labels: {
    visible: false,
    distance: 35,
    font: DEFAULT_FONT,
    margin: getSpacing(0.5),
    align: CIRCLE,
    zIndex: 1,
    position: OUTSIDE_END
  },
  animation: {
    type: PIE
  },
  highlight: {
    visible: true,
    border: {
      width: 1
    }
  },
  visible: true
});
deepExtend(PieSegment.prototype, point_events_mixin_default);
var pie_segment_default = PieSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/mixins/pie-chart-mixin.js
var PieChartMixin = {
  createLegendItem: function(value, point2, options2) {
    var legendOptions = this.options.legend || {};
    var labelsOptions = legendOptions.labels || {};
    var inactiveItems = legendOptions.inactiveItems || {};
    var inactiveItemsLabels = inactiveItems.labels || {};
    if (options2 && options2.visibleInLegend !== false) {
      var pointVisible = options2.visible !== false;
      var labelTemplate = pointVisible ? getTemplate(labelsOptions) : getTemplate(inactiveItemsLabels) || getTemplate(labelsOptions);
      var text = options2.category;
      if (labelTemplate) {
        text = labelTemplate({
          text,
          series: options2.series,
          dataItem: options2.dataItem,
          percentage: options2.percentage,
          value
        });
      }
      var itemLabelOptions, markerColor;
      if (pointVisible) {
        itemLabelOptions = {};
        markerColor = point2.color;
      } else {
        itemLabelOptions = {
          color: inactiveItemsLabels.color,
          font: inactiveItemsLabels.font
        };
        markerColor = (inactiveItems.markers || {}).color;
      }
      if (hasValue(text) && text !== "") {
        this.legendItems.push({
          active: pointVisible,
          pointIndex: options2.index,
          text,
          series: options2.series,
          markerColor,
          labels: itemLabelOptions
        });
      }
    }
  }
};
var pie_chart_mixin_default = PieChartMixin;

// node_modules/@progress/kendo-charts/dist/es/chart/pie-chart/pie-chart.js
var PIE_SECTOR_ANIM_DELAY = 70;
var PieChart = function(ChartElement2) {
  function PieChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this.points = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    PieChart2.__proto__ = ChartElement2;
  PieChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  PieChart2.prototype.constructor = PieChart2;
  PieChart2.prototype.render = function render3() {
    this.traverseDataPoints(this.addValue.bind(this));
  };
  PieChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var colorsCount = seriesColors.length;
    var series = options2.series;
    var seriesCount = series.length;
    for (var seriesIx = 0; seriesIx < seriesCount; seriesIx++) {
      var currentSeries = series[seriesIx];
      var data = currentSeries.data;
      var ref$1 = bindSegments(currentSeries);
      var total3 = ref$1.total;
      var points3 = ref$1.points;
      var count = ref$1.count;
      var anglePerValue = 360 / total3;
      var constantAngle = void 0;
      if (!isFinite(anglePerValue)) {
        constantAngle = 360 / count;
      }
      var currentAngle = void 0;
      if (defined2(currentSeries.startAngle)) {
        currentAngle = currentSeries.startAngle;
      } else {
        currentAngle = options2.startAngle;
      }
      if (seriesIx !== seriesCount - 1) {
        if (currentSeries.labels.position === OUTSIDE_END) {
          currentSeries.labels.position = CENTER;
        }
      }
      for (var i = 0; i < points3.length; i++) {
        var pointData = points3[i];
        if (!pointData) {
          continue;
        }
        var fields = pointData.fields;
        var value = pointData.value;
        var visible = pointData.visible;
        var angle = value !== 0 ? constantAngle || value * anglePerValue : 0;
        var explode = data.length !== 1 && Boolean(fields.explode);
        if (!isFunction3(currentSeries.color)) {
          currentSeries.color = fields.color || seriesColors[i % colorsCount];
        }
        callback(value, new ring_default(null, 0, 0, currentAngle, angle), {
          owner: this$1,
          category: defined2(fields.category) ? fields.category : "",
          index: i,
          series: currentSeries,
          seriesIx,
          dataItem: data[i],
          percentage: total3 !== 0 ? value / total3 : 0,
          explode,
          visibleInLegend: fields.visibleInLegend,
          visible,
          zIndex: seriesCount - seriesIx,
          animationDelay: this$1.animationDelay(i, seriesIx, seriesCount)
        });
        if (visible !== false) {
          currentAngle += angle;
        }
      }
    }
  };
  PieChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value,
      series,
      dataItem: fields.dataItem,
      category: fields.category,
      percentage: fields.percentage
    }, { defaults: series._defaults, excluded: ["data", "content", "template", "visual", "toggle"] });
  };
  PieChart2.prototype.addValue = function addValue(value, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value, fields);
    this.createLegendItem(value, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new pie_segment_default(value, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  PieChart2.prototype.reflow = function reflow(targetBox) {
    var ref2 = this;
    var options2 = ref2.options;
    var points3 = ref2.points;
    var seriesConfigs = ref2.seriesConfigs;
    if (seriesConfigs === void 0)
      seriesConfigs = [];
    var count = points3.length;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var newBox = new box_default(box.x1, box.y1, box.x1 + minWidth, box.y1 + minWidth);
    var newBoxCenter = newBox.center();
    var boxCenter = box.center();
    var seriesCount = options2.series.length;
    var leftSideLabels = [];
    var rightSideLabels = [];
    var padding = valueOrDefault2(options2.padding, defaultPadding);
    this.targetBox = targetBox;
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    newBox.translate(boxCenter.x - newBoxCenter.x, boxCenter.y - newBoxCenter.y);
    var radius = halfMinWidth - padding;
    var center = new point_default2(
      radius + newBox.x1 + padding,
      radius + newBox.y1 + padding
    );
    for (var i = 0; i < count; i++) {
      var segment = points3[i];
      var sector = segment.sector;
      var seriesIndex = segment.seriesIx;
      sector.radius = radius;
      sector.center = center;
      if (seriesConfigs.length) {
        var seriesConfig = seriesConfigs[seriesIndex];
        sector.innerRadius = seriesConfig.innerRadius;
        sector.radius = seriesConfig.radius;
      }
      if (seriesIndex === seriesCount - 1 && segment.explode) {
        sector.center = sector.clone().setRadius(sector.radius * 0.15).point(sector.middle());
      }
      segment.reflow(newBox);
      var label = segment.label;
      if (label) {
        if (label.options.position === OUTSIDE_END) {
          if (seriesIndex === seriesCount - 1) {
            if (label.orientation === RIGHT) {
              rightSideLabels.push(label);
            } else {
              leftSideLabels.push(label);
            }
          }
        }
      }
    }
    if (leftSideLabels.length > 0) {
      leftSideLabels.sort(this.labelComparator(true));
      this.leftLabelsReflow(leftSideLabels);
    }
    if (rightSideLabels.length > 0) {
      rightSideLabels.sort(this.labelComparator(false));
      this.rightLabelsReflow(rightSideLabels);
    }
    this.box = newBox;
  };
  PieChart2.prototype.leftLabelsReflow = function leftLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.rightLabelsReflow = function rightLabelsReflow(labels) {
    var distances = this.distanceBetweenLabels(labels);
    this.distributeLabels(distances, labels);
  };
  PieChart2.prototype.distanceBetweenLabels = function distanceBetweenLabels(labels) {
    var segment = last2(this.points);
    var sector = segment.sector;
    var count = labels.length - 1;
    var lr = sector.radius + segment.options.labels.distance;
    var distances = [];
    var firstBox = labels[0].box;
    var distance = round3(firstBox.y1 - (sector.center.y - lr - firstBox.height() - firstBox.height() / 2));
    distances.push(distance);
    for (var i = 0; i < count; i++) {
      var secondBox = labels[i + 1].box;
      firstBox = labels[i].box;
      distance = round3(secondBox.y1 - firstBox.y2);
      distances.push(distance);
    }
    distance = round3(sector.center.y + lr - labels[count].box.y2 - labels[count].box.height() / 2);
    distances.push(distance);
    return distances;
  };
  PieChart2.prototype.distributeLabels = function distributeLabels(distances, labels) {
    var this$1 = this;
    var count = distances.length;
    var left, right, remaining;
    for (var i = 0; i < count; i++) {
      remaining = -distances[i];
      left = right = i;
      while (remaining > 0 && (left >= 0 || right < count)) {
        remaining = this$1._takeDistance(distances, i, --left, remaining);
        remaining = this$1._takeDistance(distances, i, ++right, remaining);
      }
    }
    this.reflowLabels(distances, labels);
  };
  PieChart2.prototype._takeDistance = function _takeDistance(distances, anchor, position, amount) {
    var result = amount;
    if (distances[position] > 0) {
      var available = Math.min(distances[position], result);
      result -= available;
      distances[position] -= available;
      distances[anchor] += available;
    }
    return result;
  };
  PieChart2.prototype.reflowLabels = function reflowLabels(distances, labels) {
    var this$1 = this;
    var segment = last2(this.points);
    var sector = segment.sector;
    var labelOptions = segment.options.labels;
    var labelsCount = labels.length;
    var labelDistance = labelOptions.distance;
    var boxY = sector.center.y - (sector.radius + labelDistance) - labels[0].box.height();
    var boxX;
    distances[0] += 2;
    for (var i = 0; i < labelsCount; i++) {
      var label = labels[i];
      var box = label.box;
      boxY += distances[i];
      boxX = this$1.hAlignLabel(
        box.x2,
        sector.clone().expand(labelDistance),
        boxY,
        boxY + box.height(),
        label.orientation === RIGHT
      );
      if (label.orientation === RIGHT) {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.radius + sector.center.x + labelDistance;
        }
        label.reflow(new box_default(boxX + box.width(), boxY, boxX, boxY));
      } else {
        if (labelOptions.align !== CIRCLE) {
          boxX = sector.center.x - sector.radius - labelDistance;
        }
        label.reflow(new box_default(boxX - box.width(), boxY, boxX, boxY));
      }
      boxY += box.height();
    }
  };
  PieChart2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var ref2 = this;
    var connectors = ref2.options.connectors;
    var points3 = ref2.points;
    var count = points3.length;
    var space = 4;
    ChartElement2.prototype.createVisual.call(this);
    this._connectorLines = [];
    for (var i = 0; i < count; i++) {
      var segment = points3[i];
      var sector = segment.sector;
      var label = segment.label;
      var angle = sector.middle();
      var connectorsColor = (segment.options.connectors || {}).color || connectors.color;
      if (label) {
        var connectorLine = new drawing_exports.Path({
          stroke: {
            color: connectorsColor,
            width: connectors.width
          },
          animation: {
            type: FADEIN,
            delay: segment.animationDelay
          }
        });
        if (label.options.position === OUTSIDE_END) {
          var box = label.box;
          var centerPoint = sector.center;
          var start = sector.point(angle);
          var middle = new point_default2(box.x1, box.center().y);
          var sr = void 0, end = void 0, crossing = void 0;
          start = sector.clone().expand(connectors.padding).point(angle);
          connectorLine.moveTo(start.x, start.y);
          if (label.orientation === RIGHT) {
            end = new point_default2(box.x1 - connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default2(end.x - space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.min(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x < sector.center.x) {
              sr = sector.center.x + sector.radius + space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr < middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x + space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          } else {
            end = new point_default2(box.x2 + connectors.padding, box.center().y);
            crossing = intersection(centerPoint, start, middle, end);
            middle = new point_default2(end.x + space, end.y);
            crossing = crossing || middle;
            crossing.x = Math.max(crossing.x, middle.x);
            if (this$1.pointInCircle(crossing, sector.center, sector.radius + space) || crossing.x > sector.center.x) {
              sr = sector.center.x - sector.radius - space;
              if (segment.options.labels.align !== COLUMN) {
                if (sr > middle.x) {
                  connectorLine.lineTo(sr, start.y);
                } else {
                  connectorLine.lineTo(start.x - space * 2, start.y);
                }
              } else {
                connectorLine.lineTo(sr, start.y);
              }
              connectorLine.lineTo(middle.x, end.y);
            } else {
              crossing.y = end.y;
              connectorLine.lineTo(crossing.x, crossing.y);
            }
          }
          connectorLine.lineTo(end.x, end.y);
          this$1._connectorLines.push(connectorLine);
          this$1.visual.append(connectorLine);
        }
      }
    }
  };
  PieChart2.prototype.renderVisual = function renderVisual() {
    ChartElement2.prototype.renderVisual.call(this);
    if (find(this.options.series, function(options2) {
      return options2.autoFit;
    })) {
      var targetBox = this.targetBox;
      var pieCenter = this.box.center();
      var bbox = this.visual.bbox();
      if (!bbox) {
        return;
      }
      var bboxBottom = bbox.bottomRight();
      var scale = Math.min(
        (pieCenter.y - targetBox.y1) / (pieCenter.y - bbox.origin.y),
        (targetBox.y2 - pieCenter.y) / (bboxBottom.y - pieCenter.y),
        (pieCenter.x - targetBox.x1) / (pieCenter.x - bbox.origin.x),
        (targetBox.x2 - pieCenter.x) / (bboxBottom.x - pieCenter.x)
      );
      if (scale < 1) {
        this.visual.transform(geometry_exports.transform().scale(scale, scale, [pieCenter.x, pieCenter.y]));
      }
    }
  };
  PieChart2.prototype.labelComparator = function labelComparator(reverse) {
    var reverseValue = reverse ? -1 : 1;
    return function(a, b) {
      var first = (a.parent.sector.middle() + 270) % 360;
      var second = (b.parent.sector.middle() + 270) % 360;
      return (first - second) * reverseValue;
    };
  };
  PieChart2.prototype.hAlignLabel = function hAlignLabel(originalX, sector, y1, y2, direction) {
    var radius = sector.radius;
    var sector_center = sector.center;
    var cx = sector_center.x;
    var cy = sector_center.y;
    var t = Math.min(Math.abs(cy - y1), Math.abs(cy - y2));
    if (t > radius) {
      return originalX;
    }
    return cx + Math.sqrt(radius * radius - t * t) * (direction ? 1 : -1);
  };
  PieChart2.prototype.pointInCircle = function pointInCircle(point2, center, radius) {
    return Math.pow(center.x - point2.x, 2) + Math.pow(center.y - point2.y, 2) < Math.pow(radius, 2);
  };
  PieChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value);
  };
  PieChart2.prototype.animationDelay = function animationDelay(categoryIndex) {
    return categoryIndex * PIE_SECTOR_ANIM_DELAY;
  };
  PieChart2.prototype.stackRoot = function stackRoot() {
    return this;
  };
  return PieChart2;
}(chart_element_default);
function intersection(a1, a2, b1, b2) {
  var uat = (b2.x - b1.x) * (a1.y - b1.y) - (b2.y - b1.y) * (a1.x - b1.x);
  var ub = (b2.y - b1.y) * (a2.x - a1.x) - (b2.x - b1.x) * (a2.y - a1.y);
  var result;
  if (ub !== 0) {
    var ua = uat / ub;
    result = new point_default2(
      a1.x + ua * (a2.x - a1.x),
      a1.y + ua * (a2.y - a1.y)
    );
  }
  return result;
}
setDefaultOptions(PieChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  },
  inactiveItems: {
    markers: {},
    labels: {}
  }
});
deepExtend(PieChart.prototype, pie_chart_mixin_default);
PieChart.prototype.isStackRoot = true;
var pie_chart_default = PieChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/pie-plotarea.js
var PiePlotArea = function(PlotAreaBase2) {
  function PiePlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PiePlotArea2.__proto__ = PlotAreaBase2;
  PiePlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PiePlotArea2.prototype.constructor = PiePlotArea2;
  PiePlotArea2.prototype.render = function render3() {
    this.createPieChart(this.series);
  };
  PiePlotArea2.prototype.createPieChart = function createPieChart(series) {
    var firstSeries = series[0];
    var pieChart = new pie_chart_default(this, {
      series,
      padding: firstSeries.padding,
      startAngle: firstSeries.startAngle,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(pieChart);
  };
  PiePlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append2(this.options.legend.items, chart.legendItems);
  };
  return PiePlotArea2;
}(plotarea_base_default);
var pie_plotarea_default = PiePlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-segment.js
var DonutSegment = function(PieSegment2) {
  function DonutSegment2() {
    PieSegment2.apply(this, arguments);
  }
  if (PieSegment2)
    DonutSegment2.__proto__ = PieSegment2;
  DonutSegment2.prototype = Object.create(PieSegment2 && PieSegment2.prototype);
  DonutSegment2.prototype.constructor = DonutSegment2;
  DonutSegment2.prototype.reflowLabel = function reflowLabel() {
    var ref2 = this;
    var labelsOptions = ref2.options.labels;
    var label = ref2.label;
    var sector = this.sector.clone();
    var angle = sector.middle();
    if (label) {
      var labelHeight = label.box.height();
      if (labelsOptions.position === CENTER) {
        sector.radius -= (sector.radius - sector.innerRadius) / 2;
        var lp = sector.point(angle);
        label.reflow(new box_default(lp.x, lp.y - labelHeight / 2, lp.x, lp.y));
      } else {
        PieSegment2.prototype.reflowLabel.call(this);
      }
    }
  };
  DonutSegment2.prototype.createSegment = function createSegment(sector, options2) {
    return shape_builder_default.current.createRing(sector, options2);
  };
  return DonutSegment2;
}(pie_segment_default);
setDefaultOptions(DonutSegment, {
  overlay: {
    gradient: "roundedGlass"
  },
  labels: {
    position: CENTER
  },
  animation: {
    type: PIE
  }
});
deepExtend(DonutSegment.prototype, point_events_mixin_default);
var donut_segment_default = DonutSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/donut-chart/donut-chart.js
var DONUT_SECTOR_ANIM_DELAY = 50;
var DonutChart = function(PieChart2) {
  function DonutChart2() {
    PieChart2.apply(this, arguments);
  }
  if (PieChart2)
    DonutChart2.__proto__ = PieChart2;
  DonutChart2.prototype = Object.create(PieChart2 && PieChart2.prototype);
  DonutChart2.prototype.constructor = DonutChart2;
  DonutChart2.prototype.addValue = function addValue(value, sector, fields) {
    var segmentOptions = deepExtend({}, fields.series, { index: fields.index });
    this.evalSegmentOptions(segmentOptions, value, fields);
    this.createLegendItem(value, segmentOptions, fields);
    if (fields.visible === false) {
      return;
    }
    var segment = new donut_segment_default(value, sector, segmentOptions);
    Object.assign(segment, fields);
    this.append(segment);
    this.points.push(segment);
  };
  DonutChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var options2 = this.options;
    var box = targetBox.clone();
    var space = 5;
    var minWidth = Math.min(box.width(), box.height());
    var halfMinWidth = minWidth / 2;
    var defaultPadding = minWidth - minWidth * 0.85;
    var series = options2.series;
    var seriesCount = series.length;
    var padding = valueOrDefault2(options2.padding, defaultPadding);
    padding = padding > halfMinWidth - space ? halfMinWidth - space : padding;
    var totalSize = halfMinWidth - padding;
    var seriesWithoutSize = 0;
    var holeSize;
    for (var i = 0; i < seriesCount; i++) {
      var currentSeries = series[i];
      if (i === 0) {
        if (defined2(currentSeries.holeSize)) {
          holeSize = currentSeries.holeSize;
          totalSize -= currentSeries.holeSize;
        }
      }
      if (defined2(currentSeries.size)) {
        totalSize -= currentSeries.size;
      } else {
        seriesWithoutSize++;
      }
      if (defined2(currentSeries.margin) && i !== seriesCount - 1) {
        totalSize -= currentSeries.margin;
      }
    }
    if (!defined2(holeSize)) {
      var currentSize = (halfMinWidth - padding) / (seriesCount + 0.75);
      holeSize = currentSize * 0.75;
      totalSize -= holeSize;
    }
    var innerRadius = holeSize;
    var margin = 0;
    var size, radius;
    this.seriesConfigs = [];
    for (var i$1 = 0; i$1 < seriesCount; i$1++) {
      var currentSeries$1 = series[i$1];
      size = valueOrDefault2(currentSeries$1.size, totalSize / seriesWithoutSize);
      innerRadius += margin;
      radius = innerRadius + size;
      this$1.seriesConfigs.push({ innerRadius, radius });
      margin = currentSeries$1.margin || 0;
      innerRadius = radius;
    }
    PieChart2.prototype.reflow.call(this, targetBox);
  };
  DonutChart2.prototype.animationDelay = function animationDelay(categoryIndex, seriesIndex, seriesCount) {
    return categoryIndex * DONUT_SECTOR_ANIM_DELAY + INITIAL_ANIMATION_DURATION * (seriesIndex + 1) / (seriesCount + 1);
  };
  return DonutChart2;
}(pie_chart_default);
setDefaultOptions(DonutChart, {
  startAngle: 90,
  connectors: {
    width: 2,
    color: "#939393",
    padding: 8
  }
});
var donut_chart_default = DonutChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/donut-plotarea.js
var DonutPlotArea = function(PiePlotArea2) {
  function DonutPlotArea2() {
    PiePlotArea2.apply(this, arguments);
  }
  if (PiePlotArea2)
    DonutPlotArea2.__proto__ = PiePlotArea2;
  DonutPlotArea2.prototype = Object.create(PiePlotArea2 && PiePlotArea2.prototype);
  DonutPlotArea2.prototype.constructor = DonutPlotArea2;
  DonutPlotArea2.prototype.render = function render3() {
    this.createDonutChart(this.series);
  };
  DonutPlotArea2.prototype.createDonutChart = function createDonutChart(series) {
    var firstSeries = series[0];
    var donutChart = new donut_chart_default(this, {
      series,
      padding: firstSeries.padding,
      connectors: firstSeries.connectors,
      legend: this.options.legend
    });
    this.appendChart(donutChart);
  };
  return DonutPlotArea2;
}(pie_plotarea_default);
var donut_plotarea_default = DonutPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea-base.js
var DEFAULT_PADDING = 0.15;
var PolarPlotAreaBase = function(PlotAreaBase2) {
  function PolarPlotAreaBase2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    PolarPlotAreaBase2.__proto__ = PlotAreaBase2;
  PolarPlotAreaBase2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  PolarPlotAreaBase2.prototype.constructor = PolarPlotAreaBase2;
  PolarPlotAreaBase2.prototype.initFields = function initFields() {
    this.valueAxisRangeTracker = new axis_group_range_tracker_default();
  };
  PolarPlotAreaBase2.prototype.render = function render3() {
    this.addToLegend(this.series);
    this.createPolarAxis();
    this.createCharts();
    this.createValueAxis();
  };
  PolarPlotAreaBase2.prototype.alignAxes = function alignAxes() {
    var axis = this.valueAxis;
    var range = axis.range();
    var crossingValue = axis.options.reverse ? range.max : range.min;
    var slot = axis.getSlot(crossingValue);
    var center = this.polarAxis.getSlot(0).center;
    var axisBox = axis.box.translate(
      center.x - slot.x1,
      center.y - slot.y1
    );
    axis.reflow(axisBox);
  };
  PolarPlotAreaBase2.prototype.createValueAxis = function createValueAxis() {
    var tracker = this.valueAxisRangeTracker;
    var defaultRange = tracker.query();
    var axisOptions2 = this.valueAxisOptions({
      roundToMajorUnit: false,
      zIndex: -1
    });
    var axisType, axisDefaultRange;
    if (axisOptions2.type === LOGARITHMIC) {
      axisType = radar_logarithmic_axis_default;
      axisDefaultRange = { min: 0.1, max: 1 };
    } else {
      axisType = radar_numeric_axis_default;
      axisDefaultRange = { min: 0, max: 1 };
    }
    var range = tracker.query(name) || defaultRange || axisDefaultRange;
    if (range && defaultRange) {
      range.min = Math.min(range.min, defaultRange.min);
      range.max = Math.max(range.max, defaultRange.max);
    }
    var valueAxis = new axisType(
      range.min,
      range.max,
      axisOptions2,
      this.chartService
    );
    this.valueAxis = valueAxis;
    this.appendAxis(valueAxis);
  };
  PolarPlotAreaBase2.prototype.reflowAxes = function reflowAxes() {
    var ref2 = this;
    var options2 = ref2.options.plotArea;
    var valueAxis = ref2.valueAxis;
    var polarAxis = ref2.polarAxis;
    var box = ref2.box;
    var defaultPadding = Math.min(box.width(), box.height()) * DEFAULT_PADDING;
    var padding = getSpacing(options2.padding || {}, defaultPadding);
    var paddingBox = box.clone().unpad(padding);
    var axisBox = paddingBox.clone();
    axisBox.y2 = axisBox.y1 + Math.min(axisBox.width(), axisBox.height());
    axisBox.align(paddingBox, Y, CENTER);
    var valueAxisBox = axisBox.clone().shrink(0, axisBox.height() / 2);
    polarAxis.reflow(axisBox);
    valueAxis.reflow(valueAxisBox);
    var heightDiff = valueAxis.lineBox().height() - valueAxis.box.height();
    valueAxis.reflow(valueAxis.box.unpad({ top: heightDiff }));
    this.axisBox = axisBox;
    this.alignAxes(axisBox);
  };
  PolarPlotAreaBase2.prototype.backgroundBox = function backgroundBox() {
    return this.box;
  };
  PolarPlotAreaBase2.prototype.detachLabels = function detachLabels() {
  };
  return PolarPlotAreaBase2;
}(plotarea_base_default);
var polar_plotarea_base_default = PolarPlotAreaBase;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-scatter-chart/polar-scatter-chart.js
var PolarScatterChart = function(ScatterChart2) {
  function PolarScatterChart2() {
    ScatterChart2.apply(this, arguments);
  }
  if (ScatterChart2)
    PolarScatterChart2.__proto__ = ScatterChart2;
  PolarScatterChart2.prototype = Object.create(ScatterChart2 && ScatterChart2.prototype);
  PolarScatterChart2.prototype.constructor = PolarScatterChart2;
  PolarScatterChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    var valueRadius = slotX.center.y - slotY.y1;
    var slot = point_default2.onCircle(slotX.center, slotX.startAngle, valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  return PolarScatterChart2;
}(scatter_chart_default);
setDefaultOptions(PolarScatterChart, {
  clip: false
});
var polar_scatter_chart_default = PolarScatterChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-line-chart/polar-line-chart.js
var PolarLineChart = function(ScatterLineChart2) {
  function PolarLineChart2() {
    ScatterLineChart2.apply(this, arguments);
  }
  if (ScatterLineChart2)
    PolarLineChart2.__proto__ = ScatterLineChart2;
  PolarLineChart2.prototype = Object.create(ScatterLineChart2 && ScatterLineChart2.prototype);
  PolarLineChart2.prototype.constructor = PolarLineChart2;
  return PolarLineChart2;
}(scatter_line_chart_default);
PolarLineChart.prototype.pointSlot = polar_scatter_chart_default.prototype.pointSlot;
setDefaultOptions(PolarLineChart, {
  clip: false
});
var polar_line_chart_default = PolarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/spline-polar-area-segment.js
var SplinePolarAreaSegment = function(SplineAreaSegment2) {
  function SplinePolarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplinePolarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplinePolarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplinePolarAreaSegment2.prototype.constructor = SplinePolarAreaSegment2;
  SplinePolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var center = this._polarAxisCenter();
    fillPath.lineTo(center.x, center.y);
  };
  SplinePolarAreaSegment2.prototype._polarAxisCenter = function _polarAxisCenter() {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    return center;
  };
  SplinePolarAreaSegment2.prototype.strokeSegments = function strokeSegments() {
    var segments = this._strokeSegments;
    if (!segments) {
      var center = this._polarAxisCenter();
      var curveProcessor = new curve_processor_default(false);
      var linePoints = this.points();
      linePoints.push(center);
      segments = this._strokeSegments = curveProcessor.process(linePoints);
      segments.pop();
    }
    return segments;
  };
  return SplinePolarAreaSegment2;
}(spline_area_segment_default);
var spline_polar_area_segment_default = SplinePolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-segment.js
var PolarAreaSegment = function(AreaSegment2) {
  function PolarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    PolarAreaSegment2.__proto__ = AreaSegment2;
  PolarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  PolarAreaSegment2.prototype.constructor = PolarAreaSegment2;
  PolarAreaSegment2.prototype.fillToAxes = function fillToAxes(fillPath) {
    var polarAxis = this.parent.plotArea.polarAxis;
    var center = polarAxis.box.center();
    var centerSegment = new geometry_exports.Segment([center.x, center.y]);
    fillPath.segments.unshift(centerSegment);
    fillPath.segments.push(centerSegment);
  };
  return PolarAreaSegment2;
}(area_segment_default);
var polar_area_segment_default = PolarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/polar-area-chart/polar-area-chart.js
var PolarAreaChart = function(PolarLineChart2) {
  function PolarAreaChart2() {
    PolarLineChart2.apply(this, arguments);
  }
  if (PolarLineChart2)
    PolarAreaChart2.__proto__ = PolarLineChart2;
  PolarAreaChart2.prototype = Object.create(PolarLineChart2 && PolarLineChart2.prototype);
  PolarAreaChart2.prototype.constructor = PolarAreaChart2;
  PolarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = (currentSeries.line || {}).style;
    var segment;
    if (style === SMOOTH) {
      segment = new spline_polar_area_segment_default(linePoints, currentSeries, seriesIx);
    } else {
      segment = new polar_area_segment_default(linePoints, currentSeries, seriesIx);
    }
    return segment;
  };
  PolarAreaChart2.prototype.createMissingValue = function createMissingValue(value, missingValues) {
    var missingValue;
    if (hasValue(value.x) && missingValues !== INTERPOLATE) {
      missingValue = {
        x: value.x,
        y: value.y
      };
      if (missingValues === ZERO2) {
        missingValue.y = 0;
      }
    }
    return missingValue;
  };
  PolarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  PolarAreaChart2.prototype._hasMissingValuesGap = function _hasMissingValuesGap() {
    var this$1 = this;
    var series = this.options.series;
    for (var idx = 0; idx < series.length; idx++) {
      if (this$1.seriesMissingValues(series[idx]) === GAP) {
        return true;
      }
    }
  };
  PolarAreaChart2.prototype.sortPoints = function sortPoints(points3) {
    var this$1 = this;
    points3.sort(xComparer);
    if (this._hasMissingValuesGap()) {
      for (var idx = 0; idx < points3.length; idx++) {
        var point2 = points3[idx];
        if (point2) {
          var value = point2.value;
          if (!hasValue(value.y) && this$1.seriesMissingValues(point2.series) === GAP) {
            delete points3[idx];
          }
        }
      }
    }
    return points3;
  };
  return PolarAreaChart2;
}(polar_line_chart_default);
function xComparer(a, b) {
  return a.value.x - b.value.x;
}
var polar_area_chart_default = PolarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/polar-plotarea.js
var PolarPlotArea = function(PolarPlotAreaBase2) {
  function PolarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    PolarPlotArea2.__proto__ = PolarPlotAreaBase2;
  PolarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  PolarPlotArea2.prototype.constructor = PolarPlotArea2;
  PolarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var polarAxis = new polar_axis_default(this.options.xAxis, this.chartService);
    this.polarAxis = polarAxis;
    this.axisX = polarAxis;
    this.appendAxis(polarAxis);
  };
  PolarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    return deepExtend(defaults, {
      majorGridLines: { type: ARC },
      minorGridLines: { type: ARC }
    }, this.options.yAxis);
  };
  PolarPlotArea2.prototype.createValueAxis = function createValueAxis() {
    PolarPlotAreaBase2.prototype.createValueAxis.call(this);
    this.axisY = this.valueAxis;
  };
  PolarPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    this.valueAxisRangeTracker.update(chart.yAxisRanges);
    plotarea_base_default.prototype.appendChart.call(this, chart, pane);
  };
  PolarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createLineChart(
      filterSeriesByType(series, [POLAR_LINE]),
      pane
    );
    this.createScatterChart(
      filterSeriesByType(series, [POLAR_SCATTER]),
      pane
    );
    this.createAreaChart(
      filterSeriesByType(series, [POLAR_AREA]),
      pane
    );
  };
  PolarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new polar_line_chart_default(this, { series });
    this.appendChart(lineChart, pane);
  };
  PolarPlotArea2.prototype.createScatterChart = function createScatterChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var scatterChart = new polar_scatter_chart_default(this, { series });
    this.appendChart(scatterChart, pane);
  };
  PolarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new polar_area_chart_default(this, { series });
    this.appendChart(areaChart, pane);
  };
  PolarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var xValue = this.axisX.getValue(point2);
    var yValue = this.axisY.getValue(point2);
    if (xValue !== null && yValue !== null) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        x: xValue,
        y: yValue
      });
    }
  };
  PolarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return PolarPlotArea2;
}(polar_plotarea_base_default);
setDefaultOptions(PolarPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(PolarPlotArea.prototype, plotarea_events_mixin_default);
var polar_plotarea_default = PolarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-line-chart/radar-line-chart.js
function groupBySeriesIx(segments) {
  var seriesSegments = [];
  for (var idx = 0; idx < segments.length; idx++) {
    var segment = segments[idx];
    seriesSegments[segment.seriesIx] = seriesSegments[segment.seriesIx] || [];
    seriesSegments[segment.seriesIx].push(segment);
  }
  return seriesSegments;
}
var RadarLineChart = function(LineChart2) {
  function RadarLineChart2() {
    LineChart2.apply(this, arguments);
  }
  if (LineChart2)
    RadarLineChart2.__proto__ = LineChart2;
  RadarLineChart2.prototype = Object.create(LineChart2 && LineChart2.prototype);
  RadarLineChart2.prototype.constructor = RadarLineChart2;
  RadarLineChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var valueRadius = categorySlot.center.y - valueSlot.y1;
    var slot = point_default2.onCircle(categorySlot.center, categorySlot.middle(), valueRadius);
    return new box_default(slot.x, slot.y, slot.x, slot.y);
  };
  RadarLineChart2.prototype.renderSegments = function renderSegments() {
    LineChart2.prototype.renderSegments.call(this);
    if (this._segments && this._segments.length > 1) {
      var seriesSegments = groupBySeriesIx(this._segments);
      for (var idx = 0; idx < seriesSegments.length; idx++) {
        var segments = seriesSegments[idx];
        if (segments && segments.length > 1) {
          var firstPoint = segments[0].linePoints[0];
          var lastSegment = last2(segments);
          var lastPoint = last2(lastSegment.linePoints);
          var isFirstDataPoint = firstPoint.categoryIx === 0;
          var isLastDataPoint = lastPoint.categoryIx === lastPoint.categoriesCount - 1;
          if (isFirstDataPoint && isLastDataPoint) {
            last2(segments).linePoints.push(firstPoint);
          }
        }
      }
    }
  };
  RadarLineChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx) {
    var style = currentSeries.style;
    var pointType;
    if (style === SMOOTH) {
      pointType = spline_segment_default;
    } else {
      pointType = line_segment_default;
    }
    var segment = new pointType(linePoints, currentSeries, seriesIx);
    var missingValues = this.seriesMissingValues(currentSeries);
    if (linePoints.length === currentSeries.data.length || missingValues === INTERPOLATE) {
      segment.options.closed = true;
    }
    return segment;
  };
  return RadarLineChart2;
}(line_chart_default);
setDefaultOptions(RadarLineChart, {
  clip: false,
  limitPoints: false
});
var radar_line_chart_default = RadarLineChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/spline-radar-area-segment.js
var SplineRadarAreaSegment = function(SplineAreaSegment2) {
  function SplineRadarAreaSegment2() {
    SplineAreaSegment2.apply(this, arguments);
  }
  if (SplineAreaSegment2)
    SplineRadarAreaSegment2.__proto__ = SplineAreaSegment2;
  SplineRadarAreaSegment2.prototype = Object.create(SplineAreaSegment2 && SplineAreaSegment2.prototype);
  SplineRadarAreaSegment2.prototype.constructor = SplineRadarAreaSegment2;
  SplineRadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return SplineRadarAreaSegment2;
}(spline_area_segment_default);
var spline_radar_area_segment_default = SplineRadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-segment.js
var RadarAreaSegment = function(AreaSegment2) {
  function RadarAreaSegment2() {
    AreaSegment2.apply(this, arguments);
  }
  if (AreaSegment2)
    RadarAreaSegment2.__proto__ = AreaSegment2;
  RadarAreaSegment2.prototype = Object.create(AreaSegment2 && AreaSegment2.prototype);
  RadarAreaSegment2.prototype.constructor = RadarAreaSegment2;
  RadarAreaSegment2.prototype.fillToAxes = function fillToAxes() {
  };
  return RadarAreaSegment2;
}(area_segment_default);
var radar_area_segment_default = RadarAreaSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-area-chart/radar-area-chart.js
var RadarAreaChart = function(RadarLineChart2) {
  function RadarAreaChart2() {
    RadarLineChart2.apply(this, arguments);
  }
  if (RadarLineChart2)
    RadarAreaChart2.__proto__ = RadarLineChart2;
  RadarAreaChart2.prototype = Object.create(RadarLineChart2 && RadarLineChart2.prototype);
  RadarAreaChart2.prototype.constructor = RadarAreaChart2;
  RadarAreaChart2.prototype.createSegment = function createSegment(linePoints, currentSeries, seriesIx, prevSegment) {
    var isStacked = this.options.isStacked;
    var style = (currentSeries.line || {}).style;
    var previousSegment;
    var stackPoints;
    var segment;
    if (isStacked && seriesIx > 0 && prevSegment) {
      stackPoints = prevSegment.linePoints.slice(0);
      previousSegment = prevSegment;
    }
    if (style === SMOOTH) {
      segment = new spline_radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
      segment.options.closed = true;
    } else {
      linePoints.push(linePoints[0]);
      segment = new radar_area_segment_default(linePoints, currentSeries, seriesIx, previousSegment, stackPoints);
    }
    return segment;
  };
  RadarAreaChart2.prototype.seriesMissingValues = function seriesMissingValues2(series) {
    return series.missingValues || ZERO2;
  };
  return RadarAreaChart2;
}(radar_line_chart_default);
var radar_area_chart_default = RadarAreaChart;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-segment.js
var RadarSegment = function(DonutSegment2) {
  function RadarSegment2(value, options2) {
    DonutSegment2.call(this, value, null, options2);
  }
  if (DonutSegment2)
    RadarSegment2.__proto__ = DonutSegment2;
  RadarSegment2.prototype = Object.create(DonutSegment2 && DonutSegment2.prototype);
  RadarSegment2.prototype.constructor = RadarSegment2;
  return RadarSegment2;
}(donut_segment_default);
setDefaultOptions(RadarSegment, {
  overlay: {
    gradient: "none"
  },
  labels: {
    distance: 10
  }
});
var radar_segment_default = RadarSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-cluster-layout.js
var RadarClusterLayout = function(ChartElement2) {
  function RadarClusterLayout2(options2) {
    ChartElement2.call(this, options2);
    this.forEach = options2.rtl ? forEachReverse2 : forEach2;
  }
  if (ChartElement2)
    RadarClusterLayout2.__proto__ = ChartElement2;
  RadarClusterLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarClusterLayout2.prototype.constructor = RadarClusterLayout2;
  RadarClusterLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var options2 = ref2.options;
    var children = ref2.children;
    var gap = options2.gap;
    var spacing = options2.spacing;
    var count = children.length;
    var slots = count + gap + spacing * (count - 1);
    var slotAngle = sector.angle / slots;
    var angle = sector.startAngle + slotAngle * (gap / 2);
    this.forEach(children, function(child) {
      var slotSector = sector.clone();
      slotSector.startAngle = angle;
      slotSector.angle = slotAngle;
      if (child.sector) {
        slotSector.radius = child.sector.radius;
      }
      child.reflow(slotSector);
      child.sector = slotSector;
      angle += slotAngle + slotAngle * spacing;
    });
  };
  return RadarClusterLayout2;
}(chart_element_default);
setDefaultOptions(RadarClusterLayout, {
  gap: 1,
  spacing: 0
});
var radar_cluster_layout_default = RadarClusterLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/layout/radar-stack-layout.js
var RadarStackLayout = function(ChartElement2) {
  function RadarStackLayout2() {
    ChartElement2.apply(this, arguments);
  }
  if (ChartElement2)
    RadarStackLayout2.__proto__ = ChartElement2;
  RadarStackLayout2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  RadarStackLayout2.prototype.constructor = RadarStackLayout2;
  RadarStackLayout2.prototype.reflow = function reflow(sector) {
    var ref2 = this;
    var reverse = ref2.options.reverse;
    var children = ref2.children;
    var childrenCount = children.length;
    var first = reverse ? childrenCount - 1 : 0;
    var step = reverse ? -1 : 1;
    this.box = new box_default();
    for (var i = first; i >= 0 && i < childrenCount; i += step) {
      var childSector = children[i].sector;
      childSector.startAngle = sector.startAngle;
      childSector.angle = sector.angle;
    }
  };
  return RadarStackLayout2;
}(chart_element_default);
var radar_stack_layout_default = RadarStackLayout;

// node_modules/@progress/kendo-charts/dist/es/chart/radar-bar-chart/radar-bar-chart.js
var RadarBarChart = function(BarChart2) {
  function RadarBarChart2() {
    BarChart2.apply(this, arguments);
  }
  if (BarChart2)
    RadarBarChart2.__proto__ = BarChart2;
  RadarBarChart2.prototype = Object.create(BarChart2 && BarChart2.prototype);
  RadarBarChart2.prototype.constructor = RadarBarChart2;
  RadarBarChart2.prototype.pointType = function pointType() {
    return radar_segment_default;
  };
  RadarBarChart2.prototype.clusterType = function clusterType() {
    return radar_cluster_layout_default;
  };
  RadarBarChart2.prototype.stackType = function stackType() {
    return radar_stack_layout_default;
  };
  RadarBarChart2.prototype.categorySlot = function categorySlot(categoryAxis, categoryIx) {
    return categoryAxis.getSlot(categoryIx);
  };
  RadarBarChart2.prototype.pointSlot = function pointSlot(categorySlot, valueSlot) {
    var slot = categorySlot.clone();
    var y = categorySlot.center.y;
    slot.radius = y - valueSlot.y1;
    slot.innerRadius = y - valueSlot.y2;
    return slot;
  };
  RadarBarChart2.prototype.reflowPoint = function reflowPoint(point2, pointSlot) {
    point2.sector = pointSlot;
    point2.reflow();
  };
  RadarBarChart2.prototype.createAnimation = function createAnimation() {
    this.options.animation.center = this.box.toRect().center();
    BarChart2.prototype.createAnimation.call(this);
  };
  return RadarBarChart2;
}(bar_chart_default);
RadarBarChart.prototype.reflow = categorical_chart_default.prototype.reflow;
setDefaultOptions(RadarBarChart, {
  clip: false,
  limitPoints: false,
  animation: {
    type: "pie"
  }
});
var radar_bar_chart_default = RadarBarChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/radar-plotarea.js
var RadarPlotArea = function(PolarPlotAreaBase2) {
  function RadarPlotArea2() {
    PolarPlotAreaBase2.apply(this, arguments);
  }
  if (PolarPlotAreaBase2)
    RadarPlotArea2.__proto__ = PolarPlotAreaBase2;
  RadarPlotArea2.prototype = Object.create(PolarPlotAreaBase2 && PolarPlotAreaBase2.prototype);
  RadarPlotArea2.prototype.constructor = RadarPlotArea2;
  RadarPlotArea2.prototype.createPolarAxis = function createPolarAxis() {
    var categoryAxis = new radar_category_axis_default(this.options.categoryAxis, this.chartService);
    this.polarAxis = categoryAxis;
    this.categoryAxis = categoryAxis;
    this.appendAxis(categoryAxis);
    this.aggregateCategories();
    this.createCategoryAxesLabels();
  };
  RadarPlotArea2.prototype.valueAxisOptions = function valueAxisOptions(defaults) {
    if (this._hasBarCharts) {
      deepExtend(defaults, {
        majorGridLines: { type: ARC },
        minorGridLines: { type: ARC }
      });
    }
    if (this._isStacked100) {
      deepExtend(defaults, {
        roundToMajorUnit: false,
        labels: { format: "P0" }
      });
    }
    return deepExtend(defaults, this.options.valueAxis);
  };
  RadarPlotArea2.prototype.aggregateCategories = function aggregateCategories() {
    categorical_plotarea_default.prototype.aggregateCategories.call(this, this.panes);
  };
  RadarPlotArea2.prototype.createCategoryAxesLabels = function createCategoryAxesLabels() {
    categorical_plotarea_default.prototype.createCategoryAxesLabels.call(this, this.panes);
  };
  RadarPlotArea2.prototype.filterSeries = function filterSeries(currentSeries) {
    return currentSeries;
  };
  RadarPlotArea2.prototype.createCharts = function createCharts() {
    var series = this.filterVisibleSeries(this.series);
    var pane = this.panes[0];
    this.createAreaChart(
      filterSeriesByType(series, [RADAR_AREA]),
      pane
    );
    this.createLineChart(
      filterSeriesByType(series, [RADAR_LINE]),
      pane
    );
    this.createBarChart(
      filterSeriesByType(series, [RADAR_COLUMN]),
      pane
    );
  };
  RadarPlotArea2.prototype.chartOptions = function chartOptions(series) {
    var options2 = { series };
    var firstSeries = series[0];
    if (firstSeries) {
      var filteredSeries = this.filterVisibleSeries(series);
      var stack2 = firstSeries.stack;
      options2.isStacked = stack2 && filteredSeries.length > 1;
      options2.isStacked100 = stack2 && stack2.type === "100%" && filteredSeries.length > 1;
      if (options2.isStacked100) {
        this._isStacked100 = true;
      }
    }
    return options2;
  };
  RadarPlotArea2.prototype.createAreaChart = function createAreaChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var areaChart = new radar_area_chart_default(this, this.chartOptions(series));
    this.appendChart(areaChart, pane);
  };
  RadarPlotArea2.prototype.createLineChart = function createLineChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var lineChart = new radar_line_chart_default(this, this.chartOptions(series));
    this.appendChart(lineChart, pane);
  };
  RadarPlotArea2.prototype.createBarChart = function createBarChart(series, pane) {
    if (series.length === 0) {
      return;
    }
    var firstSeries = series[0];
    var options2 = this.chartOptions(series);
    options2.gap = firstSeries.gap;
    options2.spacing = firstSeries.spacing;
    var barChart = new radar_bar_chart_default(this, options2);
    this.appendChart(barChart, pane);
    this._hasBarCharts = true;
  };
  RadarPlotArea2.prototype.seriesCategoryAxis = function seriesCategoryAxis() {
    return this.categoryAxis;
  };
  RadarPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var category = this.categoryAxis.getCategory(point2);
    var value = this.valueAxis.getValue(point2);
    if (category !== null && value !== null) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        category,
        value
      });
    }
  };
  RadarPlotArea2.prototype.createCrosshairs = function createCrosshairs() {
  };
  return RadarPlotArea2;
}(polar_plotarea_base_default);
deepExtend(RadarPlotArea.prototype, plotarea_events_mixin_default, {
  appendChart: categorical_plotarea_default.prototype.appendChart,
  aggregateSeries: categorical_plotarea_default.prototype.aggregateSeries,
  seriesSourcePoints: categorical_plotarea_default.prototype.seriesSourcePoints
});
setDefaultOptions(RadarPlotArea, {
  categoryAxis: {
    categories: []
  },
  valueAxis: {}
});
var radar_plotarea_default = RadarPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-segment.js
var FunnelSegment = function(ChartElement2) {
  function FunnelSegment2(value, options2, segmentOptions) {
    ChartElement2.call(this, options2);
    this.value = value;
    this.options.index = segmentOptions.index;
  }
  if (ChartElement2)
    FunnelSegment2.__proto__ = ChartElement2;
  FunnelSegment2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelSegment2.prototype.constructor = FunnelSegment2;
  FunnelSegment2.prototype.reflow = function reflow(chartBox) {
    var points3 = this.points;
    var label = this.children[0];
    this.box = new box_default(points3[0].x, points3[0].y, points3[1].x, points3[2].y);
    if (label) {
      label.reflow(new box_default(chartBox.x1, points3[0].y, chartBox.x2, points3[2].y));
    }
  };
  FunnelSegment2.prototype.createVisual = function createVisual() {
    var this$1 = this;
    var options2 = this.options;
    var visual;
    ChartElement2.prototype.createVisual.call(this);
    if (options2.visual) {
      visual = options2.visual({
        category: this.category,
        dataItem: this.dataItem,
        value: this.value,
        series: this.series,
        percentage: this.percentage,
        points: this.points,
        options: options2,
        sender: this.getSender(),
        createVisual: function() {
          return this$1.createPath();
        }
      });
    } else {
      visual = this.createPath();
    }
    if (visual) {
      this.visual.append(visual);
    }
  };
  FunnelSegment2.prototype.createPath = function createPath() {
    var options2 = this.options;
    var border = options2.border;
    var path = drawing_exports.Path.fromPoints(this.points, {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: {
        color: border.color,
        opacity: border.opacity,
        width: border.width
      }
    }).close();
    return path;
  };
  FunnelSegment2.prototype.createHighlight = function createHighlight(style) {
    return drawing_exports.Path.fromPoints(this.points, style);
  };
  FunnelSegment2.prototype.highlightVisual = function highlightVisual() {
    return this.visual.children[0];
  };
  FunnelSegment2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    var path = drawing_exports.Path.fromPoints(this.points).close();
    return {
      options: this.options,
      path
    };
  };
  FunnelSegment2.prototype.tooltipAnchor = function tooltipAnchor() {
    var box = this.box;
    return {
      point: new point_default2(box.center().x, box.y1),
      align: {
        horizontal: "center",
        vertical: "top"
      }
    };
  };
  FunnelSegment2.prototype.formatValue = function formatValue(format2) {
    var point2 = this;
    return point2.owner.formatPointValue(point2, format2);
  };
  return FunnelSegment2;
}(chart_element_default);
setDefaultOptions(FunnelSegment, {
  color: WHITE,
  border: {
    width: 1
  }
});
deepExtend(FunnelSegment.prototype, point_events_mixin_default);
var funnel_segment_default = FunnelSegment;

// node_modules/@progress/kendo-charts/dist/es/chart/funnel-chart/funnel-chart.js
var FunnelChart = function(ChartElement2) {
  function FunnelChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.points = [];
    this.labels = [];
    this.legendItems = [];
    this.render();
  }
  if (ChartElement2)
    FunnelChart2.__proto__ = ChartElement2;
  FunnelChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  FunnelChart2.prototype.constructor = FunnelChart2;
  FunnelChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    return this.chartService.format.auto(format2, point2.value);
  };
  FunnelChart2.prototype.render = function render3() {
    var this$1 = this;
    var ref2 = this;
    var options2 = ref2.options;
    var seriesColors = ref2.plotArea.options.seriesColors;
    if (seriesColors === void 0)
      seriesColors = [];
    var series = options2.series[0];
    var data = series.data;
    if (!data) {
      return;
    }
    var ref$1 = bindSegments(series);
    var total3 = ref$1.total;
    var points3 = ref$1.points;
    for (var i = 0; i < points3.length; i++) {
      var pointData = points3[i];
      if (!pointData) {
        continue;
      }
      var fields = pointData.fields;
      if (!isFunction3(series.color)) {
        series.color = fields.color || seriesColors[i % seriesColors.length];
      }
      fields = deepExtend({
        index: i,
        owner: this$1,
        series,
        dataItem: data[i],
        percentage: pointData.value / total3
      }, fields, { visible: pointData.visible });
      var value = pointData.valueFields.value;
      var segment = this$1.createSegment(value, fields);
      var label = this$1.createLabel(value, fields);
      if (segment && label) {
        segment.append(label);
      }
    }
  };
  FunnelChart2.prototype.evalSegmentOptions = function evalSegmentOptions(options2, value, fields) {
    var series = fields.series;
    evalOptions(options2, {
      value,
      series,
      dataItem: fields.dataItem,
      index: fields.index
    }, { defaults: series._defaults, excluded: ["data", "content", "template", "toggle", "visual"] });
  };
  FunnelChart2.prototype.createSegment = function createSegment(value, fields) {
    var seriesOptions = deepExtend({}, fields.series);
    this.evalSegmentOptions(seriesOptions, value, fields);
    this.createLegendItem(value, seriesOptions, fields);
    if (fields.visible !== false) {
      var segment = new funnel_segment_default(value, seriesOptions, fields);
      Object.assign(segment, fields);
      this.append(segment);
      this.points.push(segment);
      return segment;
    }
  };
  FunnelChart2.prototype.createLabel = function createLabel(value, fields) {
    var series = fields.series;
    var dataItem = fields.dataItem;
    var labels = deepExtend({}, this.options.labels, series.labels);
    var text = value;
    if (labels.visible) {
      var labelTemplate = getTemplate(labels);
      var data = {
        dataItem,
        value,
        percentage: fields.percentage,
        category: fields.category,
        series
      };
      if (labelTemplate) {
        text = labelTemplate(data);
      } else if (labels.format) {
        text = this.plotArea.chartService.format.auto(labels.format, text);
      }
      if (!labels.color) {
        labels.color = auto_text_color_default(series.color);
        if (!labels.background) {
          labels.background = series.color;
        }
      }
      this.evalSegmentOptions(labels, value, fields);
      var textBox = new text_box_default(text, deepExtend({
        vAlign: labels.position
      }, labels), data);
      this.labels.push(textBox);
      return textBox;
    }
  };
  FunnelChart2.prototype.labelPadding = function labelPadding() {
    var labels = this.labels;
    var padding = { left: 0, right: 0 };
    for (var i = 0; i < labels.length; i++) {
      var label = labels[i];
      var align2 = label.options.align;
      if (align2 !== CENTER) {
        var width = labels[i].box.width();
        if (align2 === LEFT) {
          padding.left = Math.max(padding.left, width);
        } else {
          padding.right = Math.max(padding.right, width);
        }
      }
    }
    return padding;
  };
  FunnelChart2.prototype.dynamicSlopeReflow = function dynamicSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var firstSegment = segments[0];
    var maxSegment = firstSegment;
    for (var idx = 0; idx < segments.length; idx++) {
      if (segments[idx].percentage > maxSegment.percentage) {
        maxSegment = segments[idx];
      }
    }
    var lastUpperSide = firstSegment.percentage / maxSegment.percentage * width;
    var previousOffset = (width - lastUpperSide) / 2;
    var previousHeight = 0;
    for (var idx$1 = 0; idx$1 < count; idx$1++) {
      var percentage = segments[idx$1].percentage;
      var nextSegment = segments[idx$1 + 1];
      var nextPercentage = nextSegment ? nextSegment.percentage : percentage;
      var points3 = segments[idx$1].points = [];
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      var offset = void 0;
      if (!percentage) {
        offset = nextPercentage ? 0 : width / 2;
      } else {
        offset = (width - lastUpperSide * (nextPercentage / percentage)) / 2;
      }
      offset = limitValue2(offset, 0, width);
      points3.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - offset, box.y1 + height + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + offset, box.y1 + height + previousHeight));
      previousOffset = offset;
      previousHeight += height + options2.segmentSpacing;
      lastUpperSide = limitValue2(width - 2 * offset, 0, width);
    }
  };
  FunnelChart2.prototype.constantSlopeReflow = function constantSlopeReflow(box, width, totalHeight) {
    var ref2 = this;
    var options2 = ref2.options;
    var segments = ref2.points;
    var count = segments.length;
    var decreasingWidth = options2.neckRatio <= 1;
    var neckRatio = decreasingWidth ? options2.neckRatio * width : width;
    var previousOffset = decreasingWidth ? 0 : (width - width / options2.neckRatio) / 2;
    var topMostWidth = decreasingWidth ? width : width - previousOffset * 2;
    var finalNarrow = (topMostWidth - neckRatio) / 2;
    var previousHeight = 0;
    for (var idx = 0; idx < count; idx++) {
      var points3 = segments[idx].points = [];
      var percentage = segments[idx].percentage;
      var offset = options2.dynamicHeight ? finalNarrow * percentage : finalNarrow / count;
      var height = options2.dynamicHeight ? totalHeight * percentage : totalHeight / count;
      points3.push(new geometry_exports.Point(box.x1 + previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset, box.y1 + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + width - previousOffset - offset, box.y1 + height + previousHeight));
      points3.push(new geometry_exports.Point(box.x1 + previousOffset + offset, box.y1 + height + previousHeight));
      previousOffset += offset;
      previousHeight += height + options2.segmentSpacing;
    }
  };
  FunnelChart2.prototype.reflow = function reflow(chartBox) {
    var points3 = this.points;
    var count = points3.length;
    if (!count) {
      return;
    }
    var options2 = this.options;
    var box = chartBox.clone().unpad(this.labelPadding());
    var totalHeight = box.height() - options2.segmentSpacing * (count - 1);
    var width = box.width();
    if (options2.dynamicSlope) {
      this.dynamicSlopeReflow(box, width, totalHeight);
    } else {
      this.constantSlopeReflow(box, width, totalHeight);
    }
    for (var idx = 0; idx < count; idx++) {
      points3[idx].reflow(chartBox);
    }
  };
  return FunnelChart2;
}(chart_element_default);
setDefaultOptions(FunnelChart, {
  neckRatio: 0.3,
  width: 300,
  dynamicSlope: false,
  dynamicHeight: true,
  segmentSpacing: 0,
  labels: {
    visible: false,
    align: CENTER,
    position: CENTER,
    zIndex: 1
  }
});
deepExtend(FunnelChart.prototype, pie_chart_mixin_default);
var funnel_chart_default = FunnelChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/funnel-plotarea.js
var FunnelPlotArea = function(PlotAreaBase2) {
  function FunnelPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    FunnelPlotArea2.__proto__ = PlotAreaBase2;
  FunnelPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  FunnelPlotArea2.prototype.constructor = FunnelPlotArea2;
  FunnelPlotArea2.prototype.render = function render3() {
    this.createFunnelChart(this.series);
  };
  FunnelPlotArea2.prototype.createFunnelChart = function createFunnelChart(series) {
    var firstSeries = series[0];
    var funnelChart = new funnel_chart_default(this, {
      series,
      legend: this.options.legend,
      neckRatio: firstSeries.neckRatio,
      dynamicHeight: firstSeries.dynamicHeight,
      dynamicSlope: firstSeries.dynamicSlope,
      segmentSpacing: firstSeries.segmentSpacing,
      highlight: firstSeries.highlight
    });
    this.appendChart(funnelChart);
  };
  FunnelPlotArea2.prototype.appendChart = function appendChart(chart, pane) {
    PlotAreaBase2.prototype.appendChart.call(this, chart, pane);
    append2(this.options.legend.items, chart.legendItems);
  };
  return FunnelPlotArea2;
}(plotarea_base_default);
var funnel_plotarea_default = FunnelPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/color-scale.js
var colorScale = function(color, minLightnessOffset) {
  if (minLightnessOffset === void 0)
    minLightnessOffset = 0.05;
  var baseColor = parseColor(color);
  var offset = 1 - minLightnessOffset;
  return function(value) {
    var hsl = baseColor.toHSL();
    var range = 100 - hsl.l;
    var point2 = offset - value;
    hsl.l += Math.min(point2 * range, range);
    return hsl.toCss();
  };
};
var color_scale_default = colorScale;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-point.js
var HeatmapPoint = function(ChartElement2) {
  function HeatmapPoint2(value, options2) {
    ChartElement2.call(this);
    this.options = options2;
    this.color = options2.color || WHITE;
    this.value = value;
  }
  if (ChartElement2)
    HeatmapPoint2.__proto__ = ChartElement2;
  HeatmapPoint2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapPoint2.prototype.constructor = HeatmapPoint2;
  HeatmapPoint2.prototype.render = function render3() {
    if (this._rendered) {
      return;
    }
    this._rendered = true;
    this.createMarker();
    this.createLabel();
    this.createNote();
  };
  HeatmapPoint2.prototype.createLabel = function createLabel() {
    var options2 = this.options;
    var labels = options2.labels;
    if (labels.visible) {
      var pointData = this.pointData();
      var labelTemplate = getTemplate(labels);
      var labelText;
      var labelColor = labels.color;
      if (labelTemplate) {
        labelText = labelTemplate(pointData);
      } else {
        labelText = this.formatValue(labels.format);
      }
      if (!labelColor) {
        labelColor = auto_text_color_default(this.color);
      }
      this.label = new text_box_default(
        labelText,
        deepExtend(
          {
            align: CENTER,
            vAlign: CENTER,
            margin: {
              left: 5,
              right: 5
            },
            zIndex: valueOrDefault2(labels.zIndex, this.series.zIndex)
          },
          labels,
          {
            color: labelColor
          }
        ),
        pointData
      );
      this.append(this.label);
    }
  };
  HeatmapPoint2.prototype.formatValue = function formatValue(format2) {
    return this.owner.formatPointValue(this, format2);
  };
  HeatmapPoint2.prototype.reflow = function reflow(targetBox) {
    this.render();
    var label = this.label;
    this.box = targetBox;
    if (label) {
      label.reflow(this.markerBox());
    }
    if (this.note) {
      this.note.reflow(targetBox);
    }
    this.marker.reflow(this.markerBox());
  };
  HeatmapPoint2.prototype.markerBox = function markerBox() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var rect = this.box.toRect();
    var type = valueOrDefault2(markers.type, "rect");
    var isRoundRect = type === ROUNDED_RECT;
    var borderWidth = valueOrDefault2(border.width, isRoundRect ? 1 : 0);
    var halfBorderWidth = Math.round(borderWidth / 2);
    if (markers.size) {
      var center = rect.center();
      rect.size.width = rect.size.height = markers.size;
      rect.origin.x = Math.round(center.x - rect.size.width / 2);
      rect.origin.y = Math.round(center.y - rect.size.height / 2);
    }
    rect.size.width -= borderWidth;
    rect.size.height -= borderWidth;
    rect.origin.y += halfBorderWidth + 0.5;
    rect.origin.x += halfBorderWidth + 0.5;
    return rectToBox(rect);
  };
  HeatmapPoint2.prototype.markerBorder = function markerBorder() {
    var options2 = this.options;
    var markers = options2.markers;
    var border = markers.border;
    var opacity = valueOrDefault2(border.opacity, options2.opacity);
    return {
      color: border.color || this.color,
      width: border.width,
      opacity,
      dashType: border.dashType
    };
  };
  HeatmapPoint2.prototype.createMarker = function createMarker() {
    var options2 = this.options;
    var markerOptions = options2.markers;
    var marker = new shape_element_default({
      type: valueOrDefault2(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex),
      animation: options2.animation,
      visual: options2.visual
    }, {
      dataItem: this.dataItem,
      value: this.value,
      series: this.series,
      category: this.category
    });
    this.marker = marker;
    this.append(marker);
  };
  HeatmapPoint2.prototype.createHighlight = function createHighlight(style) {
    var options2 = this.options;
    var markerOptions = this.options.highlight.markers || this.options.markers;
    var highlight = new shape_element_default({
      type: valueOrDefault2(markerOptions.type, "rect"),
      width: markerOptions.size,
      height: markerOptions.size,
      rotation: markerOptions.rotation,
      background: markerOptions.color || this.color,
      border: this.markerBorder(),
      borderRadius: markerOptions.borderRadius,
      opacity: this.series.opacity || options2.opacity,
      zIndex: valueOrDefault2(options2.zIndex, this.series.zIndex)
    });
    highlight.reflow(this.markerBox());
    var visual = highlight.getElement();
    visual.options.fill = style.fill;
    visual.options.stroke = style.stroke;
    return visual;
  };
  HeatmapPoint2.prototype.highlightVisual = function highlightVisual() {
    return this.rectVisual;
  };
  HeatmapPoint2.prototype.highlightVisualArgs = function highlightVisualArgs() {
    return {
      options: this.options,
      rect: this.box.toRect(),
      visual: this.rectVisual
    };
  };
  HeatmapPoint2.prototype.tooltipAnchor = function tooltipAnchor() {
    var left = this.box.center().x;
    var top = this.box.y1 - TOOLTIP_OFFSET;
    return {
      point: new point_default2(left, top),
      align: {
        horizontal: CENTER,
        vertical: BOTTOM
      }
    };
  };
  HeatmapPoint2.prototype.overlapsBox = function overlapsBox(box) {
    return this.box.overlaps(box);
  };
  HeatmapPoint2.prototype.unclipElements = function unclipElements() {
  };
  HeatmapPoint2.prototype.pointData = function pointData() {
    return {
      x: this.value.x,
      y: this.value.y,
      value: this.value.value,
      dataItem: this.dataItem,
      series: this.series
    };
  };
  return HeatmapPoint2;
}(chart_element_default);
deepExtend(HeatmapPoint.prototype, point_events_mixin_default);
deepExtend(HeatmapPoint.prototype, note_mixin_default);
HeatmapPoint.prototype.defaults = {
  markers: {
    type: "rect",
    borderRadius: 4,
    border: {
      color: "transparent"
    }
  },
  padding: { top: 1 },
  labels: {
    visible: false,
    padding: 3
  },
  opacity: 1,
  notes: {
    label: {}
  }
};
var heatmap_point_default = HeatmapPoint;

// node_modules/@progress/kendo-charts/dist/es/chart/heatmap-chart/heatmap-chart.js
var HeatmapChart = function(ChartElement2) {
  function HeatmapChart2(plotArea, options2) {
    ChartElement2.call(this, options2);
    this.plotArea = plotArea;
    this.chartService = plotArea.chartService;
    this._initFields();
    this.render();
  }
  if (ChartElement2)
    HeatmapChart2.__proto__ = ChartElement2;
  HeatmapChart2.prototype = Object.create(ChartElement2 && ChartElement2.prototype);
  HeatmapChart2.prototype.constructor = HeatmapChart2;
  HeatmapChart2.prototype._initFields = function _initFields() {
    this.points = [];
    this.seriesOptions = [];
    this.valueRange = { min: MAX_VALUE, max: MIN_VALUE };
    this._evalSeries = [];
  };
  HeatmapChart2.prototype.render = function render3() {
    this.setRange();
    this.traverseDataPoints(this.addValue.bind(this));
  };
  HeatmapChart2.prototype.setRange = function setRange() {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$1 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var valueFields = ref$1.valueFields;
        if (defined2(valueFields.value) && valueFields.value !== null) {
          this$1.valueRange.min = Math.min(this$1.valueRange.min, valueFields.value);
          this$1.valueRange.max = Math.max(this$1.valueRange.max, valueFields.value);
        }
      }
    }
  };
  HeatmapChart2.prototype.addValue = function addValue(value, fields) {
    var point2;
    if (value && defined2(value.value) && value.value !== null) {
      point2 = this.createPoint(value, fields);
      if (point2) {
        Object.assign(point2, fields);
      }
    }
    this.points.push(point2);
  };
  HeatmapChart2.prototype.evalPointOptions = function evalPointOptions(options2, value, fields) {
    var series = fields.series;
    var seriesIx = fields.seriesIx;
    var state = { defaults: series._defaults, excluded: ["data", "tooltip", "content", "template", "visual", "toggle"] };
    var doEval = this._evalSeries[seriesIx];
    if (!defined2(doEval)) {
      this._evalSeries[seriesIx] = doEval = evalOptions(options2, {}, state, true);
    }
    var pointOptions = options2;
    if (doEval) {
      pointOptions = deepExtend({}, options2);
      evalOptions(pointOptions, {
        value,
        series,
        dataItem: fields.dataItem,
        min: this.valueRange.min,
        max: this.valueRange.max
      }, state);
    }
    return pointOptions;
  };
  HeatmapChart2.prototype.pointType = function pointType() {
    return heatmap_point_default;
  };
  HeatmapChart2.prototype.pointOptions = function pointOptions(series, seriesIx) {
    var options2 = this.seriesOptions[seriesIx];
    if (!options2) {
      var defaults = this.pointType().prototype.defaults;
      this.seriesOptions[seriesIx] = options2 = deepExtend({}, defaults, {
        markers: {
          opacity: series.opacity
        },
        tooltip: {
          format: this.options.tooltip.format
        },
        labels: {
          format: this.options.labels.format
        }
      }, series);
    }
    return options2;
  };
  HeatmapChart2.prototype.createPoint = function createPoint(value, fields) {
    var series = fields.series;
    var pointOptions = this.pointOptions(series, fields.seriesIx);
    var color = fields.color || series.color;
    pointOptions = this.evalPointOptions(pointOptions, value, fields);
    if (isFunction3(series.color)) {
      color = pointOptions.color;
    } else if (this.valueRange.max !== 0) {
      var scale = color_scale_default(color);
      color = scale(value.value / this.valueRange.max);
    }
    var point2 = new heatmap_point_default(value, pointOptions);
    point2.color = color;
    this.append(point2);
    return point2;
  };
  HeatmapChart2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxisName = series.xAxis;
    var yAxisName = series.yAxis;
    var plotArea = this.plotArea;
    var xAxis = xAxisName ? plotArea.namedXAxes[xAxisName] : plotArea.axisX;
    var yAxis = yAxisName ? plotArea.namedYAxes[yAxisName] : plotArea.axisY;
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapChart2.prototype.reflow = function reflow(targetBox) {
    var this$1 = this;
    var chartPoints = this.points;
    var limit = !this.options.clip;
    var pointIx = 0;
    this.traverseDataPoints(function(value, fields) {
      var point2 = chartPoints[pointIx++];
      var ref2 = this$1.seriesAxes(fields.series);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var indexX = xAxis.categoryIndex(value.x);
      var indexY = yAxis.categoryIndex(value.y);
      var slotX = xAxis.getSlot(indexX, indexX, limit);
      var slotY = yAxis.getSlot(indexY, indexY, limit);
      if (point2) {
        if (slotX && slotY) {
          var pointSlot = this$1.pointSlot(slotX, slotY);
          point2.reflow(pointSlot);
        } else {
          point2.visible = false;
        }
      }
    });
    this.box = targetBox;
  };
  HeatmapChart2.prototype.pointSlot = function pointSlot(slotX, slotY) {
    return new box_default(slotX.x1, slotY.y1, slotX.x2, slotY.y2);
  };
  HeatmapChart2.prototype.traverseDataPoints = function traverseDataPoints(callback) {
    var this$1 = this;
    var ref2 = this;
    var series = ref2.options.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var ref$1 = this$1.seriesAxes(currentSeries);
      var xAxis = ref$1.xAxis;
      var yAxis = ref$1.yAxis;
      var xRange = xAxis.currentRangeIndices();
      var yRange = yAxis.currentRangeIndices();
      for (var pointIx = 0; pointIx < currentSeries.data.length; pointIx++) {
        var ref$2 = this$1._bindPoint(currentSeries, seriesIx, pointIx);
        var value = ref$2.valueFields;
        var fields = ref$2.fields;
        var xIndex = xAxis.totalIndex(value.x);
        var yIndex = yAxis.totalIndex(value.y);
        var xIn = xRange.min <= xIndex && xIndex <= xRange.max;
        var yIn = yRange.min <= yIndex && yIndex <= yRange.max;
        if (xIn && yIn) {
          callback(value, deepExtend({
            pointIx,
            series: currentSeries,
            seriesIx,
            dataItem: currentSeries.data[pointIx],
            owner: this$1
          }, fields));
        }
      }
    }
  };
  HeatmapChart2.prototype.formatPointValue = function formatPointValue(point2, format2) {
    var value = point2.value;
    return this.chartService.format.auto(format2, value.x, value.y, value.value);
  };
  HeatmapChart2.prototype.animationPoints = function animationPoints() {
    var points3 = this.points;
    var result = [];
    for (var idx = 0; idx < points3.length; idx++) {
      result.push((points3[idx] || {}).marker);
    }
    return result;
  };
  return HeatmapChart2;
}(chart_element_default);
setDefaultOptions(HeatmapChart, {
  series: [],
  tooltip: {
    format: "{0}, {1}: {2}"
  },
  labels: {
    format: "{2}"
  },
  clip: true
});
deepExtend(HeatmapChart.prototype, {
  _bindPoint: categorical_chart_default.prototype._bindPoint
});
var heatmap_chart_default = HeatmapChart;

// node_modules/@progress/kendo-charts/dist/es/chart/plotarea/heatmap-plotarea.js
var HeatmapPlotArea = function(PlotAreaBase2) {
  function HeatmapPlotArea2() {
    PlotAreaBase2.apply(this, arguments);
  }
  if (PlotAreaBase2)
    HeatmapPlotArea2.__proto__ = PlotAreaBase2;
  HeatmapPlotArea2.prototype = Object.create(PlotAreaBase2 && PlotAreaBase2.prototype);
  HeatmapPlotArea2.prototype.constructor = HeatmapPlotArea2;
  HeatmapPlotArea2.prototype.initFields = function initFields() {
    this.namedXAxes = {};
    this.namedYAxes = {};
  };
  HeatmapPlotArea2.prototype.render = function render3(panes) {
    if (panes === void 0)
      panes = this.panes;
    this.bindCategories();
    this.createAxes(panes);
    this.createCharts(panes);
    this.createAxisLabels();
  };
  HeatmapPlotArea2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var series = this.srcSeries || this.series;
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var data = currentSeries.data || [];
      var ref2 = this$1.seriesAxes(currentSeries);
      var xAxis = ref2.xAxis;
      var yAxis = ref2.yAxis;
      var xCategories = createHashSet(xAxis.categories || []);
      var yCategories = createHashSet(yAxis.categories || []);
      for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {
        var ref$1 = series_binder_default.current.bindPoint(currentSeries, pointIndex).valueFields;
        var x = ref$1.x;
        var y = ref$1.y;
        if (!xCategories.has(x)) {
          xCategories.add(x);
        }
        if (!yCategories.has(y)) {
          yCategories.add(y);
        }
      }
      xAxis.categories = xCategories.values();
      yAxis.categories = yCategories.values();
    }
  };
  HeatmapPlotArea2.prototype.createCharts = function createCharts(panes) {
    var this$1 = this;
    var seriesByPane = this.groupSeriesByPane();
    for (var i = 0; i < panes.length; i++) {
      var pane = panes[i];
      var paneSeries = seriesByPane[pane.options.name || "default"] || [];
      this$1.addToLegend(paneSeries);
      var filteredSeries = this$1.filterVisibleSeries(paneSeries);
      if (!filteredSeries) {
        continue;
      }
      this$1.createHeatmapChart(
        filterSeriesByType(filteredSeries, [HEATMAP]),
        pane
      );
    }
  };
  HeatmapPlotArea2.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {
    var chart = new heatmap_chart_default(this, {
      series
    });
    this.appendChart(chart, pane);
  };
  HeatmapPlotArea2.prototype.seriesPaneName = function seriesPaneName(series) {
    var options2 = this.options;
    var xAxisName = series.xAxis;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxis = grep(xAxisOptions, function(a) {
      return a.name === xAxisName;
    })[0];
    var yAxisName = series.yAxis;
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxis = grep(yAxisOptions, function(a) {
      return a.name === yAxisName;
    })[0];
    var panes = options2.panes || [{}];
    var defaultPaneName = panes[0].name || "default";
    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;
    return paneName;
  };
  HeatmapPlotArea2.prototype.seriesAxes = function seriesAxes(series) {
    var xAxis;
    var yAxis;
    var options2 = this.options;
    var xAxisOptions = [].concat(options2.xAxis);
    var xAxisName = series.xAxis;
    if (xAxisName) {
      xAxis = xAxisOptions.find(function(axis) {
        return axis.name === xAxisName;
      });
    } else {
      xAxis = xAxisOptions[0];
    }
    var yAxisOptions = [].concat(options2.yAxis);
    var yAxisName = series.yAxis;
    if (yAxisName) {
      yAxis = yAxisOptions.find(function(axis) {
        return axis.name === yAxisName;
      });
    } else {
      yAxis = yAxisOptions[0];
    }
    if (!xAxis) {
      throw new Error("Unable to locate X axis with name " + xAxisName);
    }
    if (!yAxis) {
      throw new Error("Unable to locate Y axis with name " + yAxisName);
    }
    return { xAxis, yAxis };
  };
  HeatmapPlotArea2.prototype.createAxisLabels = function createAxisLabels() {
    var axes = this.axes;
    for (var i = 0; i < axes.length; i++) {
      axes[i].createLabels();
    }
  };
  HeatmapPlotArea2.prototype.createXYAxis = function createXYAxis(options2, vertical, axisIndex) {
    var axisName = options2.name;
    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;
    var axisOptions2 = Object.assign({
      axisCrossingValue: 0
    }, options2, {
      vertical,
      reverse: vertical || this.chartService.rtl ? !options2.reverse : options2.reverse,
      justified: false
    });
    var firstCategory = axisOptions2.categories ? axisOptions2.categories[0] : null;
    var typeSamples = [axisOptions2.min, axisOptions2.max, firstCategory];
    var series = this.series;
    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {
      var currentSeries = series[seriesIx];
      var seriesAxisName = currentSeries[vertical ? "yAxis" : "xAxis"];
      if (seriesAxisName === axisOptions2.name || axisIndex === 0 && !seriesAxisName) {
        var firstPointValue = series_binder_default.current.bindPoint(currentSeries, 0).valueFields;
        typeSamples.push(firstPointValue[vertical ? "y" : "x"]);
        break;
      }
    }
    var inferredDate;
    for (var i = 0; i < typeSamples.length; i++) {
      if (typeSamples[i] instanceof Date) {
        inferredDate = true;
        break;
      }
    }
    var axisType;
    if (equalsIgnoreCase(axisOptions2.type, DATE) || !axisOptions2.type && inferredDate) {
      axisType = date_category_axis_default;
    } else {
      axisType = category_axis_default;
    }
    var axis = new axisType(axisOptions2, this.chartService);
    axis.axisIndex = axisIndex;
    if (axisName) {
      if (namedAxes[axisName]) {
        throw new Error((vertical ? "Y" : "X") + " axis with name " + axisName + " is already defined");
      }
      namedAxes[axisName] = axis;
    }
    this.appendAxis(axis);
    axis.mapCategories();
    return axis;
  };
  HeatmapPlotArea2.prototype.createAxes = function createAxes(panes) {
    var this$1 = this;
    var options2 = this.options;
    var xAxesOptions = [].concat(options2.xAxis);
    var xAxes = [];
    var yAxesOptions = [].concat(options2.yAxis);
    var yAxes = [];
    for (var idx = 0; idx < xAxesOptions.length; idx++) {
      var axisPane = this$1.findPane(xAxesOptions[idx].pane);
      if (inArray(axisPane, panes)) {
        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));
      }
    }
    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {
      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);
      if (inArray(axisPane$1, panes)) {
        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));
      }
    }
    this.axisX = this.axisX || xAxes[0];
    this.axisY = this.axisY || yAxes[0];
  };
  HeatmapPlotArea2.prototype.removeAxis = function removeAxis(axis) {
    var axisName = axis.options.name;
    PlotAreaBase2.prototype.removeAxis.call(this, axis);
    if (axis.options.vertical) {
      delete this.namedYAxes[axisName];
    } else {
      delete this.namedXAxes[axisName];
    }
    if (axis === this.axisX) {
      delete this.axisX;
    }
    if (axis === this.axisY) {
      delete this.axisY;
    }
  };
  HeatmapPlotArea2.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {
    var coords = chart._eventCoordinates(e);
    var point2 = new point_default2(coords.x, coords.y);
    var allAxes = this.axes;
    var length = allAxes.length;
    var xValues = [];
    var yValues = [];
    for (var i = 0; i < length; i++) {
      var axis = allAxes[i];
      var values5 = axis.options.vertical ? yValues : xValues;
      appendIfNotNull(values5, axis.getCategory(point2));
    }
    if (xValues.length > 0 && yValues.length > 0) {
      chart.trigger(eventType, {
        element: eventElement2(e),
        originalEvent: e,
        x: singleItemOrArray(xValues),
        y: singleItemOrArray(yValues)
      });
    }
  };
  HeatmapPlotArea2.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options2) {
    var vertical = axis.options.vertical;
    var axes = this.groupAxes(this.panes);
    var index = (vertical ? axes.y : axes.x).indexOf(axis);
    updateAxisOptions3(this.options, index, vertical, options2);
    updateAxisOptions3(this.originalOptions, index, vertical, options2);
  };
  HeatmapPlotArea2.prototype.crosshairOptions = function crosshairOptions(axis) {
    return Object.assign({}, axis.options.crosshair, { zIndex: 0 });
  };
  return HeatmapPlotArea2;
}(plotarea_base_default);
function updateAxisOptions3(targetOptions, axisIndex, vertical, options2) {
  var axisOptions2 = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];
  deepExtend(axisOptions2, options2);
}
setDefaultOptions(HeatmapPlotArea, {
  xAxis: {},
  yAxis: {}
});
deepExtend(HeatmapPlotArea.prototype, plotarea_events_mixin_default);
var heatmap_plotarea_default = HeatmapPlotArea;

// node_modules/@progress/kendo-charts/dist/es/chart/register-charts.js
var COLOR = "color";
var FIRST = "first";
var FROM = "from";
var MAX = "max";
var MIN = "min";
var NOTE_TEXT = "noteText";
var SUMMARY_FIELD = "summary";
var TO = "to";
plotarea_factory_default.current.register(categorical_plotarea_default, [
  BAR,
  COLUMN,
  LINE,
  VERTICAL_LINE,
  AREA,
  VERTICAL_AREA,
  CANDLESTICK,
  OHLC,
  BULLET,
  VERTICAL_BULLET,
  BOX_PLOT,
  VERTICAL_BOX_PLOT,
  RANGE_COLUMN,
  RANGE_BAR,
  WATERFALL,
  HORIZONTAL_WATERFALL,
  RANGE_AREA,
  VERTICAL_RANGE_AREA
]);
plotarea_factory_default.current.register(xy_plotarea_default, [
  SCATTER,
  SCATTER_LINE,
  BUBBLE
]);
plotarea_factory_default.current.register(pie_plotarea_default, [PIE]);
plotarea_factory_default.current.register(donut_plotarea_default, [DONUT]);
plotarea_factory_default.current.register(funnel_plotarea_default, [FUNNEL]);
plotarea_factory_default.current.register(polar_plotarea_default, [POLAR_AREA, POLAR_LINE, POLAR_SCATTER]);
plotarea_factory_default.current.register(radar_plotarea_default, [RADAR_AREA, RADAR_COLUMN, RADAR_LINE]);
plotarea_factory_default.current.register(heatmap_plotarea_default, [HEATMAP]);
series_binder_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, ERROR_LOW_FIELD, ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  [FROM, TO],
  [CATEGORY, COLOR, NOTE_TEXT]
);
series_binder_default.current.register(
  [WATERFALL, HORIZONTAL_WATERFALL],
  [VALUE],
  [CATEGORY, COLOR, NOTE_TEXT, SUMMARY_FIELD]
);
series_binder_default.current.register([POLAR_AREA, POLAR_LINE, POLAR_SCATTER], [X, Y], [COLOR]);
series_binder_default.current.register([RADAR_AREA, RADAR_COLUMN, RADAR_LINE], [VALUE], [COLOR]);
series_binder_default.current.register(
  [FUNNEL],
  [VALUE],
  [CATEGORY, COLOR, "visibleInLegend", "visible"]
);
default_aggregates_default.current.register(
  [BAR, COLUMN, LINE, VERTICAL_LINE, AREA, VERTICAL_AREA, WATERFALL, HORIZONTAL_WATERFALL],
  { value: MAX, color: FIRST, noteText: FIRST, errorLow: MIN, errorHigh: MAX }
);
default_aggregates_default.current.register(
  [RANGE_COLUMN, RANGE_BAR, RANGE_AREA, VERTICAL_RANGE_AREA],
  { from: MIN, to: MAX, color: FIRST, noteText: FIRST }
);
default_aggregates_default.current.register(
  [RADAR_AREA, RADAR_COLUMN, RADAR_LINE],
  { value: MAX, color: FIRST }
);
series_binder_default.current.register(
  [SCATTER, SCATTER_LINE, BUBBLE],
  [X, Y],
  [COLOR, NOTE_TEXT, X_ERROR_LOW_FIELD, X_ERROR_HIGH_FIELD, Y_ERROR_LOW_FIELD, Y_ERROR_HIGH_FIELD]
);
series_binder_default.current.register(
  [BUBBLE],
  [X, Y, "size"],
  [COLOR, CATEGORY, NOTE_TEXT]
);
series_binder_default.current.register(
  [HEATMAP],
  [X, Y, VALUE],
  [COLOR, NOTE_TEXT]
);
series_binder_default.current.register(
  [CANDLESTICK, OHLC],
  ["open", "high", "low", "close"],
  [CATEGORY, COLOR, "downColor", NOTE_TEXT]
);
default_aggregates_default.current.register(
  [CANDLESTICK, OHLC],
  {
    open: MAX,
    high: MAX,
    low: MIN,
    close: MAX,
    color: FIRST,
    downColor: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  ["lower", "q1", "median", "q3", "upper", "mean", "outliers"],
  [CATEGORY, COLOR, NOTE_TEXT]
);
default_aggregates_default.current.register(
  [BOX_PLOT, VERTICAL_BOX_PLOT],
  {
    lower: MAX,
    q1: MAX,
    median: MAX,
    q3: MAX,
    upper: MAX,
    mean: MAX,
    outliers: FIRST,
    color: FIRST,
    noteText: FIRST
  }
);
series_binder_default.current.register(
  [BULLET, VERTICAL_BULLET],
  ["current", "target"],
  [CATEGORY, COLOR, "visibleInLegend", NOTE_TEXT]
);
default_aggregates_default.current.register(
  [BULLET, VERTICAL_BULLET],
  { current: MAX, target: MAX, color: FIRST, noteText: FIRST }
);
series_binder_default.current.register(
  [PIE, DONUT],
  [VALUE],
  [CATEGORY, COLOR, "explode", "visibleInLegend", "visible"]
);

// node_modules/@progress/kendo-charts/dist/es/chart/chart.js
var AXIS_NAMES = [CATEGORY, VALUE, X, Y];
var MOUSEMOVE = "mousemove";
var CONTEXTMENU = "contextmenu";
var MOUSELEAVE = "mouseleave";
var MOUSEMOVE_DELAY = 20;
var Chart = function(Class3) {
  function Chart2(element, userOptions, themeOptions, context2) {
    var this$1 = this;
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.observers = [];
    this.addObserver(context2.observer);
    this.chartService = new chart_service_default(this, context2);
    this.chartService.theme = themeOptions;
    this._initElement(element);
    var options2 = deepExtend({}, this.options, userOptions);
    this._originalOptions = deepExtend({}, options2);
    this._theme = themeOptions;
    this._initTheme(options2, themeOptions);
    this._initHandlers();
    this._initSurface();
    this.bindCategories();
    font_loader_default.preloadFonts(userOptions, function() {
      this$1.fontLoaded = true;
      if (!this$1._destroyed) {
        this$1.trigger("init");
        this$1._redraw();
        this$1._attachEvents();
      }
    });
  }
  if (Class3)
    Chart2.__proto__ = Class3;
  Chart2.prototype = Object.create(Class3 && Class3.prototype);
  Chart2.prototype.constructor = Chart2;
  Chart2.prototype._initElement = function _initElement(element) {
    this._setElementClass(element);
    element.style.position = "relative";
    while (element.firstChild) {
      element.removeChild(element.firstChild);
    }
    this.element = element;
  };
  Chart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart");
  };
  Chart2.prototype._initTheme = function _initTheme(options2, themeOptions) {
    var seriesCopies = [];
    var series = options2.series || [];
    for (var i = 0; i < series.length; i++) {
      seriesCopies.push(Object.assign({}, series[i]));
    }
    options2.series = seriesCopies;
    resolveAxisAliases(options2);
    this.applyDefaults(options2, themeOptions);
    if (options2.seriesColors === null) {
      delete options2.seriesColors;
    }
    this.options = deepExtend({}, themeOptions, options2);
    this.applySeriesColors();
  };
  Chart2.prototype.getSize = function getSize() {
    var chartArea = this.options.chartArea || {};
    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);
    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);
    return {
      width,
      height
    };
  };
  Chart2.prototype.resize = function resize(force) {
    var size = this.getSize();
    var currentSize = this._size;
    var hasSize = size.width > 0 || size.height > 0;
    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {
      this._size = size;
      this._resize(size, force);
      this.trigger("resize", size);
    } else if (hasSize && this._selections && find(this._selections, function(s) {
      return !s.visible;
    })) {
      this._destroySelections();
      this._setupSelection();
    }
  };
  Chart2.prototype._resize = function _resize() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.redraw = function redraw(paneName) {
    this.applyDefaults(this.options);
    this.applySeriesColors();
    if (paneName) {
      var plotArea = this._model._plotArea;
      var pane = plotArea.findPane(paneName);
      plotArea.redraw(pane);
    } else {
      this._redraw();
    }
  };
  Chart2.prototype.getAxis = function getAxis(name3) {
    return findAxisByName(name3, this._plotArea.axes);
  };
  Chart2.prototype.findAxisByName = function findAxisByName2(name3) {
    return this.getAxis(name3);
  };
  Chart2.prototype.findPaneByName = function findPaneByName(name3) {
    var panes = this._plotArea.panes;
    for (var idx = 0; idx < panes.length; idx++) {
      if (panes[idx].options.name === name3) {
        return new chart_pane_default(panes[idx]);
      }
    }
  };
  Chart2.prototype.findPaneByIndex = function findPaneByIndex(idx) {
    var panes = this._plotArea.panes;
    if (panes[idx]) {
      return new chart_pane_default(panes[idx]);
    }
  };
  Chart2.prototype.plotArea = function plotArea() {
    return new chart_plotarea_default(this._plotArea);
  };
  Chart2.prototype.toggleHighlight = function toggleHighlight(show2, filter) {
    var plotArea = this._plotArea;
    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];
    var points3;
    if (isFunction3(filter)) {
      points3 = plotArea.filterPoints(filter);
    } else {
      var seriesName, categoryName;
      if (isObject(filter)) {
        seriesName = filter.series;
        categoryName = filter.category;
      } else {
        seriesName = categoryName = filter;
      }
      if (firstSeries.type === DONUT) {
        points3 = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);
      } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {
        points3 = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);
      } else {
        points3 = plotArea.pointsBySeriesName(seriesName);
      }
    }
    if (points3) {
      this.togglePointsHighlight(show2, points3);
    }
  };
  Chart2.prototype.togglePointsHighlight = function togglePointsHighlight(show2, points3) {
    var highlight = this._highlight;
    for (var idx = 0; idx < points3.length; idx++) {
      highlight.togglePointHighlight(points3[idx], show2);
    }
  };
  Chart2.prototype.showTooltip = function showTooltip(filter) {
    var shared = this._sharedTooltip();
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var plotArea = ref2._plotArea;
    var point2, categoryIndex;
    if (isFunction3(filter)) {
      point2 = plotArea.findPoint(filter);
      if (point2 && shared) {
        categoryIndex = point2.categoryIx;
      }
    } else if (shared && defined2(filter)) {
      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);
    }
    if (shared) {
      if (categoryIndex >= 0) {
        var points3 = this._plotArea.pointsByCategoryIndex(categoryIndex);
        tooltip.showAt(points3);
      }
    } else if (point2) {
      tooltip.show(point2);
    }
  };
  Chart2.prototype.hideTooltip = function hideTooltip() {
    this._tooltip.hide();
  };
  Chart2.prototype._initSurface = function _initSurface() {
    var surface = this.surface;
    var wrap2 = this._surfaceWrap();
    var chartArea = this.options.chartArea || {};
    if (chartArea.width) {
      elementSize2(wrap2, { width: chartArea.width });
    }
    if (chartArea.height) {
      elementSize2(wrap2, { height: chartArea.height });
    }
    if (!surface || surface.options.type !== this.options.renderAs) {
      this._destroySurface();
      this.surface = drawing_exports.Surface.create(wrap2, {
        type: this.options.renderAs
      });
      this.surface.bind("mouseenter", this._surfaceMouseenterHandler);
      this.surface.bind("mouseleave", this._surfaceMouseleaveHandler);
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Chart2.prototype._surfaceWrap = function _surfaceWrap() {
    return this.element;
  };
  Chart2.prototype._redraw = function _redraw() {
    var model = this._getModel();
    this._size = {
      width: model.options.width,
      height: model.options.height
    };
    this._destroyView();
    this._model = model;
    this._plotArea = model._plotArea;
    model.renderVisual();
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.setup();
        }
      });
    }
    this._initSurface();
    this.surface.draw(model.visual);
    if (this.options.transitions !== false) {
      model.traverse(function(element) {
        if (element.animation) {
          element.animation.play();
        }
      });
    }
    this._tooltip = this._createTooltip();
    this._highlight = new highlight_default();
    this._setupSelection();
    this._createPannable();
    this._createZoomSelection();
    this._createMousewheelZoom();
    this.trigger(RENDER);
    triggerPaneRender(this._plotArea.panes);
    if (!this._navState) {
      this._cancelDomEvents();
    }
  };
  Chart2.prototype.exportVisual = function exportVisual(exportOptions) {
    var visual;
    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {
      var currentOptions = this.options;
      var options2 = deepExtend({}, exportOptions.options, {
        chartArea: {
          width: exportOptions.width,
          height: exportOptions.height
        }
      });
      clearMissingValues(this._originalOptions, options2);
      this.options = deepExtend({}, this._originalOptions, options2);
      this._initTheme(this.options, this._theme);
      this.bindCategories();
      var model = this._getModel();
      model.renderVisual();
      triggerPaneRender(model._plotArea.panes);
      visual = model.visual;
      this.options = currentOptions;
    } else {
      visual = this.surface.exportVisual();
    }
    return visual;
  };
  Chart2.prototype._sharedTooltip = function _sharedTooltip() {
    return this._plotArea instanceof categorical_plotarea_default && this.options.tooltip && this.options.tooltip.shared;
  };
  Chart2.prototype._createPannable = function _createPannable() {
    var options2 = this.options;
    if (options2.pannable !== false) {
      this._pannable = new pannable_default(this._plotArea, options2.pannable);
    }
  };
  Chart2.prototype._createZoomSelection = function _createZoomSelection() {
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    if (zoomable !== false && selection !== false) {
      this._zoomSelection = new zoom_selection_default(this, selection);
    }
  };
  Chart2.prototype._createMousewheelZoom = function _createMousewheelZoom() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel;
    if (zoomable !== false && mousewheel !== false) {
      this._mousewheelZoom = new mousewheel_zoom_default(this, mousewheel);
    }
  };
  Chart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    var pannable = this.options.pannable;
    var zoomable = this.options.zoomable;
    var selection = (zoomable || {}).selection;
    var mousewheel = (zoomable || {}).mousewheel;
    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);
    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);
    var element = this.element;
    if (this._dragZoomEnabled && allowDrag && allowZoom) {
      element.style.touchAction = this._touchAction || "";
      this._dragZoomEnabled = false;
    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {
      element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
    this._toggleDomEvents(!allowDrag, !allowZoom);
  };
  Chart2.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {
    var domEvents = this.domEvents;
    if (!domEvents) {
      return;
    }
    if (domEvents.toggleDrag) {
      domEvents.toggleDrag(drag);
    }
    if (domEvents.toggleZoom) {
      domEvents.toggleZoom(zoom);
    }
  };
  Chart2.prototype._createTooltip = function _createTooltip() {
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var tooltip;
    if (this._sharedTooltip()) {
      tooltip = this._createSharedTooltip(tooltipOptions);
    } else {
      tooltip = new tooltip_default(this.chartService, tooltipOptions);
    }
    return tooltip;
  };
  Chart2.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new shared_tooltip_default(this._plotArea, options2);
  };
  Chart2.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    applyAxisDefaults(options2, themeOptions);
    applySeriesDefaults(options2, themeOptions);
  };
  Chart2.prototype.applySeriesColors = function applySeriesColors() {
    var options2 = this.options;
    var series = options2.series;
    var colors = options2.seriesColors || [];
    for (var i = 0; i < series.length; i++) {
      var currentSeries = series[i];
      var seriesColor = colors[i % colors.length];
      var defaults = currentSeries._defaults;
      currentSeries.color = currentSeries.color || seriesColor;
      if (defaults) {
        defaults.color = defaults.color || seriesColor;
      }
    }
  };
  Chart2.prototype._getModel = function _getModel() {
    var options2 = this.options;
    var plotArea = this._createPlotArea();
    var model = new root_element_default(this._modelOptions());
    model.chart = this;
    model._plotArea = plotArea;
    var title2 = title_default.buildTitle(options2.title);
    var subtitle2 = title_default.buildTitle(options2.subtitle, {
      align: options2.title.align,
      position: options2.title.position
    });
    model.append.apply(model, title_default.orderTitles([title2, subtitle2]));
    if (options2.legend && options2.legend.visible) {
      model.append(new legend_default(plotArea.options.legend, this.chartService));
    }
    model.append(plotArea);
    model.reflow();
    return model;
  };
  Chart2.prototype._modelOptions = function _modelOptions() {
    var options2 = this.options;
    var size = this.getSize();
    return deepExtend({
      transitions: options2.transitions,
      width: size.width || DEFAULT_WIDTH,
      height: size.height || DEFAULT_HEIGHT
    }, options2.chartArea);
  };
  Chart2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var options2 = this.options;
    var plotArea = plotarea_factory_default.current.create(skipSeries ? [] : options2.series, options2, this.chartService);
    return plotArea;
  };
  Chart2.prototype._setupSelection = function _setupSelection() {
    var this$1 = this;
    var ref2 = this;
    var axes = ref2._plotArea.axes;
    var selections = this._selections = [];
    for (var i = 0; i < axes.length; i++) {
      var axis = axes[i];
      var options2 = axis.options;
      if (axis instanceof category_axis_default && options2.select && !options2.vertical) {
        var range = axis.range();
        var selection = new selection_default(
          this$1,
          axis,
          deepExtend({ min: range.min, max: range.max }, options2.select)
        );
        selections.push(selection);
      }
    }
  };
  Chart2.prototype._selectStart = function _selectStart(e) {
    return this.trigger(SELECT_START, e);
  };
  Chart2.prototype._select = function _select(e) {
    return this.trigger(SELECT, e);
  };
  Chart2.prototype._selectEnd = function _selectEnd(e) {
    return this.trigger(SELECT_END, e);
  };
  Chart2.prototype._initHandlers = function _initHandlers() {
    this._clickHandler = this._click.bind(this);
    this._mousewheelHandler = this._mousewheel.bind(this);
    this._mouseleaveHandler = this._mouseleave.bind(this);
    this._surfaceMouseenterHandler = this._mouseover.bind(this);
    this._surfaceMouseleaveHandler = this._mouseout.bind(this);
    this._mousemove = throttle(
      this._mousemove.bind(this),
      MOUSEMOVE_DELAY
    );
  };
  Chart2.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Chart2.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Chart2.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Chart2.prototype.trigger = function trigger2(name3, args) {
    if (args === void 0)
      args = {};
    if (name3 === SHOW_TOOLTIP) {
      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);
    }
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name3, args)) {
        isDefaultPrevented3 = true;
      }
    }
    return isDefaultPrevented3;
  };
  Chart2.prototype._attachEvents = function _attachEvents() {
    var obj, obj$1;
    var element = this.element;
    this._touchAction = element.style.touchAction;
    bindEvents2(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents2(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
    this.domEvents = dom_events_builder_default.create(this.element, {
      start: this._start.bind(this),
      move: this._move.bind(this),
      end: this._end.bind(this),
      tap: this._tap.bind(this),
      gesturestart: this._gesturestart.bind(this),
      gesturechange: this._gesturechange.bind(this),
      gestureend: this._gestureend.bind(this)
    });
    this._toggleDragZoomEvents();
  };
  Chart2.prototype._mouseleave = function _mouseleave2(e) {
    if (this._hoveredPoint) {
      this._hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (this._plotAreaHovered) {
      this._plotAreaHovered = false;
      this.trigger(PLOT_AREA_LEAVE);
    }
  };
  Chart2.prototype._cancelDomEvents = function _cancelDomEvents() {
    if (this.domEvents && this.domEvents.cancel) {
      this.domEvents.cancel();
    }
  };
  Chart2.prototype._gesturestart = function _gesturestart(e) {
    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {
      this._gestureDistance = e.distance;
      this._unsetActivePoint();
      this.surface.suspendTracking();
    }
  };
  Chart2.prototype._gestureend = function _gestureend(e) {
    if (this._zooming && !this._stopChartHandlers(e)) {
      if (this.surface) {
        this.surface.resumeTracking();
      }
      this._zooming = false;
      this.trigger(ZOOM_END, {});
    }
  };
  Chart2.prototype._gesturechange = function _gesturechange(e) {
    var mousewheelZoom = this._mousewheelZoom;
    if (mousewheelZoom && !this._stopChartHandlers(e)) {
      e.preventDefault();
      var previousGestureDistance = this._gestureDistance;
      var scaleDelta = -e.distance / previousGestureDistance + 1;
      if (Math.abs(scaleDelta) >= 0.1) {
        scaleDelta = Math.round(scaleDelta * 10);
        this._gestureDistance = e.distance;
        var args = { delta: scaleDelta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
        if (this._zooming || !this.trigger(ZOOM_START, args)) {
          var coords = this._eventCoordinates(e);
          if (!this._zooming) {
            this._zooming = true;
          }
          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);
          if (ranges && !this.trigger(ZOOM, args)) {
            mousewheelZoom.zoom();
          }
        }
      }
    }
  };
  Chart2.prototype._mouseout = function _mouseout(e) {
    if (e.element) {
      var element = this._drawingChartElement(e.element, e);
      if (element && element.leave) {
        element.leave(this, e.originalEvent);
      }
    }
  };
  Chart2.prototype._start = function _start(e) {
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {
      this._startNavigation(e, coords, DRAG_START);
    }
    if (this._pannable && this._pannable.start(e)) {
      this.surface.suspendTracking();
      this._unsetActivePoint();
      this._suppressHover = true;
      this.chartService.panning = true;
    }
    if (this._zoomSelection) {
      if (this._zoomSelection.start(e)) {
        this.trigger(ZOOM_START, { axisRanges: axisRanges(this._plotArea.axes), originalEvent: e });
      }
    }
  };
  Chart2.prototype._move = function _move(e) {
    var ref2 = this;
    var state = ref2._navState;
    var pannable = ref2._pannable;
    if (this._stopChartHandlers(e)) {
      return;
    }
    if (pannable) {
      var ranges = pannable.move(e);
      if (ranges && !this.trigger(DRAG, { axisRanges: ranges, originalEvent: e })) {
        pannable.pan();
      }
    } else if (state) {
      var ranges$1 = {};
      var axes = state.axes;
      for (var i = 0; i < axes.length; i++) {
        var currentAxis = axes[i];
        var axisName = currentAxis.options.name;
        if (axisName) {
          var axis = currentAxis.options.vertical ? e.y : e.x;
          var delta = axis.startLocation - axis.location;
          if (delta !== 0) {
            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);
          }
        }
      }
      state.axisRanges = ranges$1;
      this.trigger(DRAG, {
        axisRanges: ranges$1,
        originalEvent: e
      });
    }
    if (this._zoomSelection) {
      this._zoomSelection.move(e);
    }
  };
  Chart2.prototype._end = function _end(e) {
    if (this._stopChartHandlers(e)) {
      return;
    }
    var pannable = this._pannable;
    if (pannable && pannable.end(e)) {
      this.surface.resumeTracking();
      this.trigger(DRAG_END, {
        axisRanges: axisRanges(this._plotArea.axes),
        originalEvent: e
      });
      this._suppressHover = false;
      this.chartService.panning = false;
    } else {
      this._endNavigation(e, DRAG_END);
    }
    if (this._zoomSelection) {
      var ranges = this._zoomSelection.end(e);
      if (ranges && !this.trigger(ZOOM, { axisRanges: ranges, originalEvent: e })) {
        this._zoomSelection.zoom();
        this.trigger(ZOOM_END, { axisRanges: ranges, originalEvent: e });
      }
    }
  };
  Chart2.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var selections = this._selections || [];
    if (!selections.length) {
      return false;
    }
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    if (pane) {
      for (var idx = 0; idx < selections.length; idx++) {
        if (selections[idx].onPane(pane)) {
          return true;
        }
      }
    }
  };
  Chart2.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {
    var zoomable = this.options.zoomable;
    var mousewheel = (zoomable || {}).mousewheel || {};
    return valueOrDefault2(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);
  };
  Chart2.prototype._mousewheel = function _mousewheel(e) {
    var this$1 = this;
    var delta = mousewheelDelta(e);
    var mousewheelZoom = this._mousewheelZoom;
    var coords = this._eventCoordinates(e);
    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {
      return;
    }
    if (mousewheelZoom) {
      var args = { delta, axisRanges: axisRanges(this._plotArea.axes), originalEvent: e };
      if (this._zooming || !this.trigger(ZOOM_START, args)) {
        e.preventDefault();
        if (!this._zooming) {
          this._unsetActivePoint();
          this.surface.suspendTracking();
          this._zooming = true;
        }
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);
        if (args.axisRanges && !this.trigger(ZOOM, args)) {
          mousewheelZoom.zoom();
        }
        this._mwTimeout = setTimeout(function() {
          this$1.trigger(ZOOM_END, args);
          this$1._zooming = false;
          if (this$1.surface) {
            this$1.surface.resumeTracking();
          }
        }, MOUSEWHEEL_DELAY);
      }
    } else {
      var state = this._navState;
      if (!state) {
        var prevented = this._startNavigation(e, coords, ZOOM_START);
        if (!prevented) {
          state = this._navState;
        }
      }
      if (state) {
        var totalDelta = state.totalDelta || delta;
        state.totalDelta = totalDelta + delta;
        var axes = this._navState.axes;
        var ranges = {};
        for (var i = 0; i < axes.length; i++) {
          var currentAxis = axes[i];
          var axisName = currentAxis.options.name;
          if (axisName) {
            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);
          }
        }
        this.trigger(ZOOM, {
          delta,
          axisRanges: ranges,
          originalEvent: e
        });
        if (this._mwTimeout) {
          clearTimeout(this._mwTimeout);
        }
        this._mwTimeout = setTimeout(function() {
          this$1._endNavigation(e, ZOOM_END);
        }, MOUSEWHEEL_DELAY);
      }
    }
  };
  Chart2.prototype._startNavigation = function _startNavigation(e, coords, chartEvent) {
    var plotArea = this._model._plotArea;
    var pane = plotArea.findPointPane(coords);
    var axes = plotArea.axes.slice(0);
    if (!pane) {
      return;
    }
    var ranges = axisRanges(axes);
    var prevented = this.trigger(chartEvent, {
      axisRanges: ranges,
      originalEvent: e
    });
    if (prevented) {
      this._cancelDomEvents();
    } else {
      this._suppressHover = true;
      this._unsetActivePoint();
      this._navState = {
        axisRanges: ranges,
        pane,
        axes
      };
    }
  };
  Chart2.prototype._endNavigation = function _endNavigation(e, chartEvent) {
    if (this._navState) {
      this.trigger(chartEvent, {
        axisRanges: this._navState.axisRanges,
        originalEvent: e
      });
      this._suppressHover = false;
      this._navState = null;
    }
  };
  Chart2.prototype._getChartElement = function _getChartElement(e, match) {
    var element = this.surface.eventTarget(e);
    if (element) {
      return this._drawingChartElement(element, e, match);
    }
  };
  Chart2.prototype._drawingChartElement = function _drawingChartElement(element, e, match) {
    var current4 = element;
    var chartElement;
    while (current4 && !chartElement) {
      chartElement = current4.chartElement;
      current4 = current4.parent;
    }
    if (chartElement) {
      if (chartElement.aliasFor) {
        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));
      }
      if (match) {
        chartElement = chartElement.closest(match);
        if (chartElement && chartElement.aliasFor) {
          chartElement = chartElement.aliasFor();
        }
      }
      return chartElement;
    }
  };
  Chart2.prototype._eventCoordinates = function _eventCoordinates(e) {
    var coordinates = eventCoordinates2(e);
    return this._toModelCoordinates(coordinates.x, coordinates.y);
  };
  Chart2.prototype._elementPadding = function _elementPadding() {
    if (!this._padding) {
      var ref2 = elementStyles2(this.element, ["paddingLeft", "paddingTop"]);
      var paddingLeft = ref2.paddingLeft;
      var paddingTop = ref2.paddingTop;
      this._padding = {
        top: paddingTop,
        left: paddingLeft
      };
    }
    return this._padding;
  };
  Chart2.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var padding = this._elementPadding();
    var offset = elementOffset2(this.element);
    return {
      left: round3(point2.x + padding.left + offset.left),
      top: round3(point2.y + padding.top + offset.top)
    };
  };
  Chart2.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {
    var element = this.element;
    var offset = elementOffset2(element);
    var padding = this._elementPadding();
    var inverseTransform = elementScale2(element).invert();
    var point2 = new geometry_exports.Point(
      clientX - offset.left - padding.left,
      clientY - offset.top - padding.top
    ).transform(inverseTransform);
    return new point_default2(point2.x, point2.y);
  };
  Chart2.prototype._tap = function _tap(e) {
    var this$1 = this;
    var drawingElement = this.surface.eventTarget(e);
    var element = this._drawingChartElement(drawingElement, e);
    var sharedTooltip = this._sharedTooltip();
    if (!this._startHover(drawingElement, e) && !sharedTooltip) {
      this._unsetActivePoint();
    }
    if (sharedTooltip) {
      this._trackSharedTooltip(this._eventCoordinates(e), e, true);
    }
    this._propagateClick(element, e);
    this.handlingTap = true;
    setTimeout(function() {
      this$1.handlingTap = false;
    }, 0);
  };
  Chart2.prototype._click = function _click(e) {
    var element = this._getChartElement(e);
    this._propagateClick(element, e);
  };
  Chart2.prototype._propagateClick = function _propagateClick(element, e) {
    var this$1 = this;
    var current4 = element;
    while (current4) {
      if (current4.click) {
        current4.click(this$1, e);
      }
      current4 = current4.parent;
    }
  };
  Chart2.prototype._startHover = function _startHover(element, e) {
    if (this._suppressHover) {
      return false;
    }
    var point2 = this._drawingChartElement(element, e, function(element2) {
      return (element2.hover || element2.over) && !(element2 instanceof plotarea_base_default);
    });
    this._showInactiveOpacity(point2, e);
    return point2;
  };
  Chart2.prototype._displayTooltip = function _displayTooltip(point2) {
    var tooltipOptions = deepExtend({}, this.options.tooltip, point2.options.tooltip);
    if (tooltipOptions.visible) {
      this._tooltip.show(point2);
    }
  };
  Chart2.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {
    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);
    if (!chartInstance) {
      return;
    }
    if (multipleSeries) {
      this._updateSeriesOpacity(activePoint);
      this._applySeriesOpacity(chartInstance.children, null, true);
      this._applySeriesOpacity(chartInstance.children, activePoint.series);
      this._highlight.show(highlightPoints || activePoint);
    } else {
      var inactivePoints;
      if (!chartInstance.supportsPointInactiveOpacity()) {
        this._highlight.show(activePoint);
        return;
      }
      inactivePoints = this._getInactivePoints(activePoint, chartInstance);
      if (inactivePoints && inactivePoints.length) {
        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));
      }
    }
  };
  Chart2.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {
    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);
    return allPoints.filter(function(point2) {
      return point2 !== activePoint;
    });
  };
  Chart2.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {
    var this$1 = this;
    var points3 = [];
    for (var i = 0; i < container.children.length; i++) {
      var element = container.children[i];
      if (element.constructor === type) {
        points3.push(element);
      } else if (element.children && element.children.length) {
        points3 = points3.concat(this$1._getAllPointsOfType(element, type));
      }
    }
    return points3;
  };
  Chart2.prototype._updateHoveredPoint = function _updateHoveredPoint(point2, e) {
    var hoveredPoint = this._hoveredPoint;
    if (hoveredPoint && hoveredPoint !== point2) {
      hoveredPoint.out(this, e);
      this._hoveredPoint = null;
    }
    if (point2 && hoveredPoint !== point2 && point2.over) {
      this._hoveredPoint = point2;
      point2.over(this, e);
    }
  };
  Chart2.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point2, resetOpacity) {
    var this$1 = this;
    var plotArea = this._plotArea;
    var length = plotArea.series.length;
    for (var i = 0; i < length; i++) {
      var currSeries = plotArea.series[i];
      var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);
      var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);
      if (!resetOpacity && currSeries !== point2.series) {
        currSeries.defaultOpacity = defaultOpacity;
        currSeries.opacity = inactiveOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = inactiveOpacity;
        }
      } else {
        currSeries.opacity = defaultOpacity;
        if (currSeries.line) {
          currSeries.line.opacity = defaultOpacity;
        }
      }
    }
  };
  Chart2.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {
    var this$1 = this;
    for (var i = 0; i < elements.length; i++) {
      var element = elements[i];
      var currSeries = element.series || series;
      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;
      if (shouldHighlight && element.visual) {
        var opacity = series ? series.opacity : element.series.opacity;
        if (currSeries !== activeSeries || reset) {
          element.visual.opacity(reset ? 1 : opacity);
        }
      }
      if (element.children && element.children.length) {
        this$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);
      }
    }
  };
  Chart2.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point2) {
    var chartInstance = point2.parent;
    while (chartInstance && !chartInstance.plotArea) {
      chartInstance = chartInstance.parent;
    }
    return chartInstance;
  };
  Chart2.prototype._showInactiveOpacity = function _showInactiveOpacity(point2, e) {
    var activePoint = this._activePoint;
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    this._updateHoveredPoint(point2, e);
    if (point2 && activePoint !== point2 && point2.hover) {
      this._activePoint = point2;
      if (!this._sharedTooltip() && !point2.hover(this, e)) {
        this._displayTooltip(point2);
        if (hasInactiveOpacity) {
          this._displayInactiveOpacity(point2, multipleSeries);
        } else {
          this._highlight.show(point2);
        }
      }
    }
    return point2;
  };
  Chart2.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point2) {
    var multipleSeries = this._plotArea.series.length > 1;
    var hasInactiveOpacity = this._hasInactiveOpacity();
    if (hasInactiveOpacity) {
      if (multipleSeries && this._activeChartInstance) {
        this._updateSeriesOpacity(point2, true);
        this._applySeriesOpacity(this._activeChartInstance.children, null, true);
        this._activeChartInstance = null;
      }
      this._highlight && this._highlight.hide();
      this._activePoint = null;
    }
  };
  Chart2.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {
    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== void 0;
    var hasInactiveOpacity = this.options.series.filter(function(s) {
      return s.highlight.inactiveOpacity !== void 0;
    }).length > 0;
    return hasDefaultInactiveOpacity || hasInactiveOpacity;
  };
  Chart2.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {
    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;
    var seriesInactiveOpacity = series.highlight.inactiveOpacity;
    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {
    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;
  };
  Chart2.prototype._mouseover = function _mouseover(e) {
    var obj;
    var point2 = this._startHover(e.element, e.originalEvent);
    if (point2 && point2.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {
      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);
      bindEvents2(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
    }
  };
  Chart2.prototype._mouseMoveTracking = function _mouseMoveTracking(e) {
    var obj;
    var ref2 = this;
    var options2 = ref2.options;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    var point2 = ref2._activePoint;
    var coords = this._eventCoordinates(e);
    if (this._plotArea.box.containsPoint(coords)) {
      if (point2 && point2.tooltipTracking && point2.series && point2.parent.getNearestPoint) {
        var seriesPoint = point2.parent.getNearestPoint(coords.x, coords.y, point2.seriesIx);
        if (seriesPoint && seriesPoint !== point2) {
          this._activePoint = seriesPoint;
          if (!seriesPoint.hover(this, e)) {
            var tooltipOptions = deepExtend({}, options2.tooltip, seriesPoint.options.tooltip);
            if (tooltipOptions.visible) {
              tooltip.show(seriesPoint);
            }
            highlight.show(seriesPoint);
          }
        }
      }
    } else {
      unbindEvents2(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));
      this._unsetActivePoint();
      this._mouseMoveTrackHandler = null;
      this._hideInactiveOpacity(point2);
    }
  };
  Chart2.prototype._mousemove = function _mousemove(e) {
    var coords = this._eventCoordinates(e);
    var plotArea = this._plotArea;
    this._trackCrosshairs(coords);
    if (plotArea.hover) {
      var overPlotArea = plotArea.backgroundContainsPoint(coords);
      if (overPlotArea) {
        this._plotAreaHovered = true;
        this._plotArea.hover(this, e);
      } else if (this._plotAreaHovered && !overPlotArea) {
        this._plotAreaHovered = false;
        this.trigger(PLOT_AREA_LEAVE);
      }
    }
    if (this._sharedTooltip()) {
      this._trackSharedTooltip(coords, e);
    }
  };
  Chart2.prototype._trackCrosshairs = function _trackCrosshairs(coords) {
    var crosshairs = this._plotArea.crosshairs;
    for (var i = 0; i < crosshairs.length; i++) {
      var current4 = crosshairs[i];
      if (current4.box.containsPoint(coords)) {
        current4.showAt(coords);
      } else {
        current4.hide();
      }
    }
  };
  Chart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e, toggle) {
    if (this._suppressHover) {
      return;
    }
    var ref2 = this;
    var tooltipOptions = ref2.options.tooltip;
    var plotArea = ref2._plotArea;
    var categoryAxis = ref2._plotArea.categoryAxis;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    if (plotArea.backgroundContainsPoint(coords)) {
      var index = categoryAxis.pointCategoryIndex(coords);
      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {
        var points3 = plotArea.pointsByCategoryIndex(index);
        var pointArgs = points3.map(function(point2) {
          return point2.eventArgs(e);
        });
        var hoverArgs = pointArgs[0] || {};
        hoverArgs.categoryPoints = pointArgs;
        if (points3.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {
          if (tooltipOptions.visible) {
            tooltip.showAt(points3, coords);
          }
          highlight.show(points3);
          this._sharedHighlight = true;
        } else {
          tooltip.hide();
        }
        this._tooltipCategoryIx = index;
      } else if (toggle && this._sharedHighlight) {
        highlight.hide();
        tooltip.hide();
        this._sharedHighlight = false;
      }
    } else if (this._sharedHighlight) {
      highlight.hide();
      tooltip.hide();
      this._tooltipCategoryIx = null;
      this._sharedHighlight = false;
    }
  };
  Chart2.prototype.hideElements = function hideElements(options2) {
    var plotArea = this._plotArea;
    this._mousemove.cancel();
    plotArea.hideCrosshairs();
    this._unsetActivePoint(options2);
  };
  Chart2.prototype._unsetActivePoint = function _unsetActivePoint(options2) {
    var ref2 = this;
    var tooltip = ref2._tooltip;
    var highlight = ref2._highlight;
    this._activePoint = null;
    this._hoveredPoint = null;
    if (tooltip && !(options2 && options2.keepTooltipOpen)) {
      tooltip.hide();
    }
    this._tooltipCategoryIx = null;
    this._sharedHighlight = false;
    if (highlight) {
      highlight.hide();
    }
  };
  Chart2.prototype._deferRedraw = function _deferRedraw() {
    this._redraw();
  };
  Chart2.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {
    if (this._redrawTimeout) {
      clearInterval(this._redrawTimeout);
      this._redrawTimeout = null;
    }
  };
  Chart2.prototype.bindCategories = function bindCategories() {
    var this$1 = this;
    var options2 = this.options;
    var definitions = [].concat(options2.categoryAxis);
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.autoBind !== false) {
        this$1.bindCategoryAxisFromSeries(axis, axisIx);
      }
    }
  };
  Chart2.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {
    var this$1 = this;
    var series = this.options.series;
    var seriesLength = series.length;
    var uniqueCategories = new hash_map_default();
    var items = [];
    var bindable = false;
    var dateAxis;
    for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {
      var s = series[seriesIx];
      var onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;
      var data = s.data;
      var dataLength = data.length;
      var bind = s.categoryField && onAxis;
      bindable = bind || bindable;
      if (bind && dataLength > 0) {
        dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));
        var getFn = dateAxis ? getDateField : getField;
        for (var dataIx = 0; dataIx < dataLength; dataIx++) {
          var dataRow = data[dataIx];
          var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);
          if (dateAxis || !uniqueCategories.get(category)) {
            items.push([category, dataRow]);
            if (!dateAxis) {
              uniqueCategories.set(category, true);
            }
          }
        }
      }
    }
    if (items.length > 0) {
      if (dateAxis) {
        items = uniqueDates(items, function(a, b) {
          return dateComparer(a[0], b[0]);
        });
      }
      var result = transpose(items);
      axis.categories = result[0];
    } else if (bindable) {
      axis.categories = [];
    }
  };
  Chart2.prototype._isBindable = function _isBindable(series) {
    var valueFields = series_binder_default.current.valueFields(series);
    var result = true;
    for (var i = 0; i < valueFields.length; i++) {
      var field = valueFields[i];
      if (field === VALUE) {
        field = "field";
      } else {
        field = field + "Field";
      }
      if (!defined2(series[field])) {
        result = false;
        break;
      }
    }
    return result;
  };
  Chart2.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {
    var options2 = this.options;
    var transitionsState;
    if (options2.transitions !== false) {
      options2.transitions = false;
      transitionsState = true;
    }
    this._redraw();
    if (transitionsState) {
      options2.transitions = true;
    }
  };
  Chart2.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {
    var ref2 = this;
    var plotArea = ref2._plotArea;
    var highlight = ref2._highlight;
    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];
    var items;
    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL])) {
      items = plotArea.findPoint(function(point3) {
        return point3.series.index === seriesIndex && point3.index === pointIndex;
      });
    } else {
      items = plotArea.pointsBySeriesIndex(seriesIndex);
    }
    if (this._hasInactiveOpacity() && currentSeries.visible && items) {
      var multipleSeries = plotArea.series.length > 1;
      var point2 = items.length ? items[0] : items;
      this._displayInactiveOpacity(point2, multipleSeries, items);
    } else {
      highlight.show(items);
    }
  };
  Chart2.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {
    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);
  };
  Chart2.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {
    var obj, obj$1;
    unbindEvents2(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));
    if (this._shouldAttachMouseMove()) {
      bindEvents2(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));
    }
  };
  Chart2.prototype.applyOptions = function applyOptions(options2, theme) {
    clearMissingValues(this._originalOptions, options2);
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    if (theme) {
      this._theme = theme;
      this.chartService.theme = theme;
    }
    this._initTheme(this.options, this._theme);
    this._toggleDragZoomEvents();
  };
  Chart2.prototype.setOptions = function setOptions(options2, theme) {
    this.applyOptions(options2, theme);
    this.bindCategories();
    this.redraw();
    this.updateMouseMoveHandler();
  };
  Chart2.prototype.setDirection = function setDirection(rtl) {
    this.chartService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this._destroySurface();
    }
  };
  Chart2.prototype.setIntlService = function setIntlService(intl) {
    this.chartService.intl = intl;
  };
  Chart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    this._noTransitionsRedraw();
  };
  Chart2.prototype.destroy = function destroy2() {
    var obj, obj$1;
    this._destroyed = true;
    unbindEvents2(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));
    if (this.domEvents) {
      this.domEvents.destroy();
      delete this.domEvents;
    }
    if (this._mouseMoveTrackHandler) {
      unbindEvents2(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));
    }
    this._destroyView();
    this._destroySurface();
    this._clearRedrawTimeout();
  };
  Chart2.prototype._destroySurface = function _destroySurface() {
    var surface = this.surface;
    if (surface) {
      surface.unbind("mouseenter", this._surfaceMouseenterHandler);
      surface.unbind("mouseleave", this._surfaceMouseleaveHandler);
      surface.destroy();
      this.surface = null;
    }
  };
  Chart2.prototype._destroySelections = function _destroySelections() {
    var selections = this._selections;
    if (selections) {
      while (selections.length > 0) {
        selections.shift().destroy();
      }
    }
  };
  Chart2.prototype._destroyView = function _destroyView() {
    var model = this._model;
    if (model) {
      model.destroy();
      this._model = null;
    }
    this._unsetActivePoint();
    this._destroySelections();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this._highlight) {
      this._highlight.destroy();
    }
    if (this._zoomSelection) {
      this._zoomSelection.destroy();
      delete this._zoomSelection;
    }
    if (this._pannable) {
      this._pannable.destroy();
      delete this._pannable;
    }
    if (this._mousewheelZoom) {
      this._mousewheelZoom.destroy();
      delete this._mousewheelZoom;
    }
  };
  return Chart2;
}(class_default);
function resolveAxisAliases(options2) {
  var aliases = AXIS_NAMES;
  for (var idx = 0; idx < aliases.length; idx++) {
    var alias = aliases[idx] + "Axes";
    if (options2[alias]) {
      options2[aliases[idx] + "Axis"] = options2[alias];
      delete options2[alias];
    }
  }
}
function pointByCategoryName(points3, name3) {
  if (points3) {
    for (var idx = 0; idx < points3.length; idx++) {
      if (points3[idx].category === name3) {
        return [points3[idx]];
      }
    }
  }
}
function applyAxisDefaults(options2, themeOptions) {
  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};
  var axisName, axisDefaults2, axes;
  function mapAxisOptions(axisOptions2) {
    var axisColor = (axisOptions2 || {}).color || axisDefaults2.color;
    var result = deepExtend(
      {},
      themeAxisDefaults,
      themeAxisDefaults[axisName],
      axisDefaults2,
      axisDefaults2[axisName],
      {
        line: { color: axisColor },
        labels: { color: axisColor },
        title: { color: axisColor }
      },
      axisOptions2
    );
    delete result[axisName];
    return result;
  }
  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {
    axisName = AXIS_NAMES[idx] + "Axis";
    axisDefaults2 = options2.axisDefaults || {};
    axes = [].concat(options2[axisName]);
    axes = axes.map(mapAxisOptions);
    options2[axisName] = axes.length > 1 ? axes : axes[0];
  }
}
function applySeriesDefaults(options2, themeOptions) {
  var series = options2.series;
  var seriesLength = series.length;
  var seriesDefaults2 = options2.seriesDefaults;
  var commonDefaults = deepExtend({}, options2.seriesDefaults);
  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};
  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);
  cleanupNestedSeriesDefaults(commonDefaults);
  cleanupNestedSeriesDefaults(commonThemeDefaults);
  for (var i = 0; i < seriesLength; i++) {
    var seriesType = series[i].type || options2.seriesDefaults.type;
    var baseOptions = deepExtend(
      { data: [] },
      commonThemeDefaults,
      themeSeriesDefaults[seriesType],
      { tooltip: options2.tooltip },
      commonDefaults,
      seriesDefaults2[seriesType]
    );
    series[i]._defaults = baseOptions;
    series[i] = deepExtend({}, baseOptions, series[i]);
    series[i].data = series[i].data || [];
  }
}
function cleanupNestedSeriesDefaults(seriesDefaults2) {
  delete seriesDefaults2.bar;
  delete seriesDefaults2.column;
  delete seriesDefaults2.rangeColumn;
  delete seriesDefaults2.line;
  delete seriesDefaults2.verticalLine;
  delete seriesDefaults2.pie;
  delete seriesDefaults2.donut;
  delete seriesDefaults2.area;
  delete seriesDefaults2.verticalArea;
  delete seriesDefaults2.scatter;
  delete seriesDefaults2.scatterLine;
  delete seriesDefaults2.bubble;
  delete seriesDefaults2.candlestick;
  delete seriesDefaults2.ohlc;
  delete seriesDefaults2.boxPlot;
  delete seriesDefaults2.bullet;
  delete seriesDefaults2.verticalBullet;
  delete seriesDefaults2.polarArea;
  delete seriesDefaults2.polarLine;
  delete seriesDefaults2.radarArea;
  delete seriesDefaults2.radarLine;
  delete seriesDefaults2.waterfall;
}
function axisRanges(axes) {
  var ranges = {};
  for (var i = 0; i < axes.length; i++) {
    var axis = axes[i];
    var axisName = axis.options.name;
    if (axisName) {
      ranges[axisName] = axis.range();
    }
  }
  return ranges;
}
function sortDates(dates, comparer) {
  if (comparer === void 0)
    comparer = dateComparer;
  for (var i = 1, length = dates.length; i < length; i++) {
    if (comparer(dates[i], dates[i - 1]) < 0) {
      dates.sort(comparer);
      break;
    }
  }
  return dates;
}
function uniqueDates(srcDates, comparer) {
  if (comparer === void 0)
    comparer = dateComparer;
  var dates = sortDates(srcDates, comparer);
  var length = dates.length;
  var result = length > 0 ? [dates[0]] : [];
  for (var i = 1; i < length; i++) {
    if (comparer(dates[i], last2(result)) !== 0) {
      result.push(dates[i]);
    }
  }
  return result;
}
function transpose(rows) {
  var rowCount = rows.length;
  var result = [];
  for (var rowIx = 0; rowIx < rowCount; rowIx++) {
    var row = rows[rowIx];
    var colCount = row.length;
    for (var colIx = 0; colIx < colCount; colIx++) {
      result[colIx] = result[colIx] || [];
      result[colIx].push(row[colIx]);
    }
  }
  return result;
}
var DATA_FIELDS = ["data", "categories"];
function clearMissingValues(originalOptions, options2) {
  for (var field in options2) {
    if (!inArray(field, DATA_FIELDS) && options2.hasOwnProperty(field)) {
      var fieldValue = options2[field];
      var originalValue = originalOptions[field];
      if (defined2(originalValue)) {
        var nullValue = fieldValue === null;
        if (nullValue || !defined2(fieldValue)) {
          delete originalOptions[field];
          if (nullValue) {
            delete options2[field];
          }
        } else if (originalValue && isObject(fieldValue)) {
          if (isObject(originalValue)) {
            clearMissingValues(originalValue, fieldValue);
          }
        }
      }
    }
  }
}
function triggerPaneRender(panes) {
  for (var idx = 0; idx < panes.length; idx++) {
    panes[idx].notifyRender();
  }
}
setDefaultOptions(Chart, {
  renderAs: "",
  chartArea: {},
  legend: {
    visible: true,
    labels: {}
  },
  categoryAxis: {},
  seriesDefaults: {
    type: COLUMN,
    data: [],
    highlight: {
      visible: true
    },
    labels: {},
    negativeValues: {
      visible: false
    }
  },
  series: [],
  seriesColors: null,
  tooltip: {
    visible: false
  },
  transitions: true,
  valueAxis: {},
  plotArea: {},
  title: {},
  xAxis: {},
  yAxis: {},
  panes: [{}],
  pannable: false,
  zoomable: false
});
var chart_default = Chart;

// node_modules/@progress/kendo-charts/dist/es/sparkline/shared-tooltip.js
var TOP_OFFSET = -2;
var SharedTooltip2 = function(ChartSharedTooltip) {
  function SharedTooltip3() {
    ChartSharedTooltip.apply(this, arguments);
  }
  if (ChartSharedTooltip)
    SharedTooltip3.__proto__ = ChartSharedTooltip;
  SharedTooltip3.prototype = Object.create(ChartSharedTooltip && ChartSharedTooltip.prototype);
  SharedTooltip3.prototype.constructor = SharedTooltip3;
  SharedTooltip3.prototype._slotAnchor = function _slotAnchor(coords, slot) {
    var axis = this.plotArea.categoryAxis;
    var vertical = axis.options.vertical;
    var align2 = vertical ? {
      horizontal: "left",
      vertical: "center"
    } : {
      horizontal: "center",
      vertical: "bottom"
    };
    var point2;
    if (vertical) {
      point2 = new point_default2(this.plotArea.box.x2, slot.center().y);
    } else {
      point2 = new point_default2(slot.center().x, TOP_OFFSET);
    }
    return {
      point: point2,
      align: align2
    };
  };
  SharedTooltip3.prototype._defaultAnchor = function _defaultAnchor(point2, slot) {
    return this._slotAnchor({}, slot);
  };
  return SharedTooltip3;
}(shared_tooltip_default);
var shared_tooltip_default2 = SharedTooltip2;

// node_modules/@progress/kendo-charts/dist/es/sparkline/sparkline.js
var DEAULT_BAR_WIDTH = 150;
var DEAULT_BULLET_WIDTH = 150;
var NO_CROSSHAIR = [BAR, BULLET];
function hide(children) {
  var state = [];
  for (var idx = 0; idx < children.length; idx++) {
    var child = children[idx];
    state[idx] = child.style.display;
    child.style.display = "none";
  }
  return state;
}
function show(children, state) {
  for (var idx = 0; idx < children.length; idx++) {
    children[idx].style.display = state[idx];
  }
}
function wrapNumber(value) {
  return isNumber2(value) ? [value] : value;
}
var Sparkline = function(Chart2) {
  function Sparkline2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2)
    Sparkline2.__proto__ = Chart2;
  Sparkline2.prototype = Object.create(Chart2 && Chart2.prototype);
  Sparkline2.prototype.constructor = Sparkline2;
  Sparkline2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-sparkline");
  };
  Sparkline2.prototype._initElement = function _initElement(element) {
    Chart2.prototype._initElement.call(this, element);
    this._initialWidth = Math.floor(elementSize2(element).width);
  };
  Sparkline2.prototype._resize = function _resize() {
    var element = this.element;
    var state = hide(element.childNodes);
    this._initialWidth = Math.floor(elementSize2(element).width);
    show(element.childNodes, state);
    Chart2.prototype._resize.call(this);
  };
  Sparkline2.prototype._modelOptions = function _modelOptions() {
    var chartOptions = this.options;
    var stage = this._surfaceWrap();
    var displayState = hide(stage.childNodes);
    var space = document.createElement("span");
    space.innerHTML = "&nbsp;";
    stage.appendChild(space);
    var options2 = deepExtend({
      width: this._autoWidth,
      height: elementSize2(stage).height,
      transitions: chartOptions.transitions
    }, chartOptions.chartArea, {
      inline: true,
      align: false
    });
    elementSize2(stage, {
      width: options2.width,
      height: options2.height
    });
    stage.removeChild(space);
    show(stage.childNodes, displayState);
    if (this.surface) {
      this.surface.resize();
    }
    return options2;
  };
  Sparkline2.prototype._surfaceWrap = function _surfaceWrap() {
    if (!this.stage) {
      var stage = this.stage = document.createElement("span");
      this.element.appendChild(stage);
    }
    return this.stage;
  };
  Sparkline2.prototype._createPlotArea = function _createPlotArea(skipSeries) {
    var plotArea = Chart2.prototype._createPlotArea.call(this, skipSeries);
    this._autoWidth = this._initialWidth || this._calculateWidth(plotArea);
    return plotArea;
  };
  Sparkline2.prototype._calculateWidth = function _calculateWidth(plotArea) {
    var options2 = this.options;
    var margin = getSpacing(options2.chartArea.margin);
    var charts = plotArea.charts;
    var stage = this._surfaceWrap();
    var total3 = 0;
    for (var i = 0; i < charts.length; i++) {
      var currentChart = charts[i];
      var firstSeries = (currentChart.options.series || [])[0];
      if (!firstSeries) {
        continue;
      }
      if (firstSeries.type === BAR) {
        return DEAULT_BAR_WIDTH;
      }
      if (firstSeries.type === BULLET) {
        return DEAULT_BULLET_WIDTH;
      }
      if (firstSeries.type === PIE) {
        return elementSize2(stage).height;
      }
      var categoryAxis = currentChart.categoryAxis;
      if (categoryAxis) {
        var pointsCount = categoryAxis.categoriesCount() * (!currentChart.options.isStacked && inArray(firstSeries.type, [COLUMN, VERTICAL_BULLET]) ? currentChart.seriesOptions.length : 1);
        total3 = Math.max(total3, pointsCount);
      }
    }
    var size = total3 * options2.pointWidth;
    if (size > 0) {
      size += margin.left + margin.right;
    }
    return size;
  };
  Sparkline2.prototype._createSharedTooltip = function _createSharedTooltip(options2) {
    return new shared_tooltip_default2(this._plotArea, options2);
  };
  Sparkline2.normalizeOptions = function normalizeOptions(userOptions) {
    var options2 = wrapNumber(userOptions);
    if (isArray(options2)) {
      options2 = { seriesDefaults: { data: options2 } };
    } else {
      options2 = deepExtend({}, options2);
    }
    if (!options2.series) {
      options2.series = [{ data: wrapNumber(options2.data) }];
    }
    deepExtend(options2, {
      seriesDefaults: {
        type: options2.type
      }
    });
    if (inArray(options2.series[0].type, NO_CROSSHAIR) || inArray(options2.seriesDefaults.type, NO_CROSSHAIR)) {
      options2 = deepExtend({}, {
        categoryAxis: {
          crosshair: {
            visible: false
          }
        }
      }, options2);
    }
    return options2;
  };
  return Sparkline2;
}(chart_default);
setDefaultOptions(Sparkline, {
  chartArea: {
    margin: 2
  },
  axisDefaults: {
    visible: false,
    majorGridLines: {
      visible: false
    },
    valueAxis: {
      narrowRange: true
    }
  },
  seriesDefaults: {
    type: "line",
    area: {
      line: {
        width: 0.5
      }
    },
    bar: {
      stack: true
    },
    padding: 2,
    width: 0.5,
    overlay: {
      gradient: null
    },
    highlight: {
      visible: false
    },
    border: {
      width: 0
    },
    markers: {
      size: 2,
      visible: false
    }
  },
  tooltip: {
    visible: true,
    shared: true
  },
  categoryAxis: {
    crosshair: {
      visible: true,
      tooltip: {
        visible: false
      }
    }
  },
  legend: {
    visible: false
  },
  transitions: false,
  pointWidth: 5,
  panes: [{ clip: false }]
});

// node_modules/@progress/kendo-charts/dist/es/stock/fade-out-animation.js
var FadeOutAnimation = function(superclass) {
  function FadeOutAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    FadeOutAnimation2.__proto__ = superclass;
  FadeOutAnimation2.prototype = Object.create(superclass && superclass.prototype);
  FadeOutAnimation2.prototype.constructor = FadeOutAnimation2;
  FadeOutAnimation2.prototype.setup = function setup() {
    this._initialOpacity = parseFloat(elementStyles2(this.element, "opacity").opacity);
  };
  FadeOutAnimation2.prototype.step = function step(pos) {
    elementStyles2(this.element, {
      opacity: String(interpolateValue(this._initialOpacity, 0, pos))
    });
  };
  FadeOutAnimation2.prototype.abort = function abort() {
    superclass.prototype.abort.call(this);
    elementStyles2(this.element, {
      display: "none",
      opacity: String(this._initialOpacity)
    });
  };
  FadeOutAnimation2.prototype.cancel = function cancel() {
    superclass.prototype.abort.call(this);
    elementStyles2(this.element, {
      opacity: String(this._initialOpacity)
    });
  };
  return FadeOutAnimation2;
}(drawing_exports.Animation);
var fade_out_animation_default = FadeOutAnimation;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator-hint.js
function createDiv2(className, style) {
  var div = document.createElement("div");
  div.className = className;
  if (style) {
    div.style.cssText = style;
  }
  return div;
}
var NavigatorHint = function(Class3) {
  function NavigatorHint2(container, chartService, options2) {
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.container = container;
    this.chartService = chartService;
    var padding = elementStyles2(container, ["paddingLeft", "paddingTop"]);
    this.chartPadding = {
      top: padding.paddingTop,
      left: padding.paddingLeft
    };
    this.createElements();
    container.appendChild(this.element);
  }
  if (Class3)
    NavigatorHint2.__proto__ = Class3;
  NavigatorHint2.prototype = Object.create(Class3 && Class3.prototype);
  NavigatorHint2.prototype.constructor = NavigatorHint2;
  NavigatorHint2.prototype.createElements = function createElements() {
    var element = this.element = createDiv2("k-navigator-hint", "display: none; position: absolute; top: 1px; left: 1px;");
    var tooltip = this.tooltip = createDiv2("k-tooltip k-chart-tooltip");
    var scroll = this.scroll = createDiv2("k-scroll");
    tooltip.innerHTML = "&nbsp;";
    element.appendChild(tooltip);
    element.appendChild(scroll);
  };
  NavigatorHint2.prototype.show = function show2(from, to, bbox) {
    var ref2 = this;
    var element = ref2.element;
    var options2 = ref2.options;
    var scroll = ref2.scroll;
    var tooltip = ref2.tooltip;
    var middle = toDate(toTime(from) + toTime(to - from) / 2);
    var scrollWidth = bbox.width() * 0.4;
    var minPos = bbox.center().x - scrollWidth;
    var maxPos = bbox.center().x;
    var posRange = maxPos - minPos;
    var range = options2.max - options2.min;
    var scale = posRange / range;
    var offset = middle - options2.min;
    var text = this.chartService.intl.format(options2.format, from, to);
    var template3 = getTemplate(options2);
    this.clearHideTimeout();
    if (!this._visible) {
      elementStyles2(element, {
        visibility: "hidden",
        display: "block"
      });
      this._visible = true;
    }
    if (template3) {
      text = template3({
        from,
        to
      });
    }
    tooltip.innerHTML = text;
    elementStyles2(tooltip, {
      left: bbox.center().x - tooltip.offsetWidth / 2,
      top: bbox.y1
    });
    var tooltipStyle = elementStyles2(tooltip, ["marginTop", "borderTopWidth", "height"]);
    elementStyles2(scroll, {
      width: scrollWidth,
      left: minPos + offset * scale,
      top: bbox.y1 + tooltipStyle.marginTop + tooltipStyle.borderTopWidth + tooltipStyle.height / 2
    });
    elementStyles2(element, {
      visibility: "visible"
    });
  };
  NavigatorHint2.prototype.clearHideTimeout = function clearHideTimeout() {
    if (this._hideTimeout) {
      clearTimeout(this._hideTimeout);
    }
    if (this._hideAnimation) {
      this._hideAnimation.cancel();
    }
  };
  NavigatorHint2.prototype.hide = function hide2() {
    var this$1 = this;
    this.clearHideTimeout();
    this._hideTimeout = setTimeout(function() {
      this$1._visible = false;
      this$1._hideAnimation = new fade_out_animation_default(this$1.element);
      this$1._hideAnimation.setup();
      this$1._hideAnimation.play();
    }, this.options.hideDelay);
  };
  NavigatorHint2.prototype.destroy = function destroy2() {
    this.clearHideTimeout();
    if (this.container) {
      this.container.removeChild(this.element);
    }
    delete this.container;
    delete this.chartService;
    delete this.element;
    delete this.tooltip;
    delete this.scroll;
  };
  return NavigatorHint2;
}(class_default);
setDefaultOptions(NavigatorHint, {
  format: "{0:d} - {1:d}",
  hideDelay: 500
});
var navigator_hint_default = NavigatorHint;

// node_modules/@progress/kendo-charts/dist/es/stock/constants.js
var NAVIGATOR_PANE = "_navigator";
var NAVIGATOR_AXIS = NAVIGATOR_PANE;

// node_modules/@progress/kendo-charts/dist/es/stock/navigator.js
var ZOOM_ACCELERATION2 = 3;
var Navigator = function(Class3) {
  function Navigator3(chart) {
    var obj;
    Class3.call(this);
    this.chart = chart;
    var options2 = this.options = deepExtend({}, this.options, chart.options.navigator);
    var select = options2.select;
    if (select) {
      select.from = this.parseDate(select.from);
      select.to = this.parseDate(select.to);
    }
    if (!defined2(options2.hint.visible)) {
      options2.hint.visible = options2.visible;
    }
    this.chartObserver = new instance_observer_default(this, (obj = {}, obj[DRAG] = "_drag", obj[DRAG_END] = "_dragEnd", obj[ZOOM] = "_zoom", obj[ZOOM_END] = "_zoomEnd", obj));
    chart.addObserver(this.chartObserver);
  }
  if (Class3)
    Navigator3.__proto__ = Class3;
  Navigator3.prototype = Object.create(Class3 && Class3.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.parseDate = function parseDate$1(value) {
    return parseDate3(this.chart.chartService.intl, value);
  };
  Navigator3.prototype.clean = function clean() {
    if (this.selection) {
      this.selection.destroy();
      this.selection = null;
    }
    if (this.hint) {
      this.hint.destroy();
      this.hint = null;
    }
  };
  Navigator3.prototype.destroy = function destroy2() {
    if (this.chart) {
      this.chart.removeObserver(this.chartObserver);
      delete this.chart;
    }
    this.clean();
  };
  Navigator3.prototype.redraw = function redraw() {
    this._redrawSelf();
    this.initSelection();
  };
  Navigator3.prototype.initSelection = function initSelection() {
    var ref2 = this;
    var chart = ref2.chart;
    var options2 = ref2.options;
    var axis = this.mainAxis();
    var ref$1 = axis.roundedRange();
    var min3 = ref$1.min;
    var max2 = ref$1.max;
    var ref$2 = options2.select;
    var from = ref$2.from;
    var to = ref$2.to;
    var mousewheel = ref$2.mousewheel;
    var axisClone = clone(axis);
    if (axis.categoriesCount() === 0) {
      return;
    }
    this.clean();
    axisClone.box = axis.box;
    this.selection = new selection_default(chart, axisClone, {
      min: min3,
      max: max2,
      from: from || min3,
      to: to || max2,
      mousewheel: valueOrDefault2(mousewheel, { zoom: "left" }),
      visible: options2.visible
    }, new instance_observer_default(this, {
      selectStart: "_selectStart",
      select: "_select",
      selectEnd: "_selectEnd"
    }));
    if (options2.hint.visible) {
      this.hint = new navigator_hint_default(chart.element, chart.chartService, {
        min: min3,
        max: max2,
        template: getTemplate(options2.hint),
        format: options2.hint.format
      });
    }
  };
  Navigator3.prototype.setRange = function setRange() {
    var plotArea = this.chart._createPlotArea(true);
    var axis = plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    var ref2 = axis.roundedRange();
    var min3 = ref2.min;
    var max2 = ref2.max;
    var select = this.options.select || {};
    var from = select.from || min3;
    if (from < min3) {
      from = min3;
    }
    var to = select.to || max2;
    if (to > max2) {
      to = max2;
    }
    this.options.select = deepExtend({}, select, {
      from,
      to
    });
    this.filterAxes();
  };
  Navigator3.prototype._redrawSelf = function _redrawSelf(silent) {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      plotArea.redraw(last2(plotArea.panes), silent);
    }
  };
  Navigator3.prototype.redrawSlaves = function redrawSlaves() {
    var chart = this.chart;
    var plotArea = chart._plotArea;
    var slavePanes = plotArea.panes.slice(0, -1);
    plotArea.srcSeries = chart.options.series;
    plotArea.options.categoryAxis = chart.options.categoryAxis;
    plotArea.clearSeriesPointsCache();
    plotArea.redraw(slavePanes);
  };
  Navigator3.prototype._drag = function _drag(e) {
    var ref2 = this;
    var chart = ref2.chart;
    var selection = ref2.selection;
    var coords = chart._eventCoordinates(e.originalEvent);
    var navigatorAxis = this.mainAxis();
    var naviRange = navigatorAxis.roundedRange();
    var inNavigator = navigatorAxis.pane.box.containsPoint(coords);
    var axis = chart._plotArea.categoryAxis;
    var range = e.axisRanges[axis.options.name];
    var select = this.options.select;
    var duration2;
    if (!range || inNavigator || !selection) {
      return;
    }
    if (select.from && select.to) {
      duration2 = toTime(select.to) - toTime(select.from);
    } else {
      duration2 = toTime(selection.options.to) - toTime(selection.options.from);
    }
    var from = toDate(limitValue2(
      toTime(range.min),
      naviRange.min,
      toTime(naviRange.max) - duration2
    ));
    var to = toDate(limitValue2(
      toTime(from) + duration2,
      toTime(naviRange.min) + duration2,
      naviRange.max
    ));
    this.options.select = { from, to };
    if (this.options.liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(from, to);
    this.showHint(from, to);
  };
  Navigator3.prototype._dragEnd = function _dragEnd() {
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    if (this.hint) {
      this.hint.hide();
    }
  };
  Navigator3.prototype.readSelection = function readSelection() {
    var ref2 = this;
    var ref_selection_options = ref2.selection.options;
    var from = ref_selection_options.from;
    var to = ref_selection_options.to;
    var select = ref2.options.select;
    select.from = from;
    select.to = to;
  };
  Navigator3.prototype.filterAxes = function filterAxes() {
    var ref2 = this;
    var select = ref2.options.select;
    if (select === void 0)
      select = {};
    var chart = ref2.chart;
    var allAxes = chart.options.categoryAxis;
    var from = select.from;
    var to = select.to;
    for (var idx = 0; idx < allAxes.length; idx++) {
      var axis = allAxes[idx];
      if (axis.pane !== NAVIGATOR_PANE) {
        axis.min = from;
        axis.max = to;
      }
    }
  };
  Navigator3.prototype.filter = function filter() {
    var ref2 = this;
    var chart = ref2.chart;
    var select = ref2.options.select;
    if (!chart.requiresHandlers(["navigatorFilter"])) {
      return;
    }
    var mainAxis = this.mainAxis();
    var args = {
      from: select.from,
      to: select.to
    };
    if (mainAxis.options.type !== "category") {
      var axisOptions2 = new date_category_axis_default(deepExtend({
        baseUnit: "fit"
      }, chart.options.categoryAxis[0], {
        categories: [select.from, select.to]
      }), chart.chartService).options;
      args.from = addDuration(axisOptions2.min, -axisOptions2.baseUnitStep, axisOptions2.baseUnit);
      args.to = addDuration(axisOptions2.max, axisOptions2.baseUnitStep, axisOptions2.baseUnit);
    }
    this.chart.trigger("navigatorFilter", args);
  };
  Navigator3.prototype._zoom = function _zoom(e) {
    var ref2 = this;
    var axis = ref2.chart._plotArea.categoryAxis;
    var selection = ref2.selection;
    var ref_options = ref2.options;
    var select = ref_options.select;
    var liveDrag = ref_options.liveDrag;
    var mainAxis = this.mainAxis();
    var delta = e.delta;
    if (!selection) {
      return;
    }
    var fromIx = mainAxis.categoryIndex(selection.options.from);
    var toIx = mainAxis.categoryIndex(selection.options.to);
    var coords = this.chart._eventCoordinates(e.originalEvent);
    e.originalEvent.preventDefault();
    if (Math.abs(delta) > 1) {
      delta *= ZOOM_ACCELERATION2;
    }
    if (toIx - fromIx > 1) {
      selection.zoom(delta, coords);
      this.readSelection();
    } else {
      axis.options.min = select.from;
      select.from = axis.scaleRange(-e.delta * this.chart._mousewheelZoomRate(), coords).min;
    }
    if (liveDrag) {
      this.filterAxes();
      this.redrawSlaves();
    }
    selection.set(select.from, select.to);
    this.showHint(this.options.select.from, this.options.select.to);
  };
  Navigator3.prototype._zoomEnd = function _zoomEnd(e) {
    this._dragEnd(e);
  };
  Navigator3.prototype.showHint = function showHint(from, to) {
    var plotArea = this.chart._plotArea;
    if (this.hint) {
      this.hint.show(from, to, plotArea.backgroundBox());
    }
  };
  Navigator3.prototype._selectStart = function _selectStart(e) {
    return this.chart._selectStart(e);
  };
  Navigator3.prototype._select = function _select(e) {
    this.showHint(e.from, e.to);
    return this.chart._select(e);
  };
  Navigator3.prototype._selectEnd = function _selectEnd(e) {
    if (this.hint) {
      this.hint.hide();
    }
    this.readSelection();
    this.filterAxes();
    this.filter();
    this.redrawSlaves();
    return this.chart._selectEnd(e);
  };
  Navigator3.prototype.mainAxis = function mainAxis() {
    var plotArea = this.chart._plotArea;
    if (plotArea) {
      return plotArea.namedCategoryAxes[NAVIGATOR_AXIS];
    }
  };
  Navigator3.prototype.select = function select(from, to) {
    var select2 = this.options.select;
    if (from && to) {
      select2.from = this.parseDate(from);
      select2.to = this.parseDate(to);
      this.filterAxes();
      this.filter();
      this.redrawSlaves();
      this.selection.set(from, to);
    }
    return {
      from: select2.from,
      to: select2.to
    };
  };
  Navigator3.setup = function setup(options2, themeOptions) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (options2.__navi) {
      return;
    }
    options2.__navi = true;
    var naviOptions = deepExtend({}, themeOptions.navigator, options2.navigator);
    var panes = options2.panes = [].concat(options2.panes);
    var paneOptions = deepExtend({}, naviOptions.pane, { name: NAVIGATOR_PANE });
    if (!naviOptions.visible) {
      paneOptions.visible = false;
      paneOptions.height = 0.1;
    }
    panes.push(paneOptions);
    Navigator3.attachAxes(options2, naviOptions);
    Navigator3.attachSeries(options2, naviOptions, themeOptions);
  };
  Navigator3.attachAxes = function attachAxes(options2, naviOptions) {
    var series = naviOptions.series || [];
    var categoryAxes = options2.categoryAxis = [].concat(options2.categoryAxis);
    var valueAxes = options2.valueAxis = [].concat(options2.valueAxis);
    var equallySpacedSeries = filterSeriesByType(series, EQUALLY_SPACED_SERIES);
    var justifyAxis = equallySpacedSeries.length === 0;
    var base = deepExtend({
      type: "date",
      pane: NAVIGATOR_PANE,
      roundToBaseUnit: !justifyAxis,
      justified: justifyAxis,
      _collapse: false,
      majorTicks: { visible: true },
      tooltip: { visible: false },
      labels: { step: 1 },
      autoBind: naviOptions.autoBindElements,
      autoBaseUnitSteps: {
        minutes: [1],
        hours: [1, 2],
        days: [1, 2],
        weeks: [],
        months: [1],
        years: [1]
      }
    });
    var user = naviOptions.categoryAxis;
    categoryAxes.push(
      deepExtend({}, base, {
        maxDateGroups: 200
      }, user, {
        name: NAVIGATOR_AXIS,
        title: null,
        baseUnit: "fit",
        baseUnitStep: "auto",
        labels: { visible: false },
        majorTicks: { visible: false }
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_labels",
        maxDateGroups: 20,
        baseUnitStep: "auto",
        labels: { position: "" },
        plotBands: [],
        autoBaseUnitSteps: {
          minutes: []
        },
        _overlap: true
      }),
      deepExtend({}, base, user, {
        name: NAVIGATOR_AXIS + "_ticks",
        maxDateGroups: 200,
        majorTicks: {
          width: 0.5
        },
        plotBands: [],
        title: null,
        labels: { visible: false, mirror: true },
        _overlap: true
      })
    );
    valueAxes.push(deepExtend({
      name: NAVIGATOR_AXIS,
      pane: NAVIGATOR_PANE,
      majorGridLines: {
        visible: false
      },
      visible: false
    }, naviOptions.valueAxis));
  };
  Navigator3.attachSeries = function attachSeries(options2, naviOptions, themeOptions) {
    var series = options2.series = options2.series || [];
    var navigatorSeries = [].concat(naviOptions.series || []);
    var seriesColors = themeOptions.seriesColors;
    var defaults = naviOptions.seriesDefaults;
    for (var idx = 0; idx < navigatorSeries.length; idx++) {
      series.push(
        deepExtend({
          color: seriesColors[idx % seriesColors.length],
          categoryField: naviOptions.dateField,
          visibleInLegend: false,
          tooltip: {
            visible: false
          }
        }, defaults, navigatorSeries[idx], {
          axis: NAVIGATOR_AXIS,
          categoryAxis: NAVIGATOR_AXIS,
          autoBind: naviOptions.autoBindElements
        })
      );
    }
  };
  return Navigator3;
}(class_default);
function ClonedObject() {
}
function clone(obj) {
  ClonedObject.prototype = obj;
  return new ClonedObject();
}
var navigator_default = Navigator;

// node_modules/@progress/kendo-charts/dist/es/stock/stock-chart.js
var AUTO_CATEGORY_WIDTH = 28;
var StockChart = function(Chart2) {
  function StockChart2() {
    Chart2.apply(this, arguments);
  }
  if (Chart2)
    StockChart2.__proto__ = Chart2;
  StockChart2.prototype = Object.create(Chart2 && Chart2.prototype);
  StockChart2.prototype.constructor = StockChart2;
  StockChart2.prototype.applyDefaults = function applyDefaults2(options2, themeOptions) {
    var width = elementSize2(this.element).width || DEFAULT_WIDTH;
    var theme = themeOptions;
    var stockDefaults = {
      seriesDefaults: {
        categoryField: options2.dateField
      },
      axisDefaults: {
        categoryAxis: {
          name: "default",
          majorGridLines: {
            visible: false
          },
          labels: {
            step: 2
          },
          majorTicks: {
            visible: false
          },
          maxDateGroups: Math.floor(width / AUTO_CATEGORY_WIDTH)
        }
      }
    };
    if (theme) {
      theme = deepExtend({}, theme, stockDefaults);
    }
    navigator_default.setup(options2, theme);
    Chart2.prototype.applyDefaults.call(this, options2, theme);
  };
  StockChart2.prototype._setElementClass = function _setElementClass(element) {
    addClass(element, "k-chart k-stockchart");
  };
  StockChart2.prototype.setOptions = function setOptions(options2) {
    this.destroyNavigator();
    Chart2.prototype.setOptions.call(this, options2);
  };
  StockChart2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this.options.transitions = false;
    this._fullRedraw();
    this.options.transitions = transitions;
  };
  StockChart2.prototype._resize = function _resize() {
    this.noTransitionsRedraw();
  };
  StockChart2.prototype._redraw = function _redraw() {
    var navigator2 = this.navigator;
    if (!this._dirty() && navigator2 && navigator2.options.partialRedraw) {
      navigator2.redrawSlaves();
    } else {
      this._fullRedraw();
    }
  };
  StockChart2.prototype._dirty = function _dirty() {
    var options2 = this.options;
    var series = [].concat(options2.series, options2.navigator.series);
    var seriesCount = grep(series, function(s) {
      return s && s.visible;
    }).length;
    var dirty = this._seriesCount !== seriesCount;
    this._seriesCount = seriesCount;
    return dirty;
  };
  StockChart2.prototype._fullRedraw = function _fullRedraw() {
    var navigator2 = this.navigator;
    if (!navigator2) {
      navigator2 = this.navigator = new navigator_default(this);
      this.trigger("navigatorCreated", { navigator: navigator2 });
    }
    navigator2.clean();
    navigator2.setRange();
    Chart2.prototype._redraw.call(this);
    navigator2.initSelection();
  };
  StockChart2.prototype._trackSharedTooltip = function _trackSharedTooltip(coords) {
    var plotArea = this._plotArea;
    var pane = plotArea.paneByPoint(coords);
    if (pane && pane.options.name === NAVIGATOR_PANE) {
      this._unsetActivePoint();
    } else {
      Chart2.prototype._trackSharedTooltip.call(this, coords);
    }
  };
  StockChart2.prototype.bindCategories = function bindCategories() {
    Chart2.prototype.bindCategories.call(this);
    this.copyNavigatorCategories();
  };
  StockChart2.prototype.copyNavigatorCategories = function copyNavigatorCategories() {
    var definitions = [].concat(this.options.categoryAxis);
    var categories;
    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {
      var axis = definitions[axisIx];
      if (axis.name === NAVIGATOR_AXIS) {
        categories = axis.categories;
      } else if (categories && axis.pane === NAVIGATOR_PANE) {
        axis.categories = categories;
      }
    }
  };
  StockChart2.prototype.destroyNavigator = function destroyNavigator() {
    if (this.navigator) {
      this.navigator.destroy();
      this.navigator = null;
    }
  };
  StockChart2.prototype.destroy = function destroy2() {
    this.destroyNavigator();
    Chart2.prototype.destroy.call(this);
  };
  StockChart2.prototype._stopChartHandlers = function _stopChartHandlers(e) {
    var coords = this._eventCoordinates(e);
    var pane = this._plotArea.paneByPoint(coords);
    return Chart2.prototype._stopChartHandlers.call(this, e) || pane && pane.options.name === NAVIGATOR_PANE;
  };
  StockChart2.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {
    if (!this._dragZoomEnabled) {
      this.element.style.touchAction = "none";
      this._dragZoomEnabled = true;
    }
  };
  return StockChart2;
}(chart_default);
setDefaultOptions(StockChart, {
  dateField: "date",
  axisDefaults: {
    categoryAxis: {
      type: "date",
      baseUnit: "fit",
      justified: true
    },
    valueAxis: {
      narrowRange: true,
      labels: {
        format: "C"
      }
    }
  },
  navigator: {
    select: {},
    seriesDefaults: {
      markers: {
        visible: false
      },
      tooltip: {
        visible: true
      },
      line: {
        width: 2
      }
    },
    hint: {},
    visible: true
  },
  tooltip: {
    visible: true
  },
  legend: {
    visible: false
  }
});

// node_modules/@progress/kendo-charts/dist/es/gauges/constants.js
var ANGULAR_SPEED = 150;
var LINEAR_SPEED = 250;
var ARROW = "arrow";
var ARROW_POINTER = "arrowPointer";
var BAR_POINTER = "barPointer";
var DEFAULT_HEIGHT2 = 200;
var DEFAULT_LINE_WIDTH = 0.5;
var DEFAULT_WIDTH2 = 200;
var DEGREE = Math.PI / 180;
var INSIDE2 = "inside";
var LINEAR2 = "linear";
var OUTSIDE2 = "outside";
var RADIAL_POINTER = "radialPointer";
var RADIAL_RANGE_POINTER = "radialRangePointer";

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/pad.js
function pad3(bbox, value) {
  var origin = bbox.getOrigin();
  var size = bbox.getSize();
  var spacing = getSpacing(value);
  bbox.setOrigin([origin.x - spacing.left, origin.y - spacing.top]);
  bbox.setSize([size.width + (spacing.left + spacing.right), size.height + (spacing.top + spacing.bottom)]);
  return bbox;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/build-label-element.js
var Group2 = drawing_exports.Group;
var Path2 = drawing_exports.Path;
var Text3 = drawing_exports.Text;
function buildLabelElement(label, options2) {
  var labelBox = label.box;
  var textBox = label.children[0].box;
  var border = options2.border || {};
  var background = options2.background || "";
  var wrapper = Path2.fromRect(new geometry_exports.Rect([labelBox.x1, labelBox.y1], [labelBox.width(), labelBox.height()]), {
    stroke: {}
  });
  var text = new Text3(label.text, new geometry_exports.Point(textBox.x1, textBox.y1), {
    font: options2.font,
    fill: { color: options2.color }
  });
  var styleGeometry = pad3(text.bbox().clone(), options2.padding);
  var styleBox = Path2.fromRect(styleGeometry, {
    stroke: {
      color: border.width ? border.color : "",
      width: border.width,
      opacity: border.opacity,
      dashType: border.dashType,
      lineJoin: "round",
      lineCap: "round"
    },
    fill: {
      color: background
    }
  });
  var elements = new Group2();
  elements.append(wrapper);
  elements.append(styleBox);
  elements.append(text);
  return elements;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/get-range.js
function getRange(range, min3, max2) {
  var from = defined2(range.from) ? range.from : MIN_VALUE;
  var to = defined2(range.to) ? range.to : MAX_VALUE;
  range.from = Math.max(Math.min(to, from), min3);
  range.to = Math.min(Math.max(to, from), max2);
  return range;
}

// node_modules/@progress/kendo-charts/dist/es/gauges/utils/unpad.js
function unpad(bbox, value) {
  var spacing = getSpacing(value);
  spacing.left = -spacing.left;
  spacing.top = -spacing.top;
  spacing.right = -spacing.right;
  spacing.bottom = -spacing.bottom;
  return pad3(bbox, spacing);
}

// node_modules/@progress/kendo-charts/dist/es/gauges/gauge.js
var DEFAULT_MARGIN = 5;
var Path3 = drawing_exports.Path;
var Surface5 = drawing_exports.Surface;
var Gauge = function(Class3) {
  function Gauge2(element, userOptions, theme, context2) {
    if (context2 === void 0)
      context2 = {};
    Class3.call(this);
    this.element = element;
    this.theme = theme;
    this.contextService = new chart_service_default(this, context2);
    this._originalOptions = deepExtend({}, this.options, userOptions);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  }
  if (Class3)
    Gauge2.__proto__ = Class3;
  Gauge2.prototype = Object.create(Class3 && Class3.prototype);
  Gauge2.prototype.constructor = Gauge2;
  Gauge2.prototype.destroy = function destroy2() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
    }
    delete this.element;
    delete this.surfaceElement;
  };
  Gauge2.prototype.value = function value(pointerValue) {
    var pointer = this.pointers[0];
    if (arguments.length === 0) {
      return pointer.value();
    }
    pointer.value(pointerValue);
    this._setValueOptions(pointerValue);
  };
  Gauge2.prototype._draw = function _draw() {
    var surface = this.surface;
    surface.clear();
    surface.draw(this._visuals);
  };
  Gauge2.prototype.exportVisual = function exportVisual() {
    return this._visuals;
  };
  Gauge2.prototype.allValues = function allValues(values5) {
    var pointers = this.pointers;
    var allValues2 = [];
    if (arguments.length === 0) {
      for (var i = 0; i < pointers.length; i++) {
        allValues2.push(pointers[i].value());
      }
      return allValues2;
    }
    if (isArray(values5)) {
      for (var i$1 = 0; i$1 < values5.length; i$1++) {
        if (isNumber2(values5[i$1])) {
          pointers[i$1].value(values5[i$1]);
        }
      }
    }
    this._setValueOptions(values5);
  };
  Gauge2.prototype._setValueOptions = function _setValueOptions(values5) {
    var pointers = [].concat(this.options.pointer);
    var arrayValues = [].concat(values5);
    for (var i = 0; i < arrayValues.length; i++) {
      pointers[i].value = arrayValues[i];
    }
  };
  Gauge2.prototype.resize = function resize() {
    this.noTransitionsRedraw();
  };
  Gauge2.prototype.noTransitionsRedraw = function noTransitionsRedraw() {
    var transitions = this.options.transitions;
    this._toggleTransitions(false);
    this.redraw();
    this._toggleTransitions(transitions);
  };
  Gauge2.prototype.redraw = function redraw() {
    var size = this._surfaceSize();
    var wrapper = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._initSurface();
    this.gaugeArea = this._createGaugeArea();
    this._createModel();
    var bbox = unpad(wrapper.bbox(), this._gaugeAreaMargin);
    this.reflow(bbox);
  };
  Gauge2.prototype.setOptions = function setOptions(options2, theme) {
    this._originalOptions = deepExtend(this._originalOptions, options2);
    this.options = deepExtend({}, this._originalOptions);
    this._initTheme(theme);
    this.redraw();
  };
  Gauge2.prototype.setDirection = function setDirection(rtl) {
    this.contextService.rtl = Boolean(rtl);
    if (this.surface && this.surface.type === "svg") {
      this.surface.destroy();
      this.surface = null;
    }
  };
  Gauge2.prototype.setIntlService = function setIntlService(intl) {
    this.contextService.intl = intl;
  };
  Gauge2.prototype._initTheme = function _initTheme(theme) {
    var currentTheme = theme || this.theme || {};
    this.theme = currentTheme;
    this.options = deepExtend({}, currentTheme, this.options);
    var options2 = this.options;
    var pointer = options2.pointer;
    if (isArray(pointer)) {
      var pointers = [];
      for (var i = 0; i < pointer.length; i++) {
        pointers.push(deepExtend({}, currentTheme.pointer, pointer[i]));
      }
      options2.pointer = pointers;
    }
  };
  Gauge2.prototype._createGaugeArea = function _createGaugeArea() {
    var options2 = this.options.gaugeArea;
    var size = this.surface.size();
    var border = options2.border || {};
    var areaGeometry = new geometry_exports.Rect([0, 0], [size.width, size.height]);
    this._gaugeAreaMargin = options2.margin || DEFAULT_MARGIN;
    if (border.width > 0) {
      areaGeometry = unpad(areaGeometry, border.width);
    }
    var gaugeArea = Path3.fromRect(areaGeometry, {
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType,
        lineJoin: "round",
        lineCap: "round"
      },
      fill: {
        color: options2.background
      }
    });
    return gaugeArea;
  };
  Gauge2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    var element = this._surfaceElement();
    var size = this._surfaceSize();
    elementSize2(element, size);
    if (!surface || surface.options.type !== options2.renderAs) {
      if (surface) {
        surface.destroy();
      }
      this.surface = Surface5.create(element, {
        type: options2.renderAs
      });
    } else {
      this.surface.clear();
      this.surface.resize();
    }
  };
  Gauge2.prototype._surfaceSize = function _surfaceSize() {
    var options2 = this.options;
    var size = this._getSize();
    if (options2.gaugeArea) {
      deepExtend(size, options2.gaugeArea);
    }
    return size;
  };
  Gauge2.prototype._surfaceElement = function _surfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.element.appendChild(this.surfaceElement);
    }
    return this.surfaceElement;
  };
  Gauge2.prototype.getSize = function getSize() {
    return this._getSize();
  };
  Gauge2.prototype._getSize = function _getSize() {
    var element = this.element;
    var defaultSize = this._defaultSize();
    var width = element.offsetWidth;
    var height = element.offsetHeight;
    if (!width) {
      width = defaultSize.width;
    }
    if (!height) {
      height = defaultSize.height;
    }
    return { width, height };
  };
  Gauge2.prototype._defaultSize = function _defaultSize() {
    return {
      width: DEFAULT_WIDTH2,
      height: DEFAULT_HEIGHT2
    };
  };
  Gauge2.prototype._toggleTransitions = function _toggleTransitions(value) {
    var this$1 = this;
    this.options.transitions = value;
    for (var i = 0; i < this.pointers.length; i++) {
      this$1.pointers[i].options.animation.transitions = value;
    }
  };
  return Gauge2;
}(class_default);
setDefaultOptions(Gauge, {
  plotArea: {},
  theme: "default",
  renderAs: "",
  pointer: {},
  scale: {},
  gaugeArea: {}
});
var gauge_default = Gauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-scale.js
var Path4 = drawing_exports.Path;
var Group3 = drawing_exports.Group;
var Point3 = geometry_exports.Point;
function renderAxisTick(tickRenderOptions, tickOptions) {
  var position = tickRenderOptions.position;
  var tickX = tickRenderOptions.tickX;
  var tickY = tickRenderOptions.tickY;
  var start, end;
  if (tickRenderOptions.vertical) {
    start = new Point3(tickX, position);
    end = new Point3(tickX + tickOptions.size, position);
  } else {
    start = new Point3(position, tickY);
    end = new Point3(position, tickY + tickOptions.size);
  }
  var tickPath = new Path4({
    stroke: {
      color: tickOptions.color,
      width: tickOptions.width
    }
  }).moveTo(start).lineTo(end);
  return tickPath;
}
function renderTicks(tickGroup, tickPositions, tickRenderOptions, tickOptions) {
  var count = tickPositions.length;
  if (tickOptions.visible) {
    var mirror = tickRenderOptions.mirror;
    var lineBox = tickRenderOptions.lineBox;
    for (var i = tickOptions.skip; i < count; i += tickOptions.step) {
      if (i % tickOptions.skipUnit === 0) {
        continue;
      }
      tickRenderOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;
      tickRenderOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;
      tickRenderOptions.position = tickPositions[i];
      tickGroup.append(renderAxisTick(tickRenderOptions, tickOptions));
    }
  }
}
var LinearScale = function(NumericAxis2) {
  function LinearScale2(options2, service) {
    var scaleOptions = options2 || {};
    if (!defined2(scaleOptions.reverse) && scaleOptions.vertical === false && (service || {}).rtl) {
      scaleOptions = Object.assign({}, scaleOptions, {
        reverse: true
      });
    }
    NumericAxis2.call(this, 0, 1, scaleOptions, service);
    this.options.minorUnit = this.options.minorUnit || this.options.majorUnit / 10;
  }
  if (NumericAxis2)
    LinearScale2.__proto__ = NumericAxis2;
  LinearScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  LinearScale2.prototype.constructor = LinearScale2;
  LinearScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions = deepExtend({}, scaleOptions, { labels: { mirror: scaleOptions.mirror } });
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    return scaleOptions;
  };
  LinearScale2.prototype.initFields = function initFields() {
  };
  LinearScale2.prototype.render = function render3() {
    var elements = this.elements = new Group3();
    var labels = this.renderLabels();
    var scaleLine = this.renderLine();
    var scaleTicks = this.renderTicks();
    var ranges = this.renderRanges();
    elements.append(scaleLine, labels, scaleTicks, ranges);
    return elements;
  };
  LinearScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var options2 = this.options;
    var min3 = options2.min;
    var max2 = options2.max;
    var vertical = options2.vertical;
    var mirror = options2.labels.mirror;
    var ranges = options2.ranges || [];
    var elements = new Group3();
    var count = ranges.length;
    var rangeSize = options2.rangeSize || options2.minorTicks.size / 2;
    for (var i = 0; i < count; i++) {
      var range = getRange(ranges[i], min3, max2);
      var slot = this$1.getSlot(range.from, range.to);
      var slotX = vertical ? this$1.lineBox() : slot;
      var slotY = vertical ? slot : this$1.lineBox();
      if (vertical) {
        slotX.x1 -= rangeSize * (mirror ? -1 : 1);
      } else {
        slotY.y2 += rangeSize * (mirror ? -1 : 1);
      }
      elements.append(Path4.fromRect(new geometry_exports.Rect([slotX.x1, slotY.y1], [slotX.x2 - slotX.x1, slotY.y2 - slotY.y1]), {
        fill: { color: range.color, opacity: range.opacity },
        stroke: {}
      }));
    }
    return elements;
  };
  LinearScale2.prototype.renderLabels = function renderLabels() {
    var ref2 = this;
    var labels = ref2.labels;
    var options2 = ref2.options;
    var elements = new Group3();
    for (var i = 0; i < labels.length; i++) {
      elements.append(buildLabelElement(labels[i], options2.labels));
    }
    return elements;
  };
  LinearScale2.prototype.renderLine = function renderLine() {
    var line = this.options.line;
    var lineBox = this.lineBox();
    var elements = new Group3();
    if (line.width > 0 && line.visible) {
      var linePath = new Path4({
        stroke: {
          color: line.color,
          dashType: line.dashType,
          width: line.width
        }
      });
      linePath.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);
      elements.append(linePath);
    }
    return elements;
  };
  LinearScale2.prototype.renderTicks = function renderTicks$1() {
    var ticks = new Group3();
    var options2 = this.options;
    var majorUnit = options2.majorTicks.visible ? options2.majorUnit : 0;
    var tickRenderOptions = {
      vertical: options2.vertical,
      mirror: options2.labels.mirror,
      lineBox: this.lineBox()
    };
    renderTicks(ticks, this.getMajorTickPositions(), tickRenderOptions, options2.majorTicks);
    renderTicks(ticks, this.getMinorTickPositions(), tickRenderOptions, deepExtend({}, {
      skipUnit: majorUnit / options2.minorUnit
    }, options2.minorTicks));
    return ticks;
  };
  return LinearScale2;
}(numeric_axis_default);
setDefaultOptions(LinearScale, {
  min: 0,
  max: 50,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  line: {
    width: DEFAULT_LINE_WIDTH
  },
  labels: {
    position: INSIDE2,
    padding: 2
  },
  mirror: false,
  _alignLines: false
});
var linear_scale_default = LinearScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/pointer.js
var Pointer = function(Class3) {
  function Pointer2(scale, userOptions) {
    Class3.call(this);
    var ref2 = scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var options2 = this.options = deepExtend({}, this.options, userOptions);
    options2.fill = options2.color;
    this.scale = scale;
    if (defined2(options2.value)) {
      options2.value = limitValue2(options2.value, min3, max2);
    } else {
      options2.value = min3;
    }
  }
  if (Class3)
    Pointer2.__proto__ = Class3;
  Pointer2.prototype = Object.create(Class3 && Class3.prototype);
  Pointer2.prototype.constructor = Pointer2;
  Pointer2.prototype.value = function value(newValue) {
    var options2 = this.options;
    var value2 = options2.value;
    if (arguments.length === 0) {
      return value2;
    }
    var ref2 = this.scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    options2._oldValue = defined2(options2._oldValue) ? options2.value : min3;
    options2.value = limitValue2(newValue, min3, max2);
    if (this.elements) {
      this.repaint();
    }
  };
  return Pointer2;
}(class_default);
setDefaultOptions(Pointer, {
  color: BLACK
});
var pointer_default = Pointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-pointer.js
var LinearPointer = function(Pointer2) {
  function LinearPointer2(scale, options2) {
    Pointer2.call(this, scale, options2);
    this.options = deepExtend({
      track: {
        visible: defined2(options2.track)
      }
    }, this.options);
  }
  if (Pointer2)
    LinearPointer2.__proto__ = Pointer2;
  LinearPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  LinearPointer2.prototype.constructor = LinearPointer2;
  LinearPointer2.prototype.reflow = function reflow() {
    var ref2 = this;
    var options2 = ref2.options;
    var scale = ref2.scale;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var scaleLine = scale.lineBox();
    var trackSize = options2.track.size || options2.size;
    var pointerHalfSize = options2.size / 2;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    var pointerBox, pointerRangeBox, trackBox;
    space = mirror ? -space : space;
    if (vertical) {
      trackBox = new box_default(
        scaleLine.x1 + space,
        scaleLine.y1,
        scaleLine.x1 + space,
        scaleLine.y2
      );
      if (mirror) {
        trackBox.x1 -= trackSize;
      } else {
        trackBox.x2 += trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x2 + space,
          scaleLine.y1 - pointerHalfSize,
          scaleLine.x2 + space,
          scaleLine.y2 + pointerHalfSize
        );
        pointerBox = pointerRangeBox;
      }
    } else {
      trackBox = new box_default(
        scaleLine.x1,
        scaleLine.y1 - space,
        scaleLine.x2,
        scaleLine.y1 - space
      );
      if (mirror) {
        trackBox.y2 += trackSize;
      } else {
        trackBox.y1 -= trackSize;
      }
      if (options2.shape !== BAR_POINTER) {
        pointerRangeBox = new box_default(
          scaleLine.x1 - pointerHalfSize,
          scaleLine.y1 - space,
          scaleLine.x2 + pointerHalfSize,
          scaleLine.y1 - space
        );
        pointerBox = pointerRangeBox;
      }
    }
    this.trackBox = trackBox;
    this.pointerRangeBox = pointerRangeBox;
    this.box = pointerBox || trackBox.clone().pad(options2.border.width);
  };
  LinearPointer2.prototype.getElementOptions = function getElementOptions() {
    var options2 = this.options;
    return {
      fill: {
        color: options2.color,
        opacity: options2.opacity
      },
      stroke: defined2(options2.border) ? {
        color: options2.border.width ? options2.border.color || options2.color : "",
        width: options2.border.width,
        dashType: options2.border.dashType,
        opacity: options2.opacity
      } : null
    };
  };
  LinearPointer2.prototype._margin = function _margin() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var margin = getSpacing(options2.margin);
    var space = vertical ? margin[mirror ? "left" : "right"] : margin[mirror ? "bottom" : "top"];
    return space;
  };
  return LinearPointer2;
}(pointer_default);
setDefaultOptions(LinearPointer, {
  shape: BAR_POINTER,
  track: {
    border: {
      width: 1
    }
  },
  color: BLACK,
  border: {
    width: 1
  },
  opacity: 1,
  margin: getSpacing(3),
  animation: {
    type: BAR_POINTER
  },
  visible: true
});
var linear_pointer_default = LinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer-animation.js
var ArrowLinearPointerAnimation = function(superclass) {
  function ArrowLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    ArrowLinearPointerAnimation2.__proto__ = superclass;
  ArrowLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  ArrowLinearPointerAnimation2.prototype.constructor = ArrowLinearPointerAnimation2;
  ArrowLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var margin = options2.margin;
    var from = options2.from;
    var to = options2.to;
    var vertical = options2.vertical;
    var axis = vertical ? "x1" : "y1";
    if (options2.mirror === vertical) {
      from[axis] -= margin;
      to[axis] -= margin;
    } else {
      from[axis] += margin;
      to[axis] += margin;
    }
    var fromScale = this.fromScale = new geometry_exports.Point(from.x1, from.y1);
    var toScale = this.toScale = new geometry_exports.Point(to.x1, to.y1);
    if (options2.duration !== 0) {
      options2.duration = Math.max(fromScale.distanceTo(toScale) / options2.duration * 1e3, 1);
    }
  };
  ArrowLinearPointerAnimation2.prototype.step = function step(pos) {
    var translateX = interpolateValue(this.fromScale.x, this.toScale.x, pos);
    var translateY = interpolateValue(this.fromScale.y, this.toScale.y, pos);
    this.element.transform(geometry_exports.transform().translate(translateX, translateY));
  };
  return ArrowLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(ArrowLinearPointerAnimation, {
  easing: LINEAR2,
  duration: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(ARROW_POINTER, ArrowLinearPointerAnimation);
var arrow_linear_pointer_animation_default = ArrowLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/arrow-linear-pointer.js
var Point4 = geometry_exports.Point;
var Path5 = drawing_exports.Path;
var ArrowLinearPointer = function(LinearPointer2) {
  function ArrowLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined2(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.6;
    }
  }
  if (LinearPointer2)
    ArrowLinearPointer2.__proto__ = LinearPointer2;
  ArrowLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  ArrowLinearPointer2.prototype.constructor = ArrowLinearPointer2;
  ArrowLinearPointer2.prototype.pointerShape = function pointerShape() {
    var ref2 = this;
    var scale = ref2.scale;
    var size = ref2.options.size;
    var halfSize = size / 2;
    var sign = scale.options.mirror ? -1 : 1;
    var shape2;
    if (scale.options.vertical) {
      shape2 = [
        new Point4(0, 0 - halfSize),
        new Point4(0 - sign * size, 0),
        new Point4(0, 0 + halfSize)
      ];
    } else {
      shape2 = [
        new Point4(0 - halfSize, 0),
        new Point4(0, 0 + sign * size),
        new Point4(0 + halfSize, 0)
      ];
    }
    return shape2;
  };
  ArrowLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var animation = new arrow_linear_pointer_animation_default(this.elements, deepExtend(options2.animation, {
      vertical: scale.options.vertical,
      mirror: scale.options.mirror,
      margin: this._margin(options2.margin),
      from: scale.getSlot(options2._oldValue),
      to: scale.getSlot(options2.value)
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  ArrowLinearPointer2.prototype.render = function render3() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elementOptions = this.getElementOptions();
    var shape2 = this.pointerShape(options2.value);
    options2.animation.type = ARROW_POINTER;
    var elements = new Path5({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    }).moveTo(shape2[0]).lineTo(shape2[1]).lineTo(shape2[2]).close();
    var slot = scale.getSlot(options2.value);
    elements.transform(geometry_exports.transform().translate(slot.x1, slot.y1));
    this.elements = elements;
    return elements;
  };
  return ArrowLinearPointer2;
}(linear_pointer_default);
var arrow_linear_pointer_default = ArrowLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer-animation.js
var BarLinearPointerAnimation = function(superclass) {
  function BarLinearPointerAnimation2() {
    superclass.apply(this, arguments);
  }
  if (superclass)
    BarLinearPointerAnimation2.__proto__ = superclass;
  BarLinearPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  BarLinearPointerAnimation2.prototype.constructor = BarLinearPointerAnimation2;
  BarLinearPointerAnimation2.prototype.setup = function setup() {
    var options2 = this.options;
    var axis = this.axis = options2.vertical ? Y : X;
    var to = this.to = options2.newPoints[0][axis];
    var from = this.from = options2.oldPoints[0][axis];
    if (options2.duration !== 0) {
      options2.duration = Math.max(Math.abs(to - from) / options2.speed * 1e3, 1);
    }
    this._set(from);
  };
  BarLinearPointerAnimation2.prototype.step = function step(pos) {
    var value = interpolateValue(this.from, this.to, pos);
    this._set(value);
  };
  BarLinearPointerAnimation2.prototype._set = function _set(value) {
    var setter = "set" + this.axis.toUpperCase();
    var points3 = this.options.newPoints;
    points3[0][setter](value);
    points3[1][setter](value);
  };
  return BarLinearPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(BarLinearPointerAnimation, {
  easing: LINEAR2,
  speed: LINEAR_SPEED
});
drawing_exports.AnimationFactory.current.register(BAR_POINTER, BarLinearPointerAnimation);
var bar_linear_pointer_animation_default = BarLinearPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/bar-linear-pointer.js
var Group4 = drawing_exports.Group;
var Path6 = drawing_exports.Path;
var BarLinearPointer = function(LinearPointer2) {
  function BarLinearPointer2(scale, options2) {
    LinearPointer2.call(this, scale, options2);
    if (!defined2(this.options.size)) {
      this.options.size = this.scale.options.majorTicks.size * 0.3;
    }
  }
  if (LinearPointer2)
    BarLinearPointer2.__proto__ = LinearPointer2;
  BarLinearPointer2.prototype = Object.create(LinearPointer2 && LinearPointer2.prototype);
  BarLinearPointer2.prototype.constructor = BarLinearPointer2;
  BarLinearPointer2.prototype.pointerShape = function pointerShape(value) {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var ref$1 = scale.options;
    var mirror = ref$1.mirror;
    var vertical = ref$1.vertical;
    var dir = mirror === vertical ? -1 : 1;
    var size = options2.size * dir;
    var minSlot = scale.getSlot(scale.options.min);
    var slot = scale.getSlot(value);
    var axis = vertical ? Y : X;
    var sizeAxis = vertical ? X : Y;
    var margin = this._margin() * dir;
    var p1 = new geometry_exports.Point();
    p1[axis] = minSlot[axis + "1"];
    p1[sizeAxis] = minSlot[sizeAxis + "1"];
    var p2 = new geometry_exports.Point();
    p2[axis] = slot[axis + "1"];
    p2[sizeAxis] = slot[sizeAxis + "1"];
    if (vertical) {
      p1.translate(margin, 0);
      p2.translate(margin, 0);
    } else {
      p1.translate(0, margin);
      p2.translate(0, margin);
    }
    var p3 = p2.clone();
    var p4 = p1.clone();
    if (vertical) {
      p3.translate(size, 0);
      p4.translate(size, 0);
    } else {
      p3.translate(0, size);
      p4.translate(0, size);
    }
    return [p1, p2, p3, p4];
  };
  BarLinearPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var shape2 = this.pointerShape(options2.value);
    var pointerPath = this.pointerPath;
    var oldShape = this.pointerShape(options2._oldValue);
    pointerPath.moveTo(shape2[0]).lineTo(shape2[1]).lineTo(shape2[2]).lineTo(shape2[3]).close();
    var animation = new bar_linear_pointer_animation_default(pointerPath, deepExtend(options2.animation, {
      reverse: scale.options.reverse,
      vertical: scale.options.vertical,
      oldPoints: [oldShape[1], oldShape[2]],
      newPoints: [shape2[1], shape2[2]]
    }));
    if (options2.animation.transitions === false) {
      animation.options.duration = 0;
    }
    animation.setup();
    animation.play();
  };
  BarLinearPointer2.prototype.render = function render3() {
    var group = new Group4();
    var elementOptions = this.getElementOptions();
    if (this.options.track.visible) {
      group.append(this.renderTrack());
    }
    var pointer = this.pointerPath = new Path6({
      stroke: elementOptions.stroke,
      fill: elementOptions.fill
    });
    group.append(pointer);
    this.elements = group;
    return group;
  };
  BarLinearPointer2.prototype.renderTrack = function renderTrack() {
    var trackOptions = this.options.track;
    var border = trackOptions.border || {};
    var trackBox = this.trackBox.clone().pad(border.width || 0);
    return new Path6.fromRect(trackBox.toRect(), {
      fill: {
        color: trackOptions.color,
        opacity: trackOptions.opacity
      },
      stroke: {
        color: border.width ? border.color || trackOptions.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
  };
  return BarLinearPointer2;
}(linear_pointer_default);
var bar_linear_pointer_default = BarLinearPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/linear/linear-gauge.js
var DEFAULT_MIN_WIDTH = 60;
var DEFAULT_MIN_HEIGHT = 60;
var Group5 = drawing_exports.Group;
var LinearGauge = function(Gauge2) {
  function LinearGauge3() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    LinearGauge3.__proto__ = Gauge2;
  LinearGauge3.prototype = Object.create(Gauge2 && Gauge2.prototype);
  LinearGauge3.prototype.constructor = LinearGauge3;
  LinearGauge3.prototype.reflow = function reflow(bbox) {
    var pointers = this.pointers;
    var bboxX = bbox.origin.x;
    var bboxY = bbox.origin.y;
    var box = new box_default(bboxX, bboxY, bboxX + bbox.width(), bboxY + bbox.height());
    this.scale.reflow(box);
    this._shrinkScaleWidth(box);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow();
    }
    this.bbox = this._getBox(box);
    this._alignElements();
    this._shrinkElements();
    this._buildVisual();
    this._draw();
  };
  LinearGauge3.prototype._buildVisual = function _buildVisual() {
    var visuals = new Group5();
    var scaleElements = this.scale.render();
    var pointers = this.pointers;
    visuals.append(this.gaugeArea);
    visuals.append(scaleElements);
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      visuals.append(current4.render());
      current4.value(current4.options.value);
    }
    this._visuals = visuals;
  };
  LinearGauge3.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options2 = this.options;
    var scale = this.scale = new linear_scale_default(options2.scale, this.contextService);
    this.pointers = [];
    var pointers = options2.pointer;
    pointers = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointers.length; i++) {
      var currentOptions = deepExtend({}, pointers[i], {
        animation: {
          transitions: options2.transitions
        }
      });
      var pointerType = currentOptions.shape === ARROW ? arrow_linear_pointer_default : bar_linear_pointer_default;
      this$1.pointers.push(new pointerType(scale, currentOptions));
    }
  };
  LinearGauge3.prototype._defaultSize = function _defaultSize() {
    var vertical = this.options.scale.vertical;
    return {
      width: vertical ? DEFAULT_MIN_WIDTH : DEFAULT_WIDTH2,
      height: vertical ? DEFAULT_HEIGHT2 : DEFAULT_MIN_HEIGHT
    };
  };
  LinearGauge3.prototype._getBox = function _getBox(box) {
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var boxCenter = box.center();
    var plotAreaBox = pointers[0].box.clone().wrap(scale.box);
    for (var i = 0; i < pointers.length; i++) {
      plotAreaBox.wrap(pointers[i].box.clone());
    }
    var size;
    if (scale.options.vertical) {
      size = plotAreaBox.width() / 2;
      plotAreaBox = new box_default(
        boxCenter.x - size,
        box.y1,
        boxCenter.x + size,
        box.y2
      );
    } else {
      size = plotAreaBox.height() / 2;
      plotAreaBox = new box_default(
        box.x1,
        boxCenter.y - size,
        box.x2,
        boxCenter.y + size
      );
    }
    return plotAreaBox;
  };
  LinearGauge3.prototype._alignElements = function _alignElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box;
    var box = pointers[0].box.clone().wrap(scale.box);
    var plotAreaBox = this.bbox;
    for (var i = 0; i < pointers.length; i++) {
      box.wrap(pointers[i].box.clone());
    }
    var diff;
    if (scale.options.vertical) {
      diff = plotAreaBox.center().x - box.center().x;
      scale.reflow(new box_default(
        scaleBox.x1 + diff,
        plotAreaBox.y1,
        scaleBox.x2 + diff,
        plotAreaBox.y2
      ));
    } else {
      diff = plotAreaBox.center().y - box.center().y;
      scale.reflow(new box_default(
        scaleBox.x1,
        scaleBox.y1 + diff,
        scaleBox.x2,
        scaleBox.y2 + diff
      ));
    }
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  LinearGauge3.prototype._shrinkScaleWidth = function _shrinkScaleWidth(bbox) {
    var ref2 = this;
    var scale = ref2.scale;
    if (!scale.options.vertical) {
      var overflow = scale.contentBox().width() - bbox.width();
      if (overflow > 0) {
        scale.box.shrink(overflow, 0);
        scale.box.alignTo(bbox, "center");
        scale.reflow(scale.box);
      }
    }
  };
  LinearGauge3.prototype._shrinkElements = function _shrinkElements() {
    var this$1 = this;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    var scaleBox = scale.box.clone();
    var pos = scale.options.vertical ? "y" : "x";
    var pointerBox = pointers[0].box;
    for (var i = 0; i < pointers.length; i++) {
      pointerBox.wrap(pointers[i].box.clone());
    }
    scaleBox[pos + 1] += Math.max(scaleBox[pos + 1] - pointerBox[pos + 1], 0);
    scaleBox[pos + 2] -= Math.max(pointerBox[pos + 2] - scaleBox[pos + 2], 0);
    scale.reflow(scaleBox);
    for (var i$1 = 0; i$1 < pointers.length; i$1++) {
      pointers[i$1].reflow(this$1.bbox);
    }
  };
  return LinearGauge3;
}(gauge_default);
setDefaultOptions(LinearGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  },
  scale: {
    vertical: true
  }
});
var linear_gauge_default = LinearGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-scale.js
var GEO_ARC_ADJUST_ANGLE = 180;
var Arc3 = drawing_exports.Arc;
var Path7 = drawing_exports.Path;
var Group6 = drawing_exports.Group;
function drawTicks(arc, tickAngles, unit, tickOptions) {
  var ticks = new Group6();
  var center = arc.center;
  var radius = arc.getRadiusX();
  if (tickOptions.visible) {
    for (var i = 0; i < tickAngles.length; i++) {
      var tickStart = arc.pointAt(tickAngles[i]);
      var tickEnd = new geometry_exports.Point(center.x + radius - tickOptions.size, center.y).rotate(tickAngles[i], center);
      ticks.append(new Path7({
        stroke: {
          color: tickOptions.color,
          width: tickOptions.width
        }
      }).moveTo(tickStart).lineTo(tickEnd));
    }
  }
  return ticks;
}
function rangeSegment(from, to, color, opacity) {
  return { from, to, color, opacity };
}
var RadialScale = function(NumericAxis2) {
  function RadialScale2(options2, service) {
    NumericAxis2.call(this, 0, 1, options2, service);
  }
  if (NumericAxis2)
    RadialScale2.__proto__ = NumericAxis2;
  RadialScale2.prototype = Object.create(NumericAxis2 && NumericAxis2.prototype);
  RadialScale2.prototype.constructor = RadialScale2;
  RadialScale2.prototype.initUserOptions = function initUserOptions(options2) {
    var scaleOptions = deepExtend({}, this.options, options2);
    scaleOptions.majorUnit = scaleOptions.majorUnit || autoMajorUnit(scaleOptions.min, scaleOptions.max);
    scaleOptions.minorUnit = scaleOptions.minorUnit || scaleOptions.majorUnit / 10;
    return scaleOptions;
  };
  RadialScale2.prototype.initFields = function initFields() {
  };
  RadialScale2.prototype.render = function render3(center, radius) {
    var arc = this.renderArc(center, radius);
    this.bbox = arc.bbox();
    this.labelElements = this.renderLabels();
    this.ticks = this.renderTicks();
    this.ranges = this.renderRanges();
  };
  RadialScale2.prototype.reflow = function reflow(bbox) {
    var center = bbox.center();
    var radius = Math.min(bbox.height(), bbox.width()) / 2;
    if (defined2(this.bbox)) {
      this.bbox = this.arc.bbox();
      this.radius(this.arc.getRadiusX());
      this.repositionRanges();
      this.renderLabels();
    } else {
      return this.render(center, radius);
    }
  };
  RadialScale2.prototype.slotAngle = function slotAngle(value) {
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var reverse = ref2.reverse;
    var startAngle = ref2.startAngle;
    var endAngle = ref2.endAngle;
    var angle = endAngle - startAngle;
    var result;
    if (reverse) {
      result = endAngle - (value - min3) / (max2 - min3) * angle;
    } else {
      result = (value - min3) / (max2 - min3) * angle + startAngle;
    }
    return result + GEO_ARC_ADJUST_ANGLE;
  };
  RadialScale2.prototype.hasRanges = function hasRanges() {
    var ranges = this.options.ranges;
    return ranges && ranges.length;
  };
  RadialScale2.prototype.ticksSize = function ticksSize() {
    var ref2 = this.options;
    var majorTicks = ref2.majorTicks;
    var minorTicks = ref2.minorTicks;
    var size = 0;
    if (majorTicks.visible) {
      size = majorTicks.size;
    }
    if (minorTicks.visible) {
      size = Math.max(minorTicks.size, size);
    }
    return size;
  };
  RadialScale2.prototype.labelsCount = function labelsCount() {
    var count = NumericAxis2.prototype.labelsCount.call(this);
    var options2 = this.options;
    var angle = options2.endAngle - options2.startAngle;
    if (angle >= 360 && options2.max % options2.majorUnit === 0) {
      count -= 1;
    }
    return count;
  };
  RadialScale2.prototype.renderLabels = function renderLabels() {
    var this$1 = this;
    var options2 = this.options;
    var arc = this.arc.clone();
    var radius = arc.getRadiusX();
    var tickAngles = this.tickAngles(arc, options2.majorUnit);
    var rangeSize = options2.rangeSize = options2.rangeSize || radius * 0.1;
    var labelsGroup = new Group6();
    var rangeDistance = radius * 0.05;
    if (defined2(options2.rangeDistance)) {
      rangeDistance = options2.rangeDistance;
    } else {
      options2.rangeDistance = rangeDistance;
    }
    var labelsOptions = options2.labels;
    var isInside = labelsOptions.position === INSIDE2;
    var hasLabelElements = defined2(this.labelElements);
    if (isInside) {
      radius -= this.ticksSize();
      if (this.hasRanges() && !hasLabelElements) {
        radius -= rangeSize + rangeDistance;
      }
      arc.setRadiusX(radius).setRadiusY(radius);
    }
    var labels = this.labels;
    var count = labels.length;
    var padding = getSpacing(labelsOptions.padding);
    var paddingWidth = (padding.left + padding.right) / 2;
    var paddingHeight = (padding.top + padding.bottom) / 2;
    for (var i = 0; i < count; i++) {
      var label = labels[i];
      var halfWidth = label.box.width() / 2;
      var halfHeight = label.box.height() / 2;
      var angle = tickAngles[i];
      var labelAngle = (angle - GEO_ARC_ADJUST_ANGLE) * DEGREE;
      var lp = arc.pointAt(angle);
      var cx = lp.x + Math.cos(labelAngle) * (halfWidth + paddingWidth) * (isInside ? 1 : -1);
      var cy = lp.y + Math.sin(labelAngle) * (halfHeight + paddingHeight) * (isInside ? 1 : -1);
      label.reflow(new box_default(cx - halfWidth, cy - halfHeight, cx + halfWidth, cy + halfHeight));
      var labelPos = new geometry_exports.Point(label.box.x1, label.box.y1);
      var labelElement = void 0;
      if (!hasLabelElements) {
        labelElement = buildLabelElement(label, options2.labels);
        labelsGroup.append(labelElement);
      } else {
        labelElement = this$1.labelElements.children[i];
        var prevLabelPos = labelElement.bbox().origin;
        var labelTransform = labelElement.transform() || geometry_exports.transform();
        labelTransform.translate(labelPos.x - prevLabelPos.x, labelPos.y - prevLabelPos.y);
        labelElement.transform(labelTransform);
      }
      this$1.bbox = geometry_exports.Rect.union(this$1.bbox, labelElement.bbox());
    }
    return labelsGroup;
  };
  RadialScale2.prototype.repositionRanges = function repositionRanges() {
    var ranges = this.ranges.children;
    if (ranges.length > 0) {
      var ref2 = this.options;
      var rangeDistance = ref2.rangeDistance;
      var rangeSize = ref2.rangeSize;
      var rangeRadius = this.getRangeRadius();
      if (this.options.labels.position === INSIDE2) {
        rangeRadius += rangeSize + rangeDistance;
      }
      var newRadius = rangeRadius + rangeSize / 2;
      for (var i = 0; i < ranges.length; i++) {
        ranges[i]._geometry.setRadiusX(newRadius).setRadiusY(newRadius);
      }
      this.bbox = geometry_exports.Rect.union(this.bbox, this.ranges.bbox());
    }
  };
  RadialScale2.prototype.renderRanges = function renderRanges() {
    var this$1 = this;
    var segments = this.rangeSegments();
    var segmentsCount = segments.length;
    var result = new Group6();
    if (segmentsCount) {
      var ref2 = this.options;
      var rangeSize = ref2.rangeSize;
      var reverse = ref2.reverse;
      var rangeDistance = ref2.rangeDistance;
      var rangeRadius = this.getRangeRadius();
      this.radius(this.radius() - rangeSize - rangeDistance);
      for (var i = 0; i < segmentsCount; i++) {
        var segment = segments[i];
        var from = this$1.slotAngle(segment[reverse ? "to" : "from"]);
        var to = this$1.slotAngle(segment[!reverse ? "to" : "from"]);
        if (to - from !== 0) {
          result.append(this$1.createRange(from, to, rangeRadius, segment));
        }
      }
    }
    return result;
  };
  RadialScale2.prototype.createRange = function createRange(startAngle, endAngle, rangeRadius, options2) {
    var rangeSize = this.options.rangeSize;
    var rangeGeom = new geometry_exports.Arc(this.arc.center, {
      radiusX: rangeRadius + rangeSize / 2,
      radiusY: rangeRadius + rangeSize / 2,
      startAngle,
      endAngle
    });
    return new Arc3(rangeGeom, {
      stroke: {
        width: rangeSize,
        color: options2.color,
        opacity: options2.opacity,
        lineCap: options2.lineCap
      }
    });
  };
  RadialScale2.prototype.rangeSegments = function rangeSegments() {
    var options2 = this.options;
    var ranges = options2.ranges || [];
    var count = ranges.length;
    var segments = [];
    if (count) {
      var min3 = options2.min;
      var max2 = options2.max;
      var defaultColor = options2.rangePlaceholderColor;
      segments.push(rangeSegment(min3, max2, defaultColor));
      for (var i = 0; i < count; i++) {
        var range = getRange(ranges[i], min3, max2);
        var segmentsCount = segments.length;
        for (var j = 0; j < segmentsCount; j++) {
          var segment = segments[j];
          if (segment.from <= range.from && range.from <= segment.to) {
            segments.push(rangeSegment(range.from, range.to, range.color, range.opacity));
            if (segment.from <= range.to && range.to <= segment.to) {
              segments.push(rangeSegment(range.to, segment.to, defaultColor, range.opacity));
            }
            segment.to = range.from;
            break;
          }
        }
      }
    }
    return segments;
  };
  RadialScale2.prototype.getRangeRadius = function getRangeRadius() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var rangeSize = options2.rangeSize;
    var rangeDistance = options2.rangeDistance;
    var majorTickSize = options2.majorTicks.size;
    var radius;
    if (options2.labels.position === OUTSIDE2) {
      radius = arc.getRadiusX() - majorTickSize - rangeDistance - rangeSize;
    } else {
      radius = arc.getRadiusX() - rangeSize;
    }
    return radius;
  };
  RadialScale2.prototype.renderArc = function renderArc(center, radius) {
    var options2 = this.options;
    var arc = this.arc = new geometry_exports.Arc(center, {
      radiusX: radius,
      radiusY: radius,
      startAngle: options2.startAngle + GEO_ARC_ADJUST_ANGLE,
      endAngle: options2.endAngle + GEO_ARC_ADJUST_ANGLE
    });
    return arc;
  };
  RadialScale2.prototype.renderTicks = function renderTicks2() {
    var ref2 = this;
    var arc = ref2.arc;
    var options2 = ref2.options;
    var tickArc = arc.clone();
    this.majorTickAngles = this.tickAngles(arc, options2.majorUnit);
    this.majorTicks = drawTicks(tickArc, this.majorTickAngles, options2.majorUnit, options2.majorTicks);
    var allTicks = new Group6();
    allTicks.append(this.majorTicks);
    var majorTickSize = options2.majorTicks.size;
    var minorTickSize = options2.minorTicks.size;
    this._tickDifference = majorTickSize - minorTickSize;
    if (options2.labels.position === OUTSIDE2) {
      var radius = tickArc.getRadiusX();
      tickArc.setRadiusX(radius - majorTickSize + minorTickSize).setRadiusY(radius - majorTickSize + minorTickSize);
    }
    this.minorTickAngles = this.normalizeTickAngles(this.tickAngles(arc, options2.minorUnit));
    this.minorTicks = drawTicks(tickArc, this.minorTickAngles, options2.minorUnit, options2.minorTicks);
    allTicks.append(this.minorTicks);
    return allTicks;
  };
  RadialScale2.prototype.normalizeTickAngles = function normalizeTickAngles(angles) {
    var options2 = this.options;
    var skip = options2.majorUnit / options2.minorUnit;
    for (var i = angles.length - 1; i >= 0; i--) {
      if (i % skip === 0) {
        angles.splice(i, 1);
      }
    }
    return angles;
  };
  RadialScale2.prototype.tickAngles = function tickAngles(ring, stepValue) {
    var options2 = this.options;
    var reverse = options2.reverse;
    var range = options2.max - options2.min;
    var angle = ring.endAngle - ring.startAngle;
    var tickCount = range / stepValue;
    var pos = ring.startAngle;
    var step = angle / tickCount;
    if (reverse) {
      pos += angle;
      step = -step;
    }
    if (angle >= 360 && options2.max % stepValue === 0) {
      tickCount -= 1;
    }
    var positions = [];
    for (var i = 0; i < tickCount; i++) {
      positions.push(round3(pos, COORD_PRECISION));
      pos += step;
    }
    if (round3(pos) <= ring.endAngle) {
      positions.push(pos);
    }
    return positions;
  };
  RadialScale2.prototype.radius = function radius(value) {
    if (value) {
      this.arc.setRadiusX(value).setRadiusY(value);
      this.repositionTicks(this.majorTicks.children, this.majorTickAngles);
      this.repositionTicks(this.minorTicks.children, this.minorTickAngles, true);
    } else {
      return this.arc.getRadiusX();
    }
  };
  RadialScale2.prototype.repositionTicks = function repositionTicks(ticks, tickAngles, minor) {
    var diff = minor ? this._tickDifference || 0 : 0;
    var tickArc = this.arc;
    var radius = tickArc.getRadiusX();
    if (minor && this.options.labels.position === OUTSIDE2 && diff !== 0) {
      tickArc = this.arc.clone();
      tickArc.setRadiusX(radius - diff).setRadiusY(radius - diff);
    }
    for (var i = 0; i < ticks.length; i++) {
      var newPoint = tickArc.pointAt(tickAngles[i]);
      var segments = ticks[i].segments;
      var xDiff = newPoint.x - segments[0].anchor().x;
      var yDiff = newPoint.y - segments[0].anchor().y;
      ticks[i].transform(new geometry_exports.transform().translate(xDiff, yDiff));
    }
  };
  return RadialScale2;
}(numeric_axis_default);
setDefaultOptions(RadialScale, {
  min: 0,
  max: 100,
  majorTicks: {
    size: 15,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  minorTicks: {
    size: 10,
    align: INSIDE2,
    color: BLACK,
    width: DEFAULT_LINE_WIDTH,
    visible: true
  },
  startAngle: -30,
  endAngle: 210,
  labels: {
    position: INSIDE2,
    padding: 2
  }
});
var radial_scale_default = RadialScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer-animation.js
var RadialPointerAnimation = function(superclass) {
  function RadialPointerAnimation2(element, options2) {
    superclass.call(this, element, options2);
    var animationOptions = this.options;
    animationOptions.duration = Math.max(Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3, 1);
  }
  if (superclass)
    RadialPointerAnimation2.__proto__ = superclass;
  RadialPointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RadialPointerAnimation2.prototype.constructor = RadialPointerAnimation2;
  RadialPointerAnimation2.prototype.step = function step(pos) {
    var options2 = this.options;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.transform(geometry_exports.transform().rotate(angle, options2.center));
  };
  return RadialPointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RadialPointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_POINTER, RadialPointerAnimation);
var radial_pointer_animation_default = RadialPointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-pointer.js
var CAP_SIZE = 0.05;
var Circle3 = drawing_exports.Circle;
var Group7 = drawing_exports.Group;
var Path8 = drawing_exports.Path;
var RadialPointer = function(Pointer2) {
  function RadialPointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RadialPointer2.__proto__ = Pointer2;
  RadialPointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RadialPointer2.prototype.constructor = RadialPointer2;
  RadialPointer2.prototype.setAngle = function setAngle(angle) {
    this.elements.transform(geometry_exports.transform().rotate(angle, this.center));
  };
  RadialPointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (options2.animation.transitions === false) {
      this.setAngle(newAngle);
    } else {
      new radial_pointer_animation_default(this.elements, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      })).play();
    }
  };
  RadialPointer2.prototype.render = function render3() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var elements = new Group7();
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    elements.append(this._renderNeedle(), this._renderCap());
    this.elements = elements;
    this.setAngle(DEGREE);
    return elements;
  };
  RadialPointer2.prototype.reflow = function reflow(arc) {
    var center = this.center = arc.center;
    var length = limitValue2(this.options.length || 1, 0.1, 1.5);
    var radius = this.radius = arc.getRadiusX() * length;
    var capSize = this.capSize = Math.round(radius * this.options.cap.size);
    this.bbox = geometry_exports.Rect.fromPoints(
      new geometry_exports.Point(center.x - capSize, center.y - capSize),
      new geometry_exports.Point(center.x + capSize, center.y + capSize)
    );
  };
  RadialPointer2.prototype._renderNeedle = function _renderNeedle() {
    var minorTickSize = this.scale.options.minorTicks.size;
    var center = this.center;
    var needleColor = this.options.color;
    var needlePath = new Path8({
      fill: { color: needleColor },
      stroke: { color: needleColor, width: DEFAULT_LINE_WIDTH }
    });
    needlePath.moveTo(center.x + this.radius - minorTickSize, center.y).lineTo(center.x, center.y - this.capSize / 2).lineTo(center.x, center.y + this.capSize / 2).close();
    return needlePath;
  };
  RadialPointer2.prototype._renderCap = function _renderCap() {
    var options2 = this.options;
    var capColor = options2.cap.color || options2.color;
    var circle = new geometry_exports.Circle(this.center, this.capSize);
    var cap = new Circle3(circle, {
      fill: { color: capColor },
      stroke: { color: capColor }
    });
    return cap;
  };
  return RadialPointer2;
}(pointer_default);
setDefaultOptions(RadialPointer, {
  cap: {
    size: CAP_SIZE
  },
  arrow: {
    width: 16,
    height: 14
  },
  animation: {
    type: RADIAL_POINTER,
    duration: ANGULAR_SPEED
  }
});
var radial_pointer_default = RadialPointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/radial/radial-gauge.js
var Group8 = drawing_exports.Group;
var RadialGauge = function(Gauge2) {
  function RadialGauge3() {
    Gauge2.apply(this, arguments);
  }
  if (Gauge2)
    RadialGauge3.__proto__ = Gauge2;
  RadialGauge3.prototype = Object.create(Gauge2 && Gauge2.prototype);
  RadialGauge3.prototype.constructor = RadialGauge3;
  RadialGauge3.prototype.reflow = function reflow(bbox) {
    var this$1 = this;
    var pointers = this.pointers;
    this.scale.reflow(bbox);
    this._initialPlotArea = this.scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(this$1.scale.arc);
      this$1._initialPlotArea = geometry_exports.Rect.union(this$1._initialPlotArea, pointers[i].bbox);
    }
    this.fitScale(bbox);
    this.alignScale(bbox);
    this._buildVisual(this.gaugeArea, pointers, this.scale);
    this._draw();
  };
  RadialGauge3.prototype._buildVisual = function _buildVisual(gaugeArea, pointers, scale) {
    var visuals = this._visuals = new Group8();
    visuals.append(gaugeArea);
    visuals.append(scale.ticks);
    visuals.append(scale.ranges);
    this._buildPointers(pointers);
    visuals.append(scale.labelElements);
  };
  RadialGauge3.prototype._buildPointers = function _buildPointers(pointers) {
    var this$1 = this;
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      this$1._visuals.append(current4.elements);
      current4.value(current4.options.value);
    }
  };
  RadialGauge3.prototype.fitScale = function fitScale(bbox) {
    var this$1 = this;
    var arc = this.scale.arc;
    var plotAreaBox = this._initialPlotArea;
    var step = Math.abs(this.getDiff(plotAreaBox, bbox));
    var min3 = round3(step, COORD_PRECISION);
    var max2 = round3(-step, COORD_PRECISION);
    var minDiff, midDiff, maxDiff, mid, oldDiff;
    var staleFlag = 0;
    var i = 0;
    while (i++ < 100) {
      staleFlag = oldDiff === maxDiff ? staleFlag + 1 : 0;
      if (staleFlag > 5) {
        break;
      }
      if (min3 !== mid) {
        minDiff = this$1.getPlotBox(min3, bbox, arc);
        if (0 <= minDiff && minDiff <= 2) {
          break;
        }
      }
      if (max2 !== mid) {
        maxDiff = this$1.getPlotBox(max2, bbox, arc);
        if (0 <= maxDiff && maxDiff <= 2) {
          break;
        }
      }
      if (minDiff > 0 && maxDiff > 0) {
        mid = min3 * 2;
      } else if (minDiff < 0 && maxDiff < 0) {
        mid = max2 * 2;
      } else {
        mid = round3((min3 + max2) / 2 || 1, COORD_PRECISION);
      }
      midDiff = this$1.getPlotBox(mid, bbox, arc);
      if (0 <= midDiff && midDiff <= 2) {
        break;
      }
      oldDiff = maxDiff;
      if (midDiff > 0) {
        max2 = mid;
        maxDiff = midDiff;
      } else {
        min3 = mid;
        minDiff = midDiff;
      }
    }
  };
  RadialGauge3.prototype.getPlotBox = function getPlotBox(step, bbox, arc) {
    var this$1 = this;
    var scale = this.scale;
    var pointers = this.pointers;
    var radius = arc.getRadiusX();
    var scaleArc = arc.clone();
    scaleArc.setRadiusX(radius + step).setRadiusY(radius + step);
    scale.arc = scaleArc;
    scale.reflow(bbox);
    this.plotBbox = scale.bbox;
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scaleArc);
      this$1.plotBbox = geometry_exports.Rect.union(this$1.plotBbox, pointers[i].bbox);
    }
    return this.getDiff(this.plotBbox, bbox);
  };
  RadialGauge3.prototype.getDiff = function getDiff(plotBox, box) {
    return Math.min(box.width() - plotBox.width(), box.height() - plotBox.height());
  };
  RadialGauge3.prototype.alignScale = function alignScale(bbox) {
    var this$1 = this;
    var plotBoxCenter = this.plotBbox.center();
    var boxCenter = bbox.center();
    var paddingX = plotBoxCenter.x - boxCenter.x;
    var paddingY = plotBoxCenter.y - boxCenter.y;
    var ref2 = this;
    var scale = ref2.scale;
    var pointers = ref2.pointers;
    scale.arc.center.x -= paddingX;
    scale.arc.center.y -= paddingY;
    scale.reflow(bbox);
    for (var i = 0; i < pointers.length; i++) {
      pointers[i].reflow(scale.arc);
      this$1.plotBbox = geometry_exports.Rect.union(scale.bbox, pointers[i].bbox);
    }
  };
  RadialGauge3.prototype._createModel = function _createModel() {
    var this$1 = this;
    var options2 = this.options;
    var pointers = options2.pointer;
    var scale = this.scale = new radial_scale_default(options2.scale, this.contextService);
    this.pointers = [];
    var pointersArr = isArray(pointers) ? pointers : [pointers];
    for (var i = 0; i < pointersArr.length; i++) {
      var current4 = new radial_pointer_default(scale, deepExtend({}, pointersArr[i], {
        animation: {
          transitions: options2.transitions
        }
      }));
      this$1.pointers.push(current4);
    }
  };
  return RadialGauge3;
}(gauge_default);
setDefaultOptions(RadialGauge, {
  transitions: true,
  gaugeArea: {
    background: ""
  }
});
var radial_gauge_default = RadialGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-scale.js
var ArcScale = function(RadialScale2) {
  function ArcScale2() {
    RadialScale2.apply(this, arguments);
  }
  if (RadialScale2)
    ArcScale2.__proto__ = RadialScale2;
  ArcScale2.prototype = Object.create(RadialScale2 && RadialScale2.prototype);
  ArcScale2.prototype.constructor = ArcScale2;
  ArcScale2.prototype.rangeSegments = function rangeSegments() {
    var ref2 = this.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var rangePlaceholderColor = ref2.rangePlaceholderColor;
    var rangeLineCap = ref2.rangeLineCap;
    return [{ from: min3, to: max2, color: rangePlaceholderColor, lineCap: rangeLineCap }];
  };
  ArcScale2.prototype.hasRanges = function hasRanges() {
    return true;
  };
  ArcScale2.prototype.placeholderRangeAngle = function placeholderRangeAngle(angle) {
    var geometry = this.ranges.children[0].geometry();
    if (this.options.reverse) {
      geometry.setEndAngle(angle);
    } else {
      geometry.setStartAngle(angle);
    }
  };
  ArcScale2.prototype.addRange = function addRange(from, to, options2) {
    var reverse = this.options.reverse;
    var startAngle = this.slotAngle(reverse ? to : from);
    var endAngle = this.slotAngle(reverse ? from : to);
    var range = this.createRange(startAngle, endAngle, this.getRangeRadius(), options2);
    this.ranges.append(range);
    return range;
  };
  return ArcScale2;
}(radial_scale_default);
setDefaultOptions(ArcScale, {
  min: 0,
  max: 100,
  majorTicks: {
    visible: false
  },
  minorTicks: {
    visible: false
  },
  labels: {
    visible: false
  },
  startAngle: 0,
  endAngle: 180,
  rangeLineCap: "round"
});
var arc_scale_default = ArcScale;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer-animation.js
var MAX_DURATION = 800;
var RangePointerAnimation = function(superclass) {
  function RangePointerAnimation2(element, options2) {
    superclass.call(this, element, options2);
    var animationOptions = this.options;
    var duration2 = Math.abs(animationOptions.newAngle - animationOptions.oldAngle) / animationOptions.duration * 1e3;
    animationOptions.duration = limitValue2(duration2, ANGULAR_SPEED, MAX_DURATION);
    var startColor = element.elements.options.get("stroke.color");
    var color = element.currentColor();
    if (startColor !== color) {
      this.startColor = new color_default(startColor);
      this.color = new color_default(color);
    }
  }
  if (superclass)
    RangePointerAnimation2.__proto__ = superclass;
  RangePointerAnimation2.prototype = Object.create(superclass && superclass.prototype);
  RangePointerAnimation2.prototype.constructor = RangePointerAnimation2;
  RangePointerAnimation2.prototype.step = function step(pos) {
    var ref2 = this;
    var options2 = ref2.options;
    var startColor = ref2.startColor;
    var color = ref2.color;
    var angle = interpolateValue(options2.oldAngle, options2.newAngle, pos);
    this.element.angle(angle);
    if (color) {
      var r = round3(interpolateValue(startColor.r, color.r, pos));
      var g = round3(interpolateValue(startColor.g, color.g, pos));
      var b = round3(interpolateValue(startColor.b, color.b, pos));
      this.element.stroke(new color_default(r, g, b).toHex());
    }
  };
  return RangePointerAnimation2;
}(drawing_exports.Animation);
setDefaultOptions(RangePointerAnimation, {
  easing: LINEAR2,
  duration: ANGULAR_SPEED
});
drawing_exports.AnimationFactory.current.register(RADIAL_RANGE_POINTER, RangePointerAnimation);
var range_pointer_animation_default = RangePointerAnimation;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/range-pointer.js
var RangePointer = function(Pointer2) {
  function RangePointer2() {
    Pointer2.apply(this, arguments);
  }
  if (Pointer2)
    RangePointer2.__proto__ = Pointer2;
  RangePointer2.prototype = Object.create(Pointer2 && Pointer2.prototype);
  RangePointer2.prototype.constructor = RangePointer2;
  RangePointer2.prototype.repaint = function repaint() {
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    var oldAngle = scale.slotAngle(options2._oldValue);
    var newAngle = scale.slotAngle(options2.value);
    if (this.animation) {
      this.animation.abort();
    }
    if (options2.animation.transitions === false) {
      this.angle(newAngle);
      this.stroke(this.currentColor());
    } else {
      this.animation = new range_pointer_animation_default(this, deepExtend(options2.animation, {
        oldAngle,
        newAngle
      }));
      this.animation.play();
    }
  };
  RangePointer2.prototype.angle = function angle(value) {
    var geometry = this.elements.geometry();
    if (this.scale.options.reverse) {
      geometry.setStartAngle(value);
    } else {
      geometry.setEndAngle(value);
    }
    this.scale.placeholderRangeAngle(value);
  };
  RangePointer2.prototype.stroke = function stroke(value) {
    this.elements.stroke(value);
  };
  RangePointer2.prototype.render = function render3() {
    if (this.elements) {
      return;
    }
    var ref2 = this;
    var scale = ref2.scale;
    var options2 = ref2.options;
    if (options2.animation !== false) {
      deepExtend(options2.animation, {
        startAngle: 0,
        center: scale.arc.center,
        reverse: scale.options.reverse
      });
    }
    this.elements = scale.addRange(scale.options.min, this.options.value, {
      color: this.currentColor(),
      opacity: options2.opacity,
      lineCap: scale.options.rangeLineCap
    });
  };
  RangePointer2.prototype.currentColor = function currentColor() {
    var ref2 = this.scale.options;
    var min3 = ref2.min;
    var max2 = ref2.max;
    var ref$1 = this.options;
    var colors = ref$1.colors;
    var color = ref$1.color;
    var value = ref$1.value;
    var currentValue = isNumber2(value) ? value : min3;
    if (colors) {
      for (var idx = 0; idx < colors.length; idx++) {
        var ref$2 = colors[idx];
        var rangeColor = ref$2.color;
        var from = ref$2.from;
        if (from === void 0)
          from = min3;
        var to = ref$2.to;
        if (to === void 0)
          to = max2;
        if (from <= currentValue && currentValue <= to) {
          return rangeColor;
        }
      }
    }
    return color;
  };
  RangePointer2.prototype.reflow = function reflow() {
    this.render();
    this.bbox = this.elements.bbox();
  };
  return RangePointer2;
}(pointer_default);
setDefaultOptions(RangePointer, {
  animation: {
    type: RADIAL_RANGE_POINTER,
    duration: ANGULAR_SPEED
  }
});
var range_pointer_default = RangePointer;

// node_modules/@progress/kendo-charts/dist/es/gauges/arc/arc-gauge.js
var ArcGauge = function(RadialGauge3) {
  function ArcGauge3() {
    RadialGauge3.apply(this, arguments);
  }
  if (RadialGauge3)
    ArcGauge3.__proto__ = RadialGauge3;
  ArcGauge3.prototype = Object.create(RadialGauge3 && RadialGauge3.prototype);
  ArcGauge3.prototype.constructor = ArcGauge3;
  ArcGauge3.prototype._initTheme = function _initTheme(theme) {
    RadialGauge3.prototype._initTheme.call(this, theme);
    this.options.color = this.options.color || (this.theme.pointer || {}).color;
  };
  ArcGauge3.prototype._createModel = function _createModel() {
    var options2 = this.options;
    var scale = this.scale = new arc_scale_default(options2.scale, this.contextService);
    var pointer = new range_pointer_default(scale, deepExtend({}, {
      colors: options2.colors,
      color: options2.color,
      value: options2.value,
      opacity: options2.opacity,
      animation: {
        transitions: options2.transitions
      }
    }));
    this.pointers = [pointer];
  };
  ArcGauge3.prototype._buildPointers = function _buildPointers(pointers) {
    for (var i = 0; i < pointers.length; i++) {
      var current4 = pointers[i];
      current4.render();
      current4.value(current4.options.value);
    }
  };
  ArcGauge3.prototype._setValueOptions = function _setValueOptions(value) {
    this.options.value = value;
  };
  ArcGauge3.prototype.currentColor = function currentColor() {
    var pointer = this.pointers[0];
    if (pointer) {
      return pointer.currentColor();
    }
  };
  ArcGauge3.prototype.centerLabelPosition = function centerLabelPosition(width, height) {
    var size = this.getSize();
    var center = this.scale.arc.center;
    var left = center.x - width / 2;
    var top = center.y - height / 2;
    if (width < size.width) {
      var right = left + width;
      left = Math.max(left, 0);
      if (right > size.width) {
        left -= right - size.width;
      }
    }
    if (height < size.height) {
      var bbox = this.scale.bbox;
      var yLimit = bbox.bottomRight().y;
      var bottom = top + height;
      top = Math.max(top, bbox.origin.y);
      if (bottom > yLimit) {
        top -= bottom - yLimit;
      }
    }
    return {
      left,
      top
    };
  };
  return ArcGauge3;
}(radial_gauge_default);
var arc_gauge_default = ArcGauge;

// node_modules/@progress/kendo-charts/dist/es/gauges/circular/circular-gauge.js
var defaultStartAngle = 90;
var CircularGauge = function(ArcGauge3) {
  function CircularGauge3() {
    ArcGauge3.apply(this, arguments);
  }
  if (ArcGauge3)
    CircularGauge3.__proto__ = ArcGauge3;
  CircularGauge3.prototype = Object.create(ArcGauge3 && ArcGauge3.prototype);
  CircularGauge3.prototype.constructor = CircularGauge3;
  CircularGauge3.prototype._createModel = function _createModel() {
    var scaleOptions = this.options.scale;
    if (typeof scaleOptions.startAngle !== "number") {
      scaleOptions.startAngle = defaultStartAngle;
    }
    scaleOptions.endAngle = scaleOptions.startAngle + 360;
    ArcGauge3.prototype._createModel.call(this);
  };
  return CircularGauge3;
}(arc_gauge_default);
var circular_gauge_default = CircularGauge;

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/encoding.js
var DEFAULT_QUIET_ZONE_LENGTH = 10;
var Encoding = function(Class3) {
  function Encoding2(options2) {
    Class3.call(this);
    this.setOptions(options2);
    this.initProperties();
  }
  if (Class3)
    Encoding2.__proto__ = Class3;
  Encoding2.prototype = Object.create(Class3 && Class3.prototype);
  Encoding2.prototype.constructor = Encoding2;
  Encoding2.prototype.initProperties = function initProperties() {
  };
  Encoding2.prototype.setOptions = function setOptions(options2) {
    this.options = Object.assign({}, this.options, options2);
    this.quietZoneLength = this.options.addQuietZone ? 2 * this.options.quietZoneLength : 0;
  };
  Encoding2.prototype.encode = function encode(value, width, height) {
    var convertedValue = defined2(value) ? String(value) : value;
    this.initValue(convertedValue, width, height);
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    this.addData();
    if (this.options.addQuietZone) {
      this.addQuietZone();
    }
    return {
      baseUnit: this.baseUnit,
      pattern: this.pattern
    };
  };
  Encoding2.prototype.initValue = function initValue() {
  };
  Encoding2.prototype.addQuietZone = function addQuietZone() {
    this.pattern.push(this.options.quietZoneLength || DEFAULT_QUIET_ZONE_LENGTH);
  };
  Encoding2.prototype.addData = function addData() {
  };
  Encoding2.prototype.invalidCharacterError = function invalidCharacterError(character) {
    throw new Error('Character "' + character + '" is not valid for symbology ' + this.name + ".");
  };
  return Encoding2;
}(class_default);
setDefaultOptions(Encoding, {
  quietZoneLength: DEFAULT_QUIET_ZONE_LENGTH,
  addQuietZone: true,
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code11.js
var extend = Object.assign;
var Code11 = function(Encoding2) {
  function Code112() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code112.__proto__ = Encoding2;
  Code112.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code112.prototype.constructor = Code112;
  Code112.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend(this, {
      name: "Code 11",
      characterMap: ["111121", "211121", "121121", "221111", "112121", "212111", "122111", "111221", "211211", "211111", "112111"],
      cCheckSumTotal: 10,
      kCheckSumTotal: 9,
      kCheckSumMinLength: 10,
      checkSumMod: 11,
      DASH_VALUE: 10,
      DASH: "-",
      START: "112211",
      STOP: "11221"
    });
  };
  Code112.prototype.initValue = function initValue(value, width) {
    this.pattern = [];
    this.value = value;
    this.width = width;
    this.totalUnits = 0;
  };
  Code112.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  Code112.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code112.prototype.addCheckSum = function addCheckSum() {
    var value = this.value;
    var length = value.length;
    var cValue = this.getWeightedSum(value, length, this.cCheckSumTotal) % this.checkSumMod;
    this.checksum = String(cValue);
    this.addPattern(this.characterMap[cValue]);
    length++;
    if (length >= this.kCheckSumMinLength) {
      var kValue = (cValue + this.getWeightedSum(value, length, this.kCheckSumTotal)) % this.checkSumMod;
      this.checksum += kValue;
      this.addPattern(this.characterMap[kValue]);
    }
  };
  Code112.prototype.getWeightedSum = function getWeightedSum(value, length, total3) {
    var this$1 = this;
    var weightedSum = 0;
    for (var i = 0; i < value.length; i++) {
      weightedSum += this$1.weightedValue(this$1.getValue(value.charAt(i)), length, i, total3);
    }
    return weightedSum;
  };
  Code112.prototype.weightedValue = function weightedValue(value, length, index, total3) {
    var weight = (length - index) % total3 || total3;
    return weight * value;
  };
  Code112.prototype.getValue = function getValue(character) {
    if (!isNaN(character)) {
      return parseInt(character, 10);
    } else if (character !== this.DASH) {
      this.invalidCharacterError(character);
    }
    return this.DASH_VALUE;
  };
  Code112.prototype.addCharacter = function addCharacter2(character) {
    var value = this.getValue(character);
    var pattern = this.characterMap[value];
    this.addPattern(pattern);
  };
  Code112.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
      this$1.totalUnits += value;
    }
  };
  return Code112;
}(Encoding);
setDefaultOptions(Code11, {
  addCheckSum: true
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39.js
var extend2 = Object.assign;
var Code39Base = function(Encoding2) {
  function Code39Base2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Code39Base2.__proto__ = Encoding2;
  Code39Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code39Base2.prototype.constructor = Code39Base2;
  Code39Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend2(this, {
      minBaseUnitLength: 0.7
    });
  };
  Code39Base2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addStart();
    for (var idx = 0; idx < value.length; idx++) {
      this$1.addCharacter(value.charAt(idx));
    }
    if (this.options.addCheckSum) {
      this.pushCheckSum();
    }
    this.addStop();
    this.prepareValues();
  };
  Code39Base2.prototype.addCharacter = function addCharacter2(character) {
    var characterData = this.characterMap[character];
    if (!characterData) {
      this.invalidCharacterError(character);
    }
    this.addBase(characterData);
  };
  Code39Base2.prototype.addBase = function addBase() {
  };
  return Code39Base2;
}(Encoding);
var Code39 = function(Code39Base2) {
  function Code392() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code392.__proto__ = Code39Base2;
  Code392.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code392.prototype.constructor = Code392;
  Code392.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend2(this, {
      name: "Code 39",
      checkSumMod: 43,
      minRatio: 2.5,
      maxRatio: 3,
      gapWidth: 1,
      splitCharacter: "|",
      patternMappings: {
        "b": "1|",
        "w": "1|",
        "B": "ratio|",
        "W": "ratio|"
      },
      characterMap: {
        "0": { "pattern": "bwbWBwBwb", "value": 0 },
        "1": { "pattern": "BwbWbwbwB", "value": 1 },
        "2": { "pattern": "bwBWbwbwB", "value": 2 },
        "3": { "pattern": "BwBWbwbwb", "value": 3 },
        "4": { "pattern": "bwbWBwbwB", "value": 4 },
        "5": { "pattern": "BwbWBwbwb", "value": 5 },
        "6": { "pattern": "bwBWBwbwb", "value": 6 },
        "7": { "pattern": "bwbWbwBwB", "value": 7 },
        "8": { "pattern": "BwbWbwBwb", "value": 8 },
        "9": { "pattern": "bwBWbwBwb", "value": 9 },
        "A": { "pattern": "BwbwbWbwB", "value": 10 },
        "B": { "pattern": "bwBwbWbwB", "value": 11 },
        "C": { "pattern": "BwBwbWbwb", "value": 12 },
        "D": { "pattern": "bwbwBWbwB", "value": 13 },
        "E": { "pattern": "BwbwBWbwb", "value": 14 },
        "F": { "pattern": "bwBwBWbwb", "value": 15 },
        "G": { "pattern": "bwbwbWBwB", "value": 16 },
        "H": { "pattern": "BwbwbWBwb", "value": 17 },
        "I": { "pattern": "bwBwbWBwb", "value": 18 },
        "J": { "pattern": "bwbwBWBwb", "value": 19 },
        "K": { "pattern": "BwbwbwbWB", "value": 20 },
        "L": { "pattern": "bwBwbwbWB", "value": 21 },
        "M": { "pattern": "BwBwbwbWb", "value": 22 },
        "N": { "pattern": "bwbwBwbWB", "value": 23 },
        "O": { "pattern": "BwbwBwbWb", "value": 24 },
        "P": { "pattern": "bwBwBwbWb", "value": 25 },
        "Q": { "pattern": "bwbwbwBWB", "value": 26 },
        "R": { "pattern": "BwbwbwBWb", "value": 27 },
        "S": { "pattern": "bwBwbwBWb", "value": 28 },
        "T": { "pattern": "bwbwBwBWb", "value": 29 },
        "U": { "pattern": "BWbwbwbwB", "value": 30 },
        "V": { "pattern": "bWBwbwbwB", "value": 31 },
        "W": { "pattern": "BWBwbwbwb", "value": 32 },
        "X": { "pattern": "bWbwBwbwB", "value": 33 },
        "Y": { "pattern": "BWbwBwbwb", "value": 34 },
        "Z": { "pattern": "bWBwBwbwb", "value": 35 },
        "-": { "pattern": "bWbwbwBwB", "value": 36 },
        ".": { "pattern": "BWbwbwBwb", "value": 37 },
        " ": { "pattern": "bWBwbwBwb", "value": 38 },
        "$": { "pattern": "bWbWbWbwb", "value": 39 },
        "/": { "pattern": "bWbWbwbWb", "value": 40 },
        "+": { "pattern": "bWbwbWbWb", "value": 41 },
        "%": { "pattern": "bwbWbWbWb", "value": 42 },
        START: { pattern: "bWbwBwBwb" }
      }
    });
  };
  Code392.prototype.initValue = function initValue(value, width, height) {
    this.width = width;
    this.height = height;
    this.value = value;
    this.dataLength = value.length;
    this.pattern = [];
    this.patternString = "";
  };
  Code392.prototype.prepareValues = function prepareValues() {
    var this$1 = this;
    var minBaseUnit = this.minBaseUnitLength;
    var minRatio = this.minRatio;
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    var baseUnit;
    var ratio = this.maxRatio;
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code39 encoding: the current height is " + this.height + "px and the minimum height is " + minHeight + "px.");
    }
    baseUnit = this.getBaseUnit(ratio);
    while (baseUnit < minBaseUnit && ratio > minRatio) {
      ratio = parseFloat((ratio - 0.1).toFixed(1));
      baseUnit = this$1.getBaseUnit(ratio);
    }
    if (baseUnit < minBaseUnit) {
      var minWidth = Math.ceil(this.getBaseWidth(minRatio) * minBaseUnit);
      throw new Error("Insufficient width for Code39 encoding: the current width is " + this.width + 'px and the minimum width for value "' + this.value + '" is ' + minWidth + "px.");
    }
    this.ratio = ratio;
    this.baseUnit = baseUnit;
    this.patternString = this.patternString.substring(0, this.patternString.length - 1);
    this.pattern = this.pattern.concat(this.patternString.replace(/ratio/g, ratio).split(this.splitCharacter));
  };
  Code392.prototype.getBaseUnit = function getBaseUnit(ratio) {
    return this.width / this.getBaseWidth(ratio);
  };
  Code392.prototype.getBaseWidth = function getBaseWidth(ratio) {
    var characterLength = 3 * (ratio + 2);
    return this.quietZoneLength + characterLength * (this.dataLength + 2) + this.gapWidth * (this.dataLength + 1);
  };
  Code392.prototype.addStart = function addStart() {
    this.addPattern(this.characterMap.START.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addBase = function addBase(character) {
    this.addPattern(character.pattern);
    this.addCharacterGap();
  };
  Code392.prototype.addStop = function addStop() {
    this.addPattern(this.characterMap.START.pattern);
  };
  Code392.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.patternString += this$1.patternMappings[pattern.charAt(i)];
    }
  };
  Code392.prototype.addCharacterGap = function addCharacterGap() {
    this.patternString += this.gapWidth + this.splitCharacter;
  };
  return Code392;
}(Code39Base);
setDefaultOptions(Code39, {
  addCheckSum: false
});

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code39-extended.js
var Code39ExtendedBase = {
  addCharacter: function addCharacter(character) {
    if (this.characterMap[character]) {
      this.addBase(this.characterMap[character]);
    } else if (character.charCodeAt(0) > 127) {
      this.invalidCharacterError(character);
    } else {
      this.addExtended(character.charCodeAt(0));
    }
  },
  addExtended: function addExtended(code2) {
    var this$1 = this;
    var patterns;
    for (var i = 0; i < this.extendedMappings.length; i++) {
      patterns = this$1.extendedMappings[i].call(this$1, code2);
      if (patterns) {
        for (var patternIndex = 0; patternIndex < patterns.length; patternIndex++) {
          var pattern = patterns[patternIndex];
          this$1.addBase(pattern);
        }
        this$1.dataLength += patterns.length - 1;
        return;
      }
    }
  },
  extendedMappings: [
    function(code2) {
      if (97 <= code2 && code2 <= 122) {
        return [this.characterMap[this.shiftCharacters[0]], this.characterMap[String.fromCharCode(code2 - 32)]];
      }
    },
    function(code2) {
      if (33 <= code2 && code2 <= 58) {
        return [this.characterMap[this.shiftCharacters[1]], this.characterMap[String.fromCharCode(code2 + 32)]];
      }
    },
    function(code2) {
      if (1 <= code2 && code2 <= 26) {
        return [this.characterMap[this.shiftCharacters[2]], this.characterMap[String.fromCharCode(code2 + 64)]];
      }
    },
    function(code2) {
      var this$1 = this;
      var result;
      var dataCharacter;
      if (!this.specialAsciiCodes[code2]) {
        dataCharacter = Math.floor(code2 / 32) * 6 + (code2 - 27) % 32 + 64;
        result = [this.characterMap[this.shiftCharacters[3]], this.characterMap[String.fromCharCode(dataCharacter)]];
      } else {
        result = [];
        for (var i = 0; i < this.specialAsciiCodes[code2].length; i++) {
          result.push(this$1.characterMap[this$1.shiftCharacters[3]]);
          result.push(this$1.characterMap[this$1.specialAsciiCodes[code2][i]]);
        }
      }
      return result;
    }
  ],
  specialAsciiCodes: {
    "0": ["U"],
    "64": ["V"],
    "96": ["W"],
    "127": ["T", "X", "Y", "Z"]
  },
  shiftValuesAsciiCodes: {
    "39": 36,
    "40": 47,
    "41": 43,
    "42": 37
  },
  characterMap: {
    "+": false,
    "/": false,
    "$": false,
    "%": false
  },
  shiftCharacters: ["SHIFT0", "SHIFT1", "SHIFT2", "SHIFT3"]
};
var Code39Extended = function(Code392) {
  function Code39Extended2() {
    Code392.apply(this, arguments);
  }
  if (Code392)
    Code39Extended2.__proto__ = Code392;
  Code39Extended2.prototype = Object.create(Code392 && Code392.prototype);
  Code39Extended2.prototype.constructor = Code39Extended2;
  Code39Extended2.prototype.initProperties = function initProperties() {
    Code392.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 39 extended",
      characterMap: {
        SHIFT0: { "pattern": "bWbwbWbWb", "value": 41 },
        SHIFT1: { "pattern": "bWbWbwbWb", "value": 40 },
        SHIFT2: { "pattern": "bWbWbWbwb", "value": 39 },
        SHIFT3: { "pattern": "bwbWbWbWb", "value": 42 }
      }
    });
  };
  return Code39Extended2;
}(Code39);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93.js
var extend3 = Object.assign;
var Code93 = function(Code39Base2) {
  function Code932() {
    Code39Base2.apply(this, arguments);
  }
  if (Code39Base2)
    Code932.__proto__ = Code39Base2;
  Code932.prototype = Object.create(Code39Base2 && Code39Base2.prototype);
  Code932.prototype.constructor = Code932;
  Code932.prototype.initProperties = function initProperties() {
    Code39Base2.prototype.initProperties.call(this);
    extend3(this, {
      name: "Code 93",
      cCheckSumTotal: 20,
      kCheckSumTotal: 15,
      checkSumMod: 47,
      characterMap: {
        "0": { "pattern": "131112", "value": 0 },
        "1": { "pattern": "111213", "value": 1 },
        "2": { "pattern": "111312", "value": 2 },
        "3": { "pattern": "111411", "value": 3 },
        "4": { "pattern": "121113", "value": 4 },
        "5": { "pattern": "121212", "value": 5 },
        "6": { "pattern": "121311", "value": 6 },
        "7": { "pattern": "111114", "value": 7 },
        "8": { "pattern": "131211", "value": 8 },
        "9": { "pattern": "141111", "value": 9 },
        "A": { "pattern": "211113", "value": 10 },
        "B": { "pattern": "211212", "value": 11 },
        "C": { "pattern": "211311", "value": 12 },
        "D": { "pattern": "221112", "value": 13 },
        "E": { "pattern": "221211", "value": 14 },
        "F": { "pattern": "231111", "value": 15 },
        "G": { "pattern": "112113", "value": 16 },
        "H": { "pattern": "112212", "value": 17 },
        "I": { "pattern": "112311", "value": 18 },
        "J": { "pattern": "122112", "value": 19 },
        "K": { "pattern": "132111", "value": 20 },
        "L": { "pattern": "111123", "value": 21 },
        "M": { "pattern": "111222", "value": 22 },
        "N": { "pattern": "111321", "value": 23 },
        "O": { "pattern": "121122", "value": 24 },
        "P": { "pattern": "131121", "value": 25 },
        "Q": { "pattern": "212112", "value": 26 },
        "R": { "pattern": "212211", "value": 27 },
        "S": { "pattern": "211122", "value": 28 },
        "T": { "pattern": "211221", "value": 29 },
        "U": { "pattern": "221121", "value": 30 },
        "V": { "pattern": "222111", "value": 31 },
        "W": { "pattern": "112122", "value": 32 },
        "X": { "pattern": "112221", "value": 33 },
        "Y": { "pattern": "122121", "value": 34 },
        "Z": { "pattern": "123111", "value": 35 },
        "-": { "pattern": "121131", "value": 36 },
        ".": { "pattern": "311112", "value": 37 },
        " ": { "pattern": "311211", "value": 38 },
        "$": { "pattern": "321111", "value": 39 },
        "/": { "pattern": "112131", "value": 40 },
        "+": { "pattern": "113121", "value": 41 },
        "%": { "pattern": "211131", "value": 42 },
        SHIFT0: { "pattern": "122211", "value": 46 },
        SHIFT1: { "pattern": "311121", "value": 45 },
        SHIFT2: { "pattern": "121221", "value": 43 },
        SHIFT3: { "pattern": "312111", "value": 44 },
        START: { "pattern": "111141" },
        TERMINATION_BAR: "1"
      }
    });
  };
  Code932.prototype.initValue = function initValue(value, width, height) {
    this.value = value;
    this.width = width;
    this.height = height;
    this.pattern = [];
    this.values = [];
    this.dataLength = value.length;
  };
  Code932.prototype.prepareValues = function prepareValues() {
    var minHeight = Math.ceil(Math.max(0.15 * this.width, 24));
    if (this.height < minHeight) {
      throw new Error("Insufficient height for Code93 encoding: the current height is " + this.height + "px, the minimum required height is " + minHeight + "px.");
    }
    this.setBaseUnit();
    if (this.baseUnit < this.minBaseUnitLength) {
      var minWidth = Math.ceil(this.minBaseUnitLength * (this.width / this.baseUnit));
      throw new Error("Insufficient width for Code93 encoding: the current width is " + this.width + 'px and the minimum required width for value "' + this.value + '" is ' + minWidth + "px.");
    }
  };
  Code932.prototype.setBaseUnit = function setBaseUnit() {
    var checkSumLength = 2;
    this.baseUnit = this.width / (9 * (this.dataLength + 2 + checkSumLength) + this.quietZoneLength + 1);
  };
  Code932.prototype.addStart = function addStart() {
    var pattern = this.characterMap.START.pattern;
    this.addPattern(pattern);
  };
  Code932.prototype.addStop = function addStop() {
    this.addStart();
    this.pattern.push(this.characterMap.TERMINATION_BAR);
  };
  Code932.prototype.addBase = function addBase(charData) {
    this.addPattern(charData.pattern);
    this.values.push(charData.value);
  };
  Code932.prototype.pushCheckSum = function pushCheckSum() {
    var this$1 = this;
    var checkValues = this._getCheckValues();
    var charData;
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      charData = this$1.characterMap[this$1._findCharacterByValue(checkValues[i])];
      this$1.addPattern(charData.pattern);
    }
  };
  Code932.prototype._getCheckValues = function _getCheckValues() {
    var this$1 = this;
    var values5 = this.values;
    var length = values5.length;
    var wightedSum = 0;
    var cValue;
    var kValue;
    var idx;
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx, this$1.cCheckSumTotal);
    }
    cValue = wightedSum % this.checkSumMod;
    wightedSum = this.weightedValue(cValue, 1, this.kCheckSumTotal);
    for (idx = length - 1; idx >= 0; idx--) {
      wightedSum += this$1.weightedValue(values5[idx], length - idx + 1, this$1.kCheckSumTotal);
    }
    kValue = wightedSum % this.checkSumMod;
    return [cValue, kValue];
  };
  Code932.prototype._findCharacterByValue = function _findCharacterByValue(value) {
    var this$1 = this;
    for (var character in this$1.characterMap) {
      if (this$1.characterMap[character].value === value) {
        return character;
      }
    }
  };
  Code932.prototype.weightedValue = function weightedValue(value, index, total3) {
    return (index % total3 || total3) * value;
  };
  Code932.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
    }
  };
  return Code932;
}(Code39Base);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code93-extended.js
var Code93Extended = function(Code932) {
  function Code93Extended2() {
    Code932.apply(this, arguments);
  }
  if (Code932)
    Code93Extended2.__proto__ = Code932;
  Code93Extended2.prototype = Object.create(Code932 && Code932.prototype);
  Code93Extended2.prototype.constructor = Code93Extended2;
  Code93Extended2.prototype.initProperties = function initProperties() {
    Code932.prototype.initProperties.call(this);
    deepExtend(this, Code39ExtendedBase, {
      name: "Code 93 extended",
      pushCheckSum: function() {
        var this$1 = this;
        var checkValues = this._getCheckValues();
        var value;
        this.checksum = checkValues.join("");
        for (var i = 0; i < checkValues.length; i++) {
          value = checkValues[i];
          if (this$1.shiftValuesAsciiCodes[value]) {
            this$1.addExtended(this$1.shiftValuesAsciiCodes[value]);
          } else {
            var characterByValue = this$1._findCharacterByValue(value);
            this$1.addPattern(this$1.characterMap[characterByValue].pattern);
          }
        }
      }
    });
  };
  return Code93Extended2;
}(Code93);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/postnet.js
var numberRegex2 = /^\d+$/;
var extend4 = Object.assign;
var Postnet = function(Encoding2) {
  function Postnet2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Postnet2.__proto__ = Encoding2;
  Postnet2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Postnet2.prototype.constructor = Postnet2;
  Postnet2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend4(this, {
      name: "Postnet",
      START: "2",
      VALID_CODE_LENGTHS: [5, 9, 11],
      DIGIT_SEPARATOR: "-",
      characterMap: ["22111", "11122", "11212", "11221", "12112", "12121", "12211", "21112", "21121", "21211"]
    });
  };
  Postnet2.prototype.initValue = function initValue(value, width, height) {
    this.height = height;
    this.width = width;
    this.baseHeight = height / 2;
    this.value = value.replace(new RegExp(this.DIGIT_SEPARATOR, "g"), "");
    this.pattern = [];
    this.validate(this.value);
    this.checkSum = 0;
    this.setBaseUnit();
  };
  Postnet2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.START);
    this.pattern.pop();
  };
  Postnet2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    this.checkSum += parseInt(character, 10);
    this.addPattern(pattern);
  };
  Postnet2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = (10 - this.checkSum % 10) % 10;
    this.addCharacter(this.checksum);
  };
  Postnet2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 3;
    this.baseUnit = this.width / ((this.value.length + 1) * 10 + startStopLength + this.quietZoneLength);
  };
  Postnet2.prototype.validate = function validate(value) {
    if (!numberRegex2.test(value)) {
      this.invalidCharacterError(value.match(/[^0-9]/)[0]);
    }
    if (!inArray(value.length, this.VALID_CODE_LENGTHS)) {
      throw new Error("Invalid value length. Valid lengths for the Postnet symbology are " + this.VALID_CODE_LENGTHS.join(",") + ".");
    }
  };
  Postnet2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    var y1;
    for (var i = 0; i < pattern.length; i++) {
      y1 = this$1.height - this$1.baseHeight * pattern.charAt(i);
      this$1.pattern.push({ width: 1, y1, y2: this$1.height });
      this$1.pattern.push(1);
    }
  };
  return Postnet2;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/code128.js
var numberRegex3 = /^\d+$/;
var alphanumericRegex = /^[a-z0-9]+$/i;
var extend5 = Object.assign;
var State128 = function(Class3) {
  function State1282(encoding) {
    Class3.call(this);
    this.encoding = encoding;
    this.initProperties();
  }
  if (Class3)
    State1282.__proto__ = Class3;
  State1282.prototype = Object.create(Class3 && Class3.prototype);
  State1282.prototype.constructor = State1282;
  State1282.prototype.initProperties = function initProperties() {
  };
  State1282.prototype.addStart = function addStart() {
  };
  State1282.prototype.is = function is() {
  };
  State1282.prototype.isCode = function isCode() {
    return false;
  };
  State1282.prototype.move = function move() {
  };
  State1282.prototype.pushState = function pushState() {
  };
  return State1282;
}(class_default);
var State128AB = function(State1282) {
  function State128AB2(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
    this._initMoves(states);
  }
  if (State1282)
    State128AB2.__proto__ = State1282;
  State128AB2.prototype = Object.create(State1282 && State1282.prototype);
  State128AB2.prototype.constructor = State128AB2;
  State128AB2.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    deepExtend(this, {
      FNC4: "FNC4",
      SHIFT: 98
    });
  };
  State128AB2.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128AB2.prototype.is = function is(value, index) {
    var code2 = value.charCodeAt(index);
    return this.isCode(code2);
  };
  State128AB2.prototype.move = function move(encodingState) {
    var idx = 0;
    while (!this._moves[idx].call(this, encodingState) && idx < this._moves.length) {
      idx++;
    }
  };
  State128AB2.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var states = this.states, value = encodingState.value, maxLength = value.length, code2;
    if (inArray("C", states)) {
      var numberMatch = value.substr(encodingState.index).match(/\d{4,}/g);
      if (numberMatch) {
        maxLength = value.indexOf(numberMatch[0], encodingState.index);
      }
    }
    while ((code2 = encodingState.value.charCodeAt(encodingState.index)) >= 0 && this.isCode(code2) && encodingState.index < maxLength) {
      this$1.encoding.addPattern(this$1.getValue(code2));
      encodingState.index++;
    }
  };
  State128AB2.prototype._initMoves = function _initMoves(states) {
    this._moves = [];
    if (inArray(this.FNC4, states)) {
      this._moves.push(this._moveFNC);
    }
    if (inArray(this.shiftKey, states)) {
      this._moves.push(this._shiftState);
    }
    this._moves.push(this._moveState);
  };
  State128AB2.prototype._moveFNC = function _moveFNC(encodingState) {
    if (encodingState.fnc) {
      encodingState.fnc = false;
      return encodingState.previousState === this.key;
    }
  };
  State128AB2.prototype._shiftState = function _shiftState(encodingState) {
    if (encodingState.previousState === this.shiftKey && (encodingState.index + 1 >= encodingState.value.length || this.encoding[this.shiftKey].is(encodingState.value, encodingState.index + 1))) {
      this.encoding.addPattern(this.SHIFT);
      encodingState.shifted = true;
      return true;
    }
  };
  State128AB2.prototype._moveState = function _moveState() {
    this.encoding.addPattern(this.MOVE);
    return true;
  };
  return State128AB2;
}(State128);
var states128 = {};
states128.A = function(State128AB2) {
  function State128A() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128A.__proto__ = State128AB2;
  State128A.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128A.prototype.constructor = State128A;
  State128A.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend5(this, {
      key: "A",
      shiftKey: "B",
      MOVE: 101,
      START: 103
    });
  };
  State128A.prototype.isCode = function isCode(code2) {
    return 0 <= code2 && code2 < 96;
  };
  State128A.prototype.getValue = function getValue(code2) {
    if (code2 < 32) {
      return code2 + 64;
    }
    return code2 - 32;
  };
  return State128A;
}(State128AB);
states128.B = function(State128AB2) {
  function State128B() {
    State128AB2.apply(this, arguments);
  }
  if (State128AB2)
    State128B.__proto__ = State128AB2;
  State128B.prototype = Object.create(State128AB2 && State128AB2.prototype);
  State128B.prototype.constructor = State128B;
  State128B.prototype.initProperties = function initProperties() {
    State128AB2.prototype.initProperties.call(this);
    extend5(this, {
      key: "B",
      shiftKey: "A",
      MOVE: 100,
      START: 104
    });
  };
  State128B.prototype.isCode = function isCode(code2) {
    return 32 <= code2 && code2 < 128;
  };
  State128B.prototype.getValue = function getValue(code2) {
    return code2 - 32;
  };
  return State128B;
}(State128AB);
states128.C = function(State1282) {
  function State128C() {
    State1282.apply(this, arguments);
  }
  if (State1282)
    State128C.__proto__ = State1282;
  State128C.prototype = Object.create(State1282 && State1282.prototype);
  State128C.prototype.constructor = State128C;
  State128C.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "C",
      MOVE: 99,
      START: 105
    });
  };
  State128C.prototype.addStart = function addStart() {
    this.encoding.addPattern(this.START);
  };
  State128C.prototype.is = function is(value, index) {
    var next4 = getSubstring(value, index, 4);
    return (index + 4 <= value.length || value.length === 2) && numberRegex3.test(next4);
  };
  State128C.prototype.move = function move() {
    this.encoding.addPattern(this.MOVE);
  };
  State128C.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var code2;
    while ((code2 = getSubstring(encodingState.value, encodingState.index, 2)) && numberRegex3.test(code2) && code2.length === 2) {
      this$1.encoding.addPattern(parseInt(code2, 10));
      encodingState.index += 2;
    }
  };
  State128C.prototype.getValue = function getValue(code2) {
    return code2;
  };
  return State128C;
}(State128);
states128.FNC4 = function(State1282) {
  function State128FNC4(encoding, states) {
    State1282.call(this, encoding);
    this._initSubStates(states);
  }
  if (State1282)
    State128FNC4.__proto__ = State1282;
  State128FNC4.prototype = Object.create(State1282 && State1282.prototype);
  State128FNC4.prototype.constructor = State128FNC4;
  State128FNC4.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "FNC4",
      dependentStates: ["A", "B"]
    });
  };
  State128FNC4.prototype.addStart = function addStart(encodingState) {
    var code2 = encodingState.value.charCodeAt(0) - 128, subState = this._getSubState(code2);
    this.encoding[subState].addStart();
  };
  State128FNC4.prototype.is = function is(value, index) {
    var code2 = value.charCodeAt(index);
    return this.isCode(code2);
  };
  State128FNC4.prototype.isCode = function isCode(code2) {
    return 128 <= code2 && code2 < 256;
  };
  State128FNC4.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var subState = this._initSubState(encodingState), encoding = this.encoding, length = subState.value.length;
    var code2;
    encodingState.index += length;
    if (length < 3) {
      for (; subState.index < length; subState.index++) {
        code2 = subState.value.charCodeAt(subState.index);
        subState.state = this$1._getSubState(code2);
        if (subState.previousState !== subState.state) {
          subState.previousState = subState.state;
          encoding[subState.state].move(subState);
        }
        encoding.addPattern(encoding[subState.state].MOVE);
        encoding.addPattern(encoding[subState.state].getValue(code2));
      }
    } else {
      if (subState.state !== subState.previousState) {
        encoding[subState.state].move(subState);
      }
      this._pushStart(subState);
      encoding.pushData(subState, this.subStates);
      if (encodingState.index < encodingState.value.length) {
        this._pushStart(subState);
      }
    }
    encodingState.fnc = true;
    encodingState.state = subState.state;
  };
  State128FNC4.prototype._pushStart = function _pushStart(subState) {
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
    this.encoding.addPattern(this.encoding[subState.state].MOVE);
  };
  State128FNC4.prototype._initSubState = function _initSubState(encodingState) {
    var subState = {
      value: this._getAll(encodingState.value, encodingState.index),
      index: 0
    };
    subState.state = this._getSubState(subState.value.charCodeAt(0));
    subState.previousState = encodingState.previousState === this.key ? subState.state : encodingState.previousState;
    return subState;
  };
  State128FNC4.prototype._initSubStates = function _initSubStates(states) {
    var this$1 = this;
    this.subStates = [];
    for (var i = 0; i < states.length; i++) {
      if (inArray(states[i], this$1.dependentStates)) {
        this$1.subStates.push(states[i]);
      }
    }
  };
  State128FNC4.prototype._getSubState = function _getSubState(code2) {
    var this$1 = this;
    for (var i = 0; i < this.subStates.length; i++) {
      if (this$1.encoding[this$1.subStates[i]].isCode(code2)) {
        return this$1.subStates[i];
      }
    }
  };
  State128FNC4.prototype._getAll = function _getAll(value, index) {
    var code2;
    var result = "";
    var i = index;
    while ((code2 = value.charCodeAt(i++)) && this.isCode(code2)) {
      result += String.fromCharCode(code2 - 128);
    }
    return result;
  };
  return State128FNC4;
}(State128);
states128.FNC1 = function(State1282) {
  function States128FNC1(encoding, states) {
    State1282.call(this, encoding);
    this.states = states;
  }
  if (State1282)
    States128FNC1.__proto__ = State1282;
  States128FNC1.prototype = Object.create(State1282 && State1282.prototype);
  States128FNC1.prototype.constructor = States128FNC1;
  States128FNC1.prototype.initProperties = function initProperties() {
    State1282.prototype.initProperties.call(this);
    extend5(this, {
      key: "FNC1",
      startState: "C",
      startAI: "(",
      endAI: ")",
      dependentStates: ["C", "B"],
      applicationIdentifiers: {
        "22": { max: 29, type: "alphanumeric" },
        "402": { length: 17 },
        "7004": { max: 4, type: "alphanumeric" },
        "242": { max: 6, type: "alphanumeric" },
        "8020": { max: 25, type: "alphanumeric" },
        "703": { min: 3, max: 30, type: "alphanumeric" },
        "8008": { min: 8, max: 12, type: "alphanumeric" },
        "253": { min: 13, max: 17, type: "alphanumeric" },
        "8003": { min: 14, max: 30, type: "alphanumeric" },
        multiKey: [{
          ids: ["15", "17", "8005", "8100"],
          ranges: [
            [11, 13],
            [310, 316],
            [320, 336],
            [340, 369]
          ],
          type: { length: 6 }
        }, {
          ids: ["240", "241", "250", "251", "400", "401", "403", "7002", "8004", "8007", "8110"],
          ranges: [[90 - 99]],
          type: { max: 30, type: "alphanumeric" }
        }, {
          ids: ["7001"],
          ranges: [[410, 414]],
          type: { length: 13 }
        }, {
          ids: ["10", "21", "254", "420", "8002"],
          type: { max: 20, type: "alphanumeric" }
        }, {
          ids: ["00", "8006", "8017", "8018"],
          type: { length: 18 }
        }, {
          ids: ["01", "02", "8001"],
          type: { length: 14 }
        }, {
          ids: ["422"],
          ranges: [
            [424, 426]
          ],
          type: { length: 3 }
        }, {
          ids: ["20", "8102"],
          type: { length: 2 }
        }, {
          ids: ["30", "37"],
          type: { max: 8, type: "alphanumeric" }
        }, {
          ids: ["390", "392"],
          type: { max: 15, type: "alphanumeric" }
        }, {
          ids: ["421", "423"],
          type: { min: 3, max: 15, type: "alphanumeric" }
        }, {
          ids: ["391", "393"],
          type: { min: 3, max: 18, type: "alphanumeric" }
        }, {
          ids: ["7003", "8101"],
          type: { length: 10 }
        }]
      },
      START: 102
    });
  };
  States128FNC1.prototype.addStart = function addStart() {
    this.encoding[this.startState].addStart();
  };
  States128FNC1.prototype.is = function is() {
    return inArray(this.key, this.states);
  };
  States128FNC1.prototype.pushState = function pushState(encodingState) {
    var this$1 = this;
    var encoding = this.encoding, value = encodingState.value.replace(/\s/g, ""), regexSeparators = new RegExp("[" + this.startAI + this.endAI + "]", "g"), index = encodingState.index, subState = {
      state: this.startState
    }, current4, nextStart, separatorLength;
    encoding.addPattern(this.START);
    var trueCondition = true;
    while (trueCondition) {
      subState.index = 0;
      separatorLength = value.charAt(index) === this$1.startAI ? 2 : 0;
      current4 = separatorLength > 0 ? this$1.getBySeparator(value, index) : this$1.getByLength(value, index);
      if (current4.ai.length) {
        nextStart = index + separatorLength + current4.id.length + current4.ai.length;
      } else {
        nextStart = value.indexOf(this$1.startAI, index + 1);
        if (nextStart < 0) {
          if (index + current4.ai.max + current4.id.length + separatorLength < value.length) {
            throw new Error("Separators are required after variable length identifiers");
          }
          nextStart = value.length;
        }
      }
      subState.value = value.substring(index, nextStart).replace(regexSeparators, "");
      this$1.validate(current4, subState.value);
      encoding.pushData(subState, this$1.dependentStates);
      if (nextStart >= value.length) {
        break;
      }
      index = nextStart;
      if (subState.state !== this$1.startState) {
        encoding[this$1.startState].move(subState);
        subState.state = this$1.startState;
      }
      if (!current4.ai.length) {
        encoding.addPattern(this$1.START);
      }
    }
    encodingState.index = encodingState.value.length;
  };
  States128FNC1.prototype.validate = function validate(current4, value) {
    var code2 = value.substr(current4.id.length), ai = current4.ai;
    if (!ai.type && !numberRegex3.test(code2)) {
      throw new Error("Application identifier " + current4.id + " is numeric only but contains non numeric character(s).");
    }
    if (ai.type === "alphanumeric" && !alphanumericRegex.test(code2)) {
      throw new Error("Application identifier " + current4.id + " is alphanumeric only but contains non alphanumeric character(s).");
    }
    if (ai.length && ai.length !== code2.length) {
      throw new Error("Application identifier " + current4.id + " must be " + ai.length + " characters long.");
    }
    if (ai.min && ai.min > code2.length) {
      throw new Error("Application identifier " + current4.id + " must be at least " + ai.min + " characters long.");
    }
    if (ai.max && ai.max < code2.length) {
      throw new Error("Application identifier " + current4.id + " must be at most " + ai.max + " characters long.");
    }
  };
  States128FNC1.prototype.getByLength = function getByLength(value, index) {
    var this$1 = this;
    var id;
    var applicationIdentifier;
    for (var i = 2; i <= 4; i++) {
      id = getSubstring(value, index, i);
      applicationIdentifier = this$1.getApplicationIdentifier(id) || this$1.getApplicationIdentifier(id.substring(0, id.length - 1));
      if (applicationIdentifier) {
        return {
          id,
          ai: applicationIdentifier
        };
      }
    }
    this.unsupportedAIError(id);
  };
  States128FNC1.prototype.unsupportedAIError = function unsupportedAIError(id) {
    throw new Error("'" + id + "' is not a supported Application Identifier");
  };
  States128FNC1.prototype.getBySeparator = function getBySeparator(value, index) {
    var start = value.indexOf(this.startAI, index), end = value.indexOf(this.endAI, start), id = value.substring(start + 1, end), ai = this.getApplicationIdentifier(id) || this.getApplicationIdentifier(id.substr(id.length - 1));
    if (!ai) {
      this.unsupportedAIError(id);
    }
    return {
      ai,
      id
    };
  };
  States128FNC1.prototype.getApplicationIdentifier = function getApplicationIdentifier(id) {
    var applicationIdentifier = this.applicationIdentifiers, multiKey = applicationIdentifier.multiKey;
    if (applicationIdentifier[id]) {
      return applicationIdentifier[id];
    }
    for (var i = 0; i < multiKey.length; i++) {
      if (multiKey[i].ids && inArray(id, multiKey[i].ids)) {
        return multiKey[i].type;
      } else if (multiKey[i].ranges) {
        var ranges = multiKey[i].ranges;
        for (var j = 0; j < ranges.length; j++) {
          if (ranges[j][0] <= id && id <= ranges[j][1]) {
            return multiKey[i].type;
          }
        }
      }
    }
  };
  return States128FNC1;
}(State128);
var Code128Base = function(Encoding2) {
  function Code128Base2(options2) {
    Encoding2.call(this, options2);
    this._initStates();
  }
  if (Encoding2)
    Code128Base2.__proto__ = Encoding2;
  Code128Base2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Code128Base2.prototype.constructor = Code128Base2;
  Code128Base2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend5(this, {
      characterMap: [
        212222,
        222122,
        222221,
        121223,
        121322,
        131222,
        122213,
        122312,
        132212,
        221213,
        221312,
        231212,
        112232,
        122132,
        122231,
        113222,
        123122,
        123221,
        223211,
        221132,
        221231,
        213212,
        223112,
        312131,
        311222,
        321122,
        321221,
        312212,
        322112,
        322211,
        212123,
        212321,
        232121,
        111323,
        131123,
        131321,
        112313,
        132113,
        132311,
        211313,
        231113,
        231311,
        112133,
        112331,
        132131,
        113123,
        113321,
        133121,
        313121,
        211331,
        231131,
        213113,
        213311,
        213131,
        311123,
        311321,
        331121,
        312113,
        312311,
        332111,
        314111,
        221411,
        431111,
        111224,
        111422,
        121124,
        121421,
        141122,
        141221,
        112214,
        112412,
        122114,
        122411,
        142112,
        142211,
        241211,
        221114,
        413111,
        241112,
        134111,
        111242,
        121142,
        121241,
        114212,
        124112,
        124211,
        411212,
        421112,
        421211,
        212141,
        214121,
        412121,
        111143,
        111341,
        131141,
        114113,
        114311,
        411113,
        411311,
        113141,
        114131,
        311141,
        411131,
        211412,
        211214,
        211232,
        2331112
      ],
      STOP: 106
    });
  };
  Code128Base2.prototype._initStates = function _initStates() {
    var this$1 = this;
    for (var i = 0; i < this.states.length; i++) {
      this$1[this$1.states[i]] = new states128[this$1.states[i]](this$1, this$1.states);
    }
  };
  Code128Base2.prototype.initValue = function initValue(value, width, height) {
    this.pattern = [];
    this.value = value;
    this.width = width;
    this.height = height;
    this.checkSum = 0;
    this.totalUnits = 0;
    this.index = 0;
    this.position = 1;
  };
  Code128Base2.prototype.addData = function addData() {
    var encodingState = {
      value: this.value,
      index: 0,
      state: ""
    };
    if (this.value.length === 0) {
      return;
    }
    encodingState.state = encodingState.previousState = this.getNextState(encodingState, this.states);
    this.addStart(encodingState);
    this.pushData(encodingState, this.states);
    this.addCheckSum();
    this.addStop();
    this.setBaseUnit();
  };
  Code128Base2.prototype.pushData = function pushData(encodingState, states) {
    var this$1 = this;
    var trueCondition = true;
    while (trueCondition) {
      this$1[encodingState.state].pushState(encodingState);
      if (encodingState.index >= encodingState.value.length) {
        break;
      }
      if (!encodingState.shifted) {
        encodingState.previousState = encodingState.state;
        encodingState.state = this$1.getNextState(encodingState, states);
        this$1[encodingState.state].move(encodingState);
      } else {
        var temp = encodingState.state;
        encodingState.state = encodingState.previousState;
        encodingState.previousState = temp;
        encodingState.shifted = false;
      }
    }
  };
  Code128Base2.prototype.addStart = function addStart(encodingState) {
    this[encodingState.state].addStart(encodingState);
    this.position = 1;
  };
  Code128Base2.prototype.addCheckSum = function addCheckSum() {
    this.checksum = this.checkSum % 103;
    this.addPattern(this.checksum);
  };
  Code128Base2.prototype.addStop = function addStop() {
    this.addPattern(this.STOP);
  };
  Code128Base2.prototype.setBaseUnit = function setBaseUnit() {
    this.baseUnit = this.width / (this.totalUnits + this.quietZoneLength);
  };
  Code128Base2.prototype.addPattern = function addPattern(code2) {
    var this$1 = this;
    var pattern = this.characterMap[code2].toString();
    var value;
    for (var i = 0; i < pattern.length; i++) {
      value = parseInt(pattern.charAt(i), 10);
      this$1.pattern.push(value);
      this$1.totalUnits += value;
    }
    this.checkSum += code2 * this.position++;
  };
  Code128Base2.prototype.getNextState = function getNextState(encodingState, states) {
    var this$1 = this;
    for (var i = 0; i < states.length; i++) {
      if (this$1[states[i]].is(encodingState.value, encodingState.index)) {
        return states[i];
      }
    }
    this.invalidCharacterError(encodingState.value.charAt(encodingState.index));
  };
  return Code128Base2;
}(Encoding);
var Code128a = function(Code128Base2) {
  function Code128a2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128a2.__proto__ = Code128Base2;
  Code128a2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128a2.prototype.constructor = Code128a2;
  Code128a2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 A",
      states: ["A"]
    });
  };
  return Code128a2;
}(Code128Base);
var Code128b = function(Code128Base2) {
  function Code128b2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128b2.__proto__ = Code128Base2;
  Code128b2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128b2.prototype.constructor = Code128b2;
  Code128b2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 B",
      states: ["B"]
    });
  };
  return Code128b2;
}(Code128Base);
var Code128c = function(Code128Base2) {
  function Code128c2() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code128c2.__proto__ = Code128Base2;
  Code128c2.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code128c2.prototype.constructor = Code128c2;
  Code128c2.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128 C",
      states: ["C"]
    });
  };
  return Code128c2;
}(Code128Base);
var Code128 = function(Code128Base2) {
  function Code1282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    Code1282.__proto__ = Code128Base2;
  Code1282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  Code1282.prototype.constructor = Code1282;
  Code1282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code 128",
      states: ["C", "B", "A", "FNC4"]
    });
  };
  return Code1282;
}(Code128Base);
var CodeGS1128 = function(Code128Base2) {
  function CodeGS11282() {
    Code128Base2.apply(this, arguments);
  }
  if (Code128Base2)
    CodeGS11282.__proto__ = Code128Base2;
  CodeGS11282.prototype = Object.create(Code128Base2 && Code128Base2.prototype);
  CodeGS11282.prototype.constructor = CodeGS11282;
  CodeGS11282.prototype.initProperties = function initProperties() {
    Code128Base2.prototype.initProperties.call(this);
    extend5(this, {
      name: "Code GS1-128",
      states: ["FNC1", "C", "B"]
    });
  };
  return CodeGS11282;
}(Code128Base);
function getSubstring(value, index, count) {
  return value.substring(index, index + count);
}

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/msi.js
var extend6 = Object.assign;
var MsiBase = function(Encoding2) {
  function MsiBase2() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    MsiBase2.__proto__ = Encoding2;
  MsiBase2.prototype = Object.create(Encoding2 && Encoding2.prototype);
  MsiBase2.prototype.constructor = MsiBase2;
  MsiBase2.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend6(this, {
      characterMap: [
        "12121212",
        "12121221",
        "12122112",
        "12122121",
        "12211212",
        "12211221",
        "12212112",
        "12212121",
        "21121212",
        "21121221"
      ],
      START: "21",
      STOP: "121",
      checkSumType: "",
      checkSums
    });
  };
  MsiBase2.prototype.initValue = function initValue(value, width) {
    this.pattern = [];
    this.value = value;
    this.checkSumLength = 0;
    this.width = width;
  };
  MsiBase2.prototype.setBaseUnit = function setBaseUnit() {
    var startStopLength = 7;
    this.baseUnit = this.width / (12 * (this.value.length + this.checkSumLength) + this.quietZoneLength + startStopLength);
  };
  MsiBase2.prototype.addData = function addData() {
    var this$1 = this;
    var value = this.value;
    this.addPattern(this.START);
    for (var i = 0; i < value.length; i++) {
      this$1.addCharacter(value.charAt(i));
    }
    if (this.options.addCheckSum) {
      this.addCheckSum();
    }
    this.addPattern(this.STOP);
    this.setBaseUnit();
  };
  MsiBase2.prototype.addCharacter = function addCharacter2(character) {
    var pattern = this.characterMap[character];
    if (!pattern) {
      this.invalidCharacterError(character);
    }
    this.addPattern(pattern);
  };
  MsiBase2.prototype.addPattern = function addPattern(pattern) {
    var this$1 = this;
    for (var i = 0; i < pattern.length; i++) {
      this$1.pattern.push(parseInt(pattern.charAt(i), 10));
    }
  };
  MsiBase2.prototype.addCheckSum = function addCheckSum() {
    var this$1 = this;
    var checkSumFunction = this.checkSums[this.checkSumType];
    var checkValues = checkSumFunction.call(this.checkSums, this.value);
    this.checksum = checkValues.join("");
    for (var i = 0; i < checkValues.length; i++) {
      this$1.checkSumLength++;
      this$1.addPattern(this$1.characterMap[checkValues[i]]);
    }
  };
  return MsiBase2;
}(Encoding);
var MsiMod10 = function(MsiBase2) {
  function MsiMod102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod102.__proto__ = MsiBase2;
  MsiMod102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod102.prototype.constructor = MsiMod102;
  MsiMod102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo10",
      checkSumType: "Modulo10"
    });
  };
  return MsiMod102;
}(MsiBase);
var MsiMod11 = function(MsiBase2) {
  function MsiMod112() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod112.__proto__ = MsiBase2;
  MsiMod112.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod112.prototype.constructor = MsiMod112;
  MsiMod112.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo11",
      checkSumType: "Modulo11"
    });
  };
  return MsiMod112;
}(MsiBase);
var MsiMod1010 = function(MsiBase2) {
  function MsiMod10102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod10102.__proto__ = MsiBase2;
  MsiMod10102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod10102.prototype.constructor = MsiMod10102;
  MsiMod10102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo10 Modulo10",
      checkSumType: "Modulo10Modulo10"
    });
  };
  return MsiMod10102;
}(MsiBase);
var MsiMod1110 = function(MsiBase2) {
  function MsiMod11102() {
    MsiBase2.apply(this, arguments);
  }
  if (MsiBase2)
    MsiMod11102.__proto__ = MsiBase2;
  MsiMod11102.prototype = Object.create(MsiBase2 && MsiBase2.prototype);
  MsiMod11102.prototype.constructor = MsiMod11102;
  MsiMod11102.prototype.initProperties = function initProperties() {
    MsiBase2.prototype.initProperties.call(this);
    extend6(this, {
      name: "MSI Modulo11 Modulo10",
      checkSumType: "Modulo11Modulo10"
    });
  };
  return MsiMod11102;
}(MsiBase);
var checkSums = {
  Modulo10: function Modulo10(value) {
    var checkValues = [0, ""], odd = value.length % 2, idx, evenSum, oddSum;
    for (idx = 0; idx < value.length; idx++) {
      checkValues[(idx + odd) % 2] += parseInt(value.charAt(idx), 10);
    }
    oddSum = checkValues[0];
    evenSum = (checkValues[1] * 2).toString();
    for (idx = 0; idx < evenSum.length; idx++) {
      oddSum += parseInt(evenSum.charAt(idx), 10);
    }
    return [(10 - oddSum % 10) % 10];
  },
  Modulo11: function Modulo11(value) {
    var weightedSum = 0, mod = 11, length = value.length, weight, checkValue;
    for (var i = 0; i < length; i++) {
      weight = ((length - i) % 6 || 6) + 1;
      weightedSum += weight * value.charAt(i);
    }
    checkValue = (mod - weightedSum % mod) % mod;
    if (checkValue !== 10) {
      return [checkValue];
    }
    return [1, 0];
  },
  Modulo11Modulo10: function Modulo11Modulo10(value) {
    var checkValues = this.Modulo11(value), mod11Value;
    mod11Value = value + checkValues[0];
    return checkValues.concat(this.Modulo10(mod11Value));
  },
  Modulo10Modulo10: function Modulo10Modulo10(value) {
    var checkValues = this.Modulo10(value), mod10Value;
    mod10Value = value + checkValues[0];
    return checkValues.concat(this.Modulo10(mod10Value));
  }
};

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean13.js
var extend7 = Object.assign;
var Ean13 = function(Encoding2) {
  function Ean132() {
    Encoding2.apply(this, arguments);
  }
  if (Encoding2)
    Ean132.__proto__ = Encoding2;
  Ean132.prototype = Object.create(Encoding2 && Encoding2.prototype);
  Ean132.prototype.constructor = Ean132;
  Ean132.prototype.initProperties = function initProperties() {
    Encoding2.prototype.initProperties.call(this);
    extend7(this, {
      name: "EAN 13",
      keyTable: [
        "000000",
        "001011",
        "001101",
        "001110",
        "010011",
        "011001",
        "011100",
        "010101",
        "010110",
        "011010"
      ],
      characterMap: {
        digits: [
          [3, 2, 1, 1],
          [2, 2, 2, 1],
          [2, 1, 2, 2],
          [1, 4, 1, 1],
          [1, 1, 3, 2],
          [1, 2, 3, 1],
          [1, 1, 1, 4],
          [1, 3, 1, 2],
          [1, 2, 1, 3],
          [3, 1, 1, 2]
        ],
        start: [1, 1, 1],
        middle: [1, 1, 1, 1, 1]
      }
    });
  };
  Ean132.prototype.initValue = function initValue(value, width, height) {
    var valueAsString = String(value);
    if (valueAsString.length !== 12 || /\D/.test(valueAsString)) {
      throw new Error('The value of the "EAN13" encoding should be 12 symbols');
    }
    this.pattern = [];
    this.options.height = height;
    this.baseUnit = width / (95 + this.quietZoneLength);
    this.value = valueAsString;
    this.checksum = this.calculateChecksum();
    this.leftKey = valueAsString[0];
    this.leftPart = valueAsString.substr(1, 6);
    this.rightPart = valueAsString.substr(7) + this.checksum;
  };
  Ean132.prototype.addData = function addData() {
    this.addPieces(this.characterMap.start);
    this.addSide(this.leftPart, this.leftKey);
    this.addPieces(this.characterMap.middle);
    this.addSide(this.rightPart);
    this.addPieces(this.characterMap.start);
  };
  Ean132.prototype.addSide = function addSide(leftPart, key) {
    var this$1 = this;
    for (var i = 0; i < leftPart.length; i++) {
      if (key && parseInt(this$1.keyTable[key].charAt(i), 10)) {
        this$1.addPieces(Array.prototype.slice.call(this$1.characterMap.digits[leftPart.charAt(i)]).reverse(), true);
      } else {
        this$1.addPieces(this$1.characterMap.digits[leftPart.charAt(i)], true);
      }
    }
  };
  Ean132.prototype.addPieces = function addPieces(arrToAdd, limitedHeight) {
    var this$1 = this;
    for (var i = 0; i < arrToAdd.length; i++) {
      if (limitedHeight) {
        this$1.pattern.push({
          y1: 0,
          y2: this$1.options.height * 0.95,
          width: arrToAdd[i]
        });
      } else {
        this$1.pattern.push(arrToAdd[i]);
      }
    }
  };
  Ean132.prototype.calculateChecksum = function calculateChecksum() {
    var odd = 0, even = 0, value = this.value.split("").reverse().join("");
    for (var i = 0; i < value.length; i++) {
      if (i % 2) {
        even += parseInt(value.charAt(i), 10);
      } else {
        odd += parseInt(value.charAt(i), 10);
      }
    }
    var checksum2 = (10 - (3 * odd + even) % 10) % 10;
    return checksum2;
  };
  return Ean132;
}(Encoding);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/ean8.js
var extend8 = Object.assign;
var Ean8 = function(Ean132) {
  function Ean82() {
    Ean132.apply(this, arguments);
  }
  if (Ean132)
    Ean82.__proto__ = Ean132;
  Ean82.prototype = Object.create(Ean132 && Ean132.prototype);
  Ean82.prototype.constructor = Ean82;
  Ean82.prototype.initProperties = function initProperties() {
    Ean132.prototype.initProperties.call(this);
    extend8(this, {
      name: "EAN 8"
    });
  };
  Ean82.prototype.initValue = function initValue(value, width, height) {
    if (value.length !== 7 || /\D/.test(value)) {
      throw new Error("Invalid value provided");
    }
    this.value = value;
    this.options.height = height;
    this.checksum = this.calculateChecksum(this.value);
    this.leftPart = this.value.substr(0, 4);
    this.rightPart = this.value.substr(4) + this.checksum;
    this.pattern = [];
    this.baseUnit = width / (67 + this.quietZoneLength);
  };
  return Ean82;
}(Ean13);

// node_modules/@progress/kendo-charts/dist/es/barcode/encodings/main.js
var Encodings = {
  code11: Code11,
  code39: Code39,
  code39extended: Code39Extended,
  code93: Code93,
  code93extended: Code93Extended,
  code128: Code128,
  code128a: Code128a,
  code128b: Code128b,
  code128c: Code128c
};
Encodings["gs1-128"] = CodeGS1128;
Encodings.msimod10 = MsiMod10;
Encodings.msimod11 = MsiMod11;
Encodings.msimod1010 = MsiMod1010;
Encodings.msimod1110 = MsiMod1110;
Encodings.postnet = Postnet;
Encodings.ean8 = Ean8;
Encodings.ean13 = Ean13;

// node_modules/@progress/kendo-charts/dist/es/barcode/surface-size.js
function surfaceSize(element, surfaceType) {
  var display = element.style.display;
  if (surfaceType === "canvas") {
    element.style.display = "block";
  }
  var size = {
    width: element.clientWidth,
    height: element.clientHeight
  };
  element.style.display = display;
  return size;
}

// node_modules/@progress/kendo-charts/dist/es/barcode/barcode.js
var DEFAULT_BARCODE_WIDTH = 300;
var DEFAULT_BARCODE_HEIGHT = 100;
var Barcode = function(Class3) {
  function Barcode2(element, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this._setOptions(options2);
    if (options2 && defined2(options2.value)) {
      this.redraw();
    }
  }
  if (Class3)
    Barcode2.__proto__ = Class3;
  Barcode2.prototype = Object.create(Class3 && Class3.prototype);
  Barcode2.prototype.constructor = Barcode2;
  Barcode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  Barcode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-barcode");
  };
  Barcode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  Barcode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  Barcode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  Barcode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  Barcode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  Barcode2.prototype.setOptions = function setOptions(options2) {
    this._setOptions(options2);
    this._initSurface();
    this.redraw();
  };
  Barcode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size.width,
      height: size.height
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  Barcode2.prototype.getSize = function getSize() {
    return {
      width: this.element.offsetWidth,
      height: this.element.offsetHeight
    };
  };
  Barcode2.prototype._resize = function _resize() {
    this.redraw();
  };
  Barcode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  Barcode2.prototype._render = function _render() {
    var options2 = this.options;
    var value = options2.value;
    var textOptions = options2.text;
    var textMargin = getSpacing(textOptions.margin);
    var size = this._getSize();
    var border = options2.border || {};
    var encoding = this.encoding;
    var contentBox = new box_default(0, 0, size.width, size.height).unpad(border.width).unpad(options2.padding);
    var barHeight = contentBox.height();
    var encodedValue;
    var textToDisplay;
    var textHeight;
    var visual = new drawing_exports.Group();
    this.contentBox = contentBox;
    visual.append(this._getBackground(size));
    if (textOptions.visible) {
      textHeight = drawing_exports.util.measureText(value, { font: textOptions.font }).height;
      barHeight -= textHeight + textMargin.top + textMargin.bottom;
    }
    try {
      encodedValue = encoding.encode(value, contentBox.width(), barHeight);
    } catch (error2) {
      this.onError(error2);
      return visual;
    }
    if (textOptions.visible) {
      textToDisplay = value;
      if (options2.checksum && defined2(encoding.checksum)) {
        textToDisplay += " " + encoding.checksum;
      }
      visual.append(this._getText(textToDisplay));
    }
    this.barHeight = barHeight;
    this._bandsGroup = this._getBands(encodedValue.pattern, encodedValue.baseUnit);
    visual.append(this._bandsGroup);
    return visual;
  };
  Barcode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  Barcode2.prototype._getSize = function _getSize() {
    var element = this.element;
    var elementSize3 = surfaceSize(element, this.options.renderAs);
    var size = new geometry_exports.Size(DEFAULT_BARCODE_WIDTH, DEFAULT_BARCODE_HEIGHT);
    if (elementSize3.width > 0) {
      size.width = elementSize3.width;
    }
    if (elementSize3.height > 0) {
      size.height = elementSize3.height;
    }
    if (this.options.width) {
      size.width = this.options.width;
    }
    if (this.options.height) {
      size.height = this.options.height;
    }
    return size;
  };
  Barcode2.prototype.value = function value(value$1) {
    if (!defined2(value$1)) {
      return this.options.value;
    }
    this.options.value = String(value$1);
    this.redraw();
  };
  Barcode2.prototype._getBands = function _getBands(pattern, baseUnit) {
    var this$1 = this;
    var contentBox = this.contentBox;
    var offsetX = contentBox.x1;
    var stepX;
    var patternItem;
    var group = new drawing_exports.Group();
    for (var i = 0; i < pattern.length; i++) {
      patternItem = isObject(pattern[i]) ? pattern[i] : {
        width: pattern[i],
        y1: 0,
        y2: this$1.barHeight
      };
      stepX = patternItem.width * baseUnit;
      if (i % 2) {
        var rect = geometry_exports.Rect.fromPoints(
          new geometry_exports.Point(offsetX, patternItem.y1 + contentBox.y1),
          new geometry_exports.Point(offsetX + stepX, patternItem.y2 + contentBox.y1)
        );
        var path = drawing_exports.Path.fromRect(rect, {
          fill: {
            color: this$1.options.color
          },
          stroke: null
        });
        group.append(path);
      }
      offsetX += stepX;
    }
    return group;
  };
  Barcode2.prototype._getBackground = function _getBackground(size) {
    var options2 = this.options;
    var border = options2.border || {};
    var box = new box_default(0, 0, size.width, size.height).unpad(border.width / 2);
    var path = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: options2.background
      },
      stroke: {
        color: border.width ? border.color : "",
        width: border.width,
        dashType: border.dashType
      }
    });
    return path;
  };
  Barcode2.prototype._getText = function _getText(value) {
    var textOptions = this.options.text;
    var text = this._textbox = new text_box_default(value, {
      font: textOptions.font,
      color: textOptions.color,
      align: "center",
      vAlign: "bottom",
      margin: textOptions.margin
    });
    text.reflow(this.contentBox);
    text.renderVisual();
    return text.visual;
  };
  Barcode2.prototype._setOptions = function _setOptions(options2) {
    this.type = (options2.type || this.options.type).toLowerCase();
    if (this.type === "upca") {
      this.type = "ean13";
      options2.value = "0" + options2.value;
    }
    if (this.type === "upce") {
      this.type = "ean8";
      options2.value = "0" + options2.value;
    }
    if (!Encodings[this.type]) {
      throw new Error("Encoding '" + this.type + "' is not supported.");
    }
    this.encoding = new Encodings[this.type]();
    this.options = deepExtend({}, this.options, options2);
  };
  return Barcode2;
}(class_default);
setDefaultOptions(Barcode, {
  name: "Barcode",
  renderAs: "svg",
  value: "",
  type: "code39",
  checksum: false,
  width: 0,
  height: 0,
  color: "black",
  background: "white",
  text: {
    visible: true,
    font: "16px Consolas, Monaco, Sans Mono, monospace, sans-serif",
    color: "black",
    margin: {
      top: 0,
      bottom: 0,
      left: 0,
      right: 0
    }
  },
  border: {
    width: 0,
    dashType: "solid",
    color: "black"
  },
  padding: {
    top: 0,
    bottom: 0,
    left: 0,
    right: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/qrcode/utils.js
var extend9 = Object.assign;
function splitInto(str, chunkLength) {
  var result = [];
  var idx = 0;
  while (idx < str.length) {
    result.push(str.substring(idx, idx + chunkLength));
    idx += chunkLength;
  }
  return result;
}
function toBitsString(value, length) {
  var bitString = Number(value).toString(2);
  if (bitString.length < length) {
    bitString = new Array(length - bitString.length + 1).join(0) + bitString;
  }
  return bitString;
}
function toDecimal(value) {
  return parseInt(value, 2);
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/free-cell-visitor.js
var FreeCellVisitor = function(Class3) {
  function FreeCellVisitor2(matrix) {
    Class3.call(this);
    this.matrix = matrix;
    this.row = matrix.length - 1;
    this.column = matrix.length - 1;
    this.startColumn = this.column;
    this.dir = -1;
    this.c = 0;
  }
  if (Class3)
    FreeCellVisitor2.__proto__ = Class3;
  FreeCellVisitor2.prototype = Object.create(Class3 && Class3.prototype);
  FreeCellVisitor2.prototype.constructor = FreeCellVisitor2;
  FreeCellVisitor2.prototype.move = function move() {
    this.row += this.dir * this.c;
    this.c ^= 1;
    this.column = this.startColumn - this.c;
  };
  FreeCellVisitor2.prototype.getNextCell = function getNextCell() {
    var this$1 = this;
    while (this.matrix[this.row][this.column] !== void 0) {
      this$1.move();
      if (this$1.row < 0 || this$1.row >= this$1.matrix.length) {
        this$1.dir = -this$1.dir;
        this$1.startColumn -= this$1.startColumn !== 8 ? 2 : 3;
        this$1.column = this$1.startColumn;
        this$1.row = this$1.dir < 0 ? this$1.matrix.length - 1 : 0;
      }
    }
    return {
      row: this.row,
      column: this.column
    };
  };
  FreeCellVisitor2.prototype.getNextRemainderCell = function getNextRemainderCell() {
    this.move();
    if (this.matrix[this.row][this.column] === void 0) {
      return {
        row: this.row,
        column: this.column
      };
    }
  };
  return FreeCellVisitor2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding-result.js
var EncodingResult = function(Class3) {
  function EncodingResult2(dataString, version) {
    Class3.call(this);
    this.dataString = dataString;
    this.version = version;
  }
  if (Class3)
    EncodingResult2.__proto__ = Class3;
  EncodingResult2.prototype = Object.create(Class3 && Class3.prototype);
  EncodingResult2.prototype.constructor = EncodingResult2;
  return EncodingResult2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/iso-encoder.js
var IsoEncoder = function(Class3) {
  function IsoEncoder2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    IsoEncoder2.__proto__ = Class3;
  IsoEncoder2.prototype = Object.create(Class3 && Class3.prototype);
  IsoEncoder2.prototype.constructor = IsoEncoder2;
  IsoEncoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var modes = getModes(inputString), dataCodewordsCount = getDataCodewordsCount(modes), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = getDataString(modes, version);
    return new EncodingResult(dataString, version);
  };
  return IsoEncoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/qr-data-mode.js
var QRDataMode = function(Class3) {
  function QRDataMode2() {
    Class3.call(this);
    this.initProperties();
  }
  if (Class3)
    QRDataMode2.__proto__ = Class3;
  QRDataMode2.prototype = Object.create(Class3 && Class3.prototype);
  QRDataMode2.prototype.constructor = QRDataMode2;
  QRDataMode2.prototype.initProperties = function initProperties() {
    extend9(this, {
      modeIndicator: "",
      bitsInCharacterCount: []
    });
  };
  QRDataMode2.prototype.getVersionIndex = function getVersionIndex(version) {
    if (version < 10) {
      return 0;
    } else if (version > 26) {
      return 2;
    }
    return 1;
  };
  QRDataMode2.prototype.getBitsCharacterCount = function getBitsCharacterCount(version) {
    return this.bitsInCharacterCount[this.getVersionIndex(version || 40)];
  };
  QRDataMode2.prototype.getModeCountString = function getModeCountString(length, version) {
    return this.modeIndicator + toBitsString(length, this.getBitsCharacterCount(version));
  };
  QRDataMode2.prototype.encode = function encode() {
  };
  QRDataMode2.prototype.getStringBitsLength = function getStringBitsLength() {
  };
  QRDataMode2.prototype.getValue = function getValue() {
  };
  return QRDataMode2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/numeric-data-mode.js
var NumericQRDataMode = function(QRDataMode2) {
  function NumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    NumericQRDataMode2.__proto__ = QRDataMode2;
  NumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  NumericQRDataMode2.prototype.constructor = NumericQRDataMode2;
  NumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      bitsInCharacterCount: [10, 12, 14],
      modeIndicator: "0001"
    });
  };
  NumericQRDataMode2.prototype.getValue = function getValue(character) {
    return parseInt(character, 10);
  };
  NumericQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, parts = splitInto(str, 3), result = mode.getModeCountString(str.length, version);
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      result += toBitsString(parts[i], 10);
    }
    return result + toBitsString(parts[i], 1 + 3 * parts[i].length);
  };
  NumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    var mod3 = inputLength % 3;
    return 4 + this.getBitsCharacterCount(version) + 10 * Math.floor(inputLength / 3) + 3 * mod3 + (mod3 === 0 ? 0 : 1);
  };
  return NumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/alpha-numeric-data-mode.js
var AlphaNumericQRDataMode = function(QRDataMode2) {
  function AlphaNumericQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    AlphaNumericQRDataMode2.__proto__ = QRDataMode2;
  AlphaNumericQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  AlphaNumericQRDataMode2.prototype.constructor = AlphaNumericQRDataMode2;
  AlphaNumericQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      characters: {
        "0": 0,
        "1": 1,
        "2": 2,
        "3": 3,
        "4": 4,
        "5": 5,
        "6": 6,
        "7": 7,
        "8": 8,
        "9": 9,
        "A": 10,
        "B": 11,
        "C": 12,
        "D": 13,
        "E": 14,
        "F": 15,
        "G": 16,
        "H": 17,
        "I": 18,
        "J": 19,
        "K": 20,
        "L": 21,
        "M": 22,
        "N": 23,
        "O": 24,
        "P": 25,
        "Q": 26,
        "R": 27,
        "S": 28,
        "T": 29,
        "U": 30,
        "V": 31,
        "W": 32,
        "X": 33,
        "Y": 34,
        "Z": 35,
        " ": 36,
        "$": 37,
        "%": 38,
        "*": 39,
        "+": 40,
        "-": 41,
        ".": 42,
        "/": 43,
        ":": 44
      },
      bitsInCharacterCount: [9, 11, 13],
      modeIndicator: "0010"
    });
  };
  AlphaNumericQRDataMode2.prototype.getValue = function getValue(character) {
    return this.characters[character];
  };
  AlphaNumericQRDataMode2.prototype.encode = function encode(str, version) {
    var this$1 = this;
    var parts = splitInto(str, 2), result = this.getModeCountString(str.length, version), value;
    var i;
    for (i = 0; i < parts.length - 1; i++) {
      value = 45 * this$1.getValue(parts[i].charAt(0)) + this$1.getValue(parts[i].charAt(1));
      result += toBitsString(value, 11);
    }
    value = parts[i].length === 2 ? 45 * this.getValue(parts[i].charAt(0)) + this.getValue(parts[i].charAt(1)) : this.getValue(parts[i].charAt(0));
    return result + toBitsString(value, 1 + 5 * parts[i].length);
  };
  AlphaNumericQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 11 * Math.floor(inputLength / 2) + 6 * (inputLength % 2);
  };
  return AlphaNumericQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/byte-data-mode.js
var ByteQRDataMode = function(QRDataMode2) {
  function ByteQRDataMode2() {
    QRDataMode2.apply(this, arguments);
  }
  if (QRDataMode2)
    ByteQRDataMode2.__proto__ = QRDataMode2;
  ByteQRDataMode2.prototype = Object.create(QRDataMode2 && QRDataMode2.prototype);
  ByteQRDataMode2.prototype.constructor = ByteQRDataMode2;
  ByteQRDataMode2.prototype.initProperties = function initProperties() {
    QRDataMode2.prototype.initProperties.call(this);
    extend9(this, {
      bitsInCharacterCount: [8, 16, 16],
      modeIndicator: "0100"
    });
  };
  ByteQRDataMode2.prototype.getValue = function getValue(character) {
    var code2 = character.charCodeAt(0);
    if (code2 <= 127 || 160 <= code2 && code2 <= 255) {
      return code2;
    }
    throw new Error('Unsupported character in QR Code: "' + character + '".');
  };
  ByteQRDataMode2.prototype.encode = function encode(str, version) {
    var mode = this, result = mode.getModeCountString(str.length, version);
    for (var i = 0; i < str.length; i++) {
      result += toBitsString(mode.getValue(str.charAt(i)), 8);
    }
    return result;
  };
  ByteQRDataMode2.prototype.getStringBitsLength = function getStringBitsLength(inputLength, version) {
    return 4 + this.getBitsCharacterCount(version) + 8 * inputLength;
  };
  return ByteQRDataMode2;
}(QRDataMode);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/data-modes/data-mode-instances.js
var NUMERIC = "numeric";
var ALPHA_NUMERIC = "alphanumeric";
var BYTE = "byte";
var DataModeInstances = {};
DataModeInstances[NUMERIC] = new NumericQRDataMode();
DataModeInstances[ALPHA_NUMERIC] = new AlphaNumericQRDataMode();
DataModeInstances[BYTE] = new ByteQRDataMode();

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoders/utf8-encoder.js
var BYTE2 = "byte";
var Utf8Encoder = function(Class3) {
  function Utf8Encoder2() {
    Class3.call(this);
    this.initProperties();
    this.mode = DataModeInstances[this.encodingMode];
  }
  if (Class3)
    Utf8Encoder2.__proto__ = Class3;
  Utf8Encoder2.prototype = Object.create(Class3 && Class3.prototype);
  Utf8Encoder2.prototype.constructor = Utf8Encoder2;
  Utf8Encoder2.prototype.initProperties = function initProperties() {
    extend9(this, {
      encodingMode: BYTE2,
      utfBOM: "111011111011101110111111",
      initialModeCountStringLength: 20,
      ranges: [128, 2048, 65536, 2097152, 67108864]
    });
  };
  Utf8Encoder2.prototype.getEncodingResult = function getEncodingResult(inputString, errorCorrectionLevel) {
    var data = this.encode(inputString), dataCodewordsCount = this.getDataCodewordsCount(data), version = getVersion(dataCodewordsCount, errorCorrectionLevel), dataString = this.mode.getModeCountString(data.length / 8, version) + data;
    return new EncodingResult(dataString, version);
  };
  Utf8Encoder2.prototype.getDataCodewordsCount = function getDataCodewordsCount2(data) {
    var dataLength = data.length, dataCodewordsCount = Math.ceil((this.initialModeCountStringLength + dataLength) / 8);
    return dataCodewordsCount;
  };
  Utf8Encoder2.prototype.encode = function encode(str) {
    var this$1 = this;
    var result = this.utfBOM;
    for (var i = 0; i < str.length; i++) {
      result += this$1.encodeCharacter(str.charCodeAt(i));
    }
    return result;
  };
  Utf8Encoder2.prototype.encodeCharacter = function encodeCharacter(code2) {
    var bytesCount = this.getBytesCount(code2), bc = bytesCount - 1, result = "";
    if (bytesCount === 1) {
      result = toBitsString(code2, 8);
    } else {
      var significantOnes = 8 - bytesCount;
      for (var i = 0; i < bc; i++) {
        result = toBitsString(code2 >> i * 6 & 63 | 128, 8) + result;
      }
      result = (code2 >> bc * 6 | 255 >> significantOnes << significantOnes).toString(2) + result;
    }
    return result;
  };
  Utf8Encoder2.prototype.getBytesCount = function getBytesCount(code2) {
    var ranges = this.ranges;
    for (var i = 0; i < ranges.length; i++) {
      if (code2 < ranges[i]) {
        return i + 1;
      }
    }
  };
  return Utf8Encoder2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/version-codewords.js
var VersionsCodewordsInformation = [{
  L: {
    groups: [
      [1, 19]
    ],
    totalDataCodewords: 19,
    errorCodewordsPerBlock: 7
  },
  M: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 10
  },
  Q: {
    groups: [
      [1, 13]
    ],
    totalDataCodewords: 13,
    errorCodewordsPerBlock: 13
  },
  H: {
    groups: [
      [1, 9]
    ],
    totalDataCodewords: 9,
    errorCodewordsPerBlock: 17
  }
}, {
  L: {
    groups: [
      [1, 34]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 10
  },
  M: {
    groups: [
      [1, 28]
    ],
    totalDataCodewords: 28,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [1, 22]
    ],
    totalDataCodewords: 22,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [1, 16]
    ],
    totalDataCodewords: 16,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [1, 55]
    ],
    totalDataCodewords: 55,
    errorCodewordsPerBlock: 15
  },
  M: {
    groups: [
      [1, 44]
    ],
    totalDataCodewords: 44,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [2, 17]
    ],
    totalDataCodewords: 34,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 13]
    ],
    totalDataCodewords: 26,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [1, 80]
    ],
    totalDataCodewords: 80,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [2, 32]
    ],
    totalDataCodewords: 64,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 24]
    ],
    totalDataCodewords: 48,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [4, 9]
    ],
    totalDataCodewords: 36,
    errorCodewordsPerBlock: 16
  }
}, {
  L: {
    groups: [
      [1, 108]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [2, 43]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [2, 15],
      [2, 16]
    ],
    totalDataCodewords: 62,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [2, 11],
      [2, 12]
    ],
    totalDataCodewords: 46,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [2, 68]
    ],
    totalDataCodewords: 136,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 27]
    ],
    totalDataCodewords: 108,
    errorCodewordsPerBlock: 16
  },
  Q: {
    groups: [
      [4, 19]
    ],
    totalDataCodewords: 76,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [4, 15]
    ],
    totalDataCodewords: 60,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [2, 78]
    ],
    totalDataCodewords: 156,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [4, 31]
    ],
    totalDataCodewords: 124,
    errorCodewordsPerBlock: 18
  },
  Q: {
    groups: [
      [2, 14],
      [4, 15]
    ],
    totalDataCodewords: 88,
    errorCodewordsPerBlock: 18
  },
  H: {
    groups: [
      [4, 13],
      [1, 14]
    ],
    totalDataCodewords: 66,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 97]
    ],
    totalDataCodewords: 194,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [2, 38],
      [2, 39]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 18],
      [2, 19]
    ],
    totalDataCodewords: 110,
    errorCodewordsPerBlock: 22
  },
  H: {
    groups: [
      [4, 14],
      [2, 15]
    ],
    totalDataCodewords: 86,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [2, 116]
    ],
    totalDataCodewords: 232,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 36],
      [2, 37]
    ],
    totalDataCodewords: 182,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 16],
      [4, 17]
    ],
    totalDataCodewords: 132,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [4, 12],
      [4, 13]
    ],
    totalDataCodewords: 100,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 68],
      [2, 69]
    ],
    totalDataCodewords: 274,
    errorCodewordsPerBlock: 18
  },
  M: {
    groups: [
      [4, 43],
      [1, 44]
    ],
    totalDataCodewords: 216,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [6, 19],
      [2, 20]
    ],
    totalDataCodewords: 154,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [6, 15],
      [2, 16]
    ],
    totalDataCodewords: 122,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 81]
    ],
    totalDataCodewords: 324,
    errorCodewordsPerBlock: 20
  },
  M: {
    groups: [
      [1, 50],
      [4, 51]
    ],
    totalDataCodewords: 254,
    errorCodewordsPerBlock: 30
  },
  Q: {
    groups: [
      [4, 22],
      [4, 23]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [3, 12],
      [8, 13]
    ],
    totalDataCodewords: 140,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [2, 92],
      [2, 93]
    ],
    totalDataCodewords: 370,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [6, 36],
      [2, 37]
    ],
    totalDataCodewords: 290,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [4, 20],
      [6, 21]
    ],
    totalDataCodewords: 206,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [7, 14],
      [4, 15]
    ],
    totalDataCodewords: 158,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 107]
    ],
    totalDataCodewords: 428,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 37],
      [1, 38]
    ],
    totalDataCodewords: 334,
    errorCodewordsPerBlock: 22
  },
  Q: {
    groups: [
      [8, 20],
      [4, 21]
    ],
    totalDataCodewords: 244,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [12, 11],
      [4, 12]
    ],
    totalDataCodewords: 180,
    errorCodewordsPerBlock: 22
  }
}, {
  L: {
    groups: [
      [3, 115],
      [1, 116]
    ],
    totalDataCodewords: 461,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 40],
      [5, 41]
    ],
    totalDataCodewords: 365,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [11, 16],
      [5, 17]
    ],
    totalDataCodewords: 261,
    errorCodewordsPerBlock: 20
  },
  H: {
    groups: [
      [11, 12],
      [5, 13]
    ],
    totalDataCodewords: 197,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 87],
      [1, 88]
    ],
    totalDataCodewords: 523,
    errorCodewordsPerBlock: 22
  },
  M: {
    groups: [
      [5, 41],
      [5, 42]
    ],
    totalDataCodewords: 415,
    errorCodewordsPerBlock: 24
  },
  Q: {
    groups: [
      [5, 24],
      [7, 25]
    ],
    totalDataCodewords: 295,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 12],
      [7, 13]
    ],
    totalDataCodewords: 223,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [5, 98],
      [1, 99]
    ],
    totalDataCodewords: 589,
    errorCodewordsPerBlock: 24
  },
  M: {
    groups: [
      [7, 45],
      [3, 46]
    ],
    totalDataCodewords: 453,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 19],
      [2, 20]
    ],
    totalDataCodewords: 325,
    errorCodewordsPerBlock: 24
  },
  H: {
    groups: [
      [3, 15],
      [13, 16]
    ],
    totalDataCodewords: 253,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [1, 107],
      [5, 108]
    ],
    totalDataCodewords: 647,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [10, 46],
      [1, 47]
    ],
    totalDataCodewords: 507,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 22],
      [15, 23]
    ],
    totalDataCodewords: 367,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [17, 15]
    ],
    totalDataCodewords: 283,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [5, 120],
      [1, 121]
    ],
    totalDataCodewords: 721,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [9, 43],
      [4, 44]
    ],
    totalDataCodewords: 563,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [1, 23]
    ],
    totalDataCodewords: 397,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [2, 14],
      [19, 15]
    ],
    totalDataCodewords: 313,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [3, 113],
      [4, 114]
    ],
    totalDataCodewords: 795,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 44],
      [11, 45]
    ],
    totalDataCodewords: 627,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 21],
      [4, 22]
    ],
    totalDataCodewords: 445,
    errorCodewordsPerBlock: 26
  },
  H: {
    groups: [
      [9, 13],
      [16, 14]
    ],
    totalDataCodewords: 341,
    errorCodewordsPerBlock: 26
  }
}, {
  L: {
    groups: [
      [3, 107],
      [5, 108]
    ],
    totalDataCodewords: 861,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [3, 41],
      [13, 42]
    ],
    totalDataCodewords: 669,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [15, 24],
      [5, 25]
    ],
    totalDataCodewords: 485,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [15, 15],
      [10, 16]
    ],
    totalDataCodewords: 385,
    errorCodewordsPerBlock: 28
  }
}, {
  L: {
    groups: [
      [4, 116],
      [4, 117]
    ],
    totalDataCodewords: 932,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 42]
    ],
    totalDataCodewords: 714,
    errorCodewordsPerBlock: 26
  },
  Q: {
    groups: [
      [17, 22],
      [6, 23]
    ],
    totalDataCodewords: 512,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [19, 16],
      [6, 17]
    ],
    totalDataCodewords: 406,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [2, 111],
      [7, 112]
    ],
    totalDataCodewords: 1006,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [17, 46]
    ],
    totalDataCodewords: 782,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [16, 25]
    ],
    totalDataCodewords: 568,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [34, 13]
    ],
    totalDataCodewords: 442,
    errorCodewordsPerBlock: 24
  }
}, {
  L: {
    groups: [
      [4, 121],
      [5, 122]
    ],
    totalDataCodewords: 1094,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [4, 47],
      [14, 48]
    ],
    totalDataCodewords: 860,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [14, 25]
    ],
    totalDataCodewords: 614,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [16, 15],
      [14, 16]
    ],
    totalDataCodewords: 464,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 117],
      [4, 118]
    ],
    totalDataCodewords: 1174,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 45],
      [14, 46]
    ],
    totalDataCodewords: 914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [11, 24],
      [16, 25]
    ],
    totalDataCodewords: 664,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [30, 16],
      [2, 17]
    ],
    totalDataCodewords: 514,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 106],
      [4, 107]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 26
  },
  M: {
    groups: [
      [8, 47],
      [13, 48]
    ],
    totalDataCodewords: 1e3,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [7, 24],
      [22, 25]
    ],
    totalDataCodewords: 718,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [13, 16]
    ],
    totalDataCodewords: 538,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [10, 114],
      [2, 115]
    ],
    totalDataCodewords: 1370,
    errorCodewordsPerBlock: 28
  },
  M: {
    groups: [
      [19, 46],
      [4, 47]
    ],
    totalDataCodewords: 1062,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [28, 22],
      [6, 23]
    ],
    totalDataCodewords: 754,
    errorCodewordsPerBlock: 28
  },
  H: {
    groups: [
      [33, 16],
      [4, 17]
    ],
    totalDataCodewords: 596,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [8, 122],
      [4, 123]
    ],
    totalDataCodewords: 1468,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [22, 45],
      [3, 46]
    ],
    totalDataCodewords: 1128,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [8, 23],
      [26, 24]
    ],
    totalDataCodewords: 808,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [12, 15],
      [28, 16]
    ],
    totalDataCodewords: 628,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [3, 117],
      [10, 118]
    ],
    totalDataCodewords: 1531,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [3, 45],
      [23, 46]
    ],
    totalDataCodewords: 1193,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [4, 24],
      [31, 25]
    ],
    totalDataCodewords: 871,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [31, 16]
    ],
    totalDataCodewords: 661,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [7, 116],
      [7, 117]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [21, 45],
      [7, 46]
    ],
    totalDataCodewords: 1267,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [1, 23],
      [37, 24]
    ],
    totalDataCodewords: 911,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [26, 16]
    ],
    totalDataCodewords: 701,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [5, 115],
      [10, 116]
    ],
    totalDataCodewords: 1735,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [19, 47],
      [10, 48]
    ],
    totalDataCodewords: 1373,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [15, 24],
      [25, 25]
    ],
    totalDataCodewords: 985,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [25, 16]
    ],
    totalDataCodewords: 745,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [3, 116]
    ],
    totalDataCodewords: 1843,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [2, 46],
      [29, 47]
    ],
    totalDataCodewords: 1455,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [42, 24],
      [1, 25]
    ],
    totalDataCodewords: 1033,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [23, 15],
      [28, 16]
    ],
    totalDataCodewords: 793,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115]
    ],
    totalDataCodewords: 1955,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [10, 46],
      [23, 47]
    ],
    totalDataCodewords: 1541,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [10, 24],
      [35, 25]
    ],
    totalDataCodewords: 1115,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [19, 15],
      [35, 16]
    ],
    totalDataCodewords: 845,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 115],
      [1, 116]
    ],
    totalDataCodewords: 2071,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [21, 47]
    ],
    totalDataCodewords: 1631,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [29, 24],
      [19, 25]
    ],
    totalDataCodewords: 1171,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [11, 15],
      [46, 16]
    ],
    totalDataCodewords: 901,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [13, 115],
      [6, 116]
    ],
    totalDataCodewords: 2191,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [14, 46],
      [23, 47]
    ],
    totalDataCodewords: 1725,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [44, 24],
      [7, 25]
    ],
    totalDataCodewords: 1231,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [59, 16],
      [1, 17]
    ],
    totalDataCodewords: 961,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [12, 121],
      [7, 122]
    ],
    totalDataCodewords: 2306,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [12, 47],
      [26, 48]
    ],
    totalDataCodewords: 1812,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [39, 24],
      [14, 25]
    ],
    totalDataCodewords: 1286,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [22, 15],
      [41, 16]
    ],
    totalDataCodewords: 986,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [6, 121],
      [14, 122]
    ],
    totalDataCodewords: 2434,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [6, 47],
      [34, 48]
    ],
    totalDataCodewords: 1914,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [46, 24],
      [10, 25]
    ],
    totalDataCodewords: 1354,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [2, 15],
      [64, 16]
    ],
    totalDataCodewords: 1054,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [17, 122],
      [4, 123]
    ],
    totalDataCodewords: 2566,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [29, 46],
      [14, 47]
    ],
    totalDataCodewords: 1992,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [49, 24],
      [10, 25]
    ],
    totalDataCodewords: 1426,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [24, 15],
      [46, 16]
    ],
    totalDataCodewords: 1096,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [4, 122],
      [18, 123]
    ],
    totalDataCodewords: 2702,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [13, 46],
      [32, 47]
    ],
    totalDataCodewords: 2102,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [48, 24],
      [14, 25]
    ],
    totalDataCodewords: 1502,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [42, 15],
      [32, 16]
    ],
    totalDataCodewords: 1142,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [20, 117],
      [4, 118]
    ],
    totalDataCodewords: 2812,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [40, 47],
      [7, 48]
    ],
    totalDataCodewords: 2216,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [43, 24],
      [22, 25]
    ],
    totalDataCodewords: 1582,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [10, 15],
      [67, 16]
    ],
    totalDataCodewords: 1222,
    errorCodewordsPerBlock: 30
  }
}, {
  L: {
    groups: [
      [19, 118],
      [6, 119]
    ],
    totalDataCodewords: 2956,
    errorCodewordsPerBlock: 30
  },
  M: {
    groups: [
      [18, 47],
      [31, 48]
    ],
    totalDataCodewords: 2334,
    errorCodewordsPerBlock: 28
  },
  Q: {
    groups: [
      [34, 24],
      [34, 25]
    ],
    totalDataCodewords: 1666,
    errorCodewordsPerBlock: 30
  },
  H: {
    groups: [
      [20, 15],
      [61, 16]
    ],
    totalDataCodewords: 1276,
    errorCodewordsPerBlock: 30
  }
}];

// node_modules/@progress/kendo-charts/dist/es/qrcode/encodings/encoding.js
var terminator = "0000";
var NUMERIC2 = "numeric";
var ALPHA_NUMERIC2 = "alphanumeric";
var BYTE3 = "byte";
var powersOfTwo = { "1": 0 };
var powersOfTwoResult = { "0": 1 };
var irregularAlignmentPatternsStartDistance = {
  15: 20,
  16: 20,
  18: 24,
  19: 24,
  22: 20,
  24: 22,
  26: 24,
  28: 20,
  30: 20,
  31: 24,
  32: 28,
  33: 24,
  36: 18,
  37: 22,
  39: 20,
  40: 24
};
var finderPattern = [1, 0, 1, 1, 1];
var alignmentPattern = [1, 0, 1];
var errorCorrectionPatterns = { L: "01", M: "00", Q: "11", H: "10" };
var formatMaskPattern = "101010000010010";
var formatGeneratorPolynomial = "10100110111";
var versionGeneratorPolynomial = "1111100100101";
var paddingCodewords = ["11101100", "00010001"];
var finderPatternValue = 93;
var maskPatternConditions = [
  function(row, column) {
    return (row + column) % 2 === 0;
  },
  function(row, column) {
    return row % 2 === 0;
  },
  function(row, column) {
    return column % 3 === 0;
  },
  function(row, column) {
    return (row + column) % 3 === 0;
  },
  function(row, column) {
    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;
  },
  function(row, column) {
    return row * column % 2 + row * column % 3 === 0;
  },
  function(row, column) {
    return (row * column % 2 + row * column % 3) % 2 === 0;
  },
  function(row, column) {
    return ((row + column) % 2 + row * column % 3) % 2 === 0;
  }
];
var numberRegex4 = /^\d+/;
var alphaPattern = "A-Z0-9 $%*+./:-";
var alphaExclusiveSet = "A-Z $%*+./:-";
var alphaRegex = new RegExp("^[" + alphaExclusiveSet + "]+");
var alphaNumericRegex = new RegExp("^[" + alphaPattern + "]+");
var byteRegex = new RegExp("^[^" + alphaPattern + "]+");
var initMinNumericBeforeAlpha = 8;
var initMinNumericBeforeByte = 5;
var initMinAlphaBeforeByte = 8;
var minNumericBeforeAlpha = 17;
var minNumericBeforeByte = 9;
var minAlphaBeforeByte = 16;
var generatorPolynomials = [[1, 0], [1, 25, 0]];
function fillFunctionCell(matrices, bit, x, y) {
  for (var i = 0; i < matrices.length; i++) {
    matrices[i][x][y] = bit;
  }
}
function fillDataCell(matrices, bit, x, y) {
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);
  }
}
function fillData(matrices, blocks) {
  var cellVisitor = new FreeCellVisitor(matrices[0]), block, codewordIdx, cell;
  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {
    block = blocks[blockIdx];
    codewordIdx = 0;
    while (block.length > 0) {
      for (var i = 0; i < block.length; i++) {
        for (var j = 0; j < 8; j++) {
          cell = cellVisitor.getNextCell();
          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);
        }
      }
      codewordIdx++;
      while (block[0] && codewordIdx === block[0].length) {
        block.splice(0, 1);
      }
    }
  }
  while (cell = cellVisitor.getNextRemainderCell()) {
    fillDataCell(matrices, 0, cell.row, cell.column);
  }
}
function padDataString(initialDataString, totalDataCodewords) {
  var dataBitsCount = totalDataCodewords * 8, terminatorIndex = 0, paddingCodewordIndex = 0;
  var dataString = initialDataString;
  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {
    dataString += terminator.charAt(terminatorIndex++);
  }
  if (dataString.length % 8 !== 0) {
    dataString += new Array(9 - dataString.length % 8).join("0");
  }
  while (dataString.length < dataBitsCount) {
    dataString += paddingCodewords[paddingCodewordIndex];
    paddingCodewordIndex ^= 1;
  }
  return dataString;
}
function generatePowersOfTwo() {
  var result;
  var power;
  for (power = 1; power < 255; power++) {
    result = powersOfTwoResult[power - 1] * 2;
    if (result > 255) {
      result = result ^ 285;
    }
    powersOfTwoResult[power] = result;
    powersOfTwo[result] = power;
  }
  result = powersOfTwoResult[power - 1] * 2 ^ 285;
  powersOfTwoResult[power] = result;
  powersOfTwoResult[-1] = 0;
}
function xorPolynomials(x, y) {
  var result = [], idx = x.length - 2;
  for (var i = idx; i >= 0; i--) {
    result[i] = x[i] ^ y[i];
  }
  return result;
}
function multiplyPolynomials(x, y) {
  var result = [];
  for (var i = 0; i < x.length; i++) {
    for (var j = 0; j < y.length; j++) {
      if (result[i + j] === void 0) {
        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;
      } else {
        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];
      }
    }
  }
  return result;
}
function generateGeneratorPolynomials() {
  var maxErrorCorrectionCodeWordsCount = 68;
  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {
    var firstPolynomial = generatorPolynomials[idx - 1], secondPolynomial = [idx, 0];
    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);
  }
}
generatePowersOfTwo();
generateGeneratorPolynomials();
function multiplyByConstant(polynomial, power) {
  var result = [], idx = polynomial.length - 1;
  do {
    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];
    idx--;
  } while (polynomial[idx] !== void 0);
  return result;
}
function generateErrorCodewords(data, errorCodewordsCount) {
  var generator = generatorPolynomials[errorCodewordsCount - 1], result = new Array(errorCodewordsCount).concat(data), generatorPolynomial = new Array(result.length - generator.length).concat(generator), steps = data.length, errorCodewords = [], divisor, idx;
  for (idx = 0; idx < steps; idx++) {
    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);
    generatorPolynomial.splice(0, 1);
    result = xorPolynomials(divisor, result);
  }
  for (idx = result.length - 1; idx >= 0; idx--) {
    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);
  }
  return errorCodewords;
}
function getBlocks(dataStream, versionCodewordsInformation) {
  var codewordStart = 0, dataBlocks = [], errorBlocks = [], dataBlock, versionGroups = versionCodewordsInformation.groups, blockCodewordsCount, groupBlocksCount, messagePolynomial, codeword;
  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {
    groupBlocksCount = versionGroups[groupIdx][0];
    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {
      blockCodewordsCount = versionGroups[groupIdx][1];
      dataBlock = [];
      messagePolynomial = [];
      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {
        codeword = dataStream.substring(codewordStart, codewordStart + 8);
        dataBlock.push(codeword);
        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);
        codewordStart += 8;
      }
      dataBlocks.push(dataBlock);
      errorBlocks.push(generateErrorCodewords(
        messagePolynomial,
        versionCodewordsInformation.errorCodewordsPerBlock
      ));
    }
  }
  return [dataBlocks, errorBlocks];
}
function chooseMode(str, minNumericBeforeAlpha2, minNumericBeforeByte2, minAlphaBeforeByte2, previousMode) {
  var numeric = numberRegex4.exec(str), numericMatch = numeric ? numeric[0] : "", alpha = alphaRegex.exec(str), alphaMatch = alpha ? alpha[0] : "", alphaNumeric = alphaNumericRegex.exec(str), alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : "", mode, modeString;
  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha2 || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte2 && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {
    mode = NUMERIC2;
    modeString = numericMatch;
  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte2 || previousMode === ALPHA_NUMERIC2)) {
    mode = ALPHA_NUMERIC2;
    modeString = numericMatch || alphaMatch;
  } else {
    mode = BYTE3;
    if (alphaNumericMatch) {
      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];
    } else {
      modeString = byteRegex.exec(str)[0];
    }
  }
  return {
    mode,
    modeString
  };
}
function getModes(inputString) {
  var modes = [], previousMode, idx = 0;
  var str = inputString;
  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));
  previousMode = modes[0].mode;
  str = str.substr(modes[0].modeString.length);
  while (str.length > 0) {
    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);
    if (nextMode.mode !== previousMode) {
      previousMode = nextMode.mode;
      modes.push(nextMode);
      idx++;
    } else {
      modes[idx].modeString += nextMode.modeString;
    }
    str = str.substr(nextMode.modeString.length);
  }
  return modes;
}
function getDataCodewordsCount(modes) {
  var length = 0, mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    length += mode.getStringBitsLength(modes[i].modeString.length);
  }
  return Math.ceil(length / 8);
}
function getVersion(dataCodewordsCount, errorCorrectionLevel) {
  var x = 0, y = VersionsCodewordsInformation.length - 1, version = Math.floor(VersionsCodewordsInformation.length / 2);
  do {
    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {
      y = version;
    } else {
      x = version;
    }
    version = x + Math.floor((y - x) / 2);
  } while (y - x > 1);
  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {
    return version + 1;
  }
  return y + 1;
}
function getDataString(modes, version) {
  var dataString = "", mode;
  for (var i = 0; i < modes.length; i++) {
    mode = DataModeInstances[modes[i].mode];
    dataString += mode.encode(modes[i].modeString, version);
  }
  return dataString;
}
function encodeFormatInformation(format2) {
  var formatNumber2 = toDecimal(format2), encodedString, result = "";
  if (formatNumber2 === 0) {
    return "101010000010010";
  }
  encodedString = encodeBCH(toDecimal(format2), formatGeneratorPolynomial, 15);
  for (var i = 0; i < encodedString.length; i++) {
    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);
  }
  return result;
}
function encodeBCH(value, generatorPolynomial, codeLength) {
  var generatorNumber = toDecimal(generatorPolynomial), polynomialLength = generatorPolynomial.length - 1, valueNumber = value << polynomialLength, length = codeLength - polynomialLength, valueString = toBitsString(value, length), result = dividePolynomials(valueNumber, generatorNumber);
  result = valueString + toBitsString(result, polynomialLength);
  return result;
}
function dividePolynomials(numberX, numberY) {
  var yLength = numberY.toString(2).length, xLength = numberX.toString(2).length;
  var x = numberX;
  do {
    x ^= numberY << xLength - yLength;
    xLength = x.toString(2).length;
  } while (xLength >= yLength);
  return x;
}
function getNumberAt(str, idx) {
  return parseInt(str.charAt(idx), 10);
}
function initMatrices(version) {
  var matrices = [], modules = 17 + 4 * version;
  for (var i = 0; i < maskPatternConditions.length; i++) {
    matrices[i] = new Array(modules);
    for (var j = 0; j < modules; j++) {
      matrices[i][j] = new Array(modules);
    }
  }
  return matrices;
}
function addFormatInformation(matrices, formatString2) {
  var matrix = matrices[0], x, y, idx = 0, length = formatString2.length;
  for (x = 0, y = 8; x <= 8; x++) {
    if (x !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
    }
  }
  for (x = 8, y = 7; y >= 0; y--) {
    if (y !== 6) {
      fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
    }
  }
  idx = 0;
  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
  }
  fillFunctionCell(matrices, 1, matrix.length - 8, 8);
  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {
    fillFunctionCell(matrices, getNumberAt(formatString2, length - 1 - idx++), x, y);
  }
}
function encodeVersionInformation(version) {
  return encodeBCH(version, versionGeneratorPolynomial, 18);
}
function addVersionInformation(matrices, dataString) {
  var matrix = matrices[0], modules = matrix.length, x1 = 0, y1 = modules - 11, x2 = modules - 11, y2 = 0, quotient, mod, value;
  for (var idx = 0; idx < dataString.length; idx++) {
    quotient = Math.floor(idx / 3);
    mod = idx % 3;
    value = getNumberAt(dataString, dataString.length - idx - 1);
    fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);
    fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);
  }
}
function addCentricPattern(matrices, pattern, x, y) {
  var size = pattern.length + 2, length = pattern.length + 1, value;
  for (var i = 0; i < pattern.length; i++) {
    for (var j = i; j < size - i; j++) {
      value = pattern[i];
      fillFunctionCell(matrices, value, x + j, y + i);
      fillFunctionCell(matrices, value, x + i, y + j);
      fillFunctionCell(matrices, value, x + length - j, y + length - i);
      fillFunctionCell(matrices, value, x + length - i, y + length - j);
    }
  }
}
function addFinderSeparator(matrices, direction, x, y) {
  var nextX = x, nextY = y, matrix = matrices[0];
  do {
    fillFunctionCell(matrices, 0, nextX, y);
    fillFunctionCell(matrices, 0, x, nextY);
    nextX += direction[0];
    nextY += direction[1];
  } while (nextX >= 0 && nextX < matrix.length);
}
function addFinderPatterns(matrices) {
  var modules = matrices[0].length;
  addCentricPattern(matrices, finderPattern, 0, 0);
  addFinderSeparator(matrices, [-1, -1], 7, 7);
  addCentricPattern(matrices, finderPattern, modules - 7, 0);
  addFinderSeparator(matrices, [1, -1], modules - 8, 7);
  addCentricPattern(matrices, finderPattern, 0, modules - 7);
  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);
}
function addAlignmentPatterns(matrices, version) {
  if (version < 2) {
    return;
  }
  var matrix = matrices[0], modules = matrix.length, pointsCount = Math.floor(version / 7), points3 = [6], startDistance, distance, idx = 0;
  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {
    distance = (modules - 13 - startDistance) / pointsCount;
  } else {
    startDistance = distance = (modules - 13) / (pointsCount + 1);
  }
  points3.push(points3[idx++] + startDistance);
  while (points3[idx] + distance < modules) {
    points3.push(points3[idx++] + distance);
  }
  for (var i = 0; i < points3.length; i++) {
    for (var j = 0; j < points3.length; j++) {
      if (matrix[points3[i]][points3[j]] === void 0) {
        addCentricPattern(matrices, alignmentPattern, points3[i] - 2, points3[j] - 2);
      }
    }
  }
}
function addTimingFunctions(matrices) {
  var row = 6, column = 6, value = 1, modules = matrices[0].length;
  for (var i = 8; i < modules - 8; i++) {
    fillFunctionCell(matrices, value, row, i);
    fillFunctionCell(matrices, value, i, column);
    value ^= 1;
  }
}
function scoreMaskMatrixes(matrices) {
  var scores = [], previousBits = [], darkModules = [], patterns = [], adjacentSameBits = [], matrix, i, row = 0, column = 1, modulesLength = matrices[0].length;
  for (i = 0; i < matrices.length; i++) {
    scores[i] = 0;
    darkModules[i] = 0;
    adjacentSameBits[i] = [0, 0];
    patterns[i] = [0, 0];
    previousBits[i] = [];
  }
  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {
    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {
      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {
        matrix = matrices[matrixIndex];
        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);
        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {
          scores[matrixIndex] += 3;
        }
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);
        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);
        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);
      }
    }
  }
  var total3 = modulesLength * modulesLength, minIdx, min3 = Number.MAX_VALUE;
  for (i = 0; i < scores.length; i++) {
    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total3);
    if (scores[i] < min3) {
      min3 = scores[i];
      minIdx = i;
    }
  }
  return minIdx;
}
function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {
  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;
  if (patterns[idx][rowColumn] === finderPatternValue) {
    scores[idx] += 40;
  }
}
function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {
  if (previousBits[idx][rowColumn] === bit) {
    adjacentBits[idx][rowColumn]++;
  } else {
    previousBits[idx][rowColumn] = bit;
    if (adjacentBits[idx][rowColumn] >= 5) {
      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;
    }
    adjacentBits[idx][rowColumn] = 1;
  }
}
function calculateDarkModulesRatioScore(darkModules, total3) {
  var percent = Math.floor(darkModules / total3 * 100), mod5 = percent % 5, previous = Math.abs(percent - mod5 - 50), next = Math.abs(percent + 5 - mod5 - 50), score = 10 * Math.min(previous / 5, next / 5);
  return score;
}
function createQRCodeDataEncoder(encoding) {
  if (encoding && encoding.toLowerCase().indexOf("utf_8") >= 0) {
    return new Utf8Encoder();
  }
  return new IsoEncoder();
}
function encodeData(inputString, errorCorrectionLevel, encoding) {
  var encoder = createQRCodeDataEncoder(encoding), encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel), version = encodingResult.version, versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel], dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords), blocks = getBlocks(dataString, versionInformation), matrices = initMatrices(version);
  addFinderPatterns(matrices);
  addAlignmentPatterns(matrices, version);
  addTimingFunctions(matrices);
  if (version >= 7) {
    addVersionInformation(matrices, toBitsString(0, 18));
  }
  addFormatInformation(matrices, toBitsString(0, 15));
  fillData(matrices, blocks);
  var minIdx = scoreMaskMatrixes(matrices), optimalMatrix = matrices[minIdx];
  if (version >= 7) {
    addVersionInformation([optimalMatrix], encodeVersionInformation(version));
  }
  var formatString2 = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);
  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString2));
  return optimalMatrix;
}

// node_modules/@progress/kendo-charts/dist/es/qrcode/qrcode.js
var round4 = Math.round;
var crossPattern = [[0, 1], [1, 1], [1, 2], [2, 2], [2, 1], [3, 1], [3, 0], [2, 0], [2, -1], [1, -1], [1, 0]];
var squarePattern = [[0, 1], [1, 1], [1, 0]];
var QRCodeDefaults = {
  DEFAULT_SIZE: 200,
  QUIET_ZONE_LENGTH: 4,
  DEFAULT_ERROR_CORRECTION_LEVEL: "L",
  DEFAULT_BACKGROUND: "#fff",
  DEFAULT_DARK_MODULE_COLOR: "#000",
  MIN_BASE_UNIT_SIZE: 1,
  DEFAULT_LOGO_SIZE: 7
};
var QRCode = function(Class3) {
  function QRCode2(element, options2, errorHandler) {
    if (errorHandler === void 0)
      errorHandler = defaultErrorHandler;
    Class3.call(this);
    this.options = deepExtend({}, this.options, options2);
    this.element = element;
    this.wrapper = this.element;
    this.onError = errorHandler;
    this._initElement();
    this._initSurface();
    this.setOptions(options2);
  }
  if (Class3)
    QRCode2.__proto__ = Class3;
  QRCode2.prototype = Object.create(Class3 && Class3.prototype);
  QRCode2.prototype.constructor = QRCode2;
  QRCode2.prototype.destroy = function destroy2() {
    this._destroySurface();
  };
  QRCode2.prototype._initElement = function _initElement() {
    addClass(this.element, "k-qrcode");
  };
  QRCode2.prototype._initSurface = function _initSurface() {
    var ref2 = this;
    var options2 = ref2.options;
    var surface = ref2.surface;
    if (!surface || surface.options.type !== options2.renderAs) {
      this._destroySurface();
      this._initSurfaceElement();
      this.surface = this._createSurface();
    }
  };
  QRCode2.prototype._createSurface = function _createSurface() {
    return drawing_exports.Surface.create(this.surfaceElement, {
      type: this.options.renderAs
    });
  };
  QRCode2.prototype._destroySurface = function _destroySurface() {
    if (this.surface) {
      this.surface.destroy();
      this.surface = null;
      this._destroySurfaceElement();
    }
  };
  QRCode2.prototype._initSurfaceElement = function _initSurfaceElement() {
    if (!this.surfaceElement) {
      this.surfaceElement = document.createElement("div");
      this.surfaceElement.style.position = "relative";
      this.element.appendChild(this.surfaceElement);
    }
  };
  QRCode2.prototype._destroySurfaceElement = function _destroySurfaceElement() {
    if (this.surfaceElement && this.surfaceElement.parentNode) {
      this.surfaceElement.parentNode.removeChild(this.surfaceElement);
      this.surfaceElement = null;
    }
  };
  QRCode2.prototype.redraw = function redraw() {
    var size = this._getSize();
    this.surface.clear();
    this.surface.setSize({
      width: size,
      height: size
    });
    this.createVisual();
    this.surface.draw(this.visual);
  };
  QRCode2.prototype.getSize = function getSize() {
    var element = this.element;
    var elementWidth = element.clientWidth;
    var elementHeight = element.clientHeight;
    var size = { width: 0, height: 0 };
    if (elementWidth > 0) {
      size.width = elementWidth;
    }
    if (elementHeight) {
      size.height = elementHeight;
    }
    return size;
  };
  QRCode2.prototype._resize = function _resize() {
    this.redraw();
  };
  QRCode2.prototype.createVisual = function createVisual() {
    this.visual = this._render();
  };
  QRCode2.prototype.exportVisual = function exportVisual() {
    return this._render();
  };
  QRCode2.prototype._render = function _render() {
    var value = this._value, baseUnit, border = this.options.border || {}, padding = this.options.padding || 0, borderWidth = border.width || 0, quietZoneSize, matrix, size, dataSize, contentSize;
    border.width = borderWidth;
    var visual = new drawing_exports.Group();
    try {
      if (value) {
        matrix = encodeData(value, this.options.errorCorrection, this.options.encoding);
        size = this._getSize();
        contentSize = size - 2 * (borderWidth + padding);
        baseUnit = this._calculateBaseUnit(contentSize, matrix.length);
        dataSize = matrix.length * baseUnit;
        quietZoneSize = borderWidth + padding + (contentSize - dataSize) / 2;
        visual.append(this._renderBackground(size, border));
        visual.append(this._renderMatrix(matrix, baseUnit, quietZoneSize));
        if (this._hasCustomLogo()) {
          visual.append(this._renderLogo(size, baseUnit));
        } else if (this._isSwiss()) {
          visual.append(this._renderSwissCode(size, baseUnit));
        }
      }
    } catch (error2) {
      this.onError(error2);
    }
    return visual;
  };
  QRCode2.prototype._renderLogo = function _renderLogo(qrSize, baseUnit) {
    var image;
    var imageRect;
    var center = round4(qrSize / 2);
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    var logoUrl = this.options.overlay.imageUrl;
    var position = {
      x: center - logoSize.width / 2,
      y: center - logoSize.height / 2
    };
    imageRect = new geometry_exports.Rect(
      new geometry_exports.Point(position.x, position.y),
      new geometry_exports.Size(logoSize.width, logoSize.height)
    );
    image = new drawing_exports.Image(logoUrl, imageRect);
    return image;
  };
  QRCode2.prototype._renderSwissCode = function _renderSwissCode(qrSize, baseUnit) {
    var logoSize = this._getLogoSize(baseUnit * QRCodeDefaults.DEFAULT_LOGO_SIZE);
    logoSize = Math.max(logoSize.width, logoSize.height);
    var crossSize = logoSize / 4;
    var crossOffset = crossSize / 2;
    var center = qrSize / 2;
    var start = {};
    var visual = new drawing_exports.Group();
    start.x = start.y = Math.ceil(center - baseUnit - logoSize / 2);
    visual.append(this._renderShape(start, Math.ceil(logoSize + baseUnit * 2), squarePattern, "#fff"));
    start.x = start.y = center - logoSize / 2;
    visual.append(this._renderShape(start, logoSize, squarePattern, this.options.color));
    start.x = center + crossOffset - logoSize / 2;
    start.y = center + crossOffset + crossSize - logoSize / 2;
    visual.append(this._renderShape(start, crossSize, crossPattern, "#fff"));
    return visual;
  };
  QRCode2.prototype._renderShape = function _renderShape(start, step, pattern, color) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color
      },
      stroke: null
    });
    path.moveTo(start.x, start.y);
    for (var i = 0; i < pattern.length; i++) {
      path.lineTo(start.x + step * pattern[i][0], start.y + step * pattern[i][1]);
    }
    path.close();
    return path;
  };
  QRCode2.prototype._getSize = function _getSize() {
    var size;
    if (this.options.size) {
      size = parseInt(this.options.size, 10);
    } else {
      var element = this.element;
      var elementSize3 = surfaceSize(element, this.options.renderAs);
      var min3 = Math.min(elementSize3.width, elementSize3.height);
      if (min3 > 0) {
        size = min3;
      } else {
        size = QRCodeDefaults.DEFAULT_SIZE;
      }
    }
    return size;
  };
  QRCode2.prototype._calculateBaseUnit = function _calculateBaseUnit(size, matrixSize) {
    var baseUnit = Math.floor(size / matrixSize);
    if (baseUnit < QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      var minSize = Math.ceil(matrixSize * QRCodeDefaults.MIN_BASE_UNIT_SIZE);
      this.onError(new Error(
        "Insufficient size for QR Code: the current size is " + size + "px and the minimum size is " + minSize + "px."
      ));
    } else if (baseUnit * matrixSize >= size && baseUnit - 1 >= QRCodeDefaults.MIN_BASE_UNIT_SIZE) {
      baseUnit--;
    }
    return baseUnit;
  };
  QRCode2.prototype._renderMatrix = function _renderMatrix(matrix, baseUnit, quietZoneSize) {
    var path = new drawing_exports.MultiPath({
      fill: {
        color: this.options.color
      },
      stroke: null
    });
    for (var row = 0; row < matrix.length; row++) {
      var y = quietZoneSize + row * baseUnit;
      var column = 0;
      while (column < matrix.length) {
        while (matrix[row][column] === 0 && column < matrix.length) {
          column++;
        }
        if (column < matrix.length) {
          var x = column;
          while (matrix[row][column] === 1) {
            column++;
          }
          var x1 = round4(quietZoneSize + x * baseUnit);
          var y1 = round4(y);
          var x2 = round4(quietZoneSize + column * baseUnit);
          var y2 = round4(y + baseUnit);
          path.moveTo(x1, y1).lineTo(x1, y2).lineTo(x2, y2).lineTo(x2, y1).close();
        }
      }
    }
    return path;
  };
  QRCode2.prototype._renderBackground = function _renderBackground(size, border) {
    var box = new box_default(0, 0, size, size).unpad(border.width / 2);
    var background = drawing_exports.Path.fromRect(box.toRect(), {
      fill: {
        color: this.options.background
      },
      stroke: {
        color: border.color,
        width: border.width
      }
    });
    return background;
  };
  QRCode2.prototype.setOptions = function setOptions(options2) {
    var newOptions = options2 || {};
    this.options = extend9(this.options, newOptions);
    if (options2.value !== void 0) {
      this._value = String(this.options.value);
    }
    this._initSurface();
    this.redraw();
  };
  QRCode2.prototype.value = function value(value$1) {
    if (value$1 === void 0) {
      return this._value;
    }
    this._value = String(value$1);
    this.redraw();
  };
  QRCode2.prototype._hasCustomLogo = function _hasCustomLogo() {
    return Boolean(this.options.overlay.imageUrl);
  };
  QRCode2.prototype._isSwiss = function _isSwiss() {
    return this.options.overlay.type === "swiss";
  };
  QRCode2.prototype._getLogoSize = function _getLogoSize(defautLogoSize) {
    var width = this.options.overlay.width;
    var height = this.options.overlay.height;
    if (!width && !height) {
      width = height = defautLogoSize;
    } else if (width && !height) {
      height = width;
    } else if (!width && height) {
      width = height;
    }
    return {
      width,
      height
    };
  };
  return QRCode2;
}(class_default);
setDefaultOptions(QRCode, {
  name: "QRCode",
  renderAs: "svg",
  encoding: "ISO_8859_1",
  value: "",
  errorCorrection: QRCodeDefaults.DEFAULT_ERROR_CORRECTION_LEVEL,
  background: QRCodeDefaults.DEFAULT_BACKGROUND,
  color: QRCodeDefaults.DEFAULT_DARK_MODULE_COLOR,
  size: "",
  padding: 0,
  border: {
    color: "",
    width: 0
  },
  overlay: {
    type: "image",
    imageUrl: "",
    width: 0,
    height: 0
  }
});

// node_modules/@progress/kendo-charts/dist/es/map/datums.js
var WGS84 = {
  a: 6378137,
  // Semi-major radius
  b: 6356752314245179e-9,
  // Semi-minor radius
  f: 0.0033528106647474805,
  // Flattening
  e: 0.08181919084262149
  // Eccentricity
};
var datums = {
  WGS84
};

// node_modules/@progress/kendo-charts/dist/es/map/location.js
function toSquare(value) {
  return value * value;
}
var math = Math;
var abs = math.abs;
var atan = math.atan;
var atan2 = math.atan2;
var cos = math.cos;
var sin = math.sin;
var tan = math.tan;
var Location = function(Class3) {
  function Location2(lat, lng) {
    Class3.call(this);
    this.initProperties();
    if (arguments.length === 1) {
      this.lat = lat[0];
      this.lng = lat[1];
    } else {
      this.lat = lat;
      this.lng = lng;
    }
  }
  if (Class3)
    Location2.__proto__ = Class3;
  Location2.prototype = Object.create(Class3 && Class3.prototype);
  Location2.prototype.constructor = Location2;
  Location2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      DISTANCE_ITERATIONS: 100,
      DISTANCE_CONVERGENCE: 1e-12,
      DISTANCE_PRECISION: 2,
      FORMAT: "{0:N6}{1:N6}"
    });
  };
  Location2.prototype.toArray = function toArray() {
    return [
      this.lat,
      this.lng
    ];
  };
  Location2.prototype.equals = function equals(loc) {
    return loc && loc.lat === this.lat && loc.lng === this.lng;
  };
  Location2.prototype.clone = function clone2() {
    return new Location2(this.lat, this.lng);
  };
  Location2.prototype.round = function round$1(precision) {
    this.lng = round3(this.lng, precision);
    this.lat = round3(this.lat, precision);
    return this;
  };
  Location2.prototype.wrap = function wrap2() {
    this.lng = this.lng % 180;
    this.lat = this.lat % 90;
    return this;
  };
  Location2.prototype.distanceTo = function distanceTo(dest, datum) {
    return this.greatCircleTo(dest, datum).distance;
  };
  Location2.prototype.destination = function destination(distance, initialBearing, initialDatum) {
    var bearing = rad2(initialBearing);
    var datum = initialDatum || datums.WGS84;
    var fromLat = rad2(this.lat);
    var fromLng = rad2(this.lng);
    var dToR = distance / datum.a;
    var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));
    var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));
    return new Location2(deg2(lat), deg2(lng));
  };
  Location2.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {
    var this$1 = this;
    var dest = Location2.create(dest);
    var datum = initialDatum || datums.WGS84;
    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {
      return {
        distance: 0,
        azimuthFrom: 0,
        azimuthTo: 0
      };
    }
    var a = datum.a;
    var b = datum.b;
    var f = datum.f;
    var L = rad2(dest.lng - this.lng);
    var U1 = atan((1 - f) * tan(rad2(this.lat)));
    var sinU1 = sin(U1);
    var cosU1 = cos(U1);
    var U2 = atan((1 - f) * tan(rad2(dest.lat)));
    var sinU2 = sin(U2);
    var cosU2 = cos(U2);
    var lambda = L;
    var prevLambda;
    var i = this.DISTANCE_ITERATIONS;
    var converged = false;
    var sinLambda;
    var cosLambda;
    var sino;
    var cosA2;
    var coso;
    var cos2om;
    var sigma;
    while (!converged && i-- > 0) {
      sinLambda = sin(lambda);
      cosLambda = cos(lambda);
      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));
      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;
      sigma = atan2(sino, coso);
      var sinA = cosU1 * cosU2 * sinLambda / sino;
      cosA2 = 1 - toSquare(sinA);
      cos2om = 0;
      if (cosA2 !== 0) {
        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;
      }
      prevLambda = lambda;
      var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));
      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));
      converged = abs(lambda - prevLambda) <= this$1.DISTANCE_CONVERGENCE;
    }
    var u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);
    var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));
    var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));
    var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));
    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);
    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);
    return {
      distance: round3(b * A * (sigma - deltao), this.DISTANCE_PRECISION),
      azimuthFrom: deg2(azimuthFrom),
      azimuthTo: deg2(azimuthTo)
    };
  };
  Location2.prototype.toString = function toString4() {
    return String(this.lat) + "," + String(this.lng);
  };
  Location2.fromLngLat = function fromLngLat(lngAndLat) {
    return new Location2(lngAndLat[1], lngAndLat[0]);
  };
  Location2.fromLatLng = function fromLatLng(lngAndLat) {
    return new Location2(lngAndLat[0], lngAndLat[1]);
  };
  Location2.create = function create2(a, b) {
    if (defined2(a)) {
      if (a instanceof Location2) {
        return a.clone();
      } else if (arguments.length === 1 && a.length === 2) {
        return Location2.fromLatLng(a);
      }
      return new Location2(a, b);
    }
  };
  return Location2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/crs.js
var math2 = Math;
var atan3 = math2.atan;
var exp = math2.exp;
var pow3 = math2.pow;
var sin2 = math2.sin;
var log2 = math2.log;
var tan2 = math2.tan;
var Point5 = geometry_exports.Point;
var PI = math2.PI;
var PI_DIV_22 = PI / 2;
var PI_DIV_4 = PI / 4;
var DEG_TO_RAD2 = PI / 180;
var WGS842 = datums.WGS84;
var Mercator = function(Class3) {
  function Mercator2(options2) {
    Class3.call(this);
    this.initProperties();
    this._initOptions(options2);
  }
  if (Class3)
    Mercator2.__proto__ = Class3;
  Mercator2.prototype = Object.create(Class3 && Class3.prototype);
  Mercator2.prototype.constructor = Mercator2;
  Mercator2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Mercator2.prototype.initProperties = function initProperties() {
    deepExtend(this, {
      MAX_LNG: 180,
      MAX_LAT: 85.0840590501,
      INVERSE_ITERATIONS: 15,
      INVERSE_CONVERGENCE: 1e-12
    });
  };
  Mercator2.prototype.forward = function forward(loc, clamp) {
    var proj = this, options2 = proj.options, datum = options2.datum, r = datum.a, lng0 = options2.centralMeridian, lat = limitValue2(loc.lat, -proj.MAX_LAT, proj.MAX_LAT), lng = clamp ? limitValue2(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng, x = rad2(lng - lng0) * r, y = proj._projectLat(lat);
    return new Point5(x, y);
  };
  Mercator2.prototype._projectLat = function _projectLat(lat) {
    var datum = this.options.datum, ecc = datum.e, r = datum.a, y = rad2(lat), ts = tan2(PI_DIV_4 + y / 2), con = ecc * sin2(y), p2 = pow3((1 - con) / (1 + con), ecc / 2);
    return r * log2(ts * p2);
  };
  Mercator2.prototype.inverse = function inverse(point2, clamp) {
    var proj = this, options2 = proj.options, datum = options2.datum, r = datum.a, lng0 = options2.centralMeridian, lng = point2.x / (DEG_TO_RAD2 * r) + lng0, lat = limitValue2(proj._inverseY(point2.y), -proj.MAX_LAT, proj.MAX_LAT);
    if (clamp) {
      lng = limitValue2(lng, -proj.MAX_LNG, proj.MAX_LNG);
    }
    return new Location(lat, lng);
  };
  Mercator2.prototype._inverseY = function _inverseY(y) {
    var proj = this, datum = proj.options.datum, r = datum.a, ecc = datum.e, ecch = ecc / 2, ts = exp(-y / r), phi = PI_DIV_22 - 2 * atan3(ts), i;
    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {
      var con = ecc * sin2(phi), p2 = pow3((1 - con) / (1 + con), ecch), dphi = PI_DIV_22 - 2 * atan3(ts * p2) - phi;
      phi += dphi;
      if (math2.abs(dphi) <= proj.INVERSE_CONVERGENCE) {
        break;
      }
    }
    return deg2(phi);
  };
  return Mercator2;
}(class_default);
setDefaultOptions(Mercator, {
  centralMeridian: 0,
  datum: WGS842
});
var SphericalMercator = function(Mercator2) {
  function SphericalMercator2() {
    Mercator2.apply(this, arguments);
  }
  if (Mercator2)
    SphericalMercator2.__proto__ = Mercator2;
  SphericalMercator2.prototype = Object.create(Mercator2 && Mercator2.prototype);
  SphericalMercator2.prototype.constructor = SphericalMercator2;
  SphericalMercator2.prototype.initProperties = function initProperties() {
    Mercator2.prototype.initProperties.call(this);
    deepExtend(this, {
      MAX_LAT: 85.0511287798
    });
  };
  SphericalMercator2.prototype._projectLat = function _projectLat(lat) {
    var r = this.options.datum.a, y = rad2(lat), ts = tan2(PI_DIV_4 + y / 2);
    return r * log2(ts);
  };
  SphericalMercator2.prototype._inverseY = function _inverseY(y) {
    var r = this.options.datum.a, ts = exp(-y / r);
    return deg2(PI_DIV_22 - 2 * atan3(ts));
  };
  return SphericalMercator2;
}(Mercator);
var Equirectangular = function(Class3) {
  function Equirectangular2() {
    Class3.apply(this, arguments);
  }
  if (Class3)
    Equirectangular2.__proto__ = Class3;
  Equirectangular2.prototype = Object.create(Class3 && Class3.prototype);
  Equirectangular2.prototype.constructor = Equirectangular2;
  Equirectangular2.prototype.forward = function forward(loc) {
    return new Point5(loc.lng, loc.lat);
  };
  Equirectangular2.prototype.inverse = function inverse(point2) {
    return new Location(point2.y, point2.x);
  };
  return Equirectangular2;
}(class_default);
var EPSG3857 = function(Class3) {
  function EPSG38572() {
    Class3.call(this);
    var crs = this, proj = crs._proj = new SphericalMercator();
    var c = this.c = 2 * PI * proj.options.datum.a;
    this._tm = geometry_exports.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);
    this._itm = geometry_exports.transform().scale(c, -c).translate(-0.5, -0.5);
  }
  if (Class3)
    EPSG38572.__proto__ = Class3;
  EPSG38572.prototype = Object.create(Class3 && Class3.prototype);
  EPSG38572.prototype.constructor = EPSG38572;
  EPSG38572.prototype.toPoint = function toPoint(loc, scale, clamp) {
    var point2 = this._proj.forward(loc, clamp);
    return point2.transform(this._tm).scale(scale || 1);
  };
  EPSG38572.prototype.toLocation = function toLocation(point2, scale, clamp) {
    var newPoint = point2.clone().scale(1 / (scale || 1)).transform(this._itm);
    return this._proj.inverse(newPoint, clamp);
  };
  return EPSG38572;
}(class_default);
var EPSG3395 = function(Class3) {
  function EPSG33952() {
    Class3.call(this);
    this._proj = new Mercator();
  }
  if (Class3)
    EPSG33952.__proto__ = Class3;
  EPSG33952.prototype = Object.create(Class3 && Class3.prototype);
  EPSG33952.prototype.constructor = EPSG33952;
  EPSG33952.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG33952.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG33952;
}(class_default);
var EPSG4326 = function(Class3) {
  function EPSG43262() {
    Class3.call(this);
    this._proj = new Equirectangular();
  }
  if (Class3)
    EPSG43262.__proto__ = Class3;
  EPSG43262.prototype = Object.create(Class3 && Class3.prototype);
  EPSG43262.prototype.constructor = EPSG43262;
  EPSG43262.prototype.toPoint = function toPoint(loc) {
    return this._proj.forward(loc);
  };
  EPSG43262.prototype.toLocation = function toLocation(point2) {
    return this._proj.inverse(point2);
  };
  return EPSG43262;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/utils.js
var defineProperty = Object.defineProperty;
var convertToHtml = function(html) {
  var div = document.createElement("div");
  div.innerHTML = html;
  return div.firstChild;
};
var appendHtml = function(html, element) {
  var div = document.createElement("div");
  div.innerHTML = html;
  while (div.childNodes.length > 0) {
    element.appendChild(div.childNodes[0]);
  }
};
var removeChildren = function(element) {
  while (element.firstChild) {
    element.removeChild(element.firstChild);
  }
};
var prepend = function(element, originElement) {
  originElement.insertBefore(element, originElement.firstChild);
};
var wrapInner = function(parent, wrapper) {
  parent.appendChild(wrapper);
  while (parent.firstChild !== wrapper) {
    wrapper.appendChild(parent.firstChild);
  }
};
var toHyphens = function(str) {
  var result = str.replace(/([a-z][A-Z])/g, function(g) {
    return g.charAt(0) + "-" + g.charAt(1).toLowerCase();
  });
  return result;
};
var toPixels = function(value) {
  var result;
  if (value && String(value).endsWith("px")) {
    result = value;
  } else {
    result = String(value) + "px";
  }
  return result;
};
var detectOS = function(ua) {
  var os = false, minorVersion, match = [], agentRxs = {
    wp: /(Windows Phone(?: OS)?)\s(\d+)\.(\d+(\.\d+)?)/,
    fire: /(Silk)\/(\d+)\.(\d+(\.\d+)?)/,
    android: /(Android|Android.*(?:Opera|Firefox).*?\/)\s*(\d+)\.?(\d+(\.\d+)?)?/,
    iphone: /(iPhone|iPod).*OS\s+(\d+)[\._]([\d\._]+)/,
    ipad: /(iPad).*OS\s+(\d+)[\._]([\d_]+)/,
    meego: /(MeeGo).+NokiaBrowser\/(\d+)\.([\d\._]+)/,
    webos: /(webOS)\/(\d+)\.(\d+(\.\d+)?)/,
    blackberry: /(BlackBerry|BB10).*?Version\/(\d+)\.(\d+(\.\d+)?)/,
    playbook: /(PlayBook).*?Tablet\s*OS\s*(\d+)\.(\d+(\.\d+)?)/,
    windows: /(MSIE)\s+(\d+)\.(\d+(\.\d+)?)/,
    tizen: /(tizen).*?Version\/(\d+)\.(\d+(\.\d+)?)/i,
    sailfish: /(sailfish).*rv:(\d+)\.(\d+(\.\d+)?).*firefox/i,
    ffos: /(Mobile).*rv:(\d+)\.(\d+(\.\d+)?).*Firefox/
  }, osRxs = {
    ios: /^i(phone|pad|pod)$/i,
    android: /^android|fire$/i,
    blackberry: /^blackberry|playbook/i,
    windows: /windows/,
    wp: /wp/,
    flat: /sailfish|ffos|tizen/i,
    meego: /meego/
  }, formFactorRxs = {
    tablet: /playbook|ipad|fire/i
  }, browserRxs = {
    omini: /Opera\sMini/i,
    omobile: /Opera\sMobi/i,
    firefox: /Firefox|Fennec/i,
    mobilesafari: /version\/.*safari/i,
    ie: /MSIE|Windows\sPhone/i,
    chrome: /chrome|crios/i,
    webkit: /webkit/i
  };
  for (var agent in agentRxs) {
    if (agentRxs.hasOwnProperty(agent)) {
      match = ua.match(agentRxs[agent]);
      if (match) {
        if (agent === "windows" && "plugins" in navigator) {
          return false;
        }
        os = {};
        os.device = agent;
        os.tablet = testRegex(agent, formFactorRxs, false);
        os.browser = testRegex(ua, browserRxs, "default");
        os.name = testRegex(agent, osRxs);
        os[os.name] = true;
        os.majorVersion = match[2];
        os.minorVersion = (match[3] || "0").replace("_", ".");
        minorVersion = os.minorVersion.replace(".", "").substr(0, 2);
        os.flatVersion = os.majorVersion + minorVersion + new Array(3 - (minorVersion.length < 3 ? minorVersion.length : 2)).join("0");
        break;
      }
    }
  }
  return os;
};
function testRegex(agent, regexes, dflt) {
  for (var regex in regexes) {
    if (regexes.hasOwnProperty(regex) && regexes[regex].test(agent)) {
      return regex;
    }
  }
  return dflt !== void 0 ? dflt : agent;
}
var hasNativeScrolling = function(userAgent) {
  var os = detectOS(userAgent);
  return os.ios || os.android;
};
var detectBrowser = function(userAgent) {
  var browser7 = false, match = [], browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match = userAgent.match(browserRxs[agent]);
      if (match) {
        browser7 = {};
        browser7[agent] = true;
        browser7[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser7.version = parseInt(document.documentMode || match[2], 10);
        break;
      }
    }
  }
  return browser7;
};
var getEventMap = function() {
  var eventMap = {
    down: "touchstart mousedown",
    move: "mousemove touchmove",
    up: "mouseup touchend touchcancel",
    cancel: "mouseleave touchcancel"
  };
  var support3 = getSupportedFeatures();
  if (support3.touch && (support3.mobileOS.ios || support3.mobileOS.android)) {
    eventMap = {
      down: "touchstart",
      move: "touchmove",
      up: "touchend touchcancel",
      cancel: "touchcancel"
    };
  } else if (support3.pointers) {
    eventMap = {
      down: "pointerdown",
      move: "pointermove",
      up: "pointerup",
      cancel: "pointercancel pointerleave"
    };
  } else if (support3.msPointers) {
    eventMap = {
      down: "MSPointerDown",
      move: "MSPointerMove",
      up: "MSPointerUp",
      cancel: "MSPointerCancel MSPointerLeave"
    };
  }
  return eventMap;
};
var getSupportedFeatures = function() {
  var os = detectOS(navigator.userAgent);
  var browser7 = detectBrowser(navigator.userAgent);
  var chrome = browser7.chrome, mobileChrome = browser7.crios, mozilla = browser7.mozilla, safari = browser7.safari;
  var support3 = {};
  support3.mobileOS = os;
  support3.touch = "ontouchstart" in window;
  support3.pointers = !chrome && !mobileChrome && !mozilla && !safari && window.PointerEvent;
  support3.msPointers = !chrome && window.MSPointerEvent;
  support3.mouseAndTouchPresent = support3.touch && !(support3.mobileOS.ios || support3.mobileOS.android);
  support3.eventCapture = document.documentElement.addEventListener;
  var table = document.createElement("table");
  var transitions = support3.transitions = false, transforms = support3.transforms = false;
  var STRING3 = "string";
  ["Moz", "webkit", "O", "ms"].forEach(function(prefix) {
    var hasTransitions = typeof table.style[prefix + "Transition"] === STRING3;
    if (hasTransitions || typeof table.style[prefix + "Transform"] === STRING3) {
      var lowPrefix = prefix.toLowerCase();
      transforms = {
        css: lowPrefix !== "ms" ? "-" + lowPrefix + "-" : "",
        prefix,
        event: lowPrefix === "o" || lowPrefix === "webkit" ? lowPrefix : ""
      };
      if (hasTransitions) {
        transitions = transforms;
        transitions.event = transitions.event ? transitions.event + "TransitionEnd" : "transitionend";
      }
      return false;
    }
  });
  table = null;
  support3.transforms = transforms;
  support3.transitions = transitions;
  support3.delayedClick = function() {
    if (support3.touch) {
      if (support3.mobileOS.ios) {
        return true;
      }
      if (support3.mobileOS.android) {
        if (!support3.browser.chrome) {
          return true;
        }
        if (support3.browser.version < 32) {
          return false;
        }
        var meta = document.querySelector("meta[name=viewport]");
        var contentAttr = meta ? meta.getAttribute("content") : "";
        return !contentAttr.match(/user-scalable=no/i);
      }
    }
    return false;
  };
  return support3;
};
var ownsElement = function(parent, element) {
  if (!element) {
    return false;
  }
  var node = element.parentNode;
  while (node !== null) {
    if (node === parent) {
      return true;
    }
    node = node.parentNode;
  }
  return false;
};
var contains = function(parent, element) {
  return parent === element || ownsElement(parent, element);
};
var proxy = function(method, context2) {
  return method.bind(context2);
};
function isString3(value) {
  return typeof value === "string";
}
var on = function(element, events2, filter, handler, useCapture) {
  addEventListeners(element, events2, filter, handler, useCapture);
};
var addEventListeners = function(element, events2, filter, handler, useCapture) {
  var eventNames = isArray(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    addEventListener(element, eventName, filter, handler, useCapture);
  });
};
var addEventListener = function(element, event, filter, handler, useCapture) {
  var eventHandler = handler;
  var eventFilter;
  if (filter && isFunction3(filter) && !handler) {
    eventHandler = filter;
  } else if (filter && isString3(filter) && isFunction3(eventHandler)) {
    eventFilter = filter;
  }
  element.addEventListener(event, function(e) {
    var closestMatchingTarget = e.target ? e.target.closest(eventFilter) : null;
    if (!eventFilter || eventFilter && e.target && closestMatchingTarget) {
      var currentTarget = eventFilter ? closestMatchingTarget : e.currentTarget;
      defineProperty(e, "currentTarget", { value: currentTarget });
      defineProperty(e, "delegateTarget", { value: element });
      eventHandler(e);
    }
  }, Boolean(useCapture));
};
var off = function(element, events2, filter, handler, useCapture) {
  removeEventListeners(element, events2, filter, handler, useCapture);
};
var removeEventListeners = function(element, events2, handler, useCapture) {
  var eventNames = isArray(events2) ? events2 : (events2 || "").split(" ");
  eventNames.forEach(function(eventName) {
    removeEventListener(element, eventName, handler, useCapture);
  });
};
var removeEventListener = function(element, event, handler, useCapture) {
  element.removeEventListener(event, handler, Boolean(useCapture));
};
var applyEventMap = function(events2) {
  var eventMap = getEventMap(navigator.userAgent);
  function queryEventMap(e) {
    return eventMap[e] || e;
  }
  var eventRegEx = /([^ ]+)/g;
  var appliedEvents = events2.replace(eventRegEx, queryEventMap);
  return appliedEvents;
};
var setDefaultEvents = function(type, events2) {
  var proto = type.prototype;
  if (proto.events) {
    events2.forEach(function(event) {
      if (proto.events.indexOf(event) < 0) {
        proto.events.push(event);
      }
    });
  } else {
    proto.events = events2;
  }
};
var wheelDeltaY = function(jQueryEvent) {
  var e = jQueryEvent.originalEvent || jQueryEvent;
  var deltaY = e.wheelDeltaY;
  var delta;
  if (e.wheelDelta) {
    if (deltaY === void 0 || deltaY) {
      delta = e.wheelDelta;
    }
  } else if (e.detail && e.axis === e.VERTICAL_AXIS) {
    delta = -e.detail * 10;
  }
  return delta;
};
var now2 = function() {
  return Number(new Date());
};
var noop = function() {
};

// node_modules/@progress/kendo-charts/dist/es/map/scroller/observable.js
var STRING2 = "string";
var FUNCTION = "function";
var preventDefault3 = function() {
  this._defaultPrevented = true;
};
var isDefaultPrevented2 = function() {
  return this._defaultPrevented === true;
};
var Observable2 = function(Class3) {
  function Observable3() {
    Class3.call(this);
    this._events = {};
  }
  if (Class3)
    Observable3.__proto__ = Class3;
  Observable3.prototype = Object.create(Class3 && Class3.prototype);
  Observable3.prototype.constructor = Observable3;
  Observable3.prototype.destroy = function destroy2() {
    this.unbind();
  };
  Observable3.prototype.bind = function bind(event, handlers, one) {
    var that = this, idx, eventNames = typeof event === STRING2 ? [event] : event || [], length, original, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    if (handlers === void 0) {
      for (idx in event) {
        that.bind(idx, event[idx]);
      }
      return that;
    }
    var loop = function() {
      var eventName = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName];
      if (handler) {
        if (one) {
          original = handler;
          handler = function() {
            that.unbind(eventName, handler);
            original.apply(that, arguments);
          };
          handler.original = original;
        }
        events2 = that._events[eventName] = that._events[eventName] || [];
        events2.push(handler);
      }
    };
    for (idx = 0, length = eventNames.length; idx < length; idx++)
      loop();
    return that;
  };
  Observable3.prototype.one = function one(eventNames, handlers) {
    return this.bind(eventNames, handlers, true);
  };
  Observable3.prototype.first = function first(eventName, handlers) {
    var that = this, idx, eventNames = typeof eventName === STRING2 ? [eventName] : eventName, length, handler, handlersIsFunction = typeof handlers === FUNCTION, events2;
    for (idx = 0, length = eventNames.length; idx < length; idx++) {
      var eventName$1 = eventNames[idx];
      handler = handlersIsFunction ? handlers : handlers[eventName$1];
      if (handler) {
        events2 = that._events[eventName$1] = that._events[eventName$1] || [];
        events2.unshift(handler);
      }
    }
    return that;
  };
  Observable3.prototype.trigger = function trigger2(eventName, eventArgs) {
    var that = this, events2 = that._events[eventName], idx, length;
    if (events2) {
      var e = eventArgs || {};
      e.sender = that;
      e._defaultPrevented = false;
      e.preventDefault = preventDefault3;
      e.isDefaultPrevented = isDefaultPrevented2;
      events2 = events2.slice();
      for (idx = 0, length = events2.length; idx < length; idx++) {
        events2[idx].call(that, e);
      }
      return e._defaultPrevented === true;
    }
    return false;
  };
  Observable3.prototype.unbind = function unbind(eventName, handler) {
    var that = this, events2 = that._events[eventName], idx;
    if (eventName === void 0) {
      that._events = {};
    } else if (events2) {
      if (handler) {
        for (idx = events2.length - 1; idx >= 0; idx--) {
          if (events2[idx] === handler || events2[idx].original === handler) {
            events2.splice(idx, 1);
          }
        }
      } else {
        that._events[eventName] = [];
      }
    }
    return that;
  };
  Observable3.prototype._setEvents = function _setEvents(options2) {
    var this$1 = this;
    var length = (this.events || []).length;
    for (var idx = 0; idx < length; idx++) {
      var e = this$1.events[idx];
      if (this$1.options[e] && options2[e]) {
        this$1.unbind(e, this$1.options[e]);
        if (this$1._events && this$1._events[e]) {
          delete this$1._events[e];
        }
      }
    }
    this.bind(this.events, options2);
  };
  return Observable3;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/attribution.js
var Attribution = function(Observable3) {
  function Attribution2(element, options2) {
    Observable3.call(this);
    this.element = element;
    this._initOptions(options2);
    this.items = [];
    addClass(this.element, "k-widget k-attribution");
  }
  if (Observable3)
    Attribution2.__proto__ = Observable3;
  Attribution2.prototype = Object.create(Observable3 && Observable3.prototype);
  Attribution2.prototype.constructor = Attribution2;
  Attribution2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Attribution2.prototype.filter = function filter(extent, zoom) {
    this._extent = extent;
    this._zoom = zoom;
    this._render();
  };
  Attribution2.prototype.add = function add3(item) {
    var newItem = item;
    if (defined2(item)) {
      if (typeof item === "string") {
        newItem = {
          text: item
        };
      }
      this.items.push(newItem);
      this._render();
    }
  };
  Attribution2.prototype.remove = function remove(text) {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      if (item.text !== text) {
        result.push(item);
      }
    }
    this.items = result;
    this._render();
  };
  Attribution2.prototype.clear = function clear4() {
    this.items = [];
    removeChildren(this.element);
  };
  Attribution2.prototype._render = function _render() {
    var this$1 = this;
    var result = [];
    for (var i = 0; i < this.items.length; i++) {
      var item = this$1.items[i];
      var text = this$1._itemText(item);
      if (text !== "") {
        result.push(text);
      }
    }
    if (result.length > 0) {
      removeChildren(this.element);
      var html = result.join(this.options.separator);
      appendHtml(html, this.element);
      this.showElement();
    } else {
      this.hideElement();
    }
  };
  Attribution2.prototype.hideElement = function hideElement() {
    this.element.style.display = "none";
  };
  Attribution2.prototype.showElement = function showElement() {
    this.element.style.display = "";
  };
  Attribution2.prototype._itemText = function _itemText(item) {
    var text = "";
    var inZoomLevel = this._inZoomLevel(item.minZoom, item.maxZoom);
    var inArea = this._inArea(item.extent);
    if (inZoomLevel && inArea) {
      text += item.text;
    }
    return text;
  };
  Attribution2.prototype._inZoomLevel = function _inZoomLevel(min3, max2) {
    var result = true;
    var newMin = valueOrDefault2(min3, -Number.MAX_VALUE);
    var newMax = valueOrDefault2(max2, Number.MAX_VALUE);
    result = this._zoom > newMin && this._zoom < newMax;
    return result;
  };
  Attribution2.prototype._inArea = function _inArea(area) {
    var result = true;
    if (area) {
      result = area.contains(this._extent);
    }
    return result;
  };
  return Attribution2;
}(Observable2);
setDefaultOptions(Attribution, {
  name: "Attribution",
  separator: "&nbsp;|&nbsp;"
});

// node_modules/@progress/kendo-charts/dist/es/map/navigator.js
var PAN = "pan";
var directionsMap = {
  up: {
    className: "k-navigator-n",
    iconClass: "k-i-caret-alt-up"
  },
  down: {
    className: "k-navigator-s",
    iconClass: "k-i-caret-alt-down"
  },
  right: {
    className: "k-navigator-e",
    iconClass: "k-i-caret-alt-right"
  },
  left: {
    className: "k-navigator-w",
    iconClass: "k-i-caret-alt-left"
  }
};
function createButton(direction) {
  var html = '<button class="k-button k-button-square k-rounded-full k-button-flat k-button-flat-base k-icon-button ' + directionsMap[direction].className + '" aria-label="move ' + direction + '"><span class="k-icon ' + directionsMap[direction].iconClass + '" /></button>';
  return convertToHtml(html);
}
var Navigator2 = function(Observable3) {
  function Navigator3(element, options2) {
    Observable3.call(this);
    this.element = element;
    this._initOptions(options2);
    var navigateUpButton = createButton("up");
    var navigateRightlButton = createButton("right");
    var navigateDownButton = createButton("down");
    var navigateLeftButton = createButton("left");
    this.element.appendChild(navigateUpButton);
    this.element.appendChild(navigateRightlButton);
    this.element.appendChild(navigateDownButton);
    this.element.appendChild(navigateLeftButton);
    addClass(this.element, "k-widget k-navigator");
    on(this.element, "click", ".k-button", proxy(this._click, this));
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = proxy(this._keydown, this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable3)
    Navigator3.__proto__ = Observable3;
  Navigator3.prototype = Object.create(Observable3 && Observable3.prototype);
  Navigator3.prototype.constructor = Navigator3;
  Navigator3.prototype.destroy = function destroy2() {
    this.dispose();
  };
  Navigator3.prototype.dispose = function dispose() {
    off(this._keyroot, "keydown", this._keydownHandler);
  };
  Navigator3.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  Navigator3.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Navigator3.prototype._pan = function _pan(x, y) {
    var panStep = this.options.panStep;
    this.trigger(PAN, {
      x: x * panStep,
      y: y * panStep
    });
  };
  Navigator3.prototype._click = function _click(e) {
    var x = 0;
    var y = 0;
    var button = e.currentTarget;
    if (button.matches(".k-navigator-n")) {
      y = 1;
    } else if (button.matches(".k-navigator-s")) {
      y = -1;
    } else if (button.matches(".k-navigator-e")) {
      x = 1;
    } else if (button.matches(".k-navigator-w")) {
      x = -1;
    }
    this._pan(x, y);
    e.preventDefault();
  };
  Navigator3.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.UP:
        this._pan(0, 1);
        e.preventDefault();
        break;
      case keys_default.DOWN:
        this._pan(0, -1);
        e.preventDefault();
        break;
      case keys_default.RIGHT:
        this._pan(1, 0);
        e.preventDefault();
        break;
      case keys_default.LEFT:
        this._pan(-1, 0);
        e.preventDefault();
        break;
      default:
        break;
    }
  };
  return Navigator3;
}(Observable2);
setDefaultOptions(Navigator2, {
  name: "Navigator",
  panStep: 1
});
setDefaultEvents(Navigator2, [
  PAN
]);

// node_modules/@progress/kendo-charts/dist/es/map/zoom.js
function createButton2(direction, iconClass) {
  var html = '<button class="k-button k-button-md k-rounded-md k-button-solid k-button-solid-base k-icon-button k-zoom-' + direction + '" title="zoom-' + direction + '" aria-label="zoom-' + direction + '"><span class="k-icon ' + iconClass + '"></span></button>';
  return convertToHtml(html);
}
var PLUS = 187;
var MINUS = 189;
var FF_PLUS = 61;
var FF_MINUS = 173;
var CHANGE = "change";
var ZoomControl = function(Observable3) {
  function ZoomControl2(element, options2) {
    Observable3.call(this);
    this.element = element;
    this._initOptions(options2);
    var zoomInButton = createButton2("in", "k-i-plus");
    var zoomOutButton = createButton2("out", "k-i-minus");
    this.element.appendChild(zoomInButton);
    this.element.appendChild(zoomOutButton);
    addClass(this.element, "k-widget k-zoom-control k-button-group k-group-horizontal");
    this._clickHandler = this._click.bind(this);
    on(this.element, "click", ".k-button", this._clickHandler);
    var parentElement = this.element.parentNode.closest("[data-role]");
    this._keyroot = parentElement ? parentElement : this.element;
    this._tabindex(this._keyroot);
    this._keydownHandler = this._keydown.bind(this);
    on(this._keyroot, "keydown", this._keydownHandler);
  }
  if (Observable3)
    ZoomControl2.__proto__ = Observable3;
  ZoomControl2.prototype = Object.create(Observable3 && Observable3.prototype);
  ZoomControl2.prototype.constructor = ZoomControl2;
  ZoomControl2.prototype.destroy = function destroy2() {
    if (this.element) {
      off(this.element, "click", this._clickHandler);
    }
    if (this._keyroot) {
      off(this._keyroot, "keydown", this._keydownHandler);
    }
  };
  ZoomControl2.prototype._tabindex = function _tabindex(target) {
    var targetElement = target || this.wrapper || this.element;
    var element = this.element, TABINDEX = "tabindex", tabindex = targetElement.getAttribute(TABINDEX) || element.getAttribute(TABINDEX);
    element.removeAttribute(TABINDEX);
    targetElement.setAttribute(TABINDEX, !isNaN(tabindex) ? tabindex : 0);
  };
  ZoomControl2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ZoomControl2.prototype._change = function _change(direction) {
    var zoomStep = this.options.zoomStep;
    this.trigger(CHANGE, { delta: direction * zoomStep });
  };
  ZoomControl2.prototype._click = function _click(e) {
    var button = e.currentTarget;
    var direction = 1;
    if (hasClasses(button, "k-zoom-out")) {
      direction = -1;
    }
    this._change(direction);
    e.preventDefault();
  };
  ZoomControl2.prototype._keydown = function _keydown(e) {
    switch (e.which) {
      case keys_default.NUMPAD_PLUS:
      case PLUS:
      case FF_PLUS:
        this._change(1);
        break;
      case keys_default.NUMPAD_MINUS:
      case MINUS:
      case FF_MINUS:
        this._change(-1);
        break;
      default:
        break;
    }
  };
  return ZoomControl2;
}(Observable2);
setDefaultOptions(ZoomControl, {
  name: "ZoomControl",
  zoomStep: 1
});
setDefaultEvents(ZoomControl, [
  CHANGE
]);

// node_modules/@progress/kendo-charts/dist/es/map/extent.js
var math3 = Math;
var max = math3.max;
var min = math3.min;
var Extent = function(Class3) {
  function Extent2(initialNw, initialSe) {
    Class3.call(this);
    var nw = Location.create(initialNw);
    var se = Location.create(initialSe);
    if (nw.lng + 180 > se.lng + 180 && nw.lat + 90 < se.lat + 90) {
      this.se = nw;
      this.nw = se;
    } else {
      this.se = se;
      this.nw = nw;
    }
  }
  if (Class3)
    Extent2.__proto__ = Class3;
  Extent2.prototype = Object.create(Class3 && Class3.prototype);
  Extent2.prototype.constructor = Extent2;
  var staticAccessors2 = { World: { configurable: true } };
  Extent2.prototype.contains = function contains2(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault2(loc.lng, loc[1]), lat = valueOrDefault2(loc.lat, loc[0]);
    return loc && lng + 180 >= nw.lng + 180 && lng + 180 <= se.lng + 180 && lat + 90 >= se.lat + 90 && lat + 90 <= nw.lat + 90;
  };
  Extent2.prototype.center = function center() {
    var nw = this.nw;
    var se = this.se;
    var lng = nw.lng + (se.lng - nw.lng) / 2;
    var lat = nw.lat + (se.lat - nw.lat) / 2;
    return new Location(lat, lng);
  };
  Extent2.prototype.containsAny = function containsAny(locs) {
    var this$1 = this;
    var result = false;
    for (var i = 0; i < locs.length; i++) {
      result = result || this$1.contains(locs[i]);
    }
    return result;
  };
  Extent2.prototype.include = function include(loc) {
    var nw = this.nw, se = this.se, lng = valueOrDefault2(loc.lng, loc[1]), lat = valueOrDefault2(loc.lat, loc[0]);
    nw.lng = min(nw.lng, lng);
    nw.lat = max(nw.lat, lat);
    se.lng = max(se.lng, lng);
    se.lat = min(se.lat, lat);
  };
  Extent2.prototype.includeAll = function includeAll(locs) {
    var this$1 = this;
    for (var i = 0; i < locs.length; i++) {
      this$1.include(locs[i]);
    }
  };
  Extent2.prototype.edges = function edges() {
    var nw = this.nw, se = this.se;
    return {
      nw: this.nw,
      ne: new Location(nw.lat, se.lng),
      se: this.se,
      sw: new Location(se.lat, nw.lng)
    };
  };
  Extent2.prototype.toArray = function toArray() {
    var nw = this.nw, se = this.se;
    return [
      nw,
      new Location(nw.lat, se.lng),
      se,
      new Location(se.lat, nw.lng)
    ];
  };
  Extent2.prototype.overlaps = function overlaps(extent) {
    return this.containsAny(extent.toArray()) || extent.containsAny(this.toArray());
  };
  Extent2.create = function create2(a, b) {
    if (a instanceof Extent2) {
      return a;
    } else if (a && b) {
      return new Extent2(a, b);
    } else if (a && a.length === 4 && !b) {
      return new Extent2([
        a[0],
        a[1]
      ], [
        a[2],
        a[3]
      ]);
    }
  };
  staticAccessors2.World.get = function() {
    return new Extent2([90, -180], [-90, 180]);
  };
  Object.defineProperties(Extent2, staticAccessors2);
  return Extent2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/constants.js
var SHOW_TOOLTIP2 = "showTooltip";
var HIDE_TOOLTIP2 = "hideTooltip";
var CENTER_CHANGE = "centerChange";
var ZOOM_CHANGE = "zoomChange";
var INIT = "init";

// node_modules/@progress/kendo-charts/dist/es/map/tooltip/tooltip.js
var Tooltip2 = function(Class3) {
  function Tooltip3(widgetService, options2) {
    Class3.call(this);
    this.widgetService = widgetService;
    this.options = deepExtend({}, this.options, options2);
    this.offset = { x: 0, y: 0 };
  }
  if (Class3)
    Tooltip3.__proto__ = Class3;
  Tooltip3.prototype = Object.create(Class3 && Class3.prototype);
  Tooltip3.prototype.constructor = Tooltip3;
  var prototypeAccessors4 = { anchor: { configurable: true } };
  Tooltip3.prototype.show = function show2(anchor, args) {
    if (this.location === args.location) {
      return;
    }
    this.anchor = anchor;
    this.location = args.location;
    this.widgetService.notify(
      SHOW_TOOLTIP2,
      Object.assign({ anchor: this.anchor }, args)
    );
    this.visible = true;
  };
  Tooltip3.prototype.hide = function hide2() {
    if (this.widgetService) {
      this.widgetService.notify(HIDE_TOOLTIP2);
    }
    this.visible = false;
    this.location = null;
  };
  prototypeAccessors4.anchor.get = function() {
    return this._anchor;
  };
  prototypeAccessors4.anchor.set = function(anchor) {
    var documentPoint = this.widgetService.widget._toDocumentCoordinates({
      x: anchor.left - this.offset.x,
      y: anchor.top - this.offset.y
    });
    this._anchor = {
      left: documentPoint.left,
      top: documentPoint.top
    };
  };
  Tooltip3.prototype.destroy = function destroy2() {
    this.widgetService = null;
  };
  Object.defineProperties(Tooltip3.prototype, prototypeAccessors4);
  return Tooltip3;
}(class_default);
setDefaultOptions(Tooltip2, {
  border: {
    width: 1
  },
  opacity: 1
});

// node_modules/@progress/kendo-charts/dist/es/map/layers/layer.js
var Layer = function(Class3) {
  function Layer2(map2, options2) {
    Class3.call(this);
    this.support = getSupportedFeatures();
    this._initOptions(options2);
    this.map = map2;
    var element = document.createElement("div");
    addClass(element, "k-layer");
    element.style.zIndex = this.options.zIndex;
    element.style.opacity = this.options.opacity;
    this.element = element;
    map2.scrollElement.appendChild(this.element);
    this._beforeReset = this._beforeReset.bind(this);
    this._reset = this._reset.bind(this);
    this._resize = this._resize.bind(this);
    this._panEnd = this._panEnd.bind(this);
    this._activate();
    this._updateAttribution();
  }
  if (Class3)
    Layer2.__proto__ = Class3;
  Layer2.prototype = Object.create(Class3 && Class3.prototype);
  Layer2.prototype.constructor = Layer2;
  Layer2.prototype.destroy = function destroy2() {
    this._deactivate();
  };
  Layer2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Layer2.prototype.show = function show2() {
    this.reset();
    this._activate();
    this._applyExtent(true);
  };
  Layer2.prototype.hide = function hide2() {
    this._deactivate();
    this._setVisibility(false);
  };
  Layer2.prototype.reset = function reset() {
    this._beforeReset();
    this._reset();
  };
  Layer2.prototype._reset = function _reset() {
    this._applyExtent();
  };
  Layer2.prototype._beforeReset = function _beforeReset() {
  };
  Layer2.prototype._resize = function _resize() {
  };
  Layer2.prototype._panEnd = function _panEnd() {
    this._applyExtent();
  };
  Layer2.prototype._applyExtent = function _applyExtent() {
    var options2 = this.options;
    var zoom = this.map.zoom();
    var matchMinZoom = !defined2(options2.minZoom) || zoom >= options2.minZoom;
    var matchMaxZoom = !defined2(options2.maxZoom) || zoom <= options2.maxZoom;
    var extent = Extent.create(options2.extent);
    var inside = !extent || extent.overlaps(this.map.extent());
    this._setVisibility(matchMinZoom && matchMaxZoom && inside);
  };
  Layer2.prototype._setVisibility = function _setVisibility(visible) {
    this.element.style.display = visible ? "" : "none";
  };
  Layer2.prototype._activate = function _activate() {
    var map2 = this.map;
    this._deactivate();
    map2.bind("beforeReset", this._beforeReset);
    map2.bind("reset", this._reset);
    map2.bind("resize", this._resize);
    map2.bind("panEnd", this._panEnd);
  };
  Layer2.prototype._deactivate = function _deactivate() {
    var map2 = this.map;
    map2.unbind("beforeReset", this._beforeReset);
    map2.unbind("reset", this._reset);
    map2.unbind("resize", this._resize);
    map2.unbind("panEnd", this._panEnd);
  };
  Layer2.prototype._updateAttribution = function _updateAttribution() {
    var attribution = this.map.attribution;
    if (attribution) {
      attribution.add(this.options.attribution);
    }
  };
  Layer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  Layer2.prototype._hasData = function _hasData() {
    return this._data && this._data.length > 0;
  };
  Layer2.prototype._layerIndex = function _layerIndex() {
    var layers = this.map.layers || [];
    return layers.indexOf(this);
  };
  return Layer2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/tile.js
var math4 = Math;
var Point6 = geometry_exports.Point;
function compileTemplate(template3) {
  if (isFunction3(template3)) {
    return template3;
  }
  return template_service_default.compile(template3);
}
function roundPoint(point2) {
  return new Point6(round3(point2.x), round3(point2.y));
}
function renderSize(size) {
  var newSize = size;
  if (typeof size !== "string") {
    newSize += "px";
  }
  return newSize;
}
var TileLayer = function(Layer2) {
  function TileLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    if (typeof this.options.subdomains === "string") {
      this.options.subdomains = this.options.subdomains.split("");
    }
    var viewType = this._viewType();
    this._view = new viewType(this.element, this.options);
  }
  if (Layer2)
    TileLayer2.__proto__ = Layer2;
  TileLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  TileLayer2.prototype.constructor = TileLayer2;
  TileLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this._view.destroy();
    this._view = null;
  };
  TileLayer2.prototype._beforeReset = function _beforeReset() {
    var map2 = this.map;
    var origin = map2.locationToLayer(map2.extent().nw).round();
    this._view.viewOrigin(origin);
  };
  TileLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._updateView();
    this._view.reset();
  };
  TileLayer2.prototype._viewType = function _viewType() {
    return TileView;
  };
  TileLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    if (!this.support.mobileOS) {
      if (!this._pan) {
        this._pan = throttle(this._render.bind(this), 100);
      }
      this.map.bind("pan", this._pan);
    }
  };
  TileLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    if (this._pan) {
      this.map.unbind("pan", this._pan);
    }
  };
  TileLayer2.prototype._updateView = function _updateView() {
    var view = this._view, map2 = this.map, extent = map2.extent(), extentToPoint = {
      nw: map2.locationToLayer(extent.nw).round(),
      se: map2.locationToLayer(extent.se).round()
    };
    view.center(map2.locationToLayer(map2.center()));
    view.extent(extentToPoint);
    view.zoom(map2.zoom());
  };
  TileLayer2.prototype._resize = function _resize() {
    this._render();
  };
  TileLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._render();
  };
  TileLayer2.prototype._render = function _render() {
    this._updateView();
    this._view.render();
  };
  return TileLayer2;
}(Layer);
setDefaultOptions(TileLayer, {
  tileSize: 256,
  subdomains: ["a", "b", "c"],
  urlTemplate: "",
  zIndex: 1
});
var TileView = function(Class3) {
  function TileView2(element, options2) {
    Class3.call(this);
    this.element = element;
    this._initOptions(options2);
    this.pool = new TilePool();
  }
  if (Class3)
    TileView2.__proto__ = Class3;
  TileView2.prototype = Object.create(Class3 && Class3.prototype);
  TileView2.prototype.constructor = TileView2;
  TileView2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  TileView2.prototype.center = function center(center$1) {
    this._center = center$1;
  };
  TileView2.prototype.extent = function extent(extent$1) {
    this._extent = extent$1;
  };
  TileView2.prototype.viewOrigin = function viewOrigin(origin) {
    this._viewOrigin = origin;
  };
  TileView2.prototype.zoom = function zoom(zoom$1) {
    this._zoom = zoom$1;
  };
  TileView2.prototype.pointToTileIndex = function pointToTileIndex(point2) {
    return new Point6(math4.floor(point2.x / this.options.tileSize), math4.floor(point2.y / this.options.tileSize));
  };
  TileView2.prototype.tileCount = function tileCount() {
    var size = this.size(), firstTileIndex = this.pointToTileIndex(this._extent.nw), nw = this._extent.nw, point2 = this.indexToPoint(firstTileIndex).translate(-nw.x, -nw.y);
    return {
      x: math4.ceil((math4.abs(point2.x) + size.width) / this.options.tileSize),
      y: math4.ceil((math4.abs(point2.y) + size.height) / this.options.tileSize)
    };
  };
  TileView2.prototype.size = function size() {
    var nw = this._extent.nw, se = this._extent.se, diff = se.clone().translate(-nw.x, -nw.y);
    return {
      width: diff.x,
      height: diff.y
    };
  };
  TileView2.prototype.indexToPoint = function indexToPoint(index) {
    var x = index.x, y = index.y;
    return new Point6(x * this.options.tileSize, y * this.options.tileSize);
  };
  TileView2.prototype.subdomainText = function subdomainText() {
    var subdomains = this.options.subdomains;
    return subdomains[this.subdomainIndex++ % subdomains.length];
  };
  TileView2.prototype.destroy = function destroy2() {
    removeChildren(this.element);
    this.pool.empty();
  };
  TileView2.prototype.reset = function reset() {
    this.pool.reset();
    this.subdomainIndex = 0;
    this.render();
  };
  TileView2.prototype.render = function render3() {
    var this$1 = this;
    var size = this.tileCount(), firstTileIndex = this.pointToTileIndex(this._extent.nw), tile, x, y;
    for (x = 0; x < size.x; x++) {
      for (y = 0; y < size.y; y++) {
        tile = this$1.createTile({
          x: firstTileIndex.x + x,
          y: firstTileIndex.y + y
        });
        if (!tile.visible) {
          tile.show();
        }
      }
    }
  };
  TileView2.prototype.createTile = function createTile(currentIndex) {
    var options2 = this.tileOptions(currentIndex);
    var tile = this.pool.get(this._center, options2);
    if (!tile.element.parentNode) {
      this.element.append(tile.element);
    }
    return tile;
  };
  TileView2.prototype.tileOptions = function tileOptions(currentIndex) {
    var index = this.wrapIndex(currentIndex), point2 = this.indexToPoint(currentIndex), origin = this._viewOrigin, offset = point2.clone().translate(-origin.x, -origin.y);
    return {
      index,
      currentIndex,
      point: point2,
      offset: roundPoint(offset),
      zoom: this._zoom,
      size: this.options.tileSize,
      subdomain: this.subdomainText(),
      urlTemplate: this.options.urlTemplate,
      errorUrlTemplate: this.options.errorUrlTemplate
    };
  };
  TileView2.prototype.wrapIndex = function wrapIndex(index) {
    var boundary = math4.pow(2, this._zoom);
    return {
      x: this.wrapValue(index.x, boundary),
      y: limitValue2(index.y, 0, boundary - 1)
    };
  };
  TileView2.prototype.wrapValue = function wrapValue(value, boundary) {
    var remainder = math4.abs(value) % boundary;
    var wrappedValue = value;
    if (value >= 0) {
      wrappedValue = remainder;
    } else {
      wrappedValue = boundary - (remainder === 0 ? boundary : remainder);
    }
    return wrappedValue;
  };
  return TileView2;
}(class_default);
var ImageTile = function(Class3) {
  function ImageTile2(id, options2) {
    Class3.call(this);
    this.id = id;
    this.visible = true;
    this._initOptions(options2);
    this.createElement();
    this.show();
  }
  if (Class3)
    ImageTile2.__proto__ = Class3;
  ImageTile2.prototype = Object.create(Class3 && Class3.prototype);
  ImageTile2.prototype.constructor = ImageTile2;
  ImageTile2.prototype.destroy = function destroy2() {
    var element = this.element;
    var parentNode = element ? element.parentNode : null;
    if (element) {
      if (parentNode) {
        parentNode.removeChild(element);
      }
      this.element = null;
    }
  };
  ImageTile2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  ImageTile2.prototype.createElement = function createElement15() {
    var el = document.createElement("img");
    var size = this.options.size + "px";
    el.style.position = "absolute";
    el.style.display = "block";
    el.style.width = el.style.maxWidth = size;
    el.style.height = el.style.maxHeight = size;
    this.element = el;
  };
  ImageTile2.prototype.show = function show2() {
    var element = this.element;
    element.style.top = renderSize(this.options.offset.y);
    element.style.left = renderSize(this.options.offset.x);
    var url = this.url();
    if (url) {
      element.setAttribute("src", url);
    }
    element.style.visibility = "visible";
    this.visible = true;
  };
  ImageTile2.prototype.hide = function hide2() {
    this.element.style.visibility = "hidden";
    this.visible = false;
  };
  ImageTile2.prototype.url = function url() {
    var urlResult = compileTemplate(this.options.urlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.errorUrl = function errorUrl() {
    var urlResult = compileTemplate(this.options.errorUrlTemplate);
    return urlResult(this.urlOptions());
  };
  ImageTile2.prototype.urlOptions = function urlOptions() {
    var options2 = this.options;
    return {
      zoom: options2.zoom,
      subdomain: options2.subdomain,
      z: options2.zoom,
      x: options2.index.x,
      y: options2.index.y,
      s: options2.subdomain,
      quadkey: options2.quadkey,
      q: options2.quadkey,
      culture: options2.culture,
      c: options2.culture
    };
  };
  return ImageTile2;
}(class_default);
setDefaultOptions(ImageTile, {
  urlTemplate: "",
  errorUrlTemplate: ""
});
var TilePool = function(Class3) {
  function TilePool2() {
    Class3.call(this);
    this._items = [];
  }
  if (Class3)
    TilePool2.__proto__ = Class3;
  TilePool2.prototype = Object.create(Class3 && Class3.prototype);
  TilePool2.prototype.constructor = TilePool2;
  TilePool2.prototype.get = function get2(center, options2) {
    if (this._items.length >= this.options.maxSize) {
      this._remove(center);
    }
    return this._create(options2);
  };
  TilePool2.prototype.empty = function empty() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].destroy();
    }
    this._items = [];
  };
  TilePool2.prototype.reset = function reset() {
    var items = this._items;
    for (var i = 0; i < items.length; i++) {
      items[i].hide();
    }
  };
  TilePool2.prototype._create = function _create(options2) {
    var items = this._items;
    var tile;
    var id = hashKey2(options2.point.toString() + options2.offset.toString() + options2.zoom + options2.urlTemplate);
    for (var i = 0; i < items.length; i++) {
      if (items[i].id === id) {
        tile = items[i];
        break;
      }
    }
    if (tile) {
      tile.show();
    } else {
      tile = new ImageTile(id, options2);
      this._items.push(tile);
    }
    return tile;
  };
  TilePool2.prototype._remove = function _remove(center) {
    var items = this._items;
    var maxDist = -1;
    var index = -1;
    for (var i = 0; i < items.length; i++) {
      var dist = items[i].options.point.distanceTo(center);
      if (dist > maxDist && !items[i].visible) {
        index = i;
        maxDist = dist;
      }
    }
    if (index !== -1) {
      items[index].destroy();
      items.splice(index, 1);
    }
  };
  return TilePool2;
}(class_default);
setDefaultOptions(TilePool, {
  maxSize: 100
});

// node_modules/@progress/kendo-charts/dist/es/map/scroller/draggable.js
var extend10 = Object.assign;
var CHANGE2 = "change";
var TapCapture = function(Observable3) {
  function TapCapture2(element, options2) {
    Observable3.call(this);
    var that = this, domElement = element[0] || element;
    that.capture = false;
    var eventMap = getEventMap(navigator.userAgent);
    if (domElement.addEventListener) {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._press, that), true);
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.addEventListener(event, proxy(that._release, that), true);
      });
    } else {
      eventMap.down.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._press, that));
      });
      eventMap.up.split(" ").forEach(function(event) {
        domElement.attachEvent(event, proxy(that._release, that));
      });
    }
    that.bind([
      "press",
      "release"
    ], options2 || {});
  }
  if (Observable3)
    TapCapture2.__proto__ = Observable3;
  TapCapture2.prototype = Object.create(Observable3 && Observable3.prototype);
  TapCapture2.prototype.constructor = TapCapture2;
  TapCapture2.prototype.captureNext = function captureNext() {
    this.capture = true;
  };
  TapCapture2.prototype.cancelCapture = function cancelCapture() {
    this.capture = false;
  };
  TapCapture2.prototype._press = function _press(e) {
    var that = this;
    that.trigger("press");
    if (that.capture) {
      e.preventDefault();
    }
  };
  TapCapture2.prototype._release = function _release(e) {
    var that = this;
    that.trigger("release");
    if (that.capture) {
      e.preventDefault();
      that.cancelCapture();
    }
  };
  return TapCapture2;
}(Observable2);
var PaneDimension = function(Observable3) {
  function PaneDimension2(options2) {
    Observable3.call(this);
    var that = this;
    that.forcedEnabled = false;
    extend10(that, options2);
    that.scale = 1;
    if (that.horizontal) {
      that.measure = "offsetWidth";
      that.scrollSize = "scrollWidth";
      that.axis = "x";
    } else {
      that.measure = "offsetHeight";
      that.scrollSize = "scrollHeight";
      that.axis = "y";
    }
  }
  if (Observable3)
    PaneDimension2.__proto__ = Observable3;
  PaneDimension2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneDimension2.prototype.constructor = PaneDimension2;
  PaneDimension2.prototype.makeVirtual = function makeVirtual() {
    extend10(this, {
      virtual: true,
      forcedEnabled: true,
      _virtualMin: 0,
      _virtualMax: 0
    });
  };
  PaneDimension2.prototype.virtualSize = function virtualSize(min3, max2) {
    if (this._virtualMin !== min3 || this._virtualMax !== max2) {
      this._virtualMin = min3;
      this._virtualMax = max2;
      this.update();
    }
  };
  PaneDimension2.prototype.outOfBounds = function outOfBounds(offset) {
    return offset > this.max || offset < this.min;
  };
  PaneDimension2.prototype.forceEnabled = function forceEnabled() {
    this.forcedEnabled = true;
  };
  PaneDimension2.prototype.getSize = function getSize() {
    return this.container[this.measure];
  };
  PaneDimension2.prototype.getTotal = function getTotal() {
    return this.element[this.scrollSize];
  };
  PaneDimension2.prototype.rescale = function rescale(scale) {
    this.scale = scale;
  };
  PaneDimension2.prototype.update = function update(silent) {
    var that = this, total3 = that.virtual ? that._virtualMax : that.getTotal(), scaledTotal = total3 * that.scale, size = that.getSize();
    if (total3 === 0 && !that.forcedEnabled) {
      return;
    }
    that.max = that.virtual ? -that._virtualMin : 0;
    that.size = size;
    that.total = scaledTotal;
    that.min = Math.min(that.max, size - scaledTotal);
    that.minScale = size / total3;
    that.centerOffset = (scaledTotal - size) / 2;
    that.enabled = that.forcedEnabled || scaledTotal > size;
    if (!silent) {
      that.trigger(CHANGE2, that);
    }
  };
  return PaneDimension2;
}(Observable2);
var PaneDimensions = function(Observable3) {
  function PaneDimensions2(options2) {
    Observable3.call(this);
    var that = this;
    that.x = new PaneDimension(extend10({
      horizontal: true
    }, options2));
    that.y = new PaneDimension(extend10({
      horizontal: false
    }, options2));
    that.container = options2.container;
    that.forcedMinScale = options2.minScale;
    that.maxScale = options2.maxScale || 100;
    that.bind(CHANGE2, options2);
  }
  if (Observable3)
    PaneDimensions2.__proto__ = Observable3;
  PaneDimensions2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneDimensions2.prototype.constructor = PaneDimensions2;
  PaneDimensions2.prototype.rescale = function rescale(newScale) {
    this.x.rescale(newScale);
    this.y.rescale(newScale);
    this.refresh();
  };
  PaneDimensions2.prototype.centerCoordinates = function centerCoordinates() {
    return {
      x: Math.min(0, -this.x.centerOffset),
      y: Math.min(0, -this.y.centerOffset)
    };
  };
  PaneDimensions2.prototype.refresh = function refresh() {
    var that = this;
    that.x.update();
    that.y.update();
    that.enabled = that.x.enabled || that.y.enabled;
    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);
    that.fitScale = Math.max(that.x.minScale, that.y.minScale);
    that.trigger(CHANGE2);
  };
  return PaneDimensions2;
}(Observable2);
var PaneAxis = function(Observable3) {
  function PaneAxis2(options2) {
    Observable3.call(this);
    extend10(this, options2);
  }
  if (Observable3)
    PaneAxis2.__proto__ = Observable3;
  PaneAxis2.prototype = Object.create(Observable3 && Observable3.prototype);
  PaneAxis2.prototype.constructor = PaneAxis2;
  PaneAxis2.prototype.outOfBounds = function outOfBounds() {
    return this.dimension.outOfBounds(this.movable[this.axis]);
  };
  PaneAxis2.prototype.dragMove = function dragMove(delta) {
    var that = this, dimension = that.dimension, axis = that.axis, movable = that.movable, position = movable[axis] + delta;
    if (!dimension.enabled) {
      return;
    }
    var dragDelta = delta;
    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {
      dragDelta *= that.resistance;
    }
    movable.translateAxis(axis, dragDelta);
    that.trigger(CHANGE2, that);
  };
  return PaneAxis2;
}(Observable2);
var Pane2 = function(Class3) {
  function Pane3(options2) {
    Class3.call(this);
    var that = this, x, y, resistance, movable;
    extend10(that, {
      elastic: true
    }, options2);
    resistance = that.elastic ? 0.5 : 0;
    movable = that.movable;
    that.x = x = new PaneAxis({
      axis: "x",
      dimension: that.dimensions.x,
      resistance,
      movable
    });
    that.y = y = new PaneAxis({
      axis: "y",
      dimension: that.dimensions.y,
      resistance,
      movable
    });
    that.userEvents.bind([
      "press",
      "move",
      "end",
      "gesturestart",
      "gesturechange"
    ], {
      gesturestart: function gesturestart(e) {
        that.gesture = e;
        that.offset = elementOffset2(that.dimensions.container);
      },
      press: function press(e) {
        var closestAnchor = e.event.target.closest("a");
        if (closestAnchor && closestAnchor.matches("[data-navigate-on-press=true]")) {
          e.sender.cancel();
        }
      },
      gesturechange: function gesturechange(e) {
        var previousGesture = that.gesture, previousCenter = previousGesture.center, center = e.center, scaleDelta = e.distance / previousGesture.distance, minScale = that.dimensions.minScale, maxScale = that.dimensions.maxScale, coordinates;
        if (movable.scale <= minScale && scaleDelta < 1) {
          scaleDelta += (1 - scaleDelta) * 0.8;
        }
        if (movable.scale * scaleDelta >= maxScale) {
          scaleDelta = maxScale / movable.scale;
        }
        var offsetX = movable.x + that.offset.left, offsetY = movable.y + that.offset.top;
        coordinates = {
          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,
          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY
        };
        movable.scaleWith(scaleDelta);
        x.dragMove(coordinates.x);
        y.dragMove(coordinates.y);
        that.dimensions.rescale(movable.scale);
        that.gesture = e;
        e.preventDefault();
      },
      move: function move(e) {
        if (e.event.target.tagName.match(/textarea|input/i)) {
          return;
        }
        if (x.dimension.enabled || y.dimension.enabled) {
          x.dragMove(e.x.delta);
          y.dragMove(e.y.delta);
          e.preventDefault();
        } else {
          e.touch.skip();
        }
      },
      end: function end(e) {
        e.preventDefault();
      }
    });
  }
  if (Class3)
    Pane3.__proto__ = Class3;
  Pane3.prototype = Object.create(Class3 && Class3.prototype);
  Pane3.prototype.constructor = Pane3;
  return Pane3;
}(class_default);
var translate = function(x, y, scale) {
  return "translate3d(" + x + "px," + y + "px,0) scale(" + scale + ")";
};
var Movable = function(Observable3) {
  function Movable2(element) {
    Observable3.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    this.transformStyle = this.support.transitions.prefix + "Transform";
    that.element = element;
    that.element.style.webkitTransformOrigin = "left top";
    that.x = 0;
    that.y = 0;
    that.scale = 1;
    var coordinates = translate(that.x, that.y, that.scale);
    that.element.style[this.transformStyle] = coordinates;
    that._saveCoordinates(coordinates);
  }
  if (Observable3)
    Movable2.__proto__ = Observable3;
  Movable2.prototype = Object.create(Observable3 && Observable3.prototype);
  Movable2.prototype.constructor = Movable2;
  Movable2.prototype.translateAxis = function translateAxis(axis, by) {
    this[axis] += by;
    this.refresh();
  };
  Movable2.prototype.scaleTo = function scaleTo(scale) {
    this.scale = scale;
    this.refresh();
  };
  Movable2.prototype.scaleWith = function scaleWith(scaleDelta) {
    this.scale *= scaleDelta;
    this.refresh();
  };
  Movable2.prototype.translate = function translate2(coordinates) {
    this.x += coordinates.x;
    this.y += coordinates.y;
    this.refresh();
  };
  Movable2.prototype.moveAxis = function moveAxis(axis, value) {
    this[axis] = value;
    this.refresh();
  };
  Movable2.prototype.moveTo = function moveTo(coordinates) {
    extend10(this, coordinates);
    this.refresh();
  };
  Movable2.prototype.refresh = function refresh() {
    var that = this, x = that.x, y = that.y, newCoordinates;
    if (that.round) {
      x = Math.round(x);
      y = Math.round(y);
    }
    newCoordinates = translate(x, y, that.scale);
    if (newCoordinates !== that.coordinates) {
      that.element.style[this.transformStyle] = newCoordinates;
      that._saveCoordinates(newCoordinates);
      that.trigger(CHANGE2);
    }
  };
  Movable2.prototype._saveCoordinates = function _saveCoordinates(coordinates) {
    this.coordinates = coordinates;
  };
  return Movable2;
}(Observable2);

// node_modules/@progress/kendo-charts/dist/es/map/layers/shape.js
var Group9 = drawing_exports.Group;
var ShapeLayer = function(Layer2) {
  function ShapeLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    this._pan = proxy(this._pan, this);
    this.surface = drawing_exports.Surface.create(this.element, {
      width: map2.scrollElement.clientWidth,
      height: map2.scrollElement.clientHeight
    });
    this._initRoot();
    this.movable = new Movable(this.surface.element);
    this._markers = [];
    this._click = this._handler("shapeClick");
    this.surface.bind("click", this._click);
    this._mouseleave = this._handler("shapeMouseLeave");
    this.surface.bind("mouseleave", this._mouseleave);
    this.surface.bind("mouseenter", this._mouseenter.bind(this));
  }
  if (Layer2)
    ShapeLayer2.__proto__ = Layer2;
  ShapeLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  ShapeLayer2.prototype.constructor = ShapeLayer2;
  ShapeLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    this.surface.destroy();
  };
  ShapeLayer2.prototype._reset = function _reset() {
    Layer2.prototype._reset.call(this);
    this._translateSurface();
    this._data = this._readData();
    if (this._hasData()) {
      this._load(this._data);
    }
  };
  ShapeLayer2.prototype._initRoot = function _initRoot() {
    this._root = new Group9();
    this.surface.draw(this._root);
  };
  ShapeLayer2.prototype._beforeReset = function _beforeReset() {
    this.surface.clear();
    this._initRoot();
  };
  ShapeLayer2.prototype._resize = function _resize() {
    this.surface.size(this.map.size());
  };
  ShapeLayer2.prototype._readData = function _readData() {
    var data = Layer2.prototype._readData.call(this);
    if (data.type === "FeatureCollection") {
      return data.features;
    }
    if (data.type === "GeometryCollection") {
      return data.geometries;
    }
    return data;
  };
  ShapeLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this._clearMarkers();
    if (!this._loader) {
      this._loader = new GeoJsonLoader(this.map, this.options.style, this);
    }
    var container = new Group9();
    for (var i = 0; i < data.length; i++) {
      var shape2 = this$1._loader.parse(data[i]);
      if (shape2) {
        container.append(shape2);
      }
    }
    this._root.clear();
    this._root.append(container);
  };
  ShapeLayer2.prototype.shapeCreated = function shapeCreated(shape2) {
    var cancelled = false;
    if (shape2 instanceof drawing_exports.Circle && this.map.options.renderPointsAsMarkers) {
      cancelled = defined2(this._createMarker(shape2));
    }
    if (!cancelled) {
      var args = {
        layer: this,
        shape: shape2
      };
      cancelled = this.map.trigger("shapeCreated", args);
    }
    return cancelled;
  };
  ShapeLayer2.prototype.featureCreated = function featureCreated(e) {
    e.layer = this;
    this.map.trigger("shapeFeatureCreated", e);
  };
  ShapeLayer2.prototype._createMarker = function _createMarker(shape2) {
    var marker = this.map.markers.bind({
      location: shape2.location
    }, shape2.dataItem);
    if (marker) {
      this._markers.push(marker);
    }
    return marker;
  };
  ShapeLayer2.prototype._clearMarkers = function _clearMarkers() {
    var this$1 = this;
    for (var i = 0; i < this._markers.length; i++) {
      this$1.map.markers.remove(this$1._markers[i]);
    }
    this._markers = [];
  };
  ShapeLayer2.prototype._pan = function _pan() {
    if (!this._panning) {
      this._panning = true;
      this.surface.suspendTracking();
    }
  };
  ShapeLayer2.prototype._panEnd = function _panEnd(e) {
    Layer2.prototype._panEnd.call(this, e);
    this._translateSurface();
    this.surface.resumeTracking();
    this._panning = false;
  };
  ShapeLayer2.prototype._translateSurface = function _translateSurface() {
    var map2 = this.map;
    var nw = map2.locationToView(map2.extent().nw);
    if (this.surface.translate) {
      this.surface.translate(nw);
      this.movable.moveTo({
        x: nw.x,
        y: nw.y
      });
    }
  };
  ShapeLayer2.prototype._eventArgs = function _eventArgs(e) {
    return {
      layer: this,
      layerIndex: this._layerIndex(),
      shape: e.element,
      shapeIndex: (this._data || []).indexOf(e.element.dataItem),
      originalEvent: e.originalEvent
    };
  };
  ShapeLayer2.prototype._handler = function _handler(eventName) {
    var this$1 = this;
    return function(e) {
      if (e.element) {
        this$1.map.trigger(eventName, this$1._eventArgs(e));
      }
    };
  };
  ShapeLayer2.prototype._mouseenter = function _mouseenter2(e) {
    if (!e.element) {
      return;
    }
    this.map.trigger("shapeMouseEnter", this._eventArgs(e));
    var shape2 = e.element;
    var anchor = this._tooltipAnchor(e);
    this.map._tooltip.show(anchor, this._tooltipContext(shape2));
  };
  ShapeLayer2.prototype._tooltipContext = function _tooltipContext(shape2) {
    return {
      type: "shape",
      layerIndex: this._layerIndex(),
      className: "k-map-shape-tooltip",
      dataItem: shape2.dataItem,
      location: shape2.location
    };
  };
  ShapeLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var cursor = this.map.eventOffset(e.originalEvent);
    return {
      top: cursor.y,
      left: cursor.x
    };
  };
  ShapeLayer2.prototype._activate = function _activate() {
    Layer2.prototype._activate.call(this);
    this._panHandler = proxy(this._pan, this);
    this.map.bind("pan", this.panHandler);
  };
  ShapeLayer2.prototype._deactivate = function _deactivate() {
    Layer2.prototype._deactivate.call(this);
    this.map.unbind("pan", this._panHandler);
  };
  return ShapeLayer2;
}(Layer);
setDefaultOptions(ShapeLayer, {
  autoBind: true,
  zIndex: 100
});
var GeoJsonLoader = function(Class3) {
  function GeoJsonLoader2(locator, defaultStyle, observer) {
    Class3.call(this);
    this.observer = observer;
    this.locator = locator;
    this.style = defaultStyle;
  }
  if (Class3)
    GeoJsonLoader2.__proto__ = Class3;
  GeoJsonLoader2.prototype = Object.create(Class3 && Class3.prototype);
  GeoJsonLoader2.prototype.constructor = GeoJsonLoader2;
  GeoJsonLoader2.prototype.parse = function parse3(item) {
    var root = new Group9();
    var unwrap = true;
    if (item.type === "Feature") {
      unwrap = false;
      this._loadGeometryTo(root, item.geometry, item);
      this._featureCreated(root, item);
    } else {
      this._loadGeometryTo(root, item, item);
    }
    if (unwrap && root.children.length < 2) {
      root = root.children[0];
    }
    return root;
  };
  GeoJsonLoader2.prototype._shapeCreated = function _shapeCreated(shape2) {
    var cancelled = false;
    if (this.observer && this.observer.shapeCreated) {
      cancelled = this.observer.shapeCreated(shape2);
    }
    return cancelled;
  };
  GeoJsonLoader2.prototype._featureCreated = function _featureCreated(group, dataItem) {
    if (this.observer && this.observer.featureCreated) {
      this.observer.featureCreated({
        group,
        dataItem,
        properties: dataItem.properties
      });
    }
  };
  GeoJsonLoader2.prototype._loadGeometryTo = function _loadGeometryTo(container, geometry, dataItem) {
    var this$1 = this;
    var coords = geometry.coordinates;
    var i;
    var path;
    switch (geometry.type) {
      case "LineString":
        path = this._loadPolygon(container, [coords], dataItem);
        this._setLineFill(path);
        break;
      case "MultiLineString":
        for (i = 0; i < coords.length; i++) {
          path = this$1._loadPolygon(container, [coords[i]], dataItem);
          this$1._setLineFill(path);
        }
        break;
      case "Polygon":
        this._loadPolygon(container, coords, dataItem);
        break;
      case "MultiPolygon":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPolygon(container, coords[i], dataItem);
        }
        break;
      case "Point":
        this._loadPoint(container, coords, dataItem);
        break;
      case "MultiPoint":
        for (i = 0; i < coords.length; i++) {
          this$1._loadPoint(container, coords[i], dataItem);
        }
        break;
      default:
        break;
    }
  };
  GeoJsonLoader2.prototype._setLineFill = function _setLineFill(path) {
    var segments = path.segments;
    if (segments.length < 4 || !segments[0].anchor().equals(last2(segments).anchor())) {
      path.options.fill = null;
    }
  };
  GeoJsonLoader2.prototype._loadShape = function _loadShape(container, shape2) {
    if (!this._shapeCreated(shape2)) {
      container.append(shape2);
    }
    return shape2;
  };
  GeoJsonLoader2.prototype._loadPolygon = function _loadPolygon(container, rings, dataItem) {
    var shape2 = this._buildPolygon(rings);
    shape2.dataItem = dataItem;
    shape2.location = this.locator.viewToLocation(shape2.bbox().center());
    return this._loadShape(container, shape2);
  };
  GeoJsonLoader2.prototype._buildPolygon = function _buildPolygon(rings) {
    var this$1 = this;
    var type = rings.length > 1 ? drawing_exports.MultiPath : drawing_exports.Path;
    var path = new type(this.style);
    for (var i = 0; i < rings.length; i++) {
      for (var j = 0; j < rings[i].length; j++) {
        var point2 = this$1.locator.locationToView(Location.fromLngLat(rings[i][j]));
        if (j === 0) {
          path.moveTo(point2.x, point2.y);
        } else {
          path.lineTo(point2.x, point2.y);
        }
      }
    }
    return path;
  };
  GeoJsonLoader2.prototype._loadPoint = function _loadPoint(container, coords, dataItem) {
    var location = Location.fromLngLat(coords);
    var point2 = this.locator.locationToView(location);
    var circle = new geometry_exports.Circle(point2, 10);
    var shape2 = new drawing_exports.Circle(circle, this.style);
    shape2.dataItem = dataItem;
    shape2.location = location;
    return this._loadShape(container, shape2);
  };
  return GeoJsonLoader2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/layers/bubble.js
var BubbleLayer = function(ShapeLayer2) {
  function BubbleLayer2() {
    ShapeLayer2.apply(this, arguments);
  }
  if (ShapeLayer2)
    BubbleLayer2.__proto__ = ShapeLayer2;
  BubbleLayer2.prototype = Object.create(ShapeLayer2 && ShapeLayer2.prototype);
  BubbleLayer2.prototype.constructor = BubbleLayer2;
  BubbleLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  BubbleLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.surface.clear();
    if (data.length === 0) {
      return;
    }
    var options2 = this.options;
    var getValue = getter(options2.valueField);
    var newData = data.slice(0);
    newData.sort(function(a, b) {
      return getValue(b) - getValue(a);
    });
    var scaleType = this._scaleType();
    var scale;
    var getLocation = getter(this.options.locationField);
    for (var i = 0; i < newData.length; i++) {
      var dataItem = newData[i];
      var location = getLocation(dataItem);
      var value = getValue(dataItem);
      if (defined2(location) && defined2(value)) {
        if (!scale) {
          scale = new scaleType([
            0,
            value
          ], [
            options2.minSize,
            options2.maxSize
          ]);
        }
        location = Location.create(location);
        var center = this$1.map.locationToView(location);
        var size = scale.map(value);
        var symbol = this$1._createSymbol({
          center,
          size,
          style: options2.style,
          dataItem,
          location
        });
        symbol.dataItem = dataItem;
        symbol.location = location;
        symbol.value = value;
        this$1._drawSymbol(symbol);
      }
    }
  };
  BubbleLayer2.prototype._scaleType = function _scaleType() {
    var scale = this.options.scale;
    if (isFunction3(scale)) {
      return scale;
    }
    return Scales[scale];
  };
  BubbleLayer2.prototype._createSymbol = function _createSymbol(args) {
    var symbol = this.options.symbol;
    if (!isFunction3(symbol)) {
      symbol = Symbols[symbol];
    }
    return symbol(args);
  };
  BubbleLayer2.prototype._drawSymbol = function _drawSymbol(shape2) {
    var args = {
      layer: this,
      shape: shape2
    };
    var cancelled = this.map.trigger("shapeCreated", args);
    if (!cancelled) {
      this.surface.draw(shape2);
    }
  };
  BubbleLayer2.prototype._tooltipContext = function _tooltipContext(shape2) {
    return {
      type: "bubble",
      layerIndex: this._layerIndex(),
      className: "k-map-bubble-tooltip",
      dataItem: shape2.dataItem,
      location: shape2.location,
      value: shape2.value
    };
  };
  BubbleLayer2.prototype._tooltipAnchor = function _tooltipAnchor(e) {
    var shape2 = e.element;
    var center = shape2.bbox().center();
    return {
      top: center.y,
      left: center.x
    };
  };
  return BubbleLayer2;
}(ShapeLayer);
setDefaultOptions(BubbleLayer, {
  // autoBind: true,
  locationField: "location",
  valueField: "value",
  minSize: 0,
  maxSize: 100,
  scale: "sqrt",
  symbol: "circle",
  // ensure bubble layers are displayed over tile and shape layers
  zIndex: 200
});
var SqrtScale = function(Class3) {
  function SqrtScale2(domain, range) {
    Class3.call(this);
    this._domain = domain;
    this._range = range;
    var domainRange = Math.sqrt(domain[1]) - Math.sqrt(domain[0]);
    var outputRange = range[1] - range[0];
    this._ratio = outputRange / domainRange;
  }
  if (Class3)
    SqrtScale2.__proto__ = Class3;
  SqrtScale2.prototype = Object.create(Class3 && Class3.prototype);
  SqrtScale2.prototype.constructor = SqrtScale2;
  SqrtScale2.prototype.map = function map2(value) {
    var rel = (Math.sqrt(value) - Math.sqrt(this._domain[0])) * this._ratio;
    return this._range[0] + rel;
  };
  return SqrtScale2;
}(class_default);
var Scales = {
  sqrt: SqrtScale
};
var Symbols = {
  circle: function(args) {
    var geo = new geometry_exports.Circle(args.center, args.size / 2);
    return new drawing_exports.Circle(geo, args.style);
  },
  square: function(args) {
    var path = new drawing_exports.Path(args.style);
    var halfSize = args.size / 2;
    var center = args.center;
    path.moveTo(center.x - halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y - halfSize).lineTo(center.x + halfSize, center.y + halfSize).lineTo(center.x - halfSize, center.y + halfSize).close();
    return path;
  }
};

// node_modules/@progress/kendo-charts/dist/es/map/layers/marker.js
var CLICK = "click";
var MOUSE_ENTER = "mouseenter";
var MOUSE_LEAVE = "mouseleave";
var extend11 = Object.assign;
var MARKER_CLASS = ".k-marker";
var MarkerLayer = function(Layer2) {
  function MarkerLayer2(map2, options2) {
    Layer2.call(this, map2, options2);
    this._markerClickHandler = proxy(this._markerClick, this);
    on(this.element, CLICK, MARKER_CLASS, this._markerClickHandler);
    this.items = [];
    this._load(this._readData());
  }
  if (Layer2)
    MarkerLayer2.__proto__ = Layer2;
  MarkerLayer2.prototype = Object.create(Layer2 && Layer2.prototype);
  MarkerLayer2.prototype.constructor = MarkerLayer2;
  MarkerLayer2.prototype.destroy = function destroy2() {
    Layer2.prototype.destroy.call(this);
    off(this.element, CLICK, this._markerClickHandler);
    this.clear();
  };
  MarkerLayer2.prototype.add = function add3(args) {
    var this$1 = this;
    if (isArray(args)) {
      for (var i = 0; i < args.length; i++) {
        this$1._addOne(args[i]);
      }
    } else {
      return this._addOne(args);
    }
  };
  MarkerLayer2.prototype.remove = function remove(marker) {
    marker.destroy();
    var index = (this.items || []).indexOf(marker);
    if (index > -1) {
      this.items.splice(index, 1);
    }
  };
  MarkerLayer2.prototype.clear = function clear4() {
    var this$1 = this;
    for (var i = 0; i < this.items.length; i++) {
      this$1.items[i].destroy();
    }
    this.items = [];
  };
  MarkerLayer2.prototype.update = function update(marker) {
    var location = marker.location();
    if (location) {
      marker.showAt(this.map.locationToView(location));
      var args = {
        marker,
        layer: this
      };
      this.map.trigger("markerActivate", args);
    }
  };
  MarkerLayer2.prototype._reset = function _reset() {
    var this$1 = this;
    Layer2.prototype._reset.call(this);
    var items = this.items;
    for (var i = 0; i < items.length; i++) {
      this$1.update(items[i]);
    }
  };
  MarkerLayer2.prototype.bind = function bind(options2, dataItem) {
    var marker = Marker.create(options2, this.options);
    marker.dataItem = dataItem;
    var args = {
      marker,
      layer: this
    };
    var cancelled = this.map.trigger("markerCreated", args);
    if (!cancelled) {
      this.add(marker);
      return marker;
    }
  };
  MarkerLayer2.prototype._addOne = function _addOne(arg) {
    var marker = Marker.create(arg, this.options);
    marker.addTo(this);
    return marker;
  };
  MarkerLayer2.prototype._readData = function _readData() {
    var data = this.options.data || [];
    return data;
  };
  MarkerLayer2.prototype._load = function _load(data) {
    var this$1 = this;
    this._data = data;
    this.clear();
    var getLocation = getter(this.options.locationField);
    var getTitle = getter(this.options.titleField);
    for (var i = 0; i < data.length; i++) {
      var dataItem = data[i];
      this$1.bind({
        location: getLocation(dataItem),
        title: getTitle(dataItem)
      }, dataItem);
    }
  };
  MarkerLayer2.prototype._markerClick = function _markerClick(e) {
    var marker = e.target._kendoNode;
    var args = {
      // marker: $(e.target).data('kendoMarker'),
      // marker: e.target.getAttribute("data-kendoMarker"),
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker),
      originalEvent: e
    };
    this.map.trigger("markerClick", args);
  };
  MarkerLayer2.prototype._markerMouseEnter = function _markerMouseEnter(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseEnter", args);
  };
  MarkerLayer2.prototype._markerMouseLeave = function _markerMouseLeave(e) {
    var args = this._createMarkerEventArgs(e);
    this.map.trigger("markerMouseLeave", args);
  };
  MarkerLayer2.prototype._createMarkerEventArgs = function _createMarkerEventArgs(e) {
    var marker = e.marker;
    var args = extend11({}, {
      layer: this,
      layerIndex: this._layerIndex(),
      marker,
      markerIndex: (this.items || []).indexOf(marker)
    }, e);
    return args;
  };
  return MarkerLayer2;
}(Layer);
setDefaultOptions(MarkerLayer, {
  zIndex: 1e3,
  autoBind: true,
  locationField: "location",
  titleField: "title"
});
var Marker = function(Class3) {
  function Marker2(options2) {
    Class3.call(this);
    this.options = options2 || {};
  }
  if (Class3)
    Marker2.__proto__ = Class3;
  Marker2.prototype = Object.create(Class3 && Class3.prototype);
  Marker2.prototype.constructor = Marker2;
  Marker2.prototype.destroy = function destroy2() {
    this.layer = null;
    this.unbindEvents();
    this.hide();
  };
  Marker2.prototype.addTo = function addTo(parent) {
    this.layer = parent.markers || parent;
    this.layer.items.push(this);
    this.layer.update(this);
  };
  Marker2.prototype.location = function location(value) {
    if (value) {
      this.options.location = Location.create(value).toArray();
      if (this.layer) {
        this.layer.update(this);
      }
      return this;
    }
    return Location.create(this.options.location);
  };
  Marker2.prototype.showAt = function showAt(point2) {
    this.render();
    this._anchor = { left: Math.round(point2.x), top: Math.round(point2.y) };
    this.element.style.left = toPixels(this._anchor.left);
    this.element.style.top = toPixels(this._anchor.top);
  };
  Marker2.prototype.hide = function hide2() {
    if (this.element) {
      this.element.remove();
      this.element = null;
    }
  };
  Marker2.prototype.bindEvents = function bindEvents3() {
    if (!this.element) {
      return;
    }
    this._mouseEnterHandler = proxy(this._mouseEnter, this);
    on(this.element, MOUSE_ENTER, MARKER_CLASS, this._mouseEnterHandler);
    this._mouseLeaveHandler = proxy(this._mouseLeave, this);
    on(this.element, MOUSE_LEAVE, MARKER_CLASS, this._mouseLeaveHandler);
  };
  Marker2.prototype.unbindEvents = function unbindEvents3() {
    if (!this.element) {
      return;
    }
    off(this.element, MOUSE_ENTER, this._mouseEnterHandler);
    off(this.element, MOUSE_LEAVE, this._mouseLeaveHandler);
  };
  Marker2.prototype.render = function render3() {
    if (!this.element) {
      var options2 = this.options;
      var layer = this.layer;
      var element = document.createElement("span");
      addClass(element, "k-marker k-icon k-i-marker-" + toHyphens(options2.shape || "pin"));
      if (options2.title) {
        element.setAttribute("title", options2.title);
      }
      var attributes = options2.attributes || {};
      Object.keys(attributes).forEach(function(key) {
        element.setAttribute(key, attributes[key]);
      });
      element._kendoNode = this;
      element.style.zIndex = options2.zIndex;
      this.element = element;
      if (layer) {
        layer.element.appendChild(this.element);
      }
      this.bindEvents();
    }
  };
  Marker2.prototype._mouseEnter = function _mouseEnter(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseEnter(args);
    this.layer.map._tooltip.show({
      top: this._anchor.top - this.element.offsetHeight,
      left: this._anchor.left
    }, this._tooltipContext());
  };
  Marker2.prototype._tooltipContext = function _tooltipContext() {
    return {
      type: "marker",
      layerIndex: this.layer._layerIndex(),
      className: "k-map-marker-tooltip",
      dataItem: this.dataItem,
      title: this.options.title,
      location: this.location()
    };
  };
  Marker2.prototype._mouseLeave = function _mouseLeave(e) {
    var args = this._createEventArgs(e);
    this.layer._markerMouseLeave(args);
  };
  Marker2.prototype._createEventArgs = function _createEventArgs(e) {
    var args = {
      marker: this,
      originalEvent: e
    };
    return args;
  };
  Marker2.create = function create2(arg, defaults) {
    if (arg instanceof Marker2) {
      return arg;
    }
    return new Marker2(deepExtend({}, defaults, arg));
  };
  return Marker2;
}(class_default);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/fx.js
var extend12 = Object.assign;
function animationFrame(callback) {
  window.requestAnimationFrame(callback);
}
var Animation2 = function(Class3) {
  function Animation3() {
    Class3.call(this);
    var that = this;
    that._tickProxy = proxy(that._tick, that);
    that._started = false;
  }
  if (Class3)
    Animation3.__proto__ = Class3;
  Animation3.prototype = Object.create(Class3 && Class3.prototype);
  Animation3.prototype.constructor = Animation3;
  Animation3.prototype.tick = function tick() {
  };
  Animation3.prototype.done = function done() {
  };
  Animation3.prototype.onEnd = function onEnd3() {
  };
  Animation3.prototype.onCancel = function onCancel() {
  };
  Animation3.prototype.start = function start() {
    if (!this.enabled()) {
      return;
    }
    if (!this.done()) {
      this._started = true;
      animationFrame(this._tickProxy);
    } else {
      this.onEnd();
    }
  };
  Animation3.prototype.enabled = function enabled() {
    return true;
  };
  Animation3.prototype.cancel = function cancel() {
    this._started = false;
    this.onCancel();
  };
  Animation3.prototype._tick = function _tick() {
    var that = this;
    if (!that._started) {
      return;
    }
    that.tick();
    if (!that.done()) {
      animationFrame(that._tickProxy);
    } else {
      that._started = false;
      that.onEnd();
    }
  };
  return Animation3;
}(class_default);
var Transition = function(Animation3) {
  function Transition2(options2) {
    Animation3.call(this);
    extend12(this, options2);
  }
  if (Animation3)
    Transition2.__proto__ = Animation3;
  Transition2.prototype = Object.create(Animation3 && Animation3.prototype);
  Transition2.prototype.constructor = Transition2;
  Transition2.prototype.done = function done() {
    return this.timePassed() >= this.duration;
  };
  Transition2.prototype.timePassed = function timePassed() {
    return Math.min(this.duration, now2() - this.startDate);
  };
  Transition2.prototype.moveTo = function moveTo(options2) {
    var that = this, movable = that.movable;
    that.initial = movable[that.axis];
    that.delta = options2.location - that.initial;
    that.duration = typeof options2.duration === "number" ? options2.duration : 300;
    that.tick = that._easeProxy(options2.ease);
    that.startDate = now2();
    that.start();
  };
  Transition2.prototype._easeProxy = function _easeProxy(ease) {
    var that = this;
    return function() {
      that.movable.moveAxis(that.axis, ease(that.timePassed(), that.initial, that.delta, that.duration));
    };
  };
  Transition2.easeOutExpo = function easeOutExpo(t, b, c, d) {
    return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
  };
  return Transition2;
}(Animation2);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/user-events.js
var extend13 = Object.assign;
var preventDefault4 = function(e) {
  e.preventDefault();
};
var DEFAULT_MIN_HOLD = 800;
var CLICK_DELAY = 300;
var DEFAULT_THRESHOLD = 0;
var PRESS = "press";
var HOLD = "hold";
var SELECT2 = "select";
var START2 = "start";
var MOVE2 = "move";
var END2 = "end";
var CANCEL = "cancel";
var TAP = "tap";
var DOUBLETAP = "doubleTap";
var RELEASE = "release";
var GESTURESTART = "gesturestart";
var GESTURECHANGE = "gesturechange";
var GESTUREEND = "gestureend";
var GESTURETAP = "gesturetap";
var THRESHOLD = {
  "api": 0,
  "touch": 0,
  "mouse": 9,
  "pointer": 9
};
function touchDelta(touch1, touch2) {
  var x1 = touch1.x.location, y1 = touch1.y.location, x2 = touch2.x.location, y2 = touch2.y.location, dx = x1 - x2, dy = y1 - y2;
  return {
    center: {
      x: (x1 + x2) / 2,
      y: (y1 + y2) / 2
    },
    distance: Math.sqrt(dx * dx + dy * dy)
  };
}
function getTouches(e) {
  var support3 = getSupportedFeatures();
  var touches = [], originalEvent = e.originalEvent || e, currentTarget = e.currentTarget, idx = 0, length, changedTouches, touch;
  if (e.api) {
    touches.push({
      id: 2,
      event: e,
      target: e.target,
      currentTarget: e.target,
      location: e,
      type: "api"
    });
  } else if (e.type.match(/touch/)) {
    changedTouches = originalEvent ? originalEvent.changedTouches : [];
    for (length = changedTouches.length; idx < length; idx++) {
      touch = changedTouches[idx];
      touches.push({
        location: touch,
        event: e,
        target: touch.target,
        currentTarget,
        id: touch.identifier,
        type: "touch"
      });
    }
  } else if (support3.pointers || support3.msPointers) {
    touches.push({
      location: originalEvent,
      event: e,
      target: e.target,
      currentTarget,
      id: originalEvent.pointerId,
      type: "pointer"
    });
  } else {
    touches.push({
      id: 1,
      event: e,
      target: e.target,
      currentTarget,
      location: e,
      type: "mouse"
    });
  }
  return touches;
}
var TouchAxis = function(Class3) {
  function TouchAxis2(axis, location) {
    Class3.call(this);
    var that = this;
    that.support = getSupportedFeatures();
    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;
    that.axis = axis;
    that._updateLocationData(location);
    that.startLocation = that.location;
    that.velocity = that.delta = 0;
    that.timeStamp = now2();
  }
  if (Class3)
    TouchAxis2.__proto__ = Class3;
  TouchAxis2.prototype = Object.create(Class3 && Class3.prototype);
  TouchAxis2.prototype.constructor = TouchAxis2;
  TouchAxis2.prototype.move = function move(location) {
    var that = this, offset = location["page" + that.axis], timeStamp = now2(), timeDelta = timeStamp - that.timeStamp || 1;
    if (!offset && this.invalidZeroEvents) {
      return;
    }
    that.delta = offset - that.location;
    that._updateLocationData(location);
    that.initialDelta = offset - that.startLocation;
    that.velocity = that.delta / timeDelta;
    that.timeStamp = timeStamp;
  };
  TouchAxis2.prototype._updateLocationData = function _updateLocationData(location) {
    var that = this, axis = that.axis;
    that.location = location["page" + axis];
    that.client = location["client" + axis];
    that.screen = location["screen" + axis];
  };
  return TouchAxis2;
}(class_default);
var Touch = function(Class3) {
  function Touch2(userEvents, target, touchInfo) {
    Class3.call(this);
    extend13(this, {
      x: new TouchAxis("X", touchInfo.location),
      y: new TouchAxis("Y", touchInfo.location),
      type: touchInfo.type,
      useClickAsTap: userEvents.useClickAsTap,
      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],
      userEvents,
      target,
      currentTarget: touchInfo.currentTarget,
      initialTouch: touchInfo.target,
      id: touchInfo.id,
      pressEvent: touchInfo,
      _clicks: userEvents._clicks,
      supportDoubleTap: userEvents.supportDoubleTap,
      _moved: false,
      _finished: false
    });
  }
  if (Class3)
    Touch2.__proto__ = Class3;
  Touch2.prototype = Object.create(Class3 && Class3.prototype);
  Touch2.prototype.constructor = Touch2;
  Touch2.prototype.press = function press() {
    this._holdTimeout = setTimeout(proxy(this._hold, this), this.userEvents.minHold);
    this._trigger(PRESS, this.pressEvent);
  };
  Touch2.prototype._tap = function _tap(touchInfo) {
    var that = this;
    that.userEvents._clicks++;
    if (that.userEvents._clicks === 1) {
      that._clickTimeout = setTimeout(function() {
        if (that.userEvents._clicks === 1) {
          that._trigger(TAP, touchInfo);
        } else {
          that._trigger(DOUBLETAP, touchInfo);
        }
        that.userEvents._clicks = 0;
      }, CLICK_DELAY);
    }
  };
  Touch2.prototype._hold = function _hold() {
    this._trigger(HOLD, this.pressEvent);
  };
  Touch2.prototype.move = function move(touchInfo) {
    var that = this;
    var preventMove = touchInfo.type !== "api" && that.userEvents._shouldNotMove;
    if (that._finished || preventMove) {
      return;
    }
    that.x.move(touchInfo.location);
    that.y.move(touchInfo.location);
    if (!that._moved) {
      if (that._withinIgnoreThreshold()) {
        return;
      }
      if (!UserEvents.current || UserEvents.current === that.userEvents) {
        that._start(touchInfo);
      } else {
        return that.dispose();
      }
    }
    if (!that._finished) {
      that._trigger(MOVE2, touchInfo);
    }
  };
  Touch2.prototype.end = function end(touchInfo) {
    this.endTime = now2();
    if (this._finished) {
      return;
    }
    this._finished = true;
    this._trigger(RELEASE, touchInfo);
    if (this._moved) {
      this._trigger(END2, touchInfo);
    } else {
      if (!this.useClickAsTap) {
        if (this.supportDoubleTap) {
          this._tap(touchInfo);
        } else {
          this._trigger(TAP, touchInfo);
        }
      }
    }
    clearTimeout(this._holdTimeout);
    this.dispose();
  };
  Touch2.prototype.dispose = function dispose() {
    var userEvents = this.userEvents, activeTouches = userEvents.touches || [];
    this._finished = true;
    this.pressEvent = null;
    clearTimeout(this._holdTimeout);
    var activeTouchIndex = activeTouches.indexOf(this);
    activeTouches.splice(activeTouchIndex, 1);
  };
  Touch2.prototype.skip = function skip() {
    this.dispose();
  };
  Touch2.prototype.cancel = function cancel() {
    this.dispose();
  };
  Touch2.prototype.isMoved = function isMoved() {
    return this._moved;
  };
  Touch2.prototype._start = function _start(touchInfo) {
    clearTimeout(this._holdTimeout);
    this.startTime = now2();
    this._moved = true;
    this._trigger(START2, touchInfo);
  };
  Touch2.prototype._trigger = function _trigger(name3, touchInfo) {
    var that = this, jQueryEvent = touchInfo.event, data = {
      touch: that,
      x: that.x,
      y: that.y,
      target: that.target,
      event: jQueryEvent
    };
    if (that.userEvents.notify(name3, data)) {
      jQueryEvent.preventDefault();
    }
  };
  Touch2.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {
    var xDelta = this.x.initialDelta, yDelta = this.y.initialDelta;
    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;
  };
  return Touch2;
}(class_default);
function withEachUpEvent(callback) {
  var eventMap = getEventMap(navigator.userAgent);
  var downEvents = eventMap.up.split(" "), idx = 0, length = downEvents.length;
  for (; idx < length; idx++) {
    callback(downEvents[idx]);
  }
}
var UserEvents = function(Observable3) {
  function UserEvents2(element, options2) {
    Observable3.call(this);
    var that = this;
    var filter;
    var support3 = getSupportedFeatures();
    this.support = support3;
    options2 = options2 || {};
    this.options = options2;
    filter = that.filter = options2.filter;
    that.threshold = options2.threshold || DEFAULT_THRESHOLD;
    that.minHold = options2.minHold || DEFAULT_MIN_HOLD;
    that.touches = [];
    that._maxTouches = options2.multiTouch ? 2 : 1;
    that.allowSelection = options2.allowSelection;
    that.captureUpIfMoved = options2.captureUpIfMoved;
    that.useClickAsTap = !options2.fastTap && !support3.delayedClick();
    that._clicks = 0;
    that.supportDoubleTap = options2.supportDoubleTap;
    var enableGlobalSurface = !support3.touch || support3.mouseAndTouchPresent;
    extend13(that, {
      element,
      surface: options2.global && enableGlobalSurface ? element.ownerDocument.documentElement : options2.surface || element,
      stopPropagation: options2.stopPropagation,
      pressed: false
    });
    this._surfaceMoveHandler = proxy(this._move, this);
    on(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    this._surfaceEndHandler = proxy(this._end, this);
    on(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    this._elementStartHandler = proxy(this._start, this);
    on(element, applyEventMap("down"), filter, this._elementStartHandler);
    if (that.useClickAsTap) {
      this._elementClickHandler = proxy(this._click, this);
      on(element, applyEventMap("click"), filter, this._elementClickHandler);
    }
    if (support3.pointers || support3.msPointers) {
      if (support3.browser.version < 11) {
        var defaultAction = "pinch-zoom double-tap-zoom";
        element.style["-ms-touch-action"] = options2.touchAction && options2.touchAction !== "none" ? defaultAction + " " + options2.touchAction : defaultAction;
      } else {
        element.style["touch-action"] = options2.touchAction || "none";
      }
    }
    if (options2.preventDragEvent) {
      this._elementDragStartHandler = preventDefault4;
      on(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    this._elementSelectHandler = proxy(this._select, this);
    on(element, applyEventMap("mousedown"), filter, this._elementSelectHandler);
    if (that.captureUpIfMoved && support3.eventCapture) {
      var surfaceElement = that.surface, preventIfMovingProxy = proxy(that.preventIfMoving, that);
      withEachUpEvent(function(eventName) {
        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);
      });
    }
    that.bind([
      PRESS,
      HOLD,
      TAP,
      DOUBLETAP,
      START2,
      MOVE2,
      END2,
      RELEASE,
      CANCEL,
      GESTURESTART,
      GESTURECHANGE,
      GESTUREEND,
      GESTURETAP,
      SELECT2
    ], options2);
  }
  if (Observable3)
    UserEvents2.__proto__ = Observable3;
  UserEvents2.prototype = Object.create(Observable3 && Observable3.prototype);
  UserEvents2.prototype.constructor = UserEvents2;
  UserEvents2.prototype.preventIfMoving = function preventIfMoving(e) {
    if (this._isMoved()) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype.destroy = function destroy2() {
    var that = this;
    var options2 = this.options;
    var element = this.element;
    if (that._destroyed) {
      return;
    }
    that._destroyed = true;
    if (that.captureUpIfMoved && this.support.eventCapture) {
      var surfaceElement = that.surface;
      withEachUpEvent(function(eventName) {
        surfaceElement.removeEventListener(eventName, that.preventIfMoving);
      });
    }
    off(that.surface, applyEventMap("move"), this._surfaceMoveHandler);
    off(that.surface, applyEventMap("up cancel"), this._surfaceEndHandler);
    off(element, applyEventMap("down"), this._elementStartHandler);
    if (that.useClickAsTap) {
      off(element, applyEventMap("click"), this._elementClickHandler);
    }
    if (options2.preventDragEvent) {
      off(element, applyEventMap("dragstart"), this._elementDragStartHandler);
    }
    off(element, applyEventMap("mousedown"), this._elementSelectHandler);
    that._disposeAll();
    that.unbind();
    delete that.surface;
    delete that.element;
    delete that.currentTarget;
  };
  UserEvents2.prototype.capture = function capture() {
    UserEvents2.current = this;
  };
  UserEvents2.prototype.cancel = function cancel() {
    this._disposeAll();
    this.trigger(CANCEL);
  };
  UserEvents2.prototype.notify = function notify3(event, data) {
    var that = this, touches = that.touches;
    var eventName = event;
    if (this._isMultiTouch()) {
      switch (eventName) {
        case MOVE2:
          eventName = GESTURECHANGE;
          break;
        case END2:
          eventName = GESTUREEND;
          break;
        case TAP:
          eventName = GESTURETAP;
          break;
        default:
          break;
      }
      extend13(data, {
        touches
      }, touchDelta(touches[0], touches[1]));
    }
    return this.trigger(eventName, extend13(data, {
      type: eventName
    }));
  };
  UserEvents2.prototype.press = function press(x, y, target) {
    this._apiCall("_start", x, y, target);
  };
  UserEvents2.prototype.move = function move(x, y) {
    this._apiCall("_move", x, y);
  };
  UserEvents2.prototype.end = function end(x, y) {
    this._apiCall("_end", x, y);
  };
  UserEvents2.prototype._isMultiTouch = function _isMultiTouch() {
    return this.touches.length > 1;
  };
  UserEvents2.prototype._maxTouchesReached = function _maxTouchesReached() {
    return this.touches.length >= this._maxTouches;
  };
  UserEvents2.prototype._disposeAll = function _disposeAll() {
    var touches = this.touches;
    while (touches.length > 0) {
      touches.pop().dispose();
    }
  };
  UserEvents2.prototype._isMoved = function _isMoved() {
    return grep(this.touches, function(touch) {
      return touch.isMoved();
    }).length;
  };
  UserEvents2.prototype._select = function _select(e) {
    if (!this.allowSelection || this.trigger(SELECT2, { event: e })) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype._start = function _start(e) {
    var that = this, idx = 0, filter = that.filter, target, touches = getTouches(e), length = touches.length, touch, which = e.which;
    if (which && which > 1 || that._maxTouchesReached()) {
      return;
    }
    UserEvents2.current = null;
    that.currentTarget = e.currentTarget;
    if (that.stopPropagation) {
      e.stopPropagation();
    }
    for (; idx < length; idx++) {
      if (that._maxTouchesReached()) {
        break;
      }
      touch = touches[idx];
      if (filter) {
        target = touch.currentTarget;
      } else {
        target = that.element;
      }
      if (target && target.length === 0) {
        continue;
      }
      touch = new Touch(that, target, touch);
      that.touches.push(touch);
      touch.press();
      if (that._isMultiTouch()) {
        that.notify("gesturestart", {});
      }
    }
  };
  UserEvents2.prototype._move = function _move(e) {
    this._eachTouch("move", e);
  };
  UserEvents2.prototype._end = function _end(e) {
    this._eachTouch("end", e);
  };
  UserEvents2.prototype._click = function _click(e) {
    var data = {
      touch: {
        initialTouch: e.target,
        target: e.currentTarget,
        endTime: now2(),
        x: {
          location: e.pageX,
          client: e.clientX
        },
        y: {
          location: e.pageY,
          client: e.clientY
        }
      },
      x: e.pageX,
      y: e.pageY,
      target: e.currentTarget,
      event: e,
      type: "tap"
    };
    if (this.trigger("tap", data)) {
      e.preventDefault();
    }
  };
  UserEvents2.prototype._eachTouch = function _eachTouch(methodName, e) {
    var that = this, dict2 = {}, touches = getTouches(e), activeTouches = that.touches, idx, touch, touchInfo, matchingTouch;
    for (idx = 0; idx < activeTouches.length; idx++) {
      touch = activeTouches[idx];
      dict2[touch.id] = touch;
    }
    for (idx = 0; idx < touches.length; idx++) {
      touchInfo = touches[idx];
      matchingTouch = dict2[touchInfo.id];
      if (matchingTouch) {
        matchingTouch[methodName](touchInfo);
      }
    }
  };
  UserEvents2.prototype._apiCall = function _apiCall(type, x, y, target) {
    this[type]({
      api: true,
      pageX: x,
      pageY: y,
      clientX: x,
      clientY: y,
      target: target || this.element,
      stopPropagation: noop,
      preventDefault: noop
    });
  };
  UserEvents2.defaultThreshold = function defaultThreshold(value) {
    DEFAULT_THRESHOLD = value;
  };
  UserEvents2.minHold = function minHold(value) {
    DEFAULT_MIN_HOLD = value;
  };
  return UserEvents2;
}(Observable2);

// node_modules/@progress/kendo-charts/dist/es/map/scroller/scroller.js
var extend14 = Object.assign;
var abs2 = Math.abs;
var SNAPBACK_DURATION = 500;
var SCROLLBAR_OPACITY = 0.7;
var FRICTION = 0.96;
var VELOCITY_MULTIPLIER = 10;
var MAX_VELOCITY = 55;
var OUT_OF_BOUNDS_FRICTION = 0.5;
var ANIMATED_SCROLLER_PRECISION = 5;
var PULL = "pull";
var CHANGE3 = "change";
var RESIZE = "resize";
var SCROLL = "scroll";
var MOUSE_WHEEL_ID = 2;
var ZoomSnapBack = function(Animation3) {
  function ZoomSnapBack2(options2) {
    Animation3.call(this, options2);
    var that = this;
    extend14(that, options2);
    that.userEvents.bind("gestureend", that.start.bind(this));
    that.tapCapture.bind("press", that.cancel.bind(this));
  }
  if (Animation3)
    ZoomSnapBack2.__proto__ = Animation3;
  ZoomSnapBack2.prototype = Object.create(Animation3 && Animation3.prototype);
  ZoomSnapBack2.prototype.constructor = ZoomSnapBack2;
  ZoomSnapBack2.prototype.enabled = function enabled() {
    return this.movable.scale < this.dimensions.minScale;
  };
  ZoomSnapBack2.prototype.done = function done() {
    return this.dimensions.minScale - this.movable.scale < 0.01;
  };
  ZoomSnapBack2.prototype.tick = function tick() {
    var movable = this.movable;
    movable.scaleWith(1.1);
    this.dimensions.rescale(movable.scale);
  };
  ZoomSnapBack2.prototype.onEnd = function onEnd3() {
    var movable = this.movable;
    movable.scaleTo(this.dimensions.minScale);
    this.dimensions.rescale(movable.scale);
  };
  return ZoomSnapBack2;
}(Animation2);
var DragInertia = function(Animation3) {
  function DragInertia2(options2) {
    Animation3.call(this);
    var that = this;
    extend14(that, options2, {
      transition: new Transition({
        axis: options2.axis,
        movable: options2.movable,
        onEnd: function onEnd3() {
          that._end();
        }
      })
    });
    that.tapCapture.bind("press", function() {
      that.cancel();
    });
    that.userEvents.bind("end", proxy(that.start, that));
    that.userEvents.bind("gestureend", proxy(that.start, that));
    that.userEvents.bind("tap", proxy(that.onEnd, that));
  }
  if (Animation3)
    DragInertia2.__proto__ = Animation3;
  DragInertia2.prototype = Object.create(Animation3 && Animation3.prototype);
  DragInertia2.prototype.constructor = DragInertia2;
  DragInertia2.prototype.onCancel = function onCancel() {
    this.transition.cancel();
  };
  DragInertia2.prototype.freeze = function freeze(location) {
    var that = this;
    that.cancel();
    that._moveTo(location);
  };
  DragInertia2.prototype.onEnd = function onEnd3() {
    var that = this;
    if (that.paneAxis.outOfBounds()) {
      that._snapBack();
    } else {
      that._end();
    }
  };
  DragInertia2.prototype.done = function done() {
    return abs2(this.velocity) < 1;
  };
  DragInertia2.prototype.start = function start(e) {
    var that = this, velocity;
    if (!that.dimension.enabled) {
      return;
    }
    if (that.paneAxis.outOfBounds()) {
      if (that.transition._started) {
        that.transition.cancel();
        that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);
        Animation3.prototype.start.call(this);
      } else {
        that._snapBack();
      }
    } else {
      velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;
      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);
      that.tapCapture.captureNext();
      Animation3.prototype.start.call(this);
    }
  };
  DragInertia2.prototype.tick = function tick() {
    var that = this, dimension = that.dimension, friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction, delta = that.velocity *= friction, location = that.movable[that.axis] + delta;
    if (!that.elastic && dimension.outOfBounds(location)) {
      location = Math.max(Math.min(location, dimension.max), dimension.min);
      that.velocity = 0;
    }
    that.movable.moveAxis(that.axis, location);
  };
  DragInertia2.prototype._end = function _end() {
    this.tapCapture.cancelCapture();
    this.end();
  };
  DragInertia2.prototype._snapBack = function _snapBack() {
    var that = this, dimension = that.dimension, snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;
    that._moveTo(snapBack);
  };
  DragInertia2.prototype._moveTo = function _moveTo(location) {
    this.transition.moveTo({
      location,
      duration: SNAPBACK_DURATION,
      ease: Transition.easeOutExpo
    });
  };
  return DragInertia2;
}(Animation2);
var AnimatedScroller = function(Animation3) {
  function AnimatedScroller2(options2) {
    Animation3.call(this, options2);
    var that = this;
    extend14(that, options2, {
      origin: {},
      destination: {},
      offset: {}
    });
  }
  if (Animation3)
    AnimatedScroller2.__proto__ = Animation3;
  AnimatedScroller2.prototype = Object.create(Animation3 && Animation3.prototype);
  AnimatedScroller2.prototype.constructor = AnimatedScroller2;
  AnimatedScroller2.prototype.tick = function tick() {
    this._updateCoordinates();
    this.moveTo(this.origin);
  };
  AnimatedScroller2.prototype.done = function done() {
    return abs2(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs2(this.offset.x) < ANIMATED_SCROLLER_PRECISION;
  };
  AnimatedScroller2.prototype.onEnd = function onEnd3() {
    this.moveTo(this.destination);
    if (this.callback) {
      this.callback.call();
    }
  };
  AnimatedScroller2.prototype.setCoordinates = function setCoordinates(from, to) {
    this.offset = {};
    this.origin = from;
    this.destination = to;
  };
  AnimatedScroller2.prototype.setCallback = function setCallback(callback) {
    if (callback && isFunction3(callback)) {
      this.callback = callback;
    } else {
      callback = void 0;
    }
  };
  AnimatedScroller2.prototype._updateCoordinates = function _updateCoordinates() {
    this.offset = {
      x: (this.destination.x - this.origin.x) / 4,
      y: (this.destination.y - this.origin.y) / 4
    };
    this.origin = {
      y: this.origin.y + this.offset.y,
      x: this.origin.x + this.offset.x
    };
  };
  return AnimatedScroller2;
}(Animation2);
var ScrollBar = function(Class3) {
  function ScrollBar2(options2) {
    Class3.call(this);
    var that = this, horizontal = options2.axis === "x";
    var orientation = horizontal ? "horizontal" : "vertical";
    var element = convertToHtml('<div class="km-touch-scrollbar km-' + orientation + '-scrollbar" />');
    extend14(that, options2, {
      element,
      elementSize: 0,
      movable: new Movable(element),
      scrollMovable: options2.movable,
      alwaysVisible: options2.alwaysVisible,
      size: horizontal ? "width" : "height"
    });
    that.scrollMovable.bind(CHANGE3, that.refresh.bind(that));
    that.container.appendChild(element);
    if (options2.alwaysVisible) {
      that.show();
    }
  }
  if (Class3)
    ScrollBar2.__proto__ = Class3;
  ScrollBar2.prototype = Object.create(Class3 && Class3.prototype);
  ScrollBar2.prototype.constructor = ScrollBar2;
  ScrollBar2.prototype.refresh = function refresh() {
    var that = this, axis = that.axis, dimension = that.dimension, paneSize = dimension.size, scrollMovable = that.scrollMovable, sizeRatio = paneSize / dimension.total, position = Math.round(-scrollMovable[axis] * sizeRatio), size = Math.round(paneSize * sizeRatio);
    if (sizeRatio >= 1) {
      this.element.style.display = "none";
    } else {
      this.element.style.display = "";
    }
    if (position + size > paneSize) {
      size = paneSize - position;
    } else if (position < 0) {
      size += position;
      position = 0;
    }
    if (that.elementSize !== size) {
      that.element.style[that.size] = size + "px";
      that.elementSize = size;
    }
    that.movable.moveAxis(axis, position);
  };
  ScrollBar2.prototype.show = function show2() {
    this.element.style.opacity = SCROLLBAR_OPACITY;
    this.element.style.visibility = "visible";
  };
  ScrollBar2.prototype.hide = function hide2() {
    if (!this.alwaysVisible) {
      this.element.style.opacity = 0;
    }
  };
  return ScrollBar2;
}(class_default);
var Scroller = function(Observable3) {
  function Scroller2(element, options2) {
    Observable3.call(this);
    var that = this;
    this.element = element;
    this._initOptions(options2);
    var hasScrolling = hasNativeScrolling(navigator.userAgent);
    that._native = that.options.useNative && hasScrolling;
    var scrollHeader = convertToHtml('<div class="km-scroll-header"/>');
    if (that._native) {
      addClass(element, "km-native-scroller");
      prepend(scrollHeader, element);
      extend14(that, {
        scrollElement: element,
        fixedContainer: element.children[0]
      });
      return;
    }
    element.style.overflow = "hidden";
    addClass(element, "km-scroll-wrapper");
    var scrollContainer = convertToHtml('<div class="km-scroll-container"/>');
    wrapInner(element, scrollContainer);
    prepend(scrollHeader, element);
    var inner = element.children[1], tapCapture = new TapCapture(element), movable = new Movable(inner), dimensions = new PaneDimensions({
      element: inner,
      container: element,
      forcedEnabled: that.options.zoom
    }), avoidScrolling2 = this.options.avoidScrolling, userEvents = new UserEvents(element, {
      touchAction: "pan-y",
      fastTap: true,
      allowSelection: true,
      preventDragEvent: true,
      captureUpIfMoved: true,
      multiTouch: that.options.zoom,
      supportDoubleTap: that.options.supportDoubleTap,
      start: function start(e) {
        dimensions.refresh();
        var velocityX = abs2(e.x.velocity), velocityY = abs2(e.y.velocity), horizontalSwipe = velocityX * 2 >= velocityY, originatedFromFixedContainer = contains(that.fixedContainer, e.event.target), verticalSwipe = velocityY * 2 >= velocityX;
        if (!originatedFromFixedContainer && !avoidScrolling2(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {
          userEvents.capture();
        } else {
          userEvents.cancel();
        }
      }
    }), pane = new Pane2({
      movable,
      dimensions,
      userEvents,
      elastic: that.options.elastic
    }), zoomSnapBack = new ZoomSnapBack({
      movable,
      dimensions,
      userEvents,
      tapCapture
    }), animatedScroller = new AnimatedScroller({
      moveTo: function moveTo(coordinates) {
        that.scrollTo(coordinates.x, coordinates.y);
      }
    });
    movable.bind(CHANGE3, function() {
      that.scrollTop = -movable.y;
      that.scrollLeft = -movable.x;
      that.trigger(SCROLL, {
        scrollTop: that.scrollTop,
        scrollLeft: that.scrollLeft
      });
    });
    if (that.options.mousewheelScrolling) {
      this._wheelScrollHandler = this._wheelScroll.bind(this);
      on(element, "DOMMouseScroll mousewheel", this._wheelScrollHandler);
    }
    extend14(that, {
      movable,
      dimensions,
      zoomSnapBack,
      animatedScroller,
      userEvents,
      pane,
      tapCapture,
      pulled: false,
      enabled: true,
      scrollElement: inner,
      scrollTop: 0,
      scrollLeft: 0,
      fixedContainer: element.children[0]
    });
    that._initAxis("x");
    that._initAxis("y");
    that._wheelEnd = function() {
      that._wheel = false;
      that.userEvents.end(0, that._wheelY);
    };
    dimensions.refresh();
    if (that.options.pullToRefresh) {
      that._initPullToRefresh();
    }
  }
  if (Observable3)
    Scroller2.__proto__ = Observable3;
  Scroller2.prototype = Object.create(Observable3 && Observable3.prototype);
  Scroller2.prototype.constructor = Scroller2;
  Scroller2.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Scroller2.prototype._wheelScroll = function _wheelScroll(e) {
    if (e.ctrlKey) {
      return;
    }
    if (!this._wheel) {
      this._wheel = true;
      this._wheelY = 0;
      this.userEvents.press(0, this._wheelY);
    }
    clearTimeout(this._wheelTimeout);
    this._wheelTimeout = setTimeout(this._wheelEnd, 50);
    var delta = wheelDeltaY(e);
    if (delta) {
      this._wheelY += delta;
      this.userEvents.move(0, this._wheelY);
    }
    e.preventDefault();
  };
  Scroller2.prototype.makeVirtual = function makeVirtual() {
    this.dimensions.y.makeVirtual();
  };
  Scroller2.prototype.virtualSize = function virtualSize(min3, max2) {
    this.dimensions.y.virtualSize(min3, max2);
  };
  Scroller2.prototype.height = function height() {
    return this.dimensions.y.size;
  };
  Scroller2.prototype.scrollHeight = function scrollHeight() {
    return this.scrollElement.scrollHeight;
  };
  Scroller2.prototype.scrollWidth = function scrollWidth() {
    return this.scrollElement.scrollWidth;
  };
  Scroller2.prototype._resize = function _resize() {
    if (!this._native) {
      this.contentResized();
    }
  };
  Scroller2.prototype.setOptions = function setOptions(options2) {
    var that = this;
    this._initOptions(options2);
    if (options2.pullToRefresh) {
      that._initPullToRefresh();
    }
  };
  Scroller2.prototype.reset = function reset() {
    if (this._native) {
      this.scrollElement.scrollTop(0);
    } else {
      this.movable.moveTo({
        x: 0,
        y: 0
      });
      this._scale(1);
    }
  };
  Scroller2.prototype.contentResized = function contentResized() {
    this.dimensions.refresh();
    if (this.pane.x.outOfBounds()) {
      this.movable.moveAxis("x", this.dimensions.x.min);
    }
    if (this.pane.y.outOfBounds()) {
      this.movable.moveAxis("y", this.dimensions.y.min);
    }
  };
  Scroller2.prototype.zoomOut = function zoomOut() {
    var dimensions = this.dimensions;
    dimensions.refresh();
    this._scale(dimensions.fitScale);
    this.movable.moveTo(dimensions.centerCoordinates());
  };
  Scroller2.prototype.enable = function enable() {
    this.enabled = true;
  };
  Scroller2.prototype.disable = function disable() {
    this.enabled = false;
  };
  Scroller2.prototype.scrollTo = function scrollTo(x, y) {
    if (this._native) {
      this.scrollElement.scrollLeft(abs2(x));
      this.scrollElement.scrollTop(abs2(y));
    } else {
      this.dimensions.refresh();
      this.movable.moveTo({
        x,
        y
      });
    }
  };
  Scroller2.prototype.animatedScrollTo = function animatedScrollTo(x, y, callback) {
    var from, to;
    if (this._native) {
      this.scrollTo(x, y);
    } else {
      from = {
        x: this.movable.x,
        y: this.movable.y
      };
      to = {
        x,
        y
      };
      this.animatedScroller.setCoordinates(from, to);
      this.animatedScroller.setCallback(callback);
      this.animatedScroller.start();
    }
  };
  Scroller2.prototype.pullHandled = function pullHandled() {
  };
  Scroller2.prototype.destroy = function destroy2() {
    var element = this.element;
    off(element, "DOMMouseScroll mousewheel", this._wheelScrollHandler);
    if (this.userEvents) {
      this.userEvents.destroy();
    }
  };
  Scroller2.prototype._scale = function _scale(scale) {
    this.dimensions.rescale(scale);
    this.movable.scaleTo(scale);
  };
  Scroller2.prototype._initPullToRefresh = function _initPullToRefresh() {
  };
  Scroller2.prototype._dragEnd = function _dragEnd() {
  };
  Scroller2.prototype._paneChange = function _paneChange() {
  };
  Scroller2.prototype._initAxis = function _initAxis(axis) {
    var that = this, movable = that.movable, dimension = that.dimensions[axis], tapCapture = that.tapCapture, paneAxis = that.pane[axis], scrollBar = new ScrollBar({
      axis,
      movable,
      dimension,
      container: that.element,
      alwaysVisible: that.options.visibleScrollHints
    });
    dimension.bind(CHANGE3, function() {
      scrollBar.refresh();
    });
    paneAxis.bind(CHANGE3, function() {
      scrollBar.show();
    });
    that[axis + "inertia"] = new DragInertia({
      axis,
      paneAxis,
      movable,
      tapCapture,
      userEvents: that.userEvents,
      dimension,
      elastic: that.options.elastic,
      friction: that.options.friction || FRICTION,
      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,
      end: function end() {
        scrollBar.hide();
        that.trigger("scrollEnd", {
          axis,
          scrollTop: that.scrollTop,
          scrollLeft: that.scrollLeft
        });
      }
    });
  };
  return Scroller2;
}(Observable2);
setDefaultOptions(Scroller, {
  name: "Scroller",
  zoom: false,
  pullOffset: 140,
  visibleScrollHints: false,
  elastic: true,
  useNative: false,
  mousewheelScrolling: true,
  avoidScrolling: function avoidScrolling() {
    return false;
  },
  pullToRefresh: false,
  messages: {
    pullTemplate: "Pull to refresh",
    releaseTemplate: "Release to refresh",
    refreshTemplate: "Refreshing"
  }
});
setDefaultEvents(Scroller, [
  PULL,
  SCROLL,
  RESIZE
]);

// node_modules/@progress/kendo-charts/dist/es/services/map-service.js
var MapService = function MapService2(widget, context2) {
  if (context2 === void 0)
    context2 = {};
  this.sender = context2.sender || widget;
  this.widget = widget;
  this.rtl = Boolean(context2.rtl);
};
MapService.prototype.notify = function notify2(name3, args) {
  if (this.widget) {
    this.widget.trigger(name3, args);
  }
};
var map_service_default = MapService;

// node_modules/@progress/kendo-charts/dist/es/map/map.js
var math5 = Math;
var min2 = math5.min;
var pow4 = math5.pow;
var Point7 = geometry_exports.Point;
var MARKER = "marker";
var LOCATION = "location";
var FRICTION2 = 0.9;
var FRICTION_MOBILE = 0.93;
var MOUSEWHEEL2 = "DOMMouseScroll mousewheel";
var VELOCITY_MULTIPLIER2 = 5;
var DEFAULT_ZOOM_RATE = 1;
var layersMap = {
  bubble: BubbleLayer,
  shape: ShapeLayer,
  tile: TileLayer
};
layersMap[MARKER] = MarkerLayer;
function renderPos(pos) {
  var result = [];
  if (pos) {
    var parts = toHyphens(pos).split("-");
    for (var i = 0; i < parts.length; i++) {
      result.push("k-pos-" + parts[i]);
    }
  }
  return result.join(" ");
}
var Map2 = function(Observable3) {
  function Map3(element, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (context2 === void 0)
      context2 = {};
    Observable3.call(this);
    this._init(element, options2, themeOptions, context2);
  }
  if (Observable3)
    Map3.__proto__ = Observable3;
  Map3.prototype = Object.create(Observable3 && Observable3.prototype);
  Map3.prototype.constructor = Map3;
  Map3.prototype.destroy = function destroy2() {
    var this$1 = this;
    this.scroller.destroy();
    if (this._tooltip) {
      this._tooltip.destroy();
    }
    if (this.navigator) {
      this.navigator.destroy();
    }
    if (this.attribution) {
      this.attribution.destroy();
    }
    if (this.zoomControl) {
      this.zoomControl.destroy();
    }
    if (isArray(this.markers)) {
      this.markers.forEach(function(markerLayer) {
        markerLayer.destroy();
      });
    } else {
      this.markers.destroy();
    }
    for (var i = 0; i < this.layers.length; i++) {
      this$1.layers[i].destroy();
    }
    off(this.element, MOUSEWHEEL2, this._mousewheelHandler);
    Observable3.prototype.destroy.call(this);
  };
  Map3.prototype._init = function _init(element, options2, themeOptions, context2) {
    if (options2 === void 0)
      options2 = {};
    if (themeOptions === void 0)
      themeOptions = {};
    if (context2 === void 0)
      context2 = {};
    this.support = getSupportedFeatures();
    this.context = context2;
    this.initObserver(context2);
    this.initServices(context2);
    this._notifyObserver(INIT);
    this._initOptions(options2);
    this._setEvents(options2);
    this.crs = new EPSG3857();
    this._initElement(element);
    this._viewOrigin = this._getOrigin();
    this._tooltip = this._createTooltip();
    this._initScroller();
    this._initMarkers();
    this._initControls();
    this._initLayers();
    this._reset();
    this._mousewheelHandler = this._mousewheel.bind(this);
    on(this.element, MOUSEWHEEL2, this._mousewheelHandler);
  };
  Map3.prototype._initOptions = function _initOptions(options2) {
    this.options = deepExtend({}, this.options, options2);
  };
  Map3.prototype._initElement = function _initElement(element) {
    this.element = element;
    addClass(element, "k-map");
    element.style.position = "relative";
    element.setAttribute("data-role", "map");
    removeChildren(element);
    var div = convertToHtml("<div />");
    this.element.appendChild(div);
  };
  Map3.prototype.initServices = function initServices(context2) {
    if (context2 === void 0)
      context2 = {};
    this.widgetService = new map_service_default(this, context2);
  };
  Map3.prototype.initObserver = function initObserver(context2) {
    if (context2 === void 0)
      context2 = {};
    this.observers = [];
    this.addObserver(context2.observer);
  };
  Map3.prototype.addObserver = function addObserver(observer) {
    if (observer) {
      this.observers.push(observer);
    }
  };
  Map3.prototype.removeObserver = function removeObserver(observer) {
    var index = this.observers.indexOf(observer);
    if (index >= 0) {
      this.observers.splice(index, 1);
    }
  };
  Map3.prototype.requiresHandlers = function requiresHandlers2(eventNames) {
    var observers = this.observers;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].requiresHandlers(eventNames)) {
        return true;
      }
    }
  };
  Map3.prototype.trigger = function trigger2(name3, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name3, args)) {
        isDefaultPrevented3 = true;
      }
    }
    if (!isDefaultPrevented3) {
      Observable3.prototype.trigger.call(this, name3, args);
    }
    return isDefaultPrevented3;
  };
  Map3.prototype._notifyObserver = function _notifyObserver(name3, args) {
    if (args === void 0)
      args = {};
    args.sender = this;
    var observers = this.observers;
    var isDefaultPrevented3 = false;
    for (var idx = 0; idx < observers.length; idx++) {
      if (observers[idx].trigger(name3, args)) {
        isDefaultPrevented3 = true;
      }
    }
    return isDefaultPrevented3;
  };
  Map3.prototype.zoom = function zoom(level) {
    var options2 = this.options;
    var result;
    if (defined2(level)) {
      var zoomLevel = math5.round(limitValue2(level, options2.minZoom, options2.maxZoom));
      if (options2.zoom !== zoomLevel) {
        options2.zoom = zoomLevel;
        this.widgetService.notify(ZOOM_CHANGE, { zoom: options2.zoom });
        this._reset();
      }
      result = this;
    } else {
      result = options2.zoom;
    }
    return result;
  };
  Map3.prototype.center = function center(center$1) {
    var result;
    if (center$1) {
      var current4 = Location.create(center$1);
      var previous = Location.create(this.options.center);
      if (!current4.equals(previous)) {
        this.options.center = current4.toArray();
        this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
        this._reset();
      }
      result = this;
    } else {
      result = Location.create(this.options.center);
    }
    return result;
  };
  Map3.prototype.extent = function extent(extent$1) {
    var result;
    if (extent$1) {
      this._setExtent(extent$1);
      result = this;
    } else {
      result = this._getExtent();
    }
    return result;
  };
  Map3.prototype.setOptions = function setOptions(options2) {
    if (options2 === void 0)
      options2 = {};
    var element = this.element;
    this.destroy();
    removeChildren(element);
    this._init(element, options2, {}, this.context);
    this._reset();
  };
  Map3.prototype.locationToLayer = function locationToLayer(location, zoom) {
    var clamp = !this.options.wraparound;
    var locationObject = Location.create(location);
    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.layerToLocation = function layerToLocation(point2, zoom) {
    var clamp = !this.options.wraparound;
    var pointObject = Point7.create(point2);
    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);
  };
  Map3.prototype.locationToView = function locationToView(location) {
    var locationObject = Location.create(location);
    var origin = this.locationToLayer(this._viewOrigin);
    var point2 = this.locationToLayer(locationObject);
    return point2.translateWith(origin.scale(-1));
  };
  Map3.prototype.viewToLocation = function viewToLocation(point2, zoom) {
    var origin = this.locationToLayer(this._getOrigin(), zoom);
    var pointObject = Point7.create(point2);
    var pointResult = pointObject.clone().translateWith(origin);
    return this.layerToLocation(pointResult, zoom);
  };
  Map3.prototype.eventOffset = function eventOffset(e) {
    var x;
    var y;
    var offset = elementOffset2(this.element);
    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {
      x = e.x[LOCATION] - offset.left;
      y = e.y[LOCATION] - offset.top;
    } else {
      var event = e.originalEvent || e;
      x = valueOrDefault2(event.pageX, event.clientX) - offset.left;
      y = valueOrDefault2(event.pageY, event.clientY) - offset.top;
    }
    var point2 = new geometry_exports.Point(x, y);
    return point2;
  };
  Map3.prototype.eventToView = function eventToView(e) {
    var cursor = this.eventOffset(e);
    return this.locationToView(this.viewToLocation(cursor));
  };
  Map3.prototype.eventToLayer = function eventToLayer(e) {
    return this.locationToLayer(this.eventToLocation(e));
  };
  Map3.prototype.eventToLocation = function eventToLocation(e) {
    var cursor = this.eventOffset(e);
    return this.viewToLocation(cursor);
  };
  Map3.prototype.viewSize = function viewSize() {
    var element = this.element;
    var scale = this._layerSize();
    var width = element.clientWidth;
    if (!this.options.wraparound) {
      width = min2(scale, width);
    }
    return {
      width,
      height: min2(scale, element.clientHeight)
    };
  };
  Map3.prototype.exportVisual = function exportVisual() {
    this._reset();
    return false;
  };
  Map3.prototype.hideTooltip = function hideTooltip() {
    if (this._tooltip) {
      this._tooltip.hide();
    }
  };
  Map3.prototype._setOrigin = function _setOrigin(origin, zoom) {
    var size = this.viewSize(), topLeft;
    var originLocation = this._origin = Location.create(origin);
    topLeft = this.locationToLayer(originLocation, zoom);
    topLeft.x += size.width / 2;
    topLeft.y += size.height / 2;
    this.options.center = this.layerToLocation(topLeft, zoom).toArray();
    this.widgetService.notify(CENTER_CHANGE, { center: this.options.center });
    return this;
  };
  Map3.prototype._getOrigin = function _getOrigin(invalidate) {
    var size = this.viewSize(), topLeft;
    if (invalidate || !this._origin) {
      topLeft = this.locationToLayer(this.center());
      topLeft.x -= size.width / 2;
      topLeft.y -= size.height / 2;
      this._origin = this.layerToLocation(topLeft);
    }
    return this._origin;
  };
  Map3.prototype._setExtent = function _setExtent(newExtent) {
    var this$1 = this;
    var raw2 = Extent.create(newExtent);
    var se = raw2.se.clone();
    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {
      se.lng = 180 + (180 + se.lng);
    }
    var extent = new Extent(raw2.nw, se);
    this.center(extent.center());
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    var zoom;
    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {
      var topLeft = this$1.locationToLayer(extent.nw, zoom);
      var bottomRight = this$1.locationToLayer(extent.se, zoom);
      var layerWidth = math5.abs(bottomRight.x - topLeft.x);
      var layerHeight = math5.abs(bottomRight.y - topLeft.y);
      if (layerWidth <= width && layerHeight <= height) {
        break;
      }
    }
    this.zoom(zoom);
  };
  Map3.prototype._getExtent = function _getExtent() {
    var nw = this._getOrigin();
    var bottomRight = this.locationToLayer(nw);
    var size = this.viewSize();
    bottomRight.x += size.width;
    bottomRight.y += size.height;
    var se = this.layerToLocation(bottomRight);
    return new Extent(nw, se);
  };
  Map3.prototype._zoomAround = function _zoomAround(pivot, level) {
    this._setOrigin(this.layerToLocation(pivot, level), level);
    this.zoom(level);
  };
  Map3.prototype._initControls = function _initControls() {
    var controls = this.options.controls;
    if (controls.attribution) {
      this._createAttribution(controls.attribution);
    }
    if (!this.support.mobileOS) {
      if (controls.navigator) {
        this._createNavigator(controls.navigator);
      }
      if (controls.zoom) {
        this._createZoomControl(controls.zoom);
      }
    }
  };
  Map3.prototype._createControlElement = function _createControlElement(options2, defaultPosition) {
    var pos = options2.position || defaultPosition;
    var posSelector = "." + renderPos(pos).replace(" ", ".");
    var wrap2 = this.element.querySelector(".k-map-controls" + posSelector) || [];
    if (wrap2.length === 0) {
      var div$1 = document.createElement("div");
      addClass(div$1, "k-map-controls " + renderPos(pos));
      wrap2 = div$1;
      this.element.appendChild(wrap2);
    }
    var div = document.createElement("div");
    wrap2.appendChild(div);
    return div;
  };
  Map3.prototype._createAttribution = function _createAttribution(options2) {
    var element = this._createControlElement(options2, "bottomRight");
    this.attribution = new Attribution(element, options2);
  };
  Map3.prototype._createNavigator = function _createNavigator(options2) {
    var element = this._createControlElement(options2, "topLeft");
    var navigator2 = this.navigator = new Navigator2(element, options2);
    this._navigatorPan = this._navigatorPan.bind(this);
    navigator2.bind("pan", this._navigatorPan);
    this._navigatorCenter = this._navigatorCenter.bind(this);
    navigator2.bind("center", this._navigatorCenter);
  };
  Map3.prototype._navigatorPan = function _navigatorPan(e) {
    var scroller = this.scroller;
    var x = scroller.scrollLeft + e.x;
    var y = scroller.scrollTop - e.y;
    var bounds = this._virtualSize;
    var width = this.element.clientWidth;
    var height = this.element.clientHeight;
    x = limitValue2(x, bounds.x.min, bounds.x.max - width);
    y = limitValue2(y, bounds.y.min, bounds.y.max - height);
    this.scroller.one("scroll", proxy(this._scrollEnd, this));
    this.scroller.scrollTo(-x, -y);
  };
  Map3.prototype._navigatorCenter = function _navigatorCenter() {
    this.center(this.options.center);
  };
  Map3.prototype._createZoomControl = function _createZoomControl(options2) {
    var element = this._createControlElement(options2, "topLeft");
    var zoomControl = this.zoomControl = new ZoomControl(element, options2);
    this._zoomControlChange = this._zoomControlChange.bind(this);
    zoomControl.bind("change", this._zoomControlChange);
  };
  Map3.prototype._zoomControlChange = function _zoomControlChange(e) {
    if (!this.trigger("zoomStart", { originalEvent: e })) {
      this.zoom(this.zoom() + e.delta);
      this.trigger("zoomEnd", {
        originalEvent: e
      });
    }
  };
  Map3.prototype._initScroller = function _initScroller() {
    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION2;
    var zoomable = this.options.zoomable !== false;
    var scroller = this.scroller = new Scroller(this.element.children[0], {
      friction,
      velocityMultiplier: VELOCITY_MULTIPLIER2,
      zoom: zoomable,
      mousewheelScrolling: false,
      supportDoubleTap: true
    });
    scroller.bind("scroll", proxy(this._scroll, this));
    scroller.bind("scrollEnd", proxy(this._scrollEnd, this));
    scroller.userEvents.bind("gesturestart", proxy(this._scaleStart, this));
    scroller.userEvents.bind("gestureend", proxy(this._scale, this));
    scroller.userEvents.bind("doubleTap", proxy(this._doubleTap, this));
    scroller.userEvents.bind("tap", proxy(this._tap, this));
    this.scrollElement = scroller.scrollElement;
  };
  Map3.prototype._initLayers = function _initLayers() {
    var this$1 = this;
    var defs = this.options.layers, layers = this.layers = [];
    for (var i = 0; i < defs.length; i++) {
      var options2 = defs[i];
      var layer = this$1._createLayer(options2);
      layers.push(layer);
    }
  };
  Map3.prototype._createLayer = function _createLayer(options2) {
    var type = options2.type || "shape";
    var layerDefaults = this.options.layerDefaults[type];
    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options2) : deepExtend({}, layerDefaults, options2);
    var layerConstructor = layersMap[type];
    var layer = new layerConstructor(this, layerOptions);
    if (type === MARKER) {
      this.markers = layer;
    }
    return layer;
  };
  Map3.prototype._createTooltip = function _createTooltip() {
    return new Tooltip2(this.widgetService, this.options.tooltip);
  };
  Map3.prototype._initMarkers = function _initMarkers() {
    var markerLayers = (this.options.layers || []).filter(function(x) {
      return x && x.type === MARKER;
    });
    if (markerLayers.length > 0) {
      return;
    }
    this.markers = new MarkerLayer(this, this.options.markerDefaults);
    this.markers.add(this.options.markers);
  };
  Map3.prototype._scroll = function _scroll(e) {
    var origin = this.locationToLayer(this._viewOrigin).round();
    var movable = e.sender.movable;
    var offset = new geometry_exports.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);
    origin.x += offset.x;
    origin.y += offset.y;
    this._scrollOffset = offset;
    this._tooltip.offset = offset;
    this.hideTooltip();
    this._setOrigin(this.layerToLocation(origin));
    this.trigger("pan", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._scrollEnd = function _scrollEnd(e) {
    if (!this._scrollOffset || !this._panComplete()) {
      return;
    }
    this._scrollOffset = null;
    this._panEndTimestamp = now2();
    this.trigger("panEnd", {
      originalEvent: e,
      origin: this._getOrigin(),
      center: this.center()
    });
  };
  Map3.prototype._panComplete = function _panComplete() {
    return now2() - (this._panEndTimestamp || 0) > 50;
  };
  Map3.prototype._scaleStart = function _scaleStart(e) {
    if (this.trigger("zoomStart", { originalEvent: e })) {
      var touch = e.touches[1];
      if (touch) {
        touch.cancel();
      }
    }
  };
  Map3.prototype._scale = function _scale(e) {
    var scale = this.scroller.movable.scale;
    var zoom = this._scaleToZoom(scale);
    var gestureCenter = new geometry_exports.Point(e.center.x, e.center.y);
    var centerLocation = this.viewToLocation(gestureCenter, zoom);
    var centerPoint = this.locationToLayer(centerLocation, zoom);
    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);
    this._zoomAround(originPoint, zoom);
    this.trigger("zoomEnd", {
      originalEvent: e
    });
  };
  Map3.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {
    var scale = this._layerSize() * scaleDelta;
    var tiles = scale / this.options.minSize;
    var zoom = math5.log(tiles) / math5.log(2);
    return math5.round(zoom);
  };
  Map3.prototype._reset = function _reset() {
    if (this.attribution) {
      this.attribution.filter(this.center(), this.zoom());
    }
    this._viewOrigin = this._getOrigin(true);
    this._resetScroller();
    this.hideTooltip();
    this.trigger("beforeReset");
    this.trigger("reset");
  };
  Map3.prototype._resetScroller = function _resetScroller() {
    var scroller = this.scroller;
    var x = scroller.dimensions.x;
    var y = scroller.dimensions.y;
    var scale = this._layerSize();
    var nw = this.extent().nw;
    var topLeft = this.locationToLayer(nw).round();
    scroller.movable.round = true;
    scroller.reset();
    scroller.userEvents.cancel();
    var zoom = this.zoom();
    scroller.dimensions.forcedMinScale = pow4(2, this.options.minZoom - zoom);
    scroller.dimensions.maxScale = pow4(2, this.options.maxZoom - zoom);
    var xBounds = {
      min: -topLeft.x,
      max: scale - topLeft.x
    };
    var yBounds = {
      min: -topLeft.y,
      max: scale - topLeft.y
    };
    if (this.options.wraparound) {
      xBounds.max = 20 * scale;
      xBounds.min = -xBounds.max;
    }
    if (this.options.pannable === false) {
      var viewSize = this.viewSize();
      xBounds.min = yBounds.min = 0;
      xBounds.max = viewSize.width;
      yBounds.max = viewSize.height;
    }
    x.makeVirtual();
    y.makeVirtual();
    x.virtualSize(xBounds.min, xBounds.max);
    y.virtualSize(yBounds.min, yBounds.max);
    this._virtualSize = {
      x: xBounds,
      y: yBounds
    };
  };
  Map3.prototype._renderLayers = function _renderLayers() {
  };
  Map3.prototype._layerSize = function _layerSize(zoom) {
    var newZoom = valueOrDefault2(zoom, this.options.zoom);
    return this.options.minSize * pow4(2, newZoom);
  };
  Map3.prototype._tap = function _tap(e) {
    if (!this._panComplete()) {
      return;
    }
    var cursor = this.eventOffset(e);
    this.hideTooltip();
    this.trigger("click", {
      originalEvent: e,
      location: this.viewToLocation(cursor)
    });
  };
  Map3.prototype._doubleTap = function _doubleTap(e) {
    var options2 = this.options;
    if (options2.zoomable !== false) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._mousewheel = function _mousewheel(e) {
    e.preventDefault();
    var delta = mousewheelDelta(e) > 0 ? -1 : 1;
    var options2 = this.options;
    var fromZoom = this.zoom();
    var toZoom = limitValue2(fromZoom + delta, options2.minZoom, options2.maxZoom);
    if (options2.zoomable !== false && toZoom !== fromZoom) {
      if (!this.trigger("zoomStart", { originalEvent: e })) {
        var cursor = this.eventOffset(e);
        var location = this.viewToLocation(cursor);
        var postZoom = this.locationToLayer(location, toZoom);
        var origin = postZoom.translate(-cursor.x, -cursor.y);
        this._zoomAround(origin, toZoom);
        this.trigger("zoomEnd", {
          originalEvent: e
        });
      }
    }
  };
  Map3.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point2) {
    var offset = elementOffset2(this.element);
    return {
      left: round3(point2.x + offset.left),
      top: round3(point2.y + offset.top)
    };
  };
  return Map3;
}(Observable2);
setDefaultOptions(Map2, {
  name: "Map",
  controls: {
    attribution: true,
    navigator: {
      panStep: 100
    },
    zoom: true
  },
  layers: [],
  layerDefaults: {
    shape: {
      style: {
        fill: {
          color: "#fff"
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    bubble: {
      style: {
        fill: {
          color: "#fff",
          opacity: 0.5
        },
        stroke: {
          color: "#aaa",
          width: 0.5
        }
      }
    },
    marker: {
      shape: "pinTarget",
      tooltip: {
        position: "top"
      }
    }
  },
  center: [
    0,
    0
  ],
  zoom: 3,
  minSize: 256,
  minZoom: 1,
  maxZoom: 19,
  markers: [],
  markerDefaults: {
    shape: "pinTarget",
    tooltip: {
      position: "top"
    }
  },
  wraparound: true,
  // If set to true, GeoJSON layer "Point" features will be rendered as markers.
  // Otherwise, the points will be rendered as circles.
  // Defaults to `true` for KUI/jQuery, `false` everywhere else.
  renderPointsAsMarkers: false
});
setDefaultEvents(Map2, [
  "beforeReset",
  "click",
  "markerActivate",
  "markerClick",
  "markerCreated",
  // Events for implementing custom tooltips.
  "markerMouseEnter",
  "markerMouseLeave",
  "pan",
  "panEnd",
  "reset",
  "shapeClick",
  "shapeCreated",
  "shapeFeatureCreated",
  "shapeMouseEnter",
  "shapeMouseLeave",
  "zoomEnd",
  "zoomStart"
]);

// node_modules/@progress/kendo-charts/dist/es/chart/base-theme.js
var BAR_GAP = 1.5;
var BAR_SPACING = 0.4;
var BLACK2 = "#000";
var SANS = "Arial, Helvetica, sans-serif";
var SANS11 = "11px " + SANS;
var SANS12 = "12px " + SANS;
var SANS16 = "16px " + SANS;
var TRANSPARENT = "transparent";
var WHITE2 = "#fff";
var notes = function() {
  return {
    icon: {
      border: {
        width: 1
      }
    },
    label: {
      font: SANS12,
      padding: 3
    },
    line: {
      length: 10,
      width: 2
    },
    visible: true
  };
};
var axisDefaults = function() {
  return {
    labels: {
      font: SANS12
    },
    notes: notes(),
    title: {
      font: SANS16,
      margin: 5
    }
  };
};
var areaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.4
  };
};
var rangeAreaSeries = function() {
  return {
    highlight: {
      markers: {
        border: {}
      }
    },
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.4
  };
};
var barSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var boxPlotSeries = function() {
  return {
    outliersField: "",
    meanField: "",
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      whiskers: {
        width: 3
      },
      mean: {
        width: 2
      },
      median: {
        width: 2
      }
    },
    mean: {
      width: 2
    },
    median: {
      width: 2
    },
    spacing: 0.3,
    whiskers: {
      width: 2
    }
  };
};
var bubbleSeries = function() {
  return {
    border: {
      width: 0
    },
    labels: {
      background: TRANSPARENT
    },
    opacity: 0.6
  };
};
var bulletSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING,
    target: {
      color: "#ff0000"
    }
  };
};
var candlestickSeries = function() {
  return {
    border: {
      _brightness: 0.8,
      width: 1
    },
    downColor: WHITE2,
    gap: 1,
    highlight: {
      border: {
        opacity: 1,
        width: 2
      },
      line: {
        width: 2
      }
    },
    line: {
      color: BLACK2,
      width: 1
    },
    spacing: 0.3
  };
};
var columnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var donutSeries = function() {
  return {
    margin: 1
  };
};
var lineSeries = function() {
  return {
    width: 2
  };
};
var ohlcSeries = function() {
  return {
    gap: 1,
    highlight: {
      line: {
        opacity: 1,
        width: 3
      }
    },
    line: {
      width: 1
    },
    spacing: 0.3
  };
};
var radarAreaSeries = function() {
  return {
    line: {
      opacity: 1,
      width: 0
    },
    markers: {
      size: 6,
      visible: false
    },
    opacity: 0.5
  };
};
var radarLineSeries = function() {
  return {
    markers: {
      visible: false
    },
    width: 2
  };
};
var rangeBarSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var rangeColumnSeries = function() {
  return {
    gap: BAR_GAP,
    spacing: BAR_SPACING
  };
};
var scatterLineSeries = function() {
  return {
    width: 1
  };
};
var waterfallSeries = function() {
  return {
    gap: 0.5,
    line: {
      color: BLACK2,
      width: 1
    },
    spacing: BAR_SPACING
  };
};
var pieSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    }
  };
};
var funnelSeries = function() {
  return {
    labels: {
      background: "",
      color: "",
      padding: {
        top: 5,
        bottom: 5,
        left: 7,
        right: 7
      }
    }
  };
};
var heatmapSeries = function() {
  return {
    labels: {
      color: "",
      background: TRANSPARENT,
      visible: true
    },
    highlight: {
      border: {
        width: 0
      }
    }
  };
};
var seriesDefaults = function(options2) {
  return {
    visible: true,
    labels: {
      font: SANS11
    },
    overlay: options2.gradients ? {} : {
      gradient: "none"
    },
    area: areaSeries(),
    rangeArea: rangeAreaSeries(),
    verticalRangeArea: rangeAreaSeries(),
    bar: barSeries(),
    boxPlot: boxPlotSeries(),
    bubble: bubbleSeries(),
    bullet: bulletSeries(),
    candlestick: candlestickSeries(),
    column: columnSeries(),
    heatmap: heatmapSeries(),
    pie: pieSeries(),
    donut: donutSeries(),
    funnel: funnelSeries(),
    horizontalWaterfall: waterfallSeries(),
    line: lineSeries(),
    notes: notes(),
    ohlc: ohlcSeries(),
    radarArea: radarAreaSeries(),
    radarLine: radarLineSeries(),
    polarArea: radarAreaSeries(),
    polarLine: radarLineSeries(),
    rangeBar: rangeBarSeries(),
    rangeColumn: rangeColumnSeries(),
    scatterLine: scatterLineSeries(),
    verticalArea: areaSeries(),
    verticalBoxPlot: boxPlotSeries(),
    verticalBullet: bulletSeries(),
    verticalLine: lineSeries(),
    waterfall: waterfallSeries()
  };
};
var title = function() {
  return {
    font: SANS16
  };
};
var subtitle = function() {
  return {
    font: SANS12
  };
};
var legend = function() {
  return {
    labels: {
      font: SANS12
    }
  };
};
var baseTheme = function(options2) {
  if (options2 === void 0)
    options2 = {};
  return {
    axisDefaults: axisDefaults(),
    categoryAxis: {
      majorGridLines: {
        visible: true
      }
    },
    navigator: {
      pane: {
        height: 90,
        margin: {
          top: 10
        }
      }
    },
    seriesDefaults: seriesDefaults(options2),
    title: title(),
    subtitle: subtitle(),
    legend: legend()
  };
};

// node_modules/@progress/kendo-react-gauges/dist/es/theming/theme-service.js
var template2 = '\n    <div class="k-var--gauge-pointer"></div>\n    <div class="k-var--gauge-track"></div>\n    <div class="k-var--normal-text-color"></div>\n';
var ThemeService = (
  /** @class */
  function() {
    function ThemeService2(store) {
      this.store = store;
    }
    ThemeService2.prototype.setStyle = function(field, value) {
      this.store.dispatch({ type: "set", payload: { field, value } });
    };
    ThemeService2.prototype.setColors = function() {
      this.mapColor("pointer.color", "gauge-pointer");
      this.mapColor("scale.rangePlaceholderColor", "gauge-track");
      this.mapColor("scale.labels.color", "normal-text-color");
      this.mapColor("scale.minorTicks.color", "normal-text-color");
      this.mapColor("scale.majorTicks.color", "normal-text-color");
      this.mapColor("scale.line.color", "normal-text-color");
    };
    ThemeService2.prototype.mapColor = function(key, varName) {
      this.setStyle(key, this.queryStyle(varName).backgroundColor);
    };
    ThemeService2.prototype.queryStyle = function(varName) {
      var element = this.element;
      return window.getComputedStyle(element.querySelector(".k-var--".concat(varName)));
    };
    return ThemeService2;
  }()
);
var loadTheme = function(store, done, doc) {
  var service = new ThemeService(store);
  if (typeof doc === "undefined") {
    store.dispatch({ type: "push", payload: baseTheme() });
    return;
  }
  var container = service.element = doc.createElement("div");
  container.style.display = "none";
  container.innerHTML = template2;
  doc.body.appendChild(container);
  try {
    store.dispatch({ type: "push", payload: baseTheme() });
    service.setColors();
  } finally {
    doc.body.removeChild(service.element);
    delete service.element;
    done();
  }
};

// node_modules/@progress/kendo-react-common/dist/es/contexts/ZIndexContext.js
var React6 = __toESM(require_react());
var ZIndexContext = React6.createContext(0);
ZIndexContext.displayName = "KendoReactZIndexContext";

// node_modules/@progress/kendo-react-common/dist/es/browser-support.service.js
var getDocument = function() {
  return typeof document !== "undefined" ? document : {};
};
var BrowserSupportService = (
  /** @class */
  function() {
    function BrowserSupportService2() {
      this.scrollbar = 0;
    }
    Object.defineProperty(BrowserSupportService2.prototype, "scrollbarWidth", {
      get: function() {
        var document2 = getDocument();
        if (!this.scrollbar && document2 && document2.createElement) {
          var div = document2.createElement("div");
          div.style.cssText = "overflow:scroll;overflow-x:hidden;zoom:1;clear:both;display:block";
          div.innerHTML = "&nbsp;";
          document2.body.appendChild(div);
          this.scrollbar = div.offsetWidth - div.scrollWidth;
          document2.body.removeChild(div);
        }
        return this.scrollbar;
      },
      enumerable: false,
      configurable: true
    });
    return BrowserSupportService2;
  }()
);

// node_modules/@progress/kendo-react-common/dist/es/canUseDOM.js
var canUseDOM = Boolean(
  // from fbjs
  typeof window !== "undefined" && window.document && window.document.createElement
);

// node_modules/@progress/kendo-react-common/dist/es/classNames.js
var classNames = function() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var result = {};
  var addLeafKeys = function(arg) {
    return typeof arg === "object" ? Object.keys(arg).forEach(function(key) {
      result[key] = arg[key];
    }) : result[arg] = true;
  };
  ;
  var addKeys = function(list) {
    return list.filter(function(arg) {
      return arg !== true && !!arg;
    }).map(function(arg) {
      return Array.isArray(arg) ? addKeys(arg) : addLeafKeys(arg);
    });
  };
  ;
  addKeys(args);
  return Object.keys(result).map(function(key) {
    return result[key] && key || null;
  }).filter(function(el) {
    return el !== null;
  }).join(" ");
};

// node_modules/@progress/kendo-react-common/dist/es/clone.js
var React7 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/FormComponent.js
var FormComponent = (
  /** @class */
  function() {
    function FormComponent2() {
    }
    return FormComponent2;
  }()
);

// node_modules/@progress/kendo-react-common/dist/es/getter.js
var getterCache2 = {};
getterCache2.undefined = function() {
  return void 0;
};

// node_modules/@progress/kendo-react-common/dist/es/noop.js
var noop2 = function() {
};

// node_modules/@progress/kendo-react-common/dist/es/setter.js
var setterCache = {};
setterCache.undefined = function(obj) {
  return obj;
};

// node_modules/@progress/kendo-react-common/dist/es/validate-package.js
function validatePackage2(packageMetadata3) {
  if (typeof index_esm_exports !== "undefined") {
    validatePackage(packageMetadata3);
  } else {
    var message = "License activation failed for ".concat(packageMetadata3.name, "\n");
    message += "The @progress/kendo-licensing script is not loaded.\n";
    message += "See ".concat(packageMetadata3.licensingDocsUrl, " for more information.\n");
    console.warn(message);
  }
}

// node_modules/@progress/kendo-react-common/dist/es/hocs/AsyncFocusBlur.js
var React9 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useAsyncFocusBlur.js
var React8 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hocs/withPropsContext.js
var React11 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/usePropsContext.js
var React10 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDir.js
var React12 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useRtl.js
var React13 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useMouse.js
var React14 = __toESM(require_react());
var useMouse = function(props, target, extend15) {
  if (extend15 === void 0) {
    extend15 = {};
  }
  var handleMouseDown = React14.useCallback(function(event) {
    if (extend15.onMouseDown) {
      extend15.onMouseDown.call(void 0, event);
    }
    if (props.onMouseDown) {
      props.onMouseDown.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseDown, props.onMouseDown, target]);
  var handleMouseUp = React14.useCallback(function(event) {
    if (extend15.onMouseUp) {
      extend15.onMouseUp.call(void 0, event);
    }
    if (props.onMouseUp) {
      props.onMouseUp.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseUp, props.onMouseUp, target]);
  var handleClick = React14.useCallback(function(event) {
    if (extend15.onClick) {
      extend15.onClick.call(void 0, event);
    }
    if (props.onClick) {
      props.onClick.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onClick, props.onClick, target]);
  var handleDoubleClick = React14.useCallback(function(event) {
    if (extend15.onDoubleClick) {
      extend15.onDoubleClick.call(void 0, event);
    }
    if (props.onDoubleClick) {
      props.onDoubleClick.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onDoubleClick, props.onDoubleClick, target]);
  var handleMouseEnter = React14.useCallback(function(event) {
    if (extend15.onMouseEnter) {
      extend15.onMouseEnter.call(void 0, event);
    }
    if (props.onMouseEnter) {
      props.onMouseEnter.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseEnter, props.onMouseEnter, target]);
  var handleMouseLeave = React14.useCallback(function(event) {
    if (extend15.onMouseLeave) {
      extend15.onMouseLeave.call(void 0, event);
    }
    if (props.onMouseLeave) {
      props.onMouseLeave.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseLeave, props.onMouseLeave, target]);
  var handelMouseMove = React14.useCallback(function(event) {
    if (extend15.onMouseMove) {
      extend15.onMouseMove.call(void 0, event);
    }
    if (props.onMouseMove) {
      props.onMouseMove.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseMove, props.onMouseMove, target]);
  var handleMouseOut = React14.useCallback(function(event) {
    if (extend15.onMouseOut) {
      extend15.onMouseOut.call(void 0, event);
    }
    if (props.onMouseOut) {
      props.onMouseOut.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseOut, props.onMouseOut, target]);
  var handleMouseOver = React14.useCallback(function(event) {
    if (extend15.onMouseOver) {
      extend15.onMouseOver.call(void 0, event);
    }
    if (props.onMouseOver) {
      props.onMouseOver.call(void 0, {
        target: target.current,
        syntheticEvent: event
      });
    }
  }, [extend15.onMouseOver, props.onMouseOver, target]);
  return {
    onClick: handleClick,
    onMouseUp: handleMouseUp,
    onMouseDown: handleMouseDown,
    onDoubleClick: handleDoubleClick,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    onMouseMove: handelMouseMove,
    onMouseOut: handleMouseOut,
    onMouseOver: handleMouseOver
  };
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useCollection.js
var React15 = __toESM(require_react());
var COLLECTION_ACTION;
(function(COLLECTION_ACTION2) {
  COLLECTION_ACTION2[COLLECTION_ACTION2["add"] = 0] = "add";
  COLLECTION_ACTION2[COLLECTION_ACTION2["remove"] = 1] = "remove";
})(COLLECTION_ACTION || (COLLECTION_ACTION = {}));
var useCollection = function(initial) {
  if (initial === void 0) {
    initial = [];
  }
  var collection = React15.useRef(initial);
  var handleCollectionAction = React15.useCallback(function(action) {
    switch (action.type) {
      case COLLECTION_ACTION.add:
        collection.current.push(action.item);
        break;
      case COLLECTION_ACTION.remove:
        var index = collection.current.indexOf(action.item);
        collection.current.splice(index, 1);
        break;
      default:
        break;
    }
  }, []);
  return [collection.current, handleCollectionAction];
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDocument.js
var React16 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useWindow.js
var React17 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/icons/Icon.js
var React18 = __toESM(require_react());
var PropTypes3 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-common/dist/es/icons/constants.js
var SIZE_CLASSES = {
  "default": "",
  "xsmall": "k-icon-xs",
  "small": "k-icon-sm",
  "medium": "k-icon-md",
  "large": "k-icon-lg",
  "xlarge": "k-icon-xl"
};

// node_modules/@progress/kendo-react-common/dist/es/icons/Icon.js
var __assign3 = function() {
  __assign3 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign3.apply(this, arguments);
};
var __rest = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var Icon = React18.forwardRef(function(props, ref2) {
  var className = props.className, name3 = props.name, themeColor = props.themeColor, size = props.size, flip = props.flip, style = props.style, id = props.id, tabIndex = props.tabIndex, others = __rest(props, ["className", "name", "themeColor", "size", "flip", "style", "id", "tabIndex"]);
  var target = React18.useRef(null);
  var elementRef = React18.useRef(null);
  React18.useImperativeHandle(target, function() {
    return {
      element: elementRef.current
    };
  });
  React18.useImperativeHandle(ref2, function() {
    return target.current;
  });
  var sizeProp = React18.useMemo(function() {
    return size || defaultProps.size;
  }, [size]);
  var flipProp = React18.useMemo(function() {
    return flip || defaultProps.flip;
  }, [flip]);
  var fontClassNames = React18.useMemo(function() {
    var _a;
    return classNames("k-icon", name3 && toIconClass(name3), (_a = {}, _a["k-color-".concat(themeColor)] = themeColor, _a["k-flip-h"] = flipProp === "horizontal" || flipProp === "both", _a["k-flip-v"] = flipProp === "vertical" || flipProp === "both", _a), SIZE_CLASSES[sizeProp], className);
  }, [name3, themeColor, sizeProp, flipProp, className]);
  var mouseProps = useMouse(props, target);
  return React18.createElement("span", __assign3({ ref: elementRef }, others, mouseProps, { className: fontClassNames, id, tabIndex, style, role: "presentation" }));
});
Icon.propTypes = {
  style: PropTypes3.object,
  classNames: PropTypes3.string,
  name: PropTypes3.string,
  themeColor: PropTypes3.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: PropTypes3.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge"]),
  flip: PropTypes3.oneOf(["default", "horizontal", "vertical", "both"])
};
var defaultProps = {
  size: "default",
  flip: "default"
};
Icon.displayName = "KendoIcon";

// node_modules/@progress/kendo-react-common/dist/es/icons/SvgIcon.js
var React19 = __toESM(require_react());
var PropTypes4 = __toESM(require_prop_types());
var __assign4 = function() {
  __assign4 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign4.apply(this, arguments);
};
var __rest2 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var SvgIcon = React19.forwardRef(function(props, ref2) {
  var children = props.children, className = props.className, svgClassName = props.svgClassName, icon = props.icon, flip = props.flip, id = props.id, tabIndex = props.tabIndex, size = props.size, style = props.style, svgStyle = props.svgStyle, themeColor = props.themeColor, viewBox = props.viewBox, name3 = props.name, others = __rest2(props, ["children", "className", "svgClassName", "icon", "flip", "id", "tabIndex", "size", "style", "svgStyle", "themeColor", "viewBox", "name"]);
  var elementRef = React19.useRef(null);
  React19.useImperativeHandle(ref2, function() {
    return {
      element: elementRef.current
    };
  });
  var iconNameProp = React19.useMemo(function() {
    return icon ? icon.name : defaultProps2.icon;
  }, [icon]);
  var sizeProp = React19.useMemo(function() {
    return size || defaultProps2.size;
  }, [size]);
  var flipProp = React19.useMemo(function() {
    return flip || defaultProps2.flip;
  }, [flip]);
  var viewBoxProp = React19.useMemo(function() {
    return viewBox || defaultProps2.viewBox;
  }, [viewBox]);
  var elementClassNames = React19.useMemo(function() {
    var _a;
    return classNames("k-svg-icon", "k-svg-i-" + iconNameProp, (_a = {}, _a["k-color-".concat(themeColor)] = themeColor, _a["k-flip-h"] = flipProp === "horizontal" || flipProp === "both", _a["k-flip-v"] = flipProp === "vertical" || flipProp === "both", _a), SIZE_CLASSES[sizeProp], className);
  }, [iconNameProp, themeColor, sizeProp, flipProp, className]);
  var elementStyle = React19.useMemo(function() {
    if (props.width && props.height) {
      return __assign4({ width: props.width, height: props.height }, style);
    } else if (props.width) {
      return __assign4({ width: props.width, height: props.width }, style);
    } else if (props.height) {
      return __assign4({ width: props.height, height: props.height }, style);
    } else {
      return __assign4({}, style);
    }
  }, [props.width, props.height, style]);
  return React19.createElement(
    "span",
    { className: elementClassNames, style: elementStyle, ref: elementRef },
    React19.createElement("svg", __assign4({ id, className: svgClassName, style: svgStyle, "aria-hidden": true, tabIndex, focusable: false, xmlns: "http://www.w3.org/2000/svg", viewBox: icon ? icon.viewBox : viewBoxProp, dangerouslySetInnerHTML: icon ? { __html: icon.content } : void 0 }, others), icon ? void 0 : children)
  );
});
SvgIcon.propTypes = {
  style: PropTypes4.object,
  classNames: PropTypes4.string,
  children: PropTypes4.any,
  icon: PropTypes4.object,
  themeColor: PropTypes4.oneOf([
    "inherit",
    "primary",
    "secondary",
    "tertiary",
    "info",
    "success",
    "error",
    "warning",
    "dark",
    "light",
    "inverse"
  ]),
  size: PropTypes4.oneOf(["default", "xsmall", "small", "medium", "large", "xlarge"]),
  flip: PropTypes4.oneOf(["default", "horizontal", "vertical", "both"])
};
var defaultProps2 = {
  size: "default",
  flip: "default",
  icon: "",
  viewBox: "0 0 24 24"
};
SvgIcon.displayName = "KendoSvgIcon";

// node_modules/@progress/kendo-react-common/dist/es/icons/IconWrap.js
var React21 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/icons/IconsContext.js
var React20 = __toESM(require_react());
var IconsContext = React20.createContext({ type: "font" });
IconsContext.displayName = "KendoReactIconsContext";

// node_modules/@progress/kendo-react-common/dist/es/icons/IconWrap.js
var __assign5 = function() {
  __assign5 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign5.apply(this, arguments);
};
var __rest3 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var IconWrap = React21.forwardRef(function(props, ref2) {
  var _a;
  var _b = React21.useContext(IconsContext), type = _b.type, icons = _b.icons;
  var icon = props.icon, fontIconProps = __rest3(props, ["icon"]);
  var name3 = ((_a = props.icon) === null || _a === void 0 ? void 0 : _a.name) || props.name;
  var svg = name3 && icons && icons[name3] && typeof icons[name3] !== "string" ? icons[name3] : icon;
  name3 = name3 && icons && icons[name3] && typeof icons[name3] === "string" ? icons[name3] : name3;
  return type === "svg" && svg ? React21.createElement(SvgIcon, __assign5({}, props, { icon: svg, ref: ref2 })) : React21.createElement(Icon, __assign5({}, fontIconProps, { name: name3, ref: ref2 }));
});
IconWrap.displayName = "KendoIconWrap";

// node_modules/@progress/kendo-react-common/dist/es/icons/utils.js
var PropTypes5 = __toESM(require_prop_types());
var toIconClass = function(name3) {
  return "k-i-" + name3;
};
var svgIconPropType = PropTypes5.shape({
  name: PropTypes5.string.isRequired,
  content: PropTypes5.string.isRequired,
  viewBox: PropTypes5.string.isRequired
});

// node_modules/@progress/kendo-react-common/dist/es/typography/Typography.js
var React22 = __toESM(require_react());
var PropTypes6 = __toESM(require_prop_types());

// node_modules/@progress/kendo-react-common/dist/es/typography/constants.js
var FONT_SIZE_CLASSES = {
  "xsmall": "k-fs-xs",
  "small": "k-fs-sm",
  "medium": "k-fs-md",
  "large": "k-fs-lg",
  "xlarge": "k-fs-xl"
};
var FONT_WEIGHT_CLASSES = {
  "light": "k-font-weight-light",
  "normal": "k-font-weight-normal",
  "bold": "k-font-weight-bold"
};
var MARGIN_ENUM_CLASSES = {
  "xsmall": "k-m-xs",
  "small": "k-m-sm",
  "medium": "k-m-md",
  "large": "k-m-lg",
  "xlarge": "k-m-xl",
  "thin": "k-m-thin",
  "hair": "k-m-hair"
};
var MARGIN_ENUM_VALUES = {
  "xsmall": "xs",
  "small": "sm",
  "medium": "md",
  "large": "lg",
  "xlarge": "xl",
  "thin": "thin",
  "hair": "hair"
};
var MARGIN_SIDES_CLASSES = {
  "top": "k-mt-",
  "right": "k-mr-",
  "bottom": "k-mb-",
  "left": "k-ml-"
};
var TEXT_ALIGN_CLASSES = {
  "left": "k-text-left",
  "right": "k-text-right",
  "center": "k-text-center",
  "justify": "k-text-justify"
};
var TEXT_TRANSFORM_CLASSES = {
  "lowercase": "k-text-lowercase",
  "uppercase": "k-text-uppercase",
  "capitalize": "k-text-capitalize"
};
var THEME_COLOR_CLASSES = {
  "inherit": "k-color-inherit",
  "primary": "k-color-primary",
  "secondary": "k-color-secondary",
  "tertiary": "k-color-tertiary",
  "info": "k-color-info",
  "success": "k-color-success",
  "warning": "k-color-warning",
  "error": "k-color-error",
  "dark": "k-color-dark",
  "light": "k-color-light",
  "inverse": "k-color-inverse"
};

// node_modules/@progress/kendo-react-common/dist/es/typography/Typography.js
var __assign6 = function() {
  __assign6 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign6.apply(this, arguments);
};
var __rest4 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var generateTypography = function(element) {
  var component = React22.forwardRef(function(props, ref2) {
    var id = props.id, style = props.style, className = props.className, fontSize = props.fontSize, fontWeight = props.fontWeight, textAlign = props.textAlign, textTransform = props.textTransform, themeColor = props.themeColor, margin = props.margin, others = __rest4(props, ["id", "style", "className", "fontSize", "fontWeight", "textAlign", "textTransform", "themeColor", "margin"]);
    var target = React22.useRef(null);
    var elementRef = React22.useRef(null);
    React22.useImperativeHandle(target, function() {
      return {
        element: elementRef.current,
        props
      };
    });
    React22.useImperativeHandle(ref2, function() {
      return target.current;
    });
    var defaultClass = function() {
      var classMap = element === "p" ? "paragraph" : element;
      return "k-".concat(classMap);
    };
    var Component8 = element;
    var setMarginClassPerSide = function(marginSide, value) {
      var val = typeof value === "string" ? MARGIN_ENUM_VALUES[value] : value;
      return "".concat(MARGIN_SIDES_CLASSES[marginSide]).concat(val);
    };
    var setMarginClasses = function() {
      if (margin === void 0) {
        return;
      }
      if (typeof margin === "string") {
        return [MARGIN_ENUM_CLASSES[margin]];
      }
      if (typeof margin === "number" && margin >= 0 && margin <= 24) {
        return ["k-m-".concat(margin)];
      }
      if (typeof margin === "object") {
        var marginClassesList_1 = [];
        Object.keys(margin).forEach(function(key) {
          if (margin[key] !== null && margin[key] !== void 0) {
            marginClassesList_1.push(setMarginClassPerSide(key, margin[key]));
          }
        });
        var classes = marginClassesList_1.join(" ");
        return classes;
      }
    };
    var setTypographyClasses = function() {
      var typographyArray = [
        defaultClass(),
        FONT_SIZE_CLASSES[fontSize],
        FONT_WEIGHT_CLASSES[fontWeight],
        TEXT_ALIGN_CLASSES[textAlign],
        TEXT_TRANSFORM_CLASSES[textTransform],
        THEME_COLOR_CLASSES[themeColor],
        setMarginClasses(),
        className
      ];
      var typographyClasses = typographyArray.filter(function(n) {
        return n !== void 0;
      }).join(" ");
      return typographyClasses;
    };
    return React22.createElement(Component8, __assign6({ id, ref: elementRef, className: setTypographyClasses(), style }, others), props.children);
  });
  component.propTypes = {
    style: PropTypes6.object,
    className: PropTypes6.string,
    fontSize: PropTypes6.oneOf(["xsmall", "small", "medium", "large", "xlarge"]),
    fontWeight: PropTypes6.oneOf(["light", "normal", "bold"]),
    margin: PropTypes6.oneOfType([
      PropTypes6.number,
      PropTypes6.object,
      PropTypes6.oneOf(["xsmall", "small", "medium", "large", "xlarge", "thin", "hair"])
    ]),
    textAlign: PropTypes6.oneOf(["left", "right", "center", "justify"]),
    textTransform: PropTypes6.oneOf(["lowercase", "uppercase", "capitalize"]),
    themeColor: PropTypes6.oneOf([
      "inherit",
      "primary",
      "secondary",
      "tertiary",
      "info",
      "success",
      "error",
      "warning",
      "dark",
      "light",
      "inverse"
    ])
  };
  component.displayName = "KendoReactTypography".concat(element.toUpperCase());
  return component;
};
var h1 = generateTypography("h1");
var h2 = generateTypography("h2");
var h3 = generateTypography("h3");
var h4 = generateTypography("h4");
var h5 = generateTypography("h5");
var h6 = generateTypography("h6");
var p = generateTypography("p");
var code = generateTypography("code");
var pre = generateTypography("pre");

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/index.js
var React28 = __toESM(require_react());

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDraggable.js
var React25 = __toESM(require_react());

// node_modules/@progress/kendo-draggable-common/dist/es/algorithms/intersect.js
var getRatio = function(element, target) {
  var elementRect = element.getBoundingClientRect();
  var targetRect = target.getBoundingClientRect();
  var top = Math.max(targetRect.top, elementRect.top);
  var left = Math.max(targetRect.left, elementRect.left);
  var right = Math.min(targetRect.left + targetRect.width, elementRect.left + elementRect.width);
  var bottom = Math.min(targetRect.top + targetRect.height, elementRect.top + elementRect.height);
  var width = right - left;
  var height = bottom - top;
  if (left < right && top < bottom) {
    var targetArea = targetRect.width * targetRect.height;
    var entryArea = elementRect.width * elementRect.height;
    var intersectionArea = width * height;
    var intersectionRatio = intersectionArea / (targetArea + entryArea - intersectionArea);
    return Number(intersectionRatio.toFixed(4));
  }
  return 0;
};
var intersect = function(element, candidates) {
  var max2 = 0;
  var result = null;
  candidates.forEach(function(candidate) {
    if (candidate && element) {
      var ration = getRatio(element, candidate);
      if (ration > max2) {
        max2 = ration;
        result = candidate;
      }
    }
  });
  return result;
};

// node_modules/@progress/kendo-draggable-common/dist/es/utils/index.js
var detectBrowser2 = function() {
  var ua = window && window.navigator.userAgent;
  if (!ua) {
    return false;
  }
  var browser7 = false;
  var match = [];
  var browserRxs = {
    edge: /(edge)[ \/]([\w.]+)/i,
    webkit: /(chrome|crios)[ \/]([\w.]+)/i,
    safari: /(webkit)[ \/]([\w.]+)/i,
    opera: /(opera)(?:.*version|)[ \/]([\w.]+)/i,
    msie: /(msie\s|trident.*? rv:)([\w.]+)/i,
    mozilla: /(mozilla)(?:.*? rv:([\w.]+)|)/i
  };
  for (var agent in browserRxs) {
    if (browserRxs.hasOwnProperty(agent)) {
      match = ua.match(browserRxs[agent]);
      if (match) {
        browser7 = {};
        browser7[agent] = true;
        browser7[match[1].toLowerCase().split(" ")[0].split("/")[0]] = true;
        browser7.version = parseInt(document.DOCUMENT_NODE || match[2], 10);
        break;
      }
    }
  }
  return browser7;
};
var getDocument2 = function(element) {
  return element ? element.ownerDocument || window.document : window.document;
};
var getWindow = function(element) {
  var document2 = getDocument2(element);
  return document2 ? document2.defaultView || window : window;
};
var scrollableRoot = function(element) {
  var support3 = { browser: detectBrowser2() };
  var document2 = getDocument2(element);
  return support3.browser.edge || support3.browser.safari ? document2.body : document2.documentElement;
};
var isScrollable = function(el) {
  if (el && el.className && typeof el.className === "string" && el.className.indexOf("k-auto-scrollable") > -1) {
    return true;
  }
  var overflow = window.getComputedStyle(el, "overflow").overflow;
  return overflow.indexOf("auto") > -1 || overflow.indexOf("scroll") > -1;
};
var getScrollableParent = function(el) {
  var root = scrollableRoot(el);
  if (!el || el === document.body || el === document.documentElement) {
    return root;
  }
  var parent = el;
  while (parent && parent !== document.body && parent.nodeType !== Node.DOCUMENT_FRAGMENT_NODE && parent.nodeType !== Node.DOCUMENT_NODE && !isScrollable(parent)) {
    parent = parent.parentNode;
  }
  if (parent && (parent === document.body || parent.nodeType === Node.DOCUMENT_FRAGMENT_NODE)) {
    return root;
  }
  return parent;
};
var autoScrollVelocity = function(mouseX, mouseY, rect) {
  var velocity = { x: 0, y: 0 };
  var AUTO_SCROLL_AREA = 50;
  if (mouseX - rect.left < AUTO_SCROLL_AREA) {
    velocity.x = -(AUTO_SCROLL_AREA - (mouseX - rect.left));
  } else if (rect.right - mouseX < AUTO_SCROLL_AREA) {
    velocity.x = AUTO_SCROLL_AREA - (rect.right - mouseX);
  }
  if (mouseY - rect.top < AUTO_SCROLL_AREA) {
    velocity.y = -(AUTO_SCROLL_AREA - (mouseY - rect.top));
  } else if (rect.bottom - mouseY < AUTO_SCROLL_AREA) {
    velocity.y = AUTO_SCROLL_AREA - (rect.bottom - mouseY);
  }
  return velocity;
};
var scrollableViewPort = function(el, window2) {
  var root = scrollableRoot(el);
  if (el === root) {
    return {
      top: root.scrollTop,
      left: root.scrollLeft,
      bottom: root.scrollTop + window2.innerHeight,
      right: root.scrollLeft + window2.innerWidth
    };
  } else {
    var rect = el.getBoundingClientRect();
    return {
      bottom: rect.top + rect.height,
      right: rect.left + rect.width,
      left: rect.left,
      top: rect.top
    };
  }
};
var isPointerInsideContainer = function(x, y, container) {
  var rect = container.getBoundingClientRect();
  return rect.top <= y && rect.left <= x && y <= rect.bottom && x <= rect.right;
};

// node_modules/@progress/kendo-draggable-common/dist/es/drag-n-drop.js
var DRAG_AND_DROP_DISPATCH_ACTION;
(function(DRAG_AND_DROP_DISPATCH_ACTION2) {
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_DOWN"] = "pointerdown";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_MOVE"] = "pointermove";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_UP"] = "pointerup";
  DRAG_AND_DROP_DISPATCH_ACTION2["POINTER_CANCEL"] = "pointercancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_DOWN"] = "mousedown";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_MOVE"] = "mousemove";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOUSE_UP"] = "mouseup";
  DRAG_AND_DROP_DISPATCH_ACTION2["CONTEXT_MENU"] = "contextmenu";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_START"] = "touchstart";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_MOVE"] = "touchmove";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_END"] = "touchend";
  DRAG_AND_DROP_DISPATCH_ACTION2["TOUCH_CANCEL"] = "touchcancel";
  DRAG_AND_DROP_DISPATCH_ACTION2["SCROLL"] = "scroll";
  DRAG_AND_DROP_DISPATCH_ACTION2["START"] = "KENDO_DRAG_AND_DROP_START";
  DRAG_AND_DROP_DISPATCH_ACTION2["MOVE"] = "KENDO_DRAG_AND_DROP_MOVE";
  DRAG_AND_DROP_DISPATCH_ACTION2["END"] = "KENDO_DRAG_AND_DROP_END";
  DRAG_AND_DROP_DISPATCH_ACTION2["CANCEL"] = "KENDO_DRAG_AND_DROP_CANCEL";
})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));
var isTouchEvent = function(event) {
  return /^touch/.test(event.type);
};
var isScrollEvent = function(event) {
  return /^(scroll)/.test(event.type);
};
var normalizeEvent = function(event, state) {
  return isTouchEvent(event) ? {
    pageX: event.changedTouches[0].pageX,
    pageY: event.changedTouches[0].pageY,
    clientX: event.changedTouches[0].clientX,
    clientY: event.changedTouches[0].clientY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    isTouch: true,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : isScrollEvent(event) ? {
    pageX: state.pageOffset.x,
    pageY: state.pageOffset.y,
    clientX: state.clientOffset.x,
    clientY: state.clientOffset.y,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    offsetX: state.offset.x,
    offsetY: state.offset.y,
    type: event.type,
    originalEvent: event,
    altKey: false,
    ctrlKey: false,
    shiftKey: false,
    metaKey: false
  } : {
    pageX: event.pageX,
    pageY: event.pageY,
    clientX: event.clientX,
    clientY: event.clientY,
    offsetX: event.offsetX,
    offsetY: event.offsetY,
    scrollX: state.scrollOffset.x,
    scrollY: state.scrollOffset.y,
    type: event.type,
    ctrlKey: event.ctrlKey,
    shiftKey: event.shiftKey,
    altKey: event.altKey,
    metaKey: event.metaKey,
    originalEvent: event
  };
};
var noop3 = function() {
};
var dispatchDragAndDrop = function(state, action, callbacks) {
  if (callbacks === void 0) {
    callbacks = {};
  }
  var _a = callbacks.onIsPressedChange, onIsPressedChange = _a === void 0 ? noop3 : _a, _b = callbacks.onIsScrollingChange, onIsScrollingChange = _b === void 0 ? noop3 : _b, _c = callbacks.onVelocityChange, onVelocityChange = _c === void 0 ? noop3 : _c, _d = callbacks.onOffsetChange, onOffsetChange = _d === void 0 ? noop3 : _d, _e = callbacks.onPageOffsetChange, onPageOffsetChange = _e === void 0 ? noop3 : _e, _f = callbacks.onClientOffsetChange, onClientOffsetChange = _f === void 0 ? noop3 : _f, _g = callbacks.onScrollOffsetChange, onScrollOffsetChange = _g === void 0 ? noop3 : _g, _h = callbacks.onInitialScrollOffsetChange, onInitialScrollOffsetChange = _h === void 0 ? noop3 : _h;
  var drag = action.payload;
  var element = drag.element;
  var hint = drag.hint;
  var autoScrollDirection = state.autoScrollDirection;
  var overrideScrollableParent = state.scrollableParent;
  var event = normalizeEvent(action.event, state);
  switch (event.type) {
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && (event.originalEvent.which && event.originalEvent.which > 1) || state.ignoreMouse) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.START: {
      var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);
      onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? { x: scrollableParent_1.scrollX, y: scrollableParent_1.scrollY } : { x: scrollableParent_1.scrollLeft, y: scrollableParent_1.scrollTop });
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      onOffsetChange({
        x: event.offsetX,
        y: event.offsetY
      });
      onIsPressedChange(true);
      if (drag.onPress) {
        drag.onPress(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {
        break;
      }
      var scrollableParent = overrideScrollableParent || getScrollableParent(element);
      var scrollOffset = scrollableParent instanceof Window ? { x: scrollableParent.scrollX, y: scrollableParent.scrollY } : { x: scrollableParent.scrollLeft, y: scrollableParent.scrollTop };
      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;
      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;
      onScrollOffsetChange({
        x: event.scrollX,
        y: event.scrollY
      });
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE: {
      if (state.pressed) {
        if (state.autoScroll && event.originalEvent.type !== "scroll") {
          if (element) {
            var document_1 = getDocument2(element);
            var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));
            var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));
            onVelocityChange({
              x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,
              y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y
            });
            onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);
          }
        }
        if (!state.drag && drag.onDragStart) {
          drag.onDragStart(event);
        }
        if (drag.onDrag) {
          drag.onDrag(event);
        }
        var dropElement_1 = intersect(hint || element, state.drops.map(function(drop2) {
          return drop2 && drop2.element;
        }).filter(function(d) {
          return d !== (hint || element);
        }));
        var drop = state.drops.find(function(drop2) {
          return drop2.element === dropElement_1;
        });
        if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {
          if ((state.drop && state.drop.element) !== dropElement_1) {
            if (state.drop && state.drop.onDragLeave) {
              state.drop.onDragLeave(event);
            }
            if (drop.onDragEnter) {
              drop.onDragEnter(event);
            }
          } else {
            if (drop.onDragOver) {
              drop.onDragOver(event);
            }
          }
        } else if (state.drop && state.drop.onDragLeave) {
          state.drop.onDragLeave(event);
        }
      }
      onClientOffsetChange({
        x: event.clientX,
        y: event.clientY
      });
      onPageOffsetChange({
        x: event.pageX,
        y: event.pageY
      });
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:
      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {
        break;
      }
    case DRAG_AND_DROP_DISPATCH_ACTION.END: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onRelease) {
        drag.onRelease(event);
      }
      if (state.drop && state.drop.onDrop) {
        state.drop.onDrop(event);
      }
      if (state.drag && drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      break;
    }
    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:
    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:
    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL: {
      onIsPressedChange(false);
      onIsScrollingChange(false);
      onScrollOffsetChange({ x: 0, y: 0 });
      if (drag.onDragEnd) {
        drag.onDragEnd(event);
      }
      if (state.drop && state.drop.onDragLeave) {
        state.drop.onDragLeave(event);
      }
      break;
    }
    default:
      break;
  }
};

// node_modules/@progress/kendo-draggable-common/dist/es/auto-scroll.js
var autoScroll = function(scrollableParent, vel) {
  if (!scrollableParent) {
    return;
  }
  var yIsScrollable;
  var xIsScrollable;
  var isRootNode = scrollableParent === scrollableRoot(scrollableParent);
  if (isRootNode) {
    yIsScrollable = document.body.scrollHeight > window.innerHeight;
    xIsScrollable = document.body.scrollWidth > window.innerWidth;
  } else {
    yIsScrollable = scrollableParent.offsetHeight <= scrollableParent.scrollHeight;
    xIsScrollable = scrollableParent.offsetWidth <= scrollableParent.scrollWidth;
  }
  var yDelta = scrollableParent.scrollTop + vel.y;
  var yInBounds = yIsScrollable && yDelta > 0 && yDelta < scrollableParent.scrollHeight;
  var xDelta = scrollableParent.scrollLeft + vel.x;
  var xInBounds = xIsScrollable && xDelta > 0 && xDelta < scrollableParent.scrollWidth;
  if (yInBounds) {
    scrollableParent.scrollTop += vel.y;
  } else if (yIsScrollable && yDelta < 0) {
    scrollableParent.scrollTop = 0;
  }
  if (xInBounds) {
    scrollableParent.scrollLeft += vel.x;
  } else if (xIsScrollable && xDelta < 0) {
    scrollableParent.scrollLeft = 0;
  }
};

// node_modules/@progress/kendo-react-common/dist/es/hooks/useInheritedState.js
var React23 = __toESM(require_react());
var useInheritedState = function(context2, defaultValue) {
  var _a = React23.useContext(context2), contextValue = _a[0], contextSetter = _a[1];
  var _b = React23.useState(defaultValue), localValue = _b[0], localSetter = _b[1];
  var value = contextValue !== void 0 ? contextValue : localValue;
  var handleValueChange = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    contextValue !== void 0 ? contextSetter.apply(void 0, args) : localSetter(args[0]);
  };
  return [
    value,
    handleValueChange
  ];
};

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/context/index.js
var React24 = __toESM(require_react());
var DragContext = React24.createContext([
  void 0,
  noop2
]);
var DropContext = React24.createContext([
  void 0,
  noop2
]);
var DragsContext = React24.createContext([[], noop2, noop2]);
var DropsContext = React24.createContext([[], noop2, noop2]);

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDraggable.js
var IGNORE_MOUSE_TIMEOUT = 2e3;
function useDraggable(ref2, callbacks, options2) {
  if (options2 === void 0) {
    options2 = {};
  }
  var _a = callbacks.onPress, onPress = _a === void 0 ? noop2 : _a, _b = callbacks.onRelease, onRelease = _b === void 0 ? noop2 : _b, _c = callbacks.onDragStart, onDragStart = _c === void 0 ? noop2 : _c, _d = callbacks.onDrag, onDrag = _d === void 0 ? noop2 : _d, _e = callbacks.onDragEnd, onDragEnd = _e === void 0 ? noop2 : _e;
  var _f = options2.hint, hint = _f === void 0 ? null : _f, _g = options2.mouseOnly, mouseOnly = _g === void 0 ? false : _g, _h = options2.autoScroll, autoScroll2 = _h === void 0 ? true : _h, _j = options2.scrollContainer, scrollContainer = _j === void 0 ? null : _j;
  var _k = React25.useState(false), pressed = _k[0], setPressed = _k[1];
  var _l = React25.useState(false), scrolling = _l[0], setScrolling = _l[1];
  var drop = useInheritedState(DropContext)[0];
  var _m = useInheritedState(DragContext), drag = _m[0], setDrag = _m[1];
  var drops = React25.useContext(DropsContext)[0];
  var _o = React25.useContext(DragsContext), drags = _o[0], registerDrag = _o[1], deregisterDrag = _o[2];
  var velocity = React25.useRef({ x: 0, y: 0 });
  var scrollInterval = React25.useRef();
  var ignoreMouse = React25.useRef(false);
  var restoreMouseTimeout = React25.useRef();
  var scrollable = React25.useRef(null);
  var unmount = React25.useRef(false);
  var offset = React25.useRef({ x: 0, y: 0 });
  var pageOffset = React25.useRef({ x: 0, y: 0 });
  var clientOffset = React25.useRef({ x: 0, y: 0 });
  var initialClientOffset = React25.useRef({ x: 0, y: 0 });
  var scrollOffset = React25.useRef({ x: 0, y: 0 });
  var initialScrollOffset = React25.useRef({ x: 0, y: 0 });
  var supportPointerEvent = Boolean(typeof window !== "undefined" && window.PointerEvent);
  var pointers = !mouseOnly && supportPointerEvent;
  var getElement = React25.useCallback(function() {
    return ref2.current && ref2.current.element ? ref2.current.element : ref2.current;
  }, [ref2]);
  var getHintElement = React25.useCallback(function() {
    return hint && hint.current && hint.current.element ? hint.current.element : hint ? hint.current : null;
  }, [hint]);
  var getScrollContainer = React25.useCallback(function() {
    return scrollContainer && scrollContainer.current && scrollContainer.current.element ? scrollContainer.current.element : scrollContainer ? scrollContainer.current : null;
  }, [scrollContainer]);
  var getAutoScrollContainer = React25.useCallback(function() {
    return typeof autoScroll2 === "object" && autoScroll2.boundaryElementRef && autoScroll2.boundaryElementRef.current && autoScroll2.boundaryElementRef.current.element ? autoScroll2.boundaryElementRef.current.element : typeof autoScroll2 === "object" && autoScroll2.boundaryElementRef && autoScroll2.boundaryElementRef.current ? autoScroll2.boundaryElementRef.current : null;
  }, [autoScroll2]);
  var target = React25.useRef(null);
  React25.useImperativeHandle(target, function() {
    return {
      element: getElement(),
      hint: getHintElement(),
      onPress: handlePress,
      onDragStart: handleDragStart,
      onDrag: handleDrag,
      onDragEnd: handleDragEnd,
      onRelease: handleRelease,
      data: ref2.current
    };
  });
  var getDocument3 = React25.useCallback(function() {
    var element = getElement();
    return element ? element.ownerDocument || document : document;
  }, [getElement]);
  var getWindow2 = React25.useCallback(function() {
    var document2 = getDocument3();
    return document2 ? document2.defaultView || window : window;
  }, [getDocument3]);
  var getState = React25.useCallback(function() {
    return {
      drag: drag ? drag.current : null,
      drop: drop ? drop.current : null,
      drags: drags.map(function(d) {
        return d.current;
      }),
      drops: drops.map(function(d) {
        return d.current;
      }),
      pressed,
      ignoreMouse: ignoreMouse.current,
      scrollOffset: scrollOffset.current,
      offset: offset.current,
      pageOffset: pageOffset.current,
      initialScrollOffset: initialScrollOffset.current,
      clientOffset: clientOffset.current,
      initialClientOffset: initialClientOffset.current,
      velocity: velocity.current,
      autoScroll: Boolean(typeof autoScroll2 === "object" ? autoScroll2.enabled !== false : autoScroll2),
      scrollableParent: getAutoScrollContainer(),
      autoScrollDirection: typeof autoScroll2 === "object" ? autoScroll2.direction : { horizontal: true, vertical: true },
      isScrolling: scrolling
    };
  }, [drag, drop, drags, drops, pressed, autoScroll2, getAutoScrollContainer, scrolling]);
  var handlePressedChange = React25.useCallback(function(value) {
    setPressed(value);
  }, []);
  var handleScrollingChange = React25.useCallback(function(value) {
    setScrolling(value);
  }, []);
  var handleVelocityChange = React25.useCallback(function(value) {
    velocity.current = value;
  }, []);
  var handleOffsetChange = React25.useCallback(function(value) {
    offset.current = value;
  }, []);
  var handleClientOffsetChange = React25.useCallback(function(value) {
    clientOffset.current = value;
  }, []);
  var handlePageOffsetChange = React25.useCallback(function(value) {
    pageOffset.current = value;
  }, []);
  var handleInitialClientOffsetChange = React25.useCallback(function(value) {
    initialClientOffset.current = value;
  }, []);
  var handleScrollOffsetChange = React25.useCallback(function(value) {
    scrollOffset.current = value;
  }, []);
  var handleInitialScrollOffsetChange = React25.useCallback(function(value) {
    initialScrollOffset.current = value;
  }, []);
  var handlePress = React25.useCallback(function(event) {
    onPress(event);
  }, [onPress]);
  var handleRelease = React25.useCallback(function(event) {
    onRelease(event);
  }, [onRelease]);
  var handleDragStart = React25.useCallback(function(event) {
    setDrag(target, { target: ref2.current, event });
    onDragStart(event);
  }, [setDrag, ref2, onDragStart]);
  var handleDrag = React25.useCallback(function(event) {
    onDrag(event);
  }, [onDrag]);
  var handleDragEnd = React25.useCallback(function(event) {
    if (unmount.current) {
      return;
    }
    setDrag(null, { target: ref2.current, event });
    onDragEnd(event);
  }, [onDragEnd, setDrag, ref2]);
  var dispatchDragEvent = React25.useCallback(function(event) {
    dispatchDragAndDrop(getState(), { event, payload: target.current }, {
      onVelocityChange: handleVelocityChange,
      onOffsetChange: handleOffsetChange,
      onClientOffsetChange: handleClientOffsetChange,
      onPageOffsetChange: handlePageOffsetChange,
      onInitialClientOffsetChange: handleInitialClientOffsetChange,
      onScrollOffsetChange: handleScrollOffsetChange,
      onInitialScrollOffsetChange: handleInitialScrollOffsetChange,
      onIsPressedChange: handlePressedChange,
      onIsScrollingChange: handleScrollingChange
    });
  }, [
    getState,
    handleVelocityChange,
    handleOffsetChange,
    handlePageOffsetChange,
    handleClientOffsetChange,
    handleInitialClientOffsetChange,
    handleInitialScrollOffsetChange,
    handlePressedChange,
    handleScrollOffsetChange,
    handleScrollingChange
  ]);
  var handlePointerDown = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerMove = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerCancel = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handlePointerUp = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseDown = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseMove = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleMouseUp = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleContextMenu = React25.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchStart = React25.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchMove = React25.useCallback(function(event) {
    event.preventDefault();
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var handleTouchEnd = React25.useCallback(function(event) {
    if (event.touches.length === 0 && event.changedTouches.length === 1) {
      var currentWindow = getWindow2();
      ignoreMouse.current = true;
      restoreMouseTimeout.current = currentWindow.setTimeout(function() {
        ignoreMouse.current = false;
      }, IGNORE_MOUSE_TIMEOUT);
    }
    dispatchDragEvent(event);
  }, [dispatchDragEvent, getWindow2]);
  var handleScroll = React25.useCallback(function(event) {
    dispatchDragEvent(event);
  }, [dispatchDragEvent]);
  var prerequisites = React25.useCallback(function() {
    var element = getElement();
    if (element) {
      var initialTouchAction_1 = element.style.touchAction;
      element.style.touchAction = "none";
      return function() {
        element.style.touchAction = initialTouchAction_1;
      };
    }
  }, [getElement]);
  var register4 = React25.useCallback(function() {
    registerDrag(target);
    return function() {
      deregisterDrag(target);
    };
  }, [deregisterDrag, registerDrag]);
  var init = function() {
    var window2 = getWindow2();
    var element = getElement();
    var document2 = getDocument3();
    if (pointers) {
      if (element) {
        scrollable.current = getScrollableParent(element);
        if (scrollable.current) {
          scrollable.current.addEventListener("scroll", handleScroll, { passive: true });
        }
        element.addEventListener("pointerdown", handlePointerDown, { passive: true });
      }
      if (pressed) {
        document2.addEventListener("pointermove", handlePointerMove);
        document2.addEventListener("pointerup", handlePointerUp, true);
        document2.addEventListener("contextmenu", handleContextMenu);
        document2.addEventListener("pointercancel", handlePointerCancel, { passive: true });
      }
    } else {
      window2.addEventListener("touchmove", noop2, { capture: false, passive: false });
      if (element) {
        element.addEventListener("mousedown", handleMouseDown, { passive: true });
        if (!mouseOnly) {
          element.addEventListener("touchstart", handleTouchStart, { passive: true });
          if (pressed) {
            element.addEventListener("touchmove", handleTouchMove, { passive: true });
            element.addEventListener("touchend", handleTouchEnd, { passive: true });
          }
        }
      }
      if (pressed) {
        document2.addEventListener("mousemove", handleMouseMove, { passive: true });
        document2.addEventListener("mouseup", handleMouseUp, { passive: true });
      }
    }
    return function() {
      if (scrollable.current) {
        scrollable.current.removeEventListener("scroll", handleScroll);
      }
      if (element) {
        element.removeEventListener("pointerdown", handlePointerDown);
        element.removeEventListener("mousedown", handleMouseDown);
        element.removeEventListener("touchstart", handleTouchStart);
        element.removeEventListener("touchmove", handleTouchMove);
        element.removeEventListener("touchend", handleTouchEnd);
      }
      document2.removeEventListener("pointermove", handlePointerMove);
      document2.removeEventListener("pointerup", handlePointerUp, true);
      document2.removeEventListener("contextmenu", handleContextMenu);
      document2.removeEventListener("pointercancel", handlePointerCancel);
      document2.removeEventListener("mousemove", handleMouseMove);
      document2.removeEventListener("mouseup", handleMouseUp);
      window2.removeEventListener("touchmove", noop2);
      window2.clearTimeout(restoreMouseTimeout.current);
    };
  };
  React25.useEffect(function() {
    var window2 = getWindow2();
    if (scrolling) {
      var scrollableParent_1 = getScrollContainer() || getScrollableParent(document.elementFromPoint(clientOffset.current.x, clientOffset.current.y));
      window2.clearInterval(scrollInterval.current);
      scrollInterval.current = window2.setInterval(function() {
        autoScroll(scrollableParent_1, { x: velocity.current.x, y: velocity.current.y });
      }, 50);
    }
    return function() {
      window2.clearInterval(scrollInterval.current);
    };
  }, [getElement, getScrollContainer, getWindow2, scrolling]);
  React25.useEffect(prerequisites, [prerequisites]);
  React25.useEffect(init, [
    pressed,
    getWindow2,
    getElement,
    getDocument3,
    mouseOnly,
    pointers,
    handleContextMenu,
    handleMouseDown,
    handleMouseMove,
    handleMouseUp,
    handlePointerCancel,
    handlePointerDown,
    handlePointerMove,
    handlePointerUp,
    handleTouchEnd,
    handleTouchMove,
    handleTouchStart,
    handleScroll
  ]);
  React25.useEffect(function() {
    return function() {
      unmount.current = true;
    };
  }, []);
  React25.useLayoutEffect(register4, [register4]);
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useDroppable.js
var React26 = __toESM(require_react());
function useDroppable(ref2, callbacks) {
  if (callbacks === void 0) {
    callbacks = {
      onDragEnter: noop2,
      onDragOver: noop2,
      onDragLeave: noop2,
      onDrop: noop2
    };
  }
  var _a = callbacks.onDragEnter, onDragEnter = _a === void 0 ? noop2 : _a, _b = callbacks.onDragOver, onDragOver = _b === void 0 ? noop2 : _b, _c = callbacks.onDragLeave, onDragLeave = _c === void 0 ? noop2 : _c, _d = callbacks.onDrop, onDrop = _d === void 0 ? noop2 : _d;
  var _e = useInheritedState(DropContext), setDrop = _e[1];
  var _f = React26.useContext(DropsContext), registerDrop = _f[1], deregisterDrop = _f[2];
  var getElement = React26.useCallback(function() {
    return ref2.current && ref2.current.element ? ref2.current.element : ref2.current;
  }, [ref2]);
  var target = React26.useRef(null);
  React26.useImperativeHandle(target, function() {
    return {
      element: getElement(),
      onDragEnter: handleDragEnter,
      onDragOver: handleDragOver,
      onDragLeave: handleDragLeave,
      onDrop: handleDrop,
      data: ref2.current
    };
  });
  var handleDragEnter = React26.useCallback(function(event) {
    setDrop(target, { target: ref2.current, event });
    onDragEnter(event);
  }, [setDrop, ref2, onDragEnter]);
  var handleDragOver = React26.useCallback(function(event) {
    onDragOver(event);
  }, [onDragOver]);
  var handleDragLeave = React26.useCallback(function(event) {
    setDrop(null, { target: ref2.current, event });
    onDragLeave(event);
  }, [setDrop, ref2, onDragLeave]);
  var handleDrop = React26.useCallback(function(event) {
    setDrop(null, { target: ref2.current, event });
    onDrop(event);
  }, [setDrop, ref2, onDrop]);
  var register4 = React26.useCallback(function() {
    registerDrop(target);
    return function() {
      deregisterDrop(target);
    };
  }, [deregisterDrop, registerDrop]);
  React26.useLayoutEffect(register4, [register4]);
}

// node_modules/@progress/kendo-react-common/dist/es/hooks/useControlledState.js
var React27 = __toESM(require_react());
var __assign7 = function() {
  __assign7 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign7.apply(this, arguments);
};
var useControlledState = function(defaultProp, prop, callback) {
  var _a = React27.useState(prop || defaultProp), state = _a[0], setState = _a[1];
  var handleSetEdit = React27.useCallback(function(value, args) {
    setState(value);
    if (callback) {
      callback.call(void 0, __assign7(__assign7({}, args), { value }));
    }
  }, [callback, setState]);
  return [prop !== void 0 ? prop : state, handleSetEdit];
};

// node_modules/@progress/kendo-react-common/dist/es/drag-n-drop/index.js
var DragAndDrop = function(props) {
  var _a = useControlledState(null, void 0), drag = _a[0], setDrag = _a[1];
  var _b = useControlledState(null, void 0), drop = _b[0], setDrop = _b[1];
  var _c = useCollection([]), drags = _c[0], dispatchDrags = _c[1];
  var _d = useCollection([]), drops = _d[0], dispatchDrops = _d[1];
  var registerDrag = function(item) {
    dispatchDrags({
      type: COLLECTION_ACTION.add,
      item
    });
  };
  var deregisterDrag = function(item) {
    dispatchDrags({
      type: COLLECTION_ACTION.remove,
      item
    });
  };
  var registerDrop = function(item) {
    dispatchDrops({
      type: COLLECTION_ACTION.add,
      item
    });
  };
  var deregisterDrop = function(item) {
    dispatchDrops({
      type: COLLECTION_ACTION.remove,
      item
    });
  };
  return React28.createElement(
    DragContext.Provider,
    { value: [drag, setDrag] },
    React28.createElement(
      DropContext.Provider,
      { value: [drop, setDrop] },
      React28.createElement(
        DragsContext.Provider,
        { value: [drags, registerDrag, deregisterDrag] },
        React28.createElement(DropsContext.Provider, { value: [drops, registerDrop, deregisterDrop] }, props.children)
      )
    )
  );
};
DragAndDrop.displayName = "KendoReactDragAndDrop";

// node_modules/@progress/kendo-react-common/dist/es/Draggable.js
var React29 = __toESM(require_react());
var Draggable = React29.forwardRef(function(props, ref2) {
  var childRef = React29.useRef(null);
  var target = React29.useRef(null);
  var getElement = React29.useCallback(function() {
    return childRef.current && childRef.current.element ? childRef.current.element : childRef.current;
  }, [childRef]);
  React29.useImperativeHandle(target, function() {
    return { element: getElement() || null };
  });
  React29.useImperativeHandle(ref2, function() {
    return target.current;
  });
  React29.useImperativeHandle(props.childRef, function() {
    return childRef.current;
  });
  var handlePress = React29.useCallback(function(event) {
    if (!props.onPress) {
      return;
    }
    props.onPress({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onPress]);
  var handleRelease = React29.useCallback(function(event) {
    if (!props.onRelease) {
      return;
    }
    props.onRelease({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onRelease]);
  var handleDragStart = React29.useCallback(function(event) {
    if (!props.onDragStart) {
      return;
    }
    props.onDragStart({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props, getElement]);
  var handleDrag = React29.useCallback(function(event) {
    if (!props.onDrag) {
      return;
    }
    props.onDrag({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDrag]);
  var handleDragEnd = React29.useCallback(function(event) {
    if (!props.onDragEnd) {
      return;
    }
    props.onDragEnd({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDragEnd]);
  useDraggable(childRef, {
    onPress: handlePress,
    onRelease: handleRelease,
    onDragStart: handleDragStart,
    onDrag: handleDrag,
    onDragEnd: handleDragEnd
  }, {
    mouseOnly: props.mouseOnly,
    autoScroll: props.autoScroll,
    hint: props.hint,
    scrollContainer: props.scrollContainer
  });
  return props.children ? React29.cloneElement(React29.Children.only(props.children), { ref: childRef }) : null;
});
Draggable.displayName = "KendoReactDraggable";

// node_modules/@progress/kendo-react-common/dist/es/Droppable.js
var React30 = __toESM(require_react());
var Droppable = React30.forwardRef(function(props, ref2) {
  var childRef = React30.useRef(null);
  var target = React30.useRef(null);
  var getElement = React30.useCallback(function() {
    return childRef.current && childRef.current.element ? childRef.current.element : childRef.current;
  }, [childRef]);
  React30.useImperativeHandle(target, function() {
    return { element: getElement() || void 0 };
  });
  React30.useImperativeHandle(ref2, function() {
    return target.current;
  });
  React30.useImperativeHandle(props.childRef, function() {
    return childRef.current;
  });
  var handleDragEnter = React30.useCallback(function(event) {
    if (!props.onDragEnter) {
      return;
    }
    props.onDragEnter({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDragEnter, getElement]);
  var handleDragOver = React30.useCallback(function(event) {
    if (!props.onDragOver) {
      return;
    }
    props.onDragOver({
      element: getElement(),
      target: target.current,
      event
    });
  }, [getElement, props.onDragOver]);
  var handleDragLeave = React30.useCallback(function(event) {
    if (!props.onDragLeave) {
      return;
    }
    props.onDragLeave({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDragLeave, getElement]);
  var handleDrop = React30.useCallback(function(event) {
    if (!props.onDrop) {
      return;
    }
    props.onDrop({
      element: getElement(),
      target: target.current,
      event
    });
  }, [props.onDrop, getElement]);
  useDroppable(childRef, {
    onDragEnter: handleDragEnter,
    onDragOver: handleDragOver,
    onDragLeave: handleDragLeave,
    onDrop: handleDrop
  });
  return props.children ? React30.cloneElement(React30.Children.only(props.children), { ref: childRef }) : null;
});
Droppable.displayName = "KendoReactDroppable";

// node_modules/@progress/kendo-react-gauges/dist/es/store/store.js
var THROTTLE_MS = 1e3 / 60;
var createStore = function(reducer) {
  var state;
  var timerId;
  var listeners = [];
  var getState = function() {
    return state;
  };
  var dispatch = function(action) {
    state = reducer(state, action);
    if (canUseDOM) {
      window.clearTimeout(timerId);
      timerId = window.setTimeout(function() {
        return listeners.forEach(function(l) {
          return l();
        });
      }, THROTTLE_MS);
    }
  };
  var subscribe = function(listener) {
    listeners.push(listener);
    return function() {
      return listeners = listeners.filter(function(l) {
        return l !== listener;
      });
    };
  };
  dispatch({});
  return { getState, dispatch, subscribe };
};
var store_default = createStore;

// node_modules/@progress/kendo-react-gauges/dist/es/store/reducer.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var themeReducer = function(currentState, action) {
  if (action.type) {
    switch (action.type) {
      case "set":
        return reducers.themeItem(currentState, action);
      case "push":
        return Object.assign(currentState, action.payload);
      default:
        return currentState;
    }
  } else {
    return {};
  }
};
var observersReducer = function(currentState, action) {
  if (action.type) {
    switch (action.type) {
      case "add":
        return __spreadArray(__spreadArray([], currentState, true), [action.payload], false);
      case "remove":
        return currentState.filter(function(element) {
          return element !== action.payload;
        });
      default:
        return currentState;
    }
  } else {
    return [];
  }
};
var reducers = {
  configurationItem: function(currentState, action) {
    var _a;
    return Object.assign(currentState, (_a = {}, _a[action.gaugeKey] = action.payload, _a));
  },
  collectionConfigurationItem: function(currentState, action) {
    var _a;
    var inCollection = false;
    var _b = action.gaugeCollectionIdxKey.split("_"), collectionName = _b[0], collectionIdx = _b[1];
    var collection = currentState[collectionName].map(function(item, index) {
      if (parseInt(collectionIdx, 10) === index) {
        inCollection = true;
        return action.payload;
      }
      return item;
    });
    if (inCollection === false) {
      collection.splice(parseInt(collectionIdx, 10), 0, action.payload);
    }
    return Object.assign(currentState, (_a = {}, _a[collectionName] = collection, _a));
  },
  themeItem: function(currentState, action) {
    var store = {};
    var nextStore = Object.assign(store, currentState);
    var _a = action.payload, field = _a.field, value = _a.value;
    var parts = field.split(".");
    var key = parts.shift();
    while (parts.length > 0) {
      store = store[key] = store[key] || {};
      key = parts.shift();
    }
    store[key] = value;
    return nextStore;
  }
};

// node_modules/@progress/kendo-react-gauges/dist/es/utils/common.js
var isObject2 = function(value) {
  return typeof value === "object";
};
var diffOptions = function(original, current4) {
  if (Object.keys(original).length !== Object.keys(current4).length) {
    return true;
  }
  for (var field in original) {
    if (field !== "value" && original.hasOwnProperty(field)) {
      var originalValue = original[field];
      var currentValue = current4[field];
      var diff = isObject2(originalValue) && isObject2(currentValue) ? diffOptions(originalValue, currentValue) : originalValue !== currentValue;
      if (diff) {
        return true;
      }
    }
  }
  return false;
};
var isOptionsChanged = function(original, current4) {
  if (!original || !current4) {
    return true;
  }
  original = [].concat(original);
  current4 = [].concat(current4);
  if (original.length !== current4.length) {
    return true;
  }
  for (var idx = 0; idx < original.length; idx++) {
    if (diffOptions(original[idx], current4[idx])) {
      return true;
    }
  }
  return false;
};

// node_modules/@progress/kendo-react-gauges/dist/es/GaugeContext.js
var React31 = __toESM(require_react());
var GaugeContext = React31.createContext(null);
GaugeContext.displayName = "GaugeContext";

// node_modules/@progress/kendo-react-gauges/dist/es/package-metadata.js
var packageMetadata2 = {
  name: "@progress/kendo-react-gauges",
  productName: "KendoReact",
  productCodes: ["KENDOUIREACT", "KENDOUICOMPLETE"],
  publishDate: 1675429146,
  version: "",
  licensingDocsUrl: "https://www.telerik.com/kendo-react-ui/my-license/?utm_medium=product&utm_source=kendoreact&utm_campaign=kendo-ui-react-purchase-license-keys-warning"
};

// node_modules/@progress/kendo-react-gauges/dist/es/BaseGauge.js
var __extends3 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __rest5 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var BaseGauge = (
  /** @class */
  function(_super) {
    __extends3(BaseGauge2, _super);
    function BaseGauge2(props) {
      var _this = _super.call(this, props) || this;
      _this.gaugeInstance = null;
      _this.surface = null;
      _this._element = null;
      _this.themeStore = {};
      _this.themeUnsubscriber = Function.prototype;
      _this.observersStore = {};
      _this.onWindowResize = function() {
        if (_this.gaugeInstance !== null) {
          _this.gaugeInstance.resize();
          _this.trigger("render", { sender: _this });
        }
      };
      validatePackage2(packageMetadata2);
      _this.themeStore = store_default(themeReducer);
      _this.observersStore = store_default(observersReducer);
      _this.contextValue = {
        observersStore: _this.observersStore
      };
      return _this;
    }
    Object.defineProperty(BaseGauge2.prototype, "element", {
      /**
       * @hidden
       */
      get: function() {
        return this._element;
      },
      enumerable: false,
      configurable: true
    });
    BaseGauge2.prototype.componentDidMount = function() {
      var _a;
      var doc = ((_a = this._element) === null || _a === void 0 ? void 0 : _a.ownerDocument) || document;
      loadTheme(this.themeStore, this.instantiateCoreGauge.bind(this), doc);
      this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this));
      window.addEventListener("resize", this.onWindowResize);
      this.trigger("render", { sender: this });
    };
    BaseGauge2.prototype.componentDidUpdate = function(prevProps) {
      var _a = this.props, dir = _a.dir, children = _a.children, deriveOptionsFromParent = _a.deriveOptionsFromParent, getTarget = _a.getTarget, gaugeConstructor = _a.gaugeConstructor, className = _a.className, renderAs = _a.renderAs, currentOthers = __rest5(_a, ["dir", "children", "deriveOptionsFromParent", "getTarget", "gaugeConstructor", "className", "renderAs"]);
      var prevDir = prevProps.dir, prevChildren = prevProps.children, prevDeriveOptionsFromParent = prevProps.deriveOptionsFromParent, prevGetTarget = prevProps.getTarget, prevGaugeConstructor = prevProps.gaugeConstructor, prevClassName = prevProps.className, prevRenderAs = prevProps.renderAs, prevOthers = __rest5(prevProps, ["dir", "children", "deriveOptionsFromParent", "getTarget", "gaugeConstructor", "className", "renderAs"]);
      if (this.gaugeInstance !== null) {
        var currentIntlService = provideIntlService(this);
        var gaugeService = this.gaugeInstance.contextService;
        var localeChanged = currentIntlService.locale !== gaugeService._intlService.locale;
        var optionsChanged = isOptionsChanged(prevOthers, currentOthers);
        var typedCurrentOthers = currentOthers;
        if (localeChanged) {
          this.gaugeInstance.contextService._intlService = currentIntlService;
          this.gaugeInstance.contextService.format._intlService = currentIntlService;
          if (!optionsChanged) {
            this.gaugeInstance.noTransitionsRedraw();
          }
        }
        if (optionsChanged || (renderAs || "svg") !== (prevRenderAs || "svg")) {
          this.refresh();
        } else {
          if (Object.keys(currentOthers).indexOf("pointer") > -1) {
            var isPointerArray = Array.isArray(typedCurrentOthers.pointer);
            if (isPointerArray) {
              this.refreshAllValues(typedCurrentOthers.pointer.map(function(item) {
                return item.value;
              }));
            } else {
              this.refreshValue((typedCurrentOthers.pointer || {}).value);
            }
          } else {
            this.refreshValue(typedCurrentOthers.value);
          }
        }
        if (prevProps.dir !== dir) {
          this.gaugeInstance.setDirection(this.getDirection(dir));
        }
        this.trigger("render", { sender: this });
      }
    };
    BaseGauge2.prototype.componentWillUnmount = function() {
      this.themeUnsubscriber();
      var surfaceElement = this.gaugeInstance && this.gaugeInstance.surfaceElement;
      if (surfaceElement && surfaceElement.parentNode) {
        surfaceElement.parentNode.removeChild(surfaceElement);
      }
      if (this.gaugeInstance !== null) {
        this.gaugeInstance.destroy();
        this.gaugeInstance = null;
      }
      window.removeEventListener("resize", this.onWindowResize);
    };
    BaseGauge2.prototype.render = function() {
      var _this = this;
      var _a = this.props, _b = _a.style, style = _b === void 0 ? {} : _b, className = _a.className, children = _a.children;
      var gaugeStyles = Object.assign({}, style, { position: "relative" });
      return React32.createElement(
        GaugeContext.Provider,
        { value: this.contextValue },
        React32.createElement("div", { style: gaugeStyles, ref: function(el) {
          return _this._element = el;
        }, className }, children)
      );
    };
    BaseGauge2.prototype.instantiateCoreGauge = function() {
      var _a = this.props, dir = _a.dir, gaugeConstructor = _a.gaugeConstructor;
      var gaugeOptions = this.getGaugeOptions();
      this.gaugeInstance = new gaugeConstructor(this.element, gaugeOptions, this.themeStore.getState(), {
        rtl: this.getDirection(dir),
        intlService: provideIntlService(this),
        sender: this
      });
    };
    BaseGauge2.prototype.refresh = function() {
      if (this.gaugeInstance !== null) {
        var themeOptions = this.themeStore.getState();
        var gaugeOptions = this.getGaugeOptions();
        this.gaugeInstance.setOptions(gaugeOptions, themeOptions);
      }
    };
    BaseGauge2.prototype.refreshValue = function(value) {
      this.gaugeInstance.value(value);
    };
    BaseGauge2.prototype.refreshAllValues = function(values5) {
      this.gaugeInstance.allValues(values5);
    };
    BaseGauge2.prototype.getDirection = function(dir) {
      var _this = this;
      var directionFromWindow = function() {
        return canUseDOM && window.getComputedStyle(_this.element).direction;
      };
      var direction = dir !== void 0 ? dir : directionFromWindow() || "ltr";
      return direction === "rtl";
    };
    BaseGauge2.prototype.getGaugeOptions = function() {
      var _a = this.props, renderAs = _a.renderAs, transitions = _a.transitions, deriveOptionsFromParent = _a.deriveOptionsFromParent;
      var gaugeOptions = Object.assign({
        renderAs,
        transitions
      });
      if (deriveOptionsFromParent) {
        gaugeOptions = deriveOptionsFromParent(gaugeOptions);
      }
      return gaugeOptions;
    };
    BaseGauge2.prototype.trigger = function(name3, e) {
      var observers = this.observersStore.getState();
      for (var idx = 0; idx < observers.length; idx++) {
        observers[idx].trigger(name3, e);
      }
    };
    BaseGauge2.propTypes = {
      dir: PropTypes7.string,
      renderAs: PropTypes7.oneOf(["svg", "canvas"])
    };
    BaseGauge2.defaultProps = {
      renderAs: "svg"
    };
    return BaseGauge2;
  }(React32.Component)
);
registerForIntl(BaseGauge);

// node_modules/@progress/kendo-react-gauges/dist/es/ArcCenter.js
var React33 = __toESM(require_react());
var __extends4 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var ArcCenter = (
  /** @class */
  function(_super) {
    __extends4(ArcCenter2, _super);
    function ArcCenter2(props, context2) {
      var _this = _super.call(this, props, context2) || this;
      _this.state = {
        arcCenterStyles: null,
        arcCenterValue: {
          value: 0,
          color: ""
        }
      };
      _this._element = null;
      _this.gaugeObserver = new instance_observer_default(_this, {
        render: "onRender"
      });
      context2.observersStore.dispatch({
        type: "add",
        payload: _this.gaugeObserver
      });
      return _this;
    }
    ArcCenter2.prototype.render = function() {
      var _this = this;
      var render3 = this.props.render;
      var _a = this.state, arcCenterStyles = _a.arcCenterStyles, arcCenterValue = _a.arcCenterValue;
      var divStyle = arcCenterStyles ? arcCenterStyles : { zIndex: -1 };
      var renderer = null;
      if (render3) {
        renderer = React33.createElement("div", { className: "k-arcgauge-label", ref: function(element) {
          return _this._element = element;
        }, style: divStyle }, render3(arcCenterValue.value, arcCenterValue.color));
      }
      return renderer;
    };
    ArcCenter2.prototype.onRender = function(e) {
      if (!this._element) {
        return;
      }
      var gaugeInstance = e.sender.gaugeInstance;
      var width = this._element.offsetWidth;
      var height = this._element.offsetHeight;
      var position = gaugeInstance.centerLabelPosition(width, height);
      this.setState({
        arcCenterStyles: {
          left: position.left,
          top: position.top
        },
        arcCenterValue: {
          value: gaugeInstance.value(),
          color: gaugeInstance.currentColor()
        }
      });
    };
    ArcCenter2.contextType = GaugeContext;
    return ArcCenter2;
  }(React33.Component)
);

// node_modules/@progress/kendo-react-gauges/dist/es/ArcGauge.js
var __extends5 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign8 = function() {
  __assign8 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign8.apply(this, arguments);
};
var __rest6 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var ArcGauge2 = (
  /** @class */
  function(_super) {
    __extends5(ArcGauge3, _super);
    function ArcGauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._baseGauge = null;
      _this.gaugeType = arc_gauge_default;
      _this.getTarget = function() {
        return _this;
      };
      _this.deriveOptionsFromParent = function(options2) {
        var _a = _this.props, value = _a.value, color = _a.color, colors = _a.colors, opacity = _a.opacity, scale = _a.scale;
        return Object.assign({}, options2, {
          value,
          color,
          colors,
          opacity,
          scale
        });
      };
      return _this;
    }
    Object.defineProperty(ArcGauge3.prototype, "gaugeInstance", {
      /**
       * @hidden
       */
      get: function() {
        if (this._baseGauge) {
          return this._baseGauge.gaugeInstance;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ArcGauge3.prototype, "surface", {
      /**
       * The Drawing `Surface` of the Gauge.
       */
      get: function() {
        if (this._baseGauge) {
          return this._baseGauge.surface;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ArcGauge3.prototype, "element", {
      /**
       * The DOM element of the Gauge.
       */
      get: function() {
        if (this._baseGauge) {
          return this._baseGauge.element;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    ArcGauge3.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, arcCenterRender = _a.arcCenterRender, centerRender = _a.centerRender, className = _a.className, baseGaugeProps = __rest6(_a, ["children", "arcCenterRender", "centerRender", "className"]);
      return React34.createElement(
        BaseGauge,
        __assign8({}, baseGaugeProps, { deriveOptionsFromParent: this.deriveOptionsFromParent, ref: function(baseGauge) {
          return _this._baseGauge = baseGauge;
        }, gaugeConstructor: this.gaugeType, getTarget: this.getTarget, className: classNames("k-gauge k-arcgauge", className) }),
        children,
        React34.createElement(ArcCenter, { render: centerRender || arcCenterRender })
      );
    };
    ArcGauge3.prototype.exportVisual = function(options2) {
      if (this.gaugeInstance !== null && this.element) {
        return drawDOM(this.element, options2);
      }
      return Promise.resolve(new group_default());
    };
    return ArcGauge3;
  }(React34.Component)
);

// node_modules/@progress/kendo-react-gauges/dist/es/CircularGauge.js
var __extends6 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var CircularGauge2 = (
  /** @class */
  function(_super) {
    __extends6(CircularGauge3, _super);
    function CircularGauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.gaugeType = circular_gauge_default;
      return _this;
    }
    return CircularGauge3;
  }(ArcGauge2)
);

// node_modules/@progress/kendo-react-gauges/dist/es/LinearGauge.js
var React35 = __toESM(require_react());
var __extends7 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign9 = function() {
  __assign9 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign9.apply(this, arguments);
};
var __rest7 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var LinearGauge2 = (
  /** @class */
  function(_super) {
    __extends7(LinearGauge3, _super);
    function LinearGauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._baseGauge = null;
      _this.getTarget = function() {
        return _this;
      };
      _this.deriveOptionsFromParent = function(options2) {
        var _a = _this.props, pointer = _a.pointer, scale = _a.scale;
        return Object.assign({}, options2, {
          pointer,
          scale
        });
      };
      return _this;
    }
    Object.defineProperty(LinearGauge3.prototype, "gaugeInstance", {
      /**
       * @hidden
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.gaugeInstance;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LinearGauge3.prototype, "surface", {
      /**
       * The Drawing `Surface` of the Gauge.
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.surface;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(LinearGauge3.prototype, "element", {
      /**
       * The DOM element of the Gauge.
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.element;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    LinearGauge3.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, className = _a.className, baseGaugeProps = __rest7(_a, ["children", "className"]);
      return React35.createElement(BaseGauge, __assign9({}, baseGaugeProps, { deriveOptionsFromParent: this.deriveOptionsFromParent, ref: function(baseGauge) {
        return _this._baseGauge = baseGauge;
      }, gaugeConstructor: linear_gauge_default, getTarget: this.getTarget, className: classNames("k-gauge", className) }), children);
    };
    LinearGauge3.prototype.exportVisual = function(options2) {
      if (this.gaugeInstance !== null) {
        return Promise.resolve(this.gaugeInstance.exportVisual(options2));
      }
      return Promise.resolve(new group_default());
    };
    return LinearGauge3;
  }(React35.Component)
);

// node_modules/@progress/kendo-react-gauges/dist/es/RadialGauge.js
var React36 = __toESM(require_react());
var __extends8 = function() {
  var extendStatics = function(d, b) {
    extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
      d2.__proto__ = b2;
    } || function(d2, b2) {
      for (var p2 in b2)
        if (Object.prototype.hasOwnProperty.call(b2, p2))
          d2[p2] = b2[p2];
    };
    return extendStatics(d, b);
  };
  return function(d, b) {
    if (typeof b !== "function" && b !== null)
      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
    extendStatics(d, b);
    function __() {
      this.constructor = d;
    }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  };
}();
var __assign10 = function() {
  __assign10 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p2 in s)
        if (Object.prototype.hasOwnProperty.call(s, p2))
          t[p2] = s[p2];
    }
    return t;
  };
  return __assign10.apply(this, arguments);
};
var __rest8 = function(s, e) {
  var t = {};
  for (var p2 in s)
    if (Object.prototype.hasOwnProperty.call(s, p2) && e.indexOf(p2) < 0)
      t[p2] = s[p2];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p2 = Object.getOwnPropertySymbols(s); i < p2.length; i++) {
      if (e.indexOf(p2[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p2[i]))
        t[p2[i]] = s[p2[i]];
    }
  return t;
};
var RadialGauge2 = (
  /** @class */
  function(_super) {
    __extends8(RadialGauge3, _super);
    function RadialGauge3() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this._baseGauge = null;
      _this.getTarget = function() {
        return _this;
      };
      _this.deriveOptionsFromParent = function(options2) {
        var _a = _this.props, pointer = _a.pointer, scale = _a.scale;
        return Object.assign({}, options2, {
          pointer,
          scale
        });
      };
      return _this;
    }
    Object.defineProperty(RadialGauge3.prototype, "gaugeInstance", {
      /**
       * @hidden
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.gaugeInstance;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RadialGauge3.prototype, "surface", {
      /**
       * The Drawing `Surface` of the Gauge.
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.surface;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RadialGauge3.prototype, "element", {
      /**
       * The DOM element of the Gauge.
       */
      get: function() {
        if (this._baseGauge !== null) {
          return this._baseGauge.element;
        }
        return null;
      },
      enumerable: false,
      configurable: true
    });
    RadialGauge3.prototype.render = function() {
      var _this = this;
      var _a = this.props, children = _a.children, className = _a.className, baseGaugeProps = __rest8(_a, ["children", "className"]);
      return React36.createElement(BaseGauge, __assign10({}, baseGaugeProps, { deriveOptionsFromParent: this.deriveOptionsFromParent, ref: function(baseGauge) {
        return _this._baseGauge = baseGauge;
      }, gaugeConstructor: radial_gauge_default, getTarget: this.getTarget, className: classNames("k-gauge", className) }), children);
    };
    RadialGauge3.prototype.exportVisual = function(options2) {
      if (this.gaugeInstance !== null) {
        return Promise.resolve(this.gaugeInstance.exportVisual(options2));
      }
      return Promise.resolve(new group_default());
    };
    return RadialGauge3;
  }(React36.Component)
);
export {
  ArcGauge2 as ArcGauge,
  CircularGauge2 as CircularGauge,
  LinearGauge2 as LinearGauge,
  RadialGauge2 as RadialGauge
};
/*! Bundled license information:

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

object-assign/index.js:
  (*
  object-assign
  (c) Sindre Sorhus
  @license MIT
  *)
*/
//# sourceMappingURL=@progress_kendo-react-gauges.js.map
